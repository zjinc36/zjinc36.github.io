# Redis_事务

----

## Redis事务的概念

Redis的事务并不是我们传统意义上理解的事务，我们都知道单个Redis命令的执行是原子性的，但Redis没有在事务。上增加任何维持原子性的机制，所以Redis事务的执行并不是原子性的。

事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。

总结:

1. Redis事务中`如果有某一条命令执行失败，之前的命令不会回滚`，其后的命令仍然会被继续执行。 鉴于这个原因，所以说Redis的事务严格意义上来说是`不具备原子性`的。
2. Redis事务中所有命令都`会序列化、按顺序地执行`。事务在执行的过程中，`不会被其他客户端发送来的命令请求所打断`。
3.在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。

>   当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许 只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服 务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就 要充分利用Redis.工具包中提供的Redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。

## Redis事务的三个阶段

1. multi开启事务
2. 大量指令入队
3. exec执行事务块内命令，截止此处一个事务已经结束。
4. discard取消事务
5. watch监视一个或多个key,如果事务执行前key被改动，事务将打断。unwatch 取消监视。

事务执行过程中，如果服务端收到有EXEC、DISCARD、 WATCH、MULTI之外的请求，将会把请求放入队列中排队


## Redis事务相关命令

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH四个原语实现的

+   WATCH命令是一个乐观锁，可以为Redis事务提供check-and-set (CAS) 行为。可以监控一个或多个键，一旦其中有一个键被修改(或删除)，之后的事务就不会执行，监控一直持续到EXEC命令。
+   MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命 令被调用时，所有队列中的命令才会被执行。
+   EXEC:执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值nil。通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。
+   UNWATCH命令可以取消watch对所有key的监控。

## Redis事务支持隔离性吗?

Redis是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis的事务是`总是带有隔离性的`。

## Redis为什么不支持事务回滚?

`Redis命令只会因为错误的语法而失败`，或是命令用在了错误类型的键上面，这些问题不能在入队时发现，这也就是说，`从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现`，而不应该出现在生产环境中

因为不需要对回滚进行支持，所以Redis的内部可以保持简单且快速。

## Redis事务其他实现

+   基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。
+   基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。