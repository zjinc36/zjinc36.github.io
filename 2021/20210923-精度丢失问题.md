#	精度丢失问题

----


##	如何理解double精度丢失问题

很简单，从二进制角度考虑问题即可：把「0.1」转成二进制的表示，然后还原成十进制，就能看出问题。

### 把 0.1 转成二进制表示

我们知道 DEC(1) 就是 BIN(1)，但是 DEC(0.1) 怎么转换成二进制？

对了用除法：

```
0.1 = 1 ÷ 10
```

很简单，二进制就是要算

```
1 ÷ 1010
```

我们回到小学的课堂，来列竖式吧：

```
       0.000110011...
      ------------------
1010 ) 1 0000
         1010
       ------
          1100
          1010
          ----
            10000
             1010
            -----
              1100
              1010
              ----
                10
```


相信上过小学的你一定会发现，除不尽，除出了一个无限循环小数：二进制的 `0.0001100110011...`

### 舍入

我们得把 `0.0001100110011...` 放进一个 double「双精度浮点数」里面

双精度浮点数能表示多少精度呢？查看文档会发现：

+   半精度（16bit）：11 位有效数字
+   有效数字单精度（32bit）：24 位有效数字
+   有效数字双精度（64bit）：53 位有效数字
+   有效数字四精度（128bit）：113 位有效数字

好吧，双精度是 53 位有效数字

```
0.00011001100110011001100110011001100110011001100110011001 10011...
```

方便起见，我在第 53 个有效数字后面加了个空格。

那么问题来了：十进制数我们可以四舍五入，二进制怎么办？精神是一样的：待处理部分有没有达到前一位的一半，达到就进位，没达到就舍去。（暂且当作 0 舍 1 入。）
那么我们的 0.1 在 double 中就是

```
0.00011001100110011001100110011001100110011001100110011001 10011...
0.00011001100110011001100110011001100110011001100110011010
```

而 1.1 就是

```
1.0001100110011001100110011001100110011001100110011001 10011...
1.0001100110011001100110011001100110011001100110011010
```

### 加法

这个很简单，1.1 + 0.1 就是

```
  1.0001100110011001100110011001100110011001100110011010
+ 0.00011001100110011001100110011001100110011001100110011010
------------------------------------------------------------
  1.00110011001100110011001100110011001100110011001100111010
```


因为结果仍然是 double，需要再做一次保留 53 位有效数字和舍入：

```
1.0011001100110011001100110011001100110011001100110011 1010
1.0011001100110011001100110011001100110011001100110100
```

### 结果

好了，终于可以回到十进制的世界了，我们把最终结果转换回来：

```
1.0011001100110011001100110011001100110011001100110100
```

得到十进制的：

```
1.20000000000000018
```

一般的输出函数，在输出浮点数时，都会限制显示的有效数字，即会再做一次四舍五入。题目中的 1.2000000000000002 是这个结果在显示时四舍五入后的结果。

```
1.20000000000000018
1.2000000000000002
```

各个语言可能会有差异，答案是，比如可能因为选择的舍入规则的不同可能导致的结果的不同；
甚至有可能某个语言里的浮点数压根不是 IEEE 754 的浮点数，而是以字符串方式保存的，所以可能没有误差。


##  使用BigDecimal也会有重大隐患

### 重现错误
```java
float a = 0.2f;
float b = 0.01f;
BigDecimal aa = new BigDecimal(a);
BigDecimal bb = new BigDecimal(b);
System.out.println(a + b);
System.out.println(aa.add(bb));
```

输出：

```
0.21000001
0.21000000275671482086181640625
```

### 到底问题出在哪？

>   effective java 第48条解释：
>
>   如果需要精确的答案，请避免使用float和double
>
>   float和double类型主要是为了科学计算和工程计算而设计，他们执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近和计算而精心设计的，然而，他们并没有提供完全精确的结果，所以不应该被用于精确的结果的场合

+   从effective java中，明确的说了，float和double是不精确的运算，他们只是为了广泛的运算保证有一个相近的值
+   为什么要使用二进制计算double，float和double他们执行的二进制浮点运算，因为使用二进制计算效率要高，适用于日常运算，而二进制也能给我提供一个相对准确的值
+   为什么二进制运算不能提供准确的值，其实不能说二进制不能提供准确的值，而是二进制不能准确的表示一个小数，就像十进制不能准确的表示1/3,1/6等。
+   为什么十进制不能表示1/3 ，因为1/3=0.333333333333333。。。。。，我们始终不能说清楚这后面有多少个3，所以说十进制表示不了1/3.
+   为什么二进制不能表示一个小数，举例0.1换成二进制，请看下面的运算

```
0.1 * 2 = 0.2     -----0
0.2 * 2 = 0.4     -----0
0.4 * 2 = 0.8     -----0
0.8 * 2 = 1.6     -----1
0.6 * 2 = 1.2     -----1
0.2 * 2 = 0.4     -----0
.
.
.
//你懂的 0.0001100110011001100110011001100110011001100110011001101
```

所以二进制表示不了0.1，但是有的小数却可以表示，就像十进制能表示1/2一样，请看0.5

```
0.5 * 2 = 1     -----1
//所以0.5用二进制表示就是0.1
```

这解释了，new BigDecimal(0.1);返回一个错误的值，而 new BigDecimal(0.5);返回一个准确的值，`从本质上讲0.1，只要他的类型是double或者float，它本身就一个不准确的值，这其实跟BigDecimal无关`。我们使用new BigDecimal(Double d);这个构造时，假如入参是0.1，这其中会将0.1转成Double，而此时0.1的值就已经不准确了,比如以下代码

```java
System.out.println(0.5*3);
System.out.println(0.1*3);
//这两句代码，可能很清楚说明二进制不能表示0.1，可以表示0.5
```

BigDecimal使用标度scale来表示小数点后有几位，针对传入的字符串，BigDecimal去根据字符串中的'.'来判断小数点后有几位，最终利用long类型来存储整个去掉了小数点的数字，作为尾数（类似二进制的那个尾数）,比如一个数是12.3333,那么这个long类型的值就是123333,而scale就是4。当接收的是float、double类型时，很不幸，传来之前这个数就已经犯法了。同时scale也会非常长(本应是1实际是26)。


### 正确运用BigDecimal

既然知道了为什么，我们就只要避免这个问题就行了，这个问题说到底是double或者float造成的，那么我们在构造BigDecimal的对象时，不用这两个构造方法就行了,所以`我们一般都将数据转成字符串`。

另外，BigDecimal所创建的是对象，我们不能使用传统的`+、-、*、/`等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。

在一般开发过程中，我们数据库中存储的数据都是float和double类型的。在进行拿来拿去运算的时候还需要不断的转化，这样十分的不方便。这里我写了一个工具类：

```java
/**
 * @author: Ji YongGuang.
 * @date: 19:50 2017/12/14.
 */
public class BigDecimalUtil {

    private BigDecimalUtil() {

    }

    public static BigDecimal add(double v1, double v2) {// v1 + v2
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.add(b2);
    }

    public static BigDecimal sub(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.subtract(b2);
    }

    public static BigDecimal mul(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.multiply(b2);
    }

    public static BigDecimal div(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        // 2 = 保留小数点后两位   ROUND_HALF_UP = 四舍五入
        return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);// 应对除不尽的情况
    }
}
```

该工具类提供了double类型的基本的加减乘除运算。直接调用即可。

#   参考
+   [【超详细】解释BigDecimal精度的坑](https://blog.csdn.net/gege87417376/article/details/79550749)
+   [使用BigDecimal也会有重大隐患？](https://zhuanlan.zhihu.com/p/395868160)
+   [如何理解double精度丢失问题？](https://www.zhihu.com/question/42024389)