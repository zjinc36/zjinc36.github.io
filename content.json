[{"title":"JVM从入门到精通_09_方法区","date":"2020-08-27T18:29:44.000Z","path":"2020/08/28/JVM从入门到精通-09-方法区/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 前言这次所讲述的是运行时数据区的最后一个部分从线程共享与否的角度来看ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理 栈、堆、方法区的交互关系下面就涉及了对象的访问定位 Person：存放在元空间，也可以说方法区 person：存放在Java栈的局部变量表中 new Person()：存放在Java堆中 方法区的理解《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 所以，方法区看作是一块独立于Java堆的内存空间。方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace 加载大量的第三方的jar包 Tomcat部署的工程过多（30~50个） 大量动态的生成反射类 关闭JVM就会释放这个区域的内存。 HotSpot中方法区的演进在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。 DK 1.8后，元空间存放在堆外内存中 本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限） 而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存 永久代、元空间二者并不只是名字变了，内部结构也调整了 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常 设置方法区大小与OOM方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 jdk7及以前 通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M -XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。 JDK8以后元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。 如何解决这些OOM 要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） 内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 方法区的内部结构《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等 类型信息对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息： 这个类型的完整有效名称（全名=包名.类名） 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类） 这个类型的修饰符（public，abstract，final的某个子集） 这个类型直接接口的一个有序列表 域信息JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。 域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集） 方法（Method）信息JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序： 方法名称 方法的返回类型（或void） 方法参数的数量和类型（按顺序） 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集） 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外） 异常表（abstract和native方法除外） 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 non-final的类变量静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它 1234567891011121314151617/** * non-final的类变量 */public class MethodAreaTest &#123; public static void main(String[] args) &#123; Order order = new Order(); order.hello(); System.out.println(order.count); &#125;&#125;class Order &#123; public static int count = 1; public static final int number = 2; public static void hello() &#123; System.out.println(\"hello!\"); &#125;&#125; 如上代码所示，即使我们把order设置为null，也不会出现空指针异常 全局常量全局常量就是使用 static final 进行修饰 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 运行时常量池 VS 常量池运行时常量池，就是运行时常量池 方法区，内部包含了运行时常量池 字节码文件，内部包含了常量池 要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。 要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。 常量池一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用 为什么需要常量池一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。 比如：如下的代码： 12345public class SimpleClass &#123; public void sayHello() &#123; System.out.println(\"hello\"); &#125;&#125; 虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。 常量池中有什么 数量值 字符串值 类引用 字段引用 方法引用 例如下面这段代码 12345public class MethodAreaTest2 &#123; public static void main(String args[]) &#123; Object obj = new Object(); &#125;&#125; 将会被翻译成如下字节码 123new #2 dupinvokespecial 小结常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。 常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。 JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。 运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。 方法区使用举例123456789public class MethodAreaDemo &#123; public static void main(String args[]) &#123; int x = 500; int y = 100; int a = x / y; int b = 50; System.out.println(a+b); &#125;&#125; 字节码执行过程展示首先现将操作数500放入到操作数栈中然后存储到局部变量表中然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作将500 和 100 进行一个除法运算，在把结果入栈在最后就是输出流，需要调用运行时常量池的常量最后调用invokevirtual（虚方法调用），然后返回返回时程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。 方法区的演进细节首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一 Hotspot中方法区的变化： JDK1.6及以前 有永久代，静态变量存储在永久代上 JDK1.7 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中 JDK1.8 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 JDK6的时候 JDK7的时候 JDK8的时候，元空间大小只受物理内存影响 为什么永久代要被元空间替代？JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有： 为永久代设置空间大小是很难确定的。 在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。 “Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space” 而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。 对永久代进行调优是很困难的。 主要是为了降低Full GC 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型 StringTable为什么要调整位置jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。 这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。 静态变量存放在那里？静态引用对应的对象实体始终都存在堆空间 可以使用 jhsdb.ext，需要在jdk9的时候才引入的 staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。 接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点 方法区的垃圾回收有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。 回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收） 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。 该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 总结 常见面试题百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？ 蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配 小米： jvm内存分区，为什么要有新生代和老年代 字节跳动： 二面：Java的内存分区 二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？ 京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。 天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改 拼多多： JVM内存分哪几个区，每个区的作用是什么？ 美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"解决Github-Page无法访问的其中一种情况","date":"2020-08-26T12:56:43.000Z","path":"2020/08/26/解决Github-Page无法访问的其中一种情况/","text":"修改ip网上很多帖子,但是我修改之后无效 修改dns服务器 查看域名指向哪里1nslookup github.io 我本地如下,指向了127.0.0.1,所以确认是需要修改dns服务器地址了 修改dns服务器地址修改文件 /etc/resolvconf/resolv.conf.d/head（这个文件默认为空），添加以下内容：1nameserver 114.114.114.114 执行更新： 1resolvconf -u 通过 /etc/resolv.conf 查看 DNS 设置,可看到多了: 1nameserver 114.114.114.114 此时nslookup可以看到如下然后能成功访问","tags":[]},{"title":"Ubuntu中修改DNS的方法","date":"2020-08-26T12:43:41.000Z","path":"2020/08/26/Ubuntu中修改DNS的方法/","text":"修改DNS的方法修改文件 /etc/resolvconf/resolv.conf.d/head（这个文件默认为空），添加以下内容： 1nameserver 114.114.114.114 :wq 保存退出 执行更新： 1resolvconf -u 通过 /etc/resolv.conf 查看 DNS 设置: 可看到多了: 1nameserver 114.114.114.114 /etc/resolv.conf基本说明/etc/resolv.conf是DNS名称解析器库的主要配置文件。 解析程序是C库中的一组函数，提供对Internet域名系统 （ DNS ）的访问。 这些功能被配置为检查/etc/hosts文件或多个DNSNameservers中的条目，或者使用主机的网络信息服务 （ NIS ）数据库。 在使用systemd（系统和服务管理器）的现代Linux系统上，DNS或名称解析服务通过systemd解析的服务提供给本地应用程序。 默认情况下，此服务具有四种用于处理域名解析的模式，并在默认操作模式下使用systemd DNS存根文件（ /run/systemd/resolve/stub-resolv.conf ）。 DNS存根文件包含本地存根127.0.0.53作为唯一的DNS服务器，并且重定向到/etc/resolv.conf文件，该文件用于添加系统使用的Nameservers。 如果在/etc/resolv.conf上运行以下ls命令 ，您将看到该文件是/run/systemd/resolve/stub-resolv.conf文件的符号链接。 12$ ls -l /etc/resolv.conflrwxrwxrwx 1 root root 39 Feb 15 2019 /etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf 不幸的是，由于/etc/resolv.conf是由systemd解析的服务间接管理的，在某些情况下是由网络服务（通过使用initscripts或NetworkManager ）间接管理的，因此，用户手动进行的任何更改都无法永久保存或仅保存持续一会儿。 为什么要修改 /etc/resolv.conf文件？主要原因可能是因为系统DNS设置配置错误，或者您更喜欢使用特定的Nameservers或您自己的Nameservers。 以下cat命令在我的Ubuntu系统上的/etc/resolv.conf文件中显示默认Nameservers。 1cat /etc/resolv.conf 检查DNSNameservers在这种情况下，当APT程序包管理器之类的本地应用程序尝试访问本地网络上的FQDN （ 完全合格的域名 ）时，结果是“ 名称解析临时失败 ”错误，如下图所示。 临时故障解决当您运行ping命令时，也会发生同样的情况。 1$ ping google.com 名称解析暂时失败 因此，当用户尝试手动设置Nameservers时，更改不会持续很长时间，也不会在重新启动后被撤销。 要解决此问题，您可以安装并使用reolvconf实用程序使更改永久生效 。 要安装下一部分中所示的resolvconf软件包，首先需要在/etc/resolv.conf文件中手动设置以下Nameservers，以便在Internet上访问Ubuntu仓库服务器的FQDM。 12nameserver 8.8.4.4nameserver 8.8.8.8 在Ubuntu和Debian中安装resolvconf首先，更新系统软件包，然后通过运行以下命令从官方系统信息库安装resolvconf 。 12$ sudo apt update$ sudo apt install resolvconf 一旦resolvconf安装完成， systemd将触发resolvconf.service自动启动和启用。 要检查它是否已启动并正在运行，请发出以下命令。 1$ sudo systemctl status resolvconf.service 如果由于某种原因未启动并自动启用该服务，则可以按以下步骤启动并启用它。 123$ sudo systemctl start resolvconf.service$ sudo systemctl enable resolvconf.service$ sudo systemctl status resolvconf.service 在Ubuntu和Debian中设置永久DNSNameservers接下来，打开/etc/resolvconf/resolv.conf.d/head配置文件。 1$ sudo nano /etc/resolvconf/resolv.conf.d/head 并在其中添加以下几行： 12nameserver 8.8.8.8 nameserver 8.8.4.4 在Resolvconf中设置永久DNSNameservers 保存更改，然后重新启动resolvconf.service或重新引导系统。 1$ sudo systemctl start resolvconf.service 现在，当您检查/etc/resolv.conf文件时，Nameservers条目应永久存储在此处。 从今以后，您将不会在系统上遇到任何有关名称解析的问题永久DNSNameservers","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"Nslookup命令-查DNS信息用","date":"2020-08-26T12:35:29.000Z","path":"2020/08/26/nslookup命令-查DNS信息用/","text":"基本说明 nslookup命令是常用域名查询工具，就是查DNS信息用的命令。 nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。 进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。 语法nslookup(选项)(参数) 选项 -sil：不显示任何警告信息。 参数域名：指定要查询域名。 实例12345678[root@localhost ~]# nslookup www.linuxde.netServer: 202.96.104.15Address: 202.96.104.15#53Non-authoritative answer:www.linuxde.net canonical name = host.1.linuxde.net.Name: host.1.linuxde.netAddress: 100.42.212.8 参考 如何在Ubuntu和Debian中设置永久DNSNameservers ubuntu 修改 DNS 的方法","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"Ubuntu20.04中安装flameshot截屏工具","date":"2020-08-01T23:27:28.000Z","path":"2020/08/02/Ubuntu20-04中安装flameshot截屏工具/","text":"作用截图工具，可添加文字、箭头等 安装在软件商店里有，直接搜索软件名flameshot安装就行 效果图 使用快捷键 快捷键 描述 ←、↓、↑、→ 移动选择区域 1px Shift + ←、↓、↑、→ 将选择区域大小更改 1px Esc 退出截图 Ctrl + C 复制到粘贴板 Ctrl + S 将选择区域保存为文件 Ctrl + Z 撤销最近的一次操作 鼠标右键 展示颜色拾取器 鼠标滚轮 改变工具的宽度 边按住 Shift 键并拖动选择区域的其中一个控制点将会对它相反方向的控制点做类似的拖放操作。 Flameshot 命令行选项Flameshot 支持一系列的命令行选项来延时截图和保存图片到自定义的路径。 要使用 Flameshot GUI 模式，运行： 1flameshot gui 要使用 GUI 模式截屏并将你选取的区域保存到一个自定义的路径，运行： 1flameshot gui -p ~/myStuff/captures 要延时 2 秒后打开 GUI 模式可以使用： 1flameshot gui -d 2000 要延时 2 秒并将截图保存到一个自定义的路径（无 GUI）可以使用： 1flameshot full -p ~/myStuff/captures -d 2000 要截图全屏并保存到自定义的路径和粘贴板中使用： 1flameshot full -c -p ~/myStuff/captures 要在截屏中包含鼠标并将图片保存为 PNG 格式可以使用： 1flameshot screen -r 要对屏幕 1 进行截屏并将截屏复制到粘贴板中可以运行： 1flameshot screen -n 1 -c 参考Linux中的截图工具 - FlameshotUbuntu 20.04 截图软件的使用 (gnome-screenshot、flameshot、shutter 截图编辑三叉戟)","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu刷新DNS","date":"2020-07-31T09:59:24.000Z","path":"2020/07/31/Ubuntu刷新DNS/","text":"方式一:刷新DNS1sudo /etc/init.d/nscd restart 如果发现提示命令找不到： 1sudo: /etc/init.d/nscd: command not found 需要先安装nscd包： 1sudo apt-get install nscd 方式二:重启网络刷dns1sudo /etc/init.d/networking restart","tags":[{"name":"Ubuntu配置","slug":"Ubuntu配置","permalink":"https://zjinc36.github.io/tags/Ubuntu配置/"}]},{"title":"循环冗余校验（CRC）算法","date":"2020-07-27T22:39:14.000Z","path":"2020/07/28/循环冗余校验（CRC）算法/","text":"参考 知乎:https://www.zhihu.com/question/20303082/answer/158430490 – 作者：红猴子 循环冗余校验（CRC）算法入门引导 从奇偶校验说起所谓通讯过程的校验是指在通讯数据后加上一些附加信息，通过这些附加信息来判断接收到的数据是否和发送出的数据相同。比如说RS232串行通讯可以设置奇偶校验位，所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个。比如我们要发送的字节是0x1a，二进制表示为0001 1010。 采用奇校验，则在数据后补上个0，数据变为0001 1010 0，数据中1的个数为奇数个（3个） 采用偶校验，则在数据后补上个1，数据变为0001 1010 1，数据中1的个数为偶数个（4个） 接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错。 奇偶校验的缺点也很明显，首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大。因此，在高速数据通讯中很少采用奇偶校验。奇偶校验优点也很明显，它很简单，因此可以用硬件来实现，这样可以减少软件的负担。因此，奇偶校验也被广泛的应用着。 奇偶校验就先介绍到这来，之所以从奇偶校验说起，是因为这种校验方式最简单，而且后面将会知道奇偶校验其实就是CRC 校验的一种(CRC-1)。 累加和校验另一种常见的校验方式是累加和校验。所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后加入一个字节的校验数据。这个字节内容为前面数据包中全部数据的忽略进位的按字节累加和。比如下面的例子： 我们要传输的信息为： 6、23、4 加上校验和后的数据包：6、23、4、33 这里 33 为前三个字节的校验和。接收方收到全部数据后对前三个数据进行同样的累加计算，如果累加和与最后一个字节相同的话就认为传输的数据没有错误。 累加和校验由于实现起来非常简单，也被广泛的采用。但是这种校验方式的检错能力也比较一般，对于单字节的校验和大概有1/256 的概率将原本是错误的通讯数据误判为正确数据。之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节） CRC(Cyclic Redundancy )算法CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面 发送端计算CRC的过程 为什么添加4个0后面说明 什么是生成多项式后面说明 为什么是XOR后面说明 验证码串是否正确 生成多项式比如说我们有两个二进制数，分别为：1101 和1011。 1101 与如下的多项式相联系： 1011与如下的多项式相联系： 两个多项式的乘法： 得到结果后，合并同类项时采用模2运算。也就是说乘除法采用正常的多项式乘除法，而加减法都采用模2运算。所谓模2运算就是结果除以2后取余数。比如3 mod 2 = 1。因此，上面最终得到的多项式为：对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明) 加减法采用模2运算后其实就成了一种运算了，就是我们通常所说的异或运算： 异或加法 异或减法 0+0=0 0-0=0 0+1=1 1-0=1 1+0=1 0-1=1 1+1=0 1-1=0 采用了模2的加减法后，不需要考虑借位的问题，所以除法变简单了。最后得到的余数就是CRC 校验字。为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“生成多项式”。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。好在这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了。 最常用的几种生成多项式如下： 什么是位宽文献中提到的生成多项式经常会说到多项式的位宽（Width，简记为W），这个位宽不是多项式对应的二进制数的位数，而是位数减1。 比如CRC8中用到的位宽为8的生成多项式，其实对应得二进制数有九位：100110001。另外一点，多项式表示和二进制表示都很繁琐，交流起来不方便，因此，文献中多用16进制简写法来表示，因为生成多项式的最高位肯定为1，最高位的位置由位宽可知，故在简记式中，将最高的1统一去掉了，如CRC32的生成多项式简记为04C11DB7实际上表示的是104C11DB7。当然，这样简记除了方便外，在编程计算时也有它的用处。 为什么理论上有7个1但只写了6个 对于对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明)的例子，是将最高的1统一去掉了 为什么需要补4个0 对于发送端计算CRC的过程的例子，除数是5位数10011，也就是位宽为4（W=4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0。 奇偶校验与生成多项式的关系位宽W=1的生成多项式(CRC1)有两种，分别是X^1和X^1+X^0，读者可以自己证明10 对应的就是奇偶校验中的奇校验，而11对应则是偶校验。因此，写到这里我们知道了奇偶校验其实就是CRC校验的一种特例，这也是我要以奇偶校验作为开篇介绍的原因了。","tags":[]},{"title":"ubuntu中Rime输入法的安装和配置","date":"2020-07-26T12:24:13.000Z","path":"2020/07/26/ubuntu中Rime输入法的安装和配置/","text":"官方网站及文档https://rime.im/ 安装 安装 1sudo apt install ibus-rime 添加Rime输入法 配置 Rime的配置是没有界面的 根据个人喜好修改配置文件：一般用户直接修改default.yaml即可。修改前最好备份一下 网上有很多高端教程要大家创建default.custom.yaml，是因为rime升级的时候貌似会进行覆盖操作 但我实践中还是认为找个地方记下来才靠谱，这种基础配置，除非系统爆炸，否则不会再打开第二次的。增加default.custom.yaml，以后看到反而更容易出现混乱。 1vim ~/.config/ibus/rime/default.yaml 如下修改 1234567schema_list: - schema: luna_pinyin_simp #simp是简体，第一位是默认输入法 menu: page_size: 7 #每页候选词个数ascii_composer: switch_key: Shift_L: commit_code #左shift提交字母 修改完之后重启 1ibus restart 修改候选字的大小 安装gnome的插件ibus font setting 地址：https://extensions.gnome.org/extension/1121/ibus-font-setting/","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"ubuntu18.04中ibus-Sunpinyin的安装与设置","date":"2020-07-26T11:43:09.000Z","path":"2020/07/26/Ubuntu18.04中ibus-sunpinyin的安装与设置/","text":"安装1sudo apt-get install ibus-sunpinyin 添加 配置终端输入1ibus-setup 在设置中添加sun-pinyin输入法 设置 有可能打不开(问题如下) ubuntu18.04安装了ibus-pinyin, 选用了sunpinyin，但是无法调出sunpinyin的设置窗口。 当通过命令/usr/lib/ibus/ibus-setup-sunpinyin时，出现如下错误： 1234Traceback (most recent call last): File \"/usr/share//ibus-sunpinyin/setup/main.py\", line 42, in &lt;module&gt; import ibusImportError: No module named ibus 解决需要安装python-ibus，到 https://launchpad.net/ubuntu/trusty/amd64/python-ibus/1.5.5-1ubuntu3.2 下载python-ibus_1.5.5-1ubuntu3.2_all.deb安装包，通过命令安装即可 1234sudo gdebi python-ibus_1.5.5-1ubuntu3.2_all.deb# 如果没有gdebi命令,用如下命令安装sudo apt-get install gdebi 修改候选字的大小 安装gnome的插件ibus font setting 地址：https://extensions.gnome.org/extension/1121/ibus-font-setting/ 如果配置没有生效 遇事不决先重启 1ibus restart 注销系统重新登录","tags":[{"name":"Ubuntu配置","slug":"Ubuntu配置","permalink":"https://zjinc36.github.io/tags/Ubuntu配置/"}]},{"title":"Ubuntu设置开机自动加/挂载硬盘","date":"2020-07-24T18:28:39.000Z","path":"2020/07/25/Ubuntu设置开机自动加-挂载硬盘/","text":"找到要挂载的磁盘的名称 查看磁盘的分区UUID 新打开一个终端：sudo blkid 找到分区的UUID与tpye 在/etc/fstab中添加12345678910111213141516171819202122232425262728# /etc/fstab: static file system information.## Use 'blkid' to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;# # &lt;file system&gt; 磁盘设备名或该设备的Label# # &lt;mount point&gt; 挂载点（目录）# # &lt;type&gt; 磁盘分区的文件系统# # &lt;options&gt; 文件系统参数# # &lt;dump&gt; 能否被dump命令作用# # &lt;pass&gt; 是否以fsck检测扇区# / was on /dev/nvme0n1p5 during installationUUID=81ae4ddb-7784-45bf-b770-47cb89c85aca / ext4 errors=remount-ro 0 1# /boot/efi was on /dev/nvme0n1p1 during installationUUID=3024-823F /boot/efi vfat umask=0077 0 1# swap was on /dev/nvme0n1p6 during installationUUID=7b9777a0-d735-4c9e-b6ba-109ffce567c2 none swap sw 0 0# 复制前面的# UUID=81ae4ddb-7784-45bf-b770-47cb89c85aca / ext4 errors=remount-ro 0 1# 将UUID改为前面得到的UUID# 把/改为/media/zjc/otherDocuments# 把errors=remount-ro改为defaults# 后面的1改0UUID=EC9CB4199CB3DBF0 /media/zjc/otherDocuments ntfs defaults 0 1","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu18.04如何固定图标到任务栏","date":"2020-07-18T14:53:24.000Z","path":"2020/07/18/Ubuntu18-04如何固定图标到任务栏/","text":"添加图标123sudo vim /usr/share/applications/softName.desktop或者sudo vim ~/.local/share/applications/softName.desktop softName就是添加快捷方式的名称，也就是软件的名称 添加如下内容 1234567891011[Desktop Entry]#!/usr/bin/env xdg-open[Desktop Entry]Version=1.0Terminal=falseType=ApplicationName=Exec=Icon=NoDisplay=falseStartupWMClass= 说明 [Desktop Entry] 每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件 Version = 1.0 标明Desktop Entry的版本（可选） Name = IdeaIU 程序名称（必须），这里以创建一个idea的快捷方式为例 GenericName = IdeaIU 程序通用名称（可选） Comment =IdeaIU 程序描述（可选） Exec = 程序的启动命令（必选），可以带参数运行 Icon = 设置快捷方式的图标（可选），当Type为Application，此项有效 Terminal = false 是否在终端中运行（可选），当Type为Application，此项有效 Type = Application desktop的类型（必选），常见值有“Application”和“Link” Categories = GNOME;Application;Network; //注明在菜单栏中显示的类别（可选） 将图标放到任务栏点击应用按钮，把刚生成的应用图标拖到任务栏中 但是有可能会出现启动应用出现双图标,如下 为了解决这个问题，首先打开应用，然后在终端输入： 1xprop |grep WM_CLASS 此时鼠标指针会变成一个十字准心，点击已经打开的软件界面，终端会反馈一条信息，包括2个字符串把第1个字符串里的内容添加到StartupWMClass里，保存，关闭应用重新打开，将不会出现双图标的情况了","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中批量下载bilibili网站的视频","date":"2020-07-11T11:50:44.000Z","path":"2020/07/11/Ubuntu中批量下载bilibili网站的视频/","text":"方案一:you-get项目地址Github地址:https://github.com/soimort/you-get 安装12pip3 install you-get #安装You-Getpip3 install --upgrade you-get #升级You-Get 使用1you-get --playlist -o ./ https://www.bilibili.com/video/视频地址\\?p\\=1 方案二项目地址Github地址:https://github.com/Henryhaohao/Bilibili_video_download 使用 将项目克隆到本地 运行 1python /your/address/bilibili_video_download.py","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中安装分区管理工具gparted","date":"2020-07-08T15:16:44.000Z","path":"2020/07/08/Ubuntu中安装分区管理工具gparted/","text":"作用 官网 GNOME Partition Editor,分区管理工具 安装 https://gparted.org/download.php Ubuntu安装 1sudo apt-get install gparted 主界面","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中基于Docker安装QQ和WeChat","date":"2020-07-08T14:30:14.000Z","path":"2020/07/08/Ubuntu中基于Docker安装QQ和WeChat/","text":"github上有这两个项目 https://github.com/bestwu/docker-wechat https://github.com/bestwu/docker-qq 有个管理脚本脚本 https://github.com/ygcaicn/ubuntu_qq","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中安装桌面搜索应用DocFetcher","date":"2020-07-07T08:15:49.000Z","path":"2020/07/07/Ubuntu中安装桌面搜索应用DocFetcher/","text":"作用 DocFetcher 是一个使用 Java 语言开发的开源桌面搜索应用程序 能搜索docx和pdf的内容 平台Windows，Linux 和 OS X 安装 基于java,所以需要运行环境：Java Runtime Environment（JRE）1.7 + 参考官网说明:http://docfetcher.sourceforge.net/en/download.html 使用方法建立索引为了快速的进行文本检索，DocFetcher 在检索文档文本前需要建立索引，用户可以根据需要为文件夹或者整个磁盘建立索引，当然，仅仅在第一次检索时需要为所要检索的文件夹或磁盘建立索引，建立索引后，当文件内容发生了变化 DocFetcher 会自动更新索引。以下是建立索引的详细方法： 如图所示，右击[搜索范围]框的空白处，选择弹出菜单中的[建立索引 - 资料夹]。 在弹出的选择窗口中选择需要检索文档的位置，点击[确认]。 在弹出的窗口中可以对索引的细节进行设置，可以选择所要检索的文件格式，在排除列表中可以使用正则表达式过滤不需要建立索引的文件和文件格式，其他选项没有特殊要求使用默认值即可。最后选择[执行]，将开始建立索引。 建立索引的过程耗时较长，具体时间取决于所选建立索引的文件夹中包含的文件数量及文件大小。索引建立完成后在首页的[搜索范围]框内便有了对应的目录。 检索数据对于建立好索引的目录，可以通过勾选检索目录、勾选文件类型、设定文件大小、输入关键字来进行文本检索，这里仅对 DocFetcher 的检索语法做简单介绍，详细内容请参照官方文档。 短语搜索：需要将所要检索的短语放入英文双引号内。如 ：”可转债”，返回包含词语”可转债”的文件； 布尔运算：支持复杂条件的检索，常用运算符包含 AND、OR 、NOT 等，短语间没有运算符时将默认使用 OR。如 “可转债” AND “可交换债”，返回既包含短语”可转债”又包含短语”可交换债”的文件； 通配符：问号（’?’）和星号（’‘）可用于表示某些字符未知。如 ：”可”，返回包含”可以”、”可转债”、”可交换债”等包含以”可”开头的语句的文件； 模糊搜索：可以搜索与给定单词类似的单词。如，roam~，返回包含 foam 和的单词的文档 roams 的文件。 检索关键字格式关键字是默认分词的，中文分词有时候一言难尽，所以如果想搜索整个词语请务必使用英文双引号括住，否则将导致 DocFetcher 将词语分词后使用 OR 运算进行检索，最终使检索结果出乎意料 参考DocFetcher 使用教程——高效的文档文本检索工具","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中安装离线API文档大全Zeal","date":"2020-07-07T08:03:04.000Z","path":"2020/07/07/Ubuntu中安装离线API文档大全Zeal/","text":"官网Zeal 作用离线 API 文档大全 平台Linux 和 Windows 安装 参考这里https://zealdocs.org/download.html ubuntu安装1sudo apt-get install zeal 使用下载文档在初次安装 Zeal 之后，需要转到 File → Options → Docsets 先下载文档，然后方能使用 使用文档 有两种方式来查询文档 直接输入 keyword 关键字进行查询，这将搜索已下载的所有文档。 包含文档类型前缀的查询，例如：python:keyword 这将仅限于搜索 Python 文档。","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Scala中的特殊符号","date":"2020-07-05T12:00:27.000Z","path":"2020/07/05/Scala中的特殊符号/","text":"泛型限定 符号 作用 说明 [T &lt;: UpperBound] 上界 无 [T &gt;: LowerBound] 下界 无 [T &lt;% ViewBound] 视界 比上界多了隐式转换 [T : ContextBound] 上下文界 是隐式参数的语法糖 [+T] 协变 C[+T]：如果A是B的子类，那么C[A]是C[B]的子类，称为协变 [-T] 逆变 C[-T]：如果A是B的子类，那么C[B]是C[A]的子类，称为逆变 =:= A 必须和 B相等 Scala 2.10 中被移除了 &lt;:&lt; A 必须是 B的子类 Scala 2.10 中被移除了 &lt;%&lt; A 必须可以被看做是 B Scala 2.10 中被移除了 如果你在尝试使用 &lt;:&lt; 或者 &lt;%&lt; 的时候出错了，那请注意这些符号在 Scala 2.10 中被移除了。Scala School 里的例子仅能在 Scala 2.9.x 下正常工作。你可以使用新版本的 Scala，但可能会遇到错误 123456789101112131415scala&gt; class Container[A](value: A) &#123; def addIt(implicit evidence: A =:= Int) = 123 + value &#125;defined class Containerscala&gt; (new Container(123)).addItres11: Int = 246scala&gt; (new Container(\"123\")).addIt&lt;console&gt;:10: error: could not find implicit value for parameter evidence: =:=[java.lang.String,Int]// 类似地，根据之前的隐式转换，我们可以将约束放松为可视性：scala&gt; class Container[A](value: A) &#123; def addIt(implicit evidence: A &lt;%&lt; Int) = 123 + value &#125;defined class Containerscala&gt; (new Container(\"123\")).addItres15: Int = 246 集合操作符这些符号全都是连接的作用，将元素与集合、集合与集合相连接 集合拼接 :: ++:等操作12345scala&gt; val a = List(1,2,3)a: List[Int] = List(1, 2, 3)scala&gt; val b = List(4,5,6)b: List[Int] = List(4, 5, 6) 符号 位置 解释 操作 结果 :: 前插 把a当成一个元素，前插到b集合 a :: b List(List(1, 2, 3), 4, 5, 6) +: 前插 同上 a +: b List(List(1, 2, 3), 4, 5, 6) :+ 后插 把b当成一个元素，后插到a集合 a :+ b List(1, 2, 3, List(4, 5, 6)) ++ 拼接 a和b集合顺序合并 a ++ b List(1, 2, 3, 4, 5, 6) ++: 拼接 同上 a ++:b List(1, 2, 3, 4, 5, 6) ::: 拼接 同上 a :::b List(1, 2, 3, 4, 5, 6) ::操作符是右结合的，如9 :: 5 :: 2 :: Nil相当于9 :: (5 :: (2 :: Nil))。 所以 :: +: :::这些操作符都是在前面插入。:+ ++ ++:这些是追加、拼接。 集合拼接 ++= –= 等操作 ++= —= ++= 用于拼接容器，而 += 用于拼接元素 加法 xs += x 把元素 x 添加到集合 xs 中。该操作有副作用，它会返回左操作符，这里是 xs 自身。 xs += (x, y, z) 添加指定的元素到集合 xs 中，并返回 xs 本身。（同样有副作用） xs ++= ys 添加集合 ys 中的所有元素到集合 xs 中，并返回 xs 本身。（表达式有副作用） xs add x 把元素 x 添加到集合 xs 中，如集合 xs 之前没有包含 x，该操作返回 true，否则返回 false。 移除 xs -= x 从集合 xs 中删除元素 x，并返回 xs 本身。（表达式有副作用） xs -= (x, y, z) 从集合 xs 中删除指定的元素，并返回 xs 本身。（表达式有副作用） xs –= ys 从集合 xs 中删除所有属于集合 ys 的元素，并返回 xs 本身。（表达式有副作用） xs remove x 从集合 xs 中删除元素 x 。如之前 xs 中包含了 x 元素，返回 true，否则返回 false。 xs retain p 只保留集合 xs 中满足条件 p 的元素。 xs.clear() 删除集合 xs 中的所有元素。 更新 xs(x) = b （ 同 xs.update(x, b) ）参数 b 为布尔类型，如果值为 true 就把元素x加入集合 xs，否则从集合 xs 中删除 x。 克隆 xs.clone 产生一个与 xs 具有相同元素的可变集合。 字符串插值 符号 作用 s 字符串插值器 在任何字符串前加上s，就可以直接在串中使用变量 f 插值器 在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数 raw 插值器 除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的 举例 s 字符串插值器 1234567val name=\"James\"// $name嵌套在一个将被s字符串插值器处理的字符串中。// 插值器知道在这个字符串的这个地方应该插入这个name变量的值，以使输出字符串为Hello,James。// 使用s插值器，在这个字符串中可以使用任何在处理范围内的名字。println(s\"Hello,$name\") //Hello,James println(s\"1+1=$&#123;1+1&#125;\") //将会输出字符串1+1=2。任何表达式都可以嵌入到$&#123;&#125;中。 f 插值器 1234567891011121314val height=1.9dval name=\"James\"// f 插值器是类型安全的println(f\"$name%s is $height%2.2f meters tall\")//James is 1.90 meters tall val height:Double=1.9d// 如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：scala&gt;f\"$height%4d\"&lt;console&gt;:9: error: type mismatch; found : Double required: Int f\"$height%4d\" ^ f 插值器利用了java中的字符串数据格式。这种以%开头的格式在 raw 插值器 123456789scala&gt;s\"a\\nb\"res0:String=ab // 这里，s 插值器用回车代替了\\n。而raw插值器却不会如此处理。scala&gt;raw\"a\\nb\"res1:String=a\\nb // 当不想输入\\n被转换为回车的时候，raw 插值器是非常实用的。 _（下划线）的用法 通配符 12//_可以起到类似于*作用的通配符import org.apache.spark.SparkContext._ 指代集合中的每一个元素 123// 例如 遍历集合筛选列表中大于某个值的元素。val lst = List(1,2,3,4,5)val lstFilter = lst.filter(_ &gt; 3) 获取元组中指定下标的元素值 12val ss = (1,\"22\",\"333\")println(ss._1) 使用模式匹配可以用来获取元组的组员 123val m = Map(1 -&gt; 2,2 -&gt; 4)//如果不需要所有部件， 则在不需要的部件使用_； 本例只取key,因此在value处用_for ((k,_) &lt;- m) println(k) 成员变量而非局部变量添加默认值 1234var s:Int=_def main(args: Array[String]): Unit = &#123; println(s)&#125; 可变长度参数 123456scala&gt; val arr = Array(1,2,3,4,5)arr: Array[Int] = Array(1, 2, 3, 4, 5)scala&gt; val Array(first, second, _*) = arrfirst: Int = 1second: Int = 2 不需要的部件使用_ 1234567891011121314151617Some(5) match &#123; case Some(_) =&gt; println(\"Yes\") &#125;match &#123; case List(1,_,_) =&gt; \" a list with three element and the first element is 1\" case List(_*) =&gt; \" a list with zero or more elements \" case Map[_,_] =&gt; \" matches a map with any key type and any value type \" case _ =&gt;&#125;val (a, _) = (1, 2)for (_ &lt;- 1 to 10)//如果不需要所有部件， 则在不需要的部件使用_； 本例只取key,因此在value处用 _ val m = Map(1 -&gt; 2,2 -&gt; 4)for ((k,_) &lt;- m) println(k) :_*参数序列处理:_* 作为一个整体，告诉编译器你希望将某个参数当作参数序列处理 当函数接收的参数不定长的时候，假如你想输入一个队列，可以在一个队列后加入“:_*”，因此，这里的“1 to 5”也可以改写为：“Seq(1,2,3,4,5)”。 1234567891011object Sample &#123; def main (args: Array[String])=&#123; val result=sum(1 to 5:_*) // 在后面写上: _*将1 to 5转化为参数序列 println(result) &#125; def sum(parms:Int*)=&#123; var result=0 for(parm &lt;- parms)result+=parm result &#125;&#125; 模式匹配中使用 @@的主要功能是在模式匹配中，匹配到一个模式后，将引用交给@前的参数案例1 12345678910111213141516val o: Option[Int] = Some(2)o match &#123; case Some(x) =&gt; println(x) // 打印2 case _ =&gt; println(\"do nothing\")&#125;o match &#123; case someRef @ Some(x) =&gt; println(someRef) // 打印Some(2) case _ =&gt; println(\"do nothing\")&#125;o match &#123; case x @ Some(_) =&gt; println(x) // 打印Some(2) case _ =&gt; println(\"do nothing\")&#125; 案例2 12345678910// 在处理 request 请求的时候，需要匹配请求的路径，然后还需要直接使用 requetdef intent = &#123; case req @ GET(Path(Seg(\"api\" :: \"user\" :: IntPathElement(userId) :: Nil))) =&gt; val f = (userManager ? FindUserById(userId)) respond(f, req) case req @ GET(Path(Seg(\"api\" :: \"user\" :: Nil))) &amp; Params(EmailParam(email)) =&gt; val f = (userManager ? FindUserByEmail(email)) respond(f, req) &#125; Akka 相关特殊字符! ? 符号 作用 ! 表示“即发即忘”，例如异步发送消息并立即返回,也称为tell ? 异步发送消息并返回表示可能回复的Future,也称为ask 举例 send ! 12345case ArticleBody(uri, body) =&gt; //If we get the parsed article back, then we've just parsed it cacheActor ! SetRequest(uri, body) //Cache it as we just parsed it senderRef ! body context.stop(self) ask ? 1val future = pongActor ? \"unknown\"","tags":[{"name":"BigData","slug":"BigData","permalink":"https://zjinc36.github.io/tags/BigData/"}]},{"title":"Ubuntu中安装词典GoldenDict","date":"2020-06-14T12:15:30.000Z","path":"2020/06/14/Ubuntu中安装词典GoldenDict/","text":"安装1sudo apt-get install goldendict 添加词库 离线词库下载测试过http://download.huzheng.org/zh_CN/测试过英汉:朗文5++ ·双解·例句发音没测试过http://download.huzheng.org/ 添加 添加在线搜索这里添加有道http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8 取消百科的搜索 调整词典顺序 使用 快捷键 屏幕取词将需要查询的内容选取,按ctrl + c + c快捷键 教程安装使用 GoldenDict 查词神器 (Windows/Mac/Linux)","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中一键OCR识别图片截图文字转文本","date":"2020-06-14T09:20:26.000Z","path":"2020/06/14/Ubuntu中一键OCR识别图片截图文字转文本/","text":"主要思路利用截图软件gnome-screenshot 进行截取需要被文字识别的图片；利用文字识别OCR软件tesseract，进行识别将结果输出，复制到文件和剪切板 步骤1：安装依赖软件安装tesseracttesseract是一个开源的OCR引擎，最初是由惠普公司开发用来作为其平板扫描仪的OCR引擎，2005年惠普将其开源出来，之后google接手负责维护。目前稳定的版本是3.0。4.0版本加入了基于LSTM的神经网络技术，中文字符识别准确率有所提高。 添加源 1sudo add-apt-repository ppa:alex-p/tesseract-ocr 更新源 1sudo apt-get update 安装 1sudo apt-get install tesseract-ocr 安装中文字库 tesseract支持60多种语言的识别不同，使用之前需要先下载对应语言的字库，下载地址：https://github.com/tesseract-ocr/tessdata 下载完成之后把.traineddata字库文件放到tessdata目录下，默认路径是/usr/share/tesseract-ocr/4.00/tessdata 安装剩余软件：shutter，xclip, imagemagick这3个不需要添加源，直接终端输入代码： 123456# 截屏软件sudo apt-get install shutter# 终端复制命令sudo apt-get install xclip# 图片处理sudo apt-get install imagemagick 步骤2：制作shell脚本 创建一个可执行脚本,脚本内容为以下代码,并脚本放到环境变量所在目录 注意：将代码中，SCR=”/home/Username/Documents/temp”双引号中的路径替换成你想要存放截图以及识别结果txt文档的路径 用tesseract --list-langs检查安装过的语言包 12345tesseract --list-langsList of available languages (3):engchi_simosd 脚本内容如下 1234567891011121314151617181920212223242526272829303132333435#!/bin/bash# Dependencies: tesseract-ocr imagemagick shutter xclip#Name: OCR#Date: 2020-06-14#Fuction: take a screenshot and OCR the letters in the picture#Path: /home/UserName/...#you can only scan one character at a timeSCR=\"/home/UserName/Documents/temp\"####take a shot what you wana to OCR to text# The purpose of assigning the result to the variable is# to wait for this command to complete before executing the next lineshutterOutput=`shutter -s -e -o $SCR.png &gt; /dev/null 2&gt;&amp;1`####increase the pngmogrify -modulate 100,0 -resize 400% $SCR.png#should increase detection rate####OCR by tesseract# Language packages are identified with the `tesseract --list-langs` commandtesseract $SCR.png $SCR &amp;&gt; /dev/null -l eng+chi_sim####use sed to delete the blanks &amp; get the text and copy to clipboardcat $SCR.txt | sed 's/ //g' | xclip -selection clipboard# If you need to delete the newline, please use this statement# and comment the previous sentence (the first line plus #)#cat $SCR.txt | sed 's/ //g'| xargs | xclip -selection clipboard# The pop-up window prompts the end of OCRnotify-send \"OCR Done\"exit 步骤3：设置快捷键，一键调用shell脚本 进入：设置-&gt;键盘 拉到底部，点击+ 名称：自由设置，建议以shell脚本名称命名 命令：脚本名字 参考Linux系统（ubuntu）一键OCR识别图片截图文字转文本Tesseract安装使用","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Linux中使用tar和gzip进行打包拆包压缩解压","date":"2020-06-11T09:22:52.000Z","path":"2020/06/11/Linux中使用tar和gzip进行打包拆包压缩解压/","text":"压缩格式： windows (zip、rar) linux (gz ，bzip，zip) 先打包再压缩， 打包后可以拆包，压缩后可以解压 打包：目录可能有很多个文件，我先把它们打包成一个文件 压缩：把打包后的那个文件压缩 tar打包与拆包打包 命令 1tar -cvf 打包后的文件名即归档文件.tar 欲打包的文件夹名 例子 1tar -cvf news.tar ./java 把java文件夹打包成new.tar 拆包 命令 1tar -xvf 打包后的文件名即归档文件名.tar 例子 1tar -xvf news.tar 可以把new.tar拆包，拆出来java文件夹 参数说明1234567891011- c ：打包，创建的一个归档文件 ，即打包文件夹- x ：拆包- z ：以gzip 格式压缩，默认压缩倍数 6倍 （0-9）- j ：以bzip2格式压缩- v ：显示打包或者拆包的文件信息- f ： 后面紧接一个 归档文件 gzip 压缩与解压(bzip2也可以)压缩 命令 1gzip 要压缩的打包后的文件名即归档文件名.tar 例子 1gzip news.tar 解压 命令 1gzip -d 要解压的文件名.tar.gz 例子 1gzip -d news.tar.gz 打包且压缩 命令 1tar -czvf 打包并压缩后的文件名.tar.gz 欲打包及压缩的文件夹名 例子 12345tar -czvf news.tar.gz ./java或tar -czvf news.tar.gz java/或tar -czvf news.tar.gz java 解压及拆包 命令 1tar -xzvf 打包及压缩后的文件名.tar.gz 例子 1tar -xzvf news.tar.gz","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"Java中用final修饰静态变量后对静态代码块的影响","date":"2020-06-10T12:34:22.000Z","path":"2020/06/10/Java中用final修饰静态变量后对静态代码块的影响/","text":"判断如下代码打印结果User.java 123456public class User &#123; public static int age = 20; static &#123; System.out.println(\"user....\"); &#125;&#125; Emp.java 1234567public class Emp &#123; // 注意,这里的final public final static int age = 30; static &#123; System.out.println(\"Emp....\"); &#125;&#125; 运行代码 123456public class Test &#123; public static void main(String[] args) &#123; System.out.println(User.age); System.out.println(Emp.age); &#125;&#125; 结果 123user....2030 问:为什么不打印Emp....,按理来说,static代码块在代码类加载的时候就应该调用的,也就是说Emp....应该要打印出来的 为什么不打印Emp....我们分别查看User.java和Emp.java的字节码 不加final的User的字节码 1234567891011121314151617181920212223242526272829303132333435363738&#123; public static int age; descriptor: I flags: ACC_PUBLIC, ACC_STATIC static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=2, locals=0, args_size=0 0: bipush 20 2: putstatic #10 // Field age:I 5: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 8: ldc #18 // String user.... 10: invokevirtual #20 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 13: return LineNumberTable: line 4: 0 line 6: 5 line 7: 13 LocalVariableTable: Start Length Slot Name Signature public com.zjc.hbasedemo.User(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #29 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/zjc/hbasedemo/User;&#125;SourceFile: &quot;User.java&quot; 加final的Emp的字节码 123456789101112131415161718192021222324252627282930313233343536&#123; public static final int age; descriptor: I flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL ConstantValue: int 30 static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=2, locals=0, args_size=0 0: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #18 // String Emp.... 5: invokevirtual #20 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 6: 0 line 7: 8 LocalVariableTable: Start Length Slot Name Signature public com.zjc.hbasedemo.Emp(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #29 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/zjc/hbasedemo/Emp;&#125;SourceFile: &quot;Emp.java&quot; 结论对于有final关键字来说 对final的含义来说,是将变量变为一个”不可改变的变量(类似常量)” 而从字节码可以看出,有final关键字的变量比static更早被赋值,所以,当我们调用Emp.age时,并不需要static块的内容被加载,所以static块的内容不会被打印 对于无final关键字来说,从字节码中可以得出这段代码 123456public class User &#123; public static int age = 20; static &#123; System.out.println(\"user....\"); &#125;&#125; 相当于这段代码 12345678public class User &#123; // (这代码在Test.java中调用也要跟着改,这里只是说明用) // public static int age = 20; static &#123; int age = 20; System.out.println(\"User....\"); &#125;&#125;","tags":[]},{"title":"Java中的多态传递","date":"2020-06-10T12:07:09.000Z","path":"2020/06/10/Java中的多态传递/","text":"下述代码中的A a = new C();中,类C是否实现了接口A1234567891011public class Test &#123; public static void main(String[] args) &#123; A a = new C(); &#125;&#125;interface A &#123;&#125;class B implements A &#123;&#125;class C extends B &#123;&#125; 我们可以打印看看 1234567891011public class Test &#123; public static void main(String[] args) &#123; System.out.println(C.class.getInterfaces().length); &#125;&#125;interface A &#123;&#125;class B implements A &#123;&#125;class C extends B &#123;&#125; 打印结果 10 说明C事实上是没有实现接口A的 那为什么A a = new C();没有报错呢? 实现类是可以代替接口出现的 1A a = new B(); 子类是可以代替父类对象出现的 1B b = new C(); 所以可以写成 1A a = new C(); 语法上是没问题的,虽然C没有特定实现A,但由于有一个多态传递的功能,所以是不会报错的","tags":[{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"}]},{"title":"Java的类加载器","date":"2020-06-10T10:33:35.000Z","path":"2020/06/10/Java的类加载器/","text":"类加载器分类Java虚拟机自带的加载器 启动类加载器(Bootstrap) -&gt; 加载java核心类库 扩展类加载器(Extension) 应用类加载器(Application) -&gt; 自定义类一般都是应用加载器加载的 用户自定义的类加载器(本文不讲) java.lang.ClassLoader 的子类 用户可以定制类的加载方式 类加载器的作用加载类 Java类加载器（英语：Java Classloader）是Java运行时环境（Java Runtime Environment）的一个部件，负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。 类加载器的加载路径打印加载路径的代码1234567891011121314151617181920212223242526272829303132333435public class ClassLoaderTest &#123; public static void main(String[] args) &#123; System.out.println(\"BootstrapClassLoader 的加载路径: \"); //String[] bootUrls = System.getProperty(\"sun.boot.class.path\").split(\";\"); URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for(URL url : urls) System.out.println(url); System.out.println(\"----------------------------\"); //取得扩展类加载器 URLClassLoader extClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader().getParent(); System.out.println(extClassLoader); System.out.println(\"扩展类加载器 的加载路径: \"); urls = extClassLoader.getURLs(); for(URL url : urls) System.out.println(url); System.out.println(\"----------------------------\"); //取得应用(系统)类加载器 URLClassLoader appClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader(); System.out.println(appClassLoader); System.out.println(\"应用(系统)类加载器 的加载路径: \"); urls = appClassLoader.getURLs(); for(URL url : urls) System.out.println(url); System.out.println(\"----------------------------\"); &#125;&#125; 执行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127BootstrapClassLoader 的加载路径:file:/usr/lib/jvm/java-8-oracle/jre/lib/resources.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/rt.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/sunrsasign.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/jsse.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/jce.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/charsets.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/jfr.jarfile:/usr/lib/jvm/java-8-oracle/jre/classes----------------------------sun.misc.Launcher$ExtClassLoader@15db9742扩展类加载器 的加载路径:file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/sunpkcs11.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/cldrdata.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/dnsns.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/sunjce_provider.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/jfxrt.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/localedata.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/jaccess.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/sunec.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/ext/zipfs.jar----------------------------sun.misc.Launcher$AppClassLoader@73d16e93应用(系统)类加载器 的加载路径:file:/home/zjc/Documents/eclipse-workspace/hbase/target/classes/file:/home/zjc/.m2/repository/org/apache/hbase/hbase-server/1.3.1/hbase-server-1.3.1.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-common/1.3.1/hbase-common-1.3.1.jarfile:/home/zjc/.m2/repository/com/github/stephenc/findbugs/findbugs-annotations/1.3.9-1/findbugs-annotations-1.3.9-1.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-protocol/1.3.1/hbase-protocol-1.3.1.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-procedure/1.3.1/hbase-procedure-1.3.1.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-common/1.3.1/hbase-common-1.3.1-tests.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-prefix-tree/1.3.1/hbase-prefix-tree-1.3.1.jarfile:/home/zjc/.m2/repository/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jarfile:/home/zjc/.m2/repository/commons-codec/commons-codec/1.9/commons-codec-1.9.jarfile:/home/zjc/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-hadoop-compat/1.3.1/hbase-hadoop-compat-1.3.1.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-hadoop2-compat/1.3.1/hbase-hadoop2-compat-1.3.1.jarfile:/home/zjc/.m2/repository/com/yammer/metrics/metrics-core/2.2.0/metrics-core-2.2.0.jarfile:/home/zjc/.m2/repository/org/slf4j/slf4j-api/1.7.2/slf4j-api-1.7.2.jarfile:/home/zjc/.m2/repository/com/google/guava/guava/12.0.1/guava-12.0.1.jarfile:/home/zjc/.m2/repository/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jarfile:/home/zjc/.m2/repository/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jarfile:/home/zjc/.m2/repository/com/sun/jersey/jersey-server/1.9/jersey-server-1.9.jarfile:/home/zjc/.m2/repository/asm/asm/3.1/asm-3.1.jarfile:/home/zjc/.m2/repository/commons-cli/commons-cli/1.2/commons-cli-1.2.jarfile:/home/zjc/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jarfile:/home/zjc/.m2/repository/commons-lang/commons-lang/2.6/commons-lang-2.6.jarfile:/home/zjc/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jarfile:/home/zjc/.m2/repository/org/apache/commons/commons-math/2.2/commons-math-2.2.jarfile:/home/zjc/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jarfile:/home/zjc/.m2/repository/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jarfile:/home/zjc/.m2/repository/org/slf4j/slf4j-log4j12/1.6.1/slf4j-log4j12-1.6.1.jarfile:/home/zjc/.m2/repository/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jarfile:/home/zjc/.m2/repository/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jarfile:/home/zjc/.m2/repository/org/mortbay/jetty/jetty-sslengine/6.1.26/jetty-sslengine-6.1.26.jarfile:/home/zjc/.m2/repository/org/mortbay/jetty/jsp-2.1/6.1.14/jsp-2.1-6.1.14.jarfile:/home/zjc/.m2/repository/org/mortbay/jetty/jsp-api-2.1/6.1.14/jsp-api-2.1-6.1.14.jarfile:/home/zjc/.m2/repository/org/mortbay/jetty/servlet-api-2.5/6.1.14/servlet-api-2.5-6.1.14.jarfile:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jarfile:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jarfile:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jarfile:/home/zjc/.m2/repository/tomcat/jasper-compiler/5.5.23/jasper-compiler-5.5.23.jarfile:/home/zjc/.m2/repository/tomcat/jasper-runtime/5.5.23/jasper-runtime-5.5.23.jarfile:/home/zjc/.m2/repository/commons-el/commons-el/1.0/commons-el-1.0.jarfile:/home/zjc/.m2/repository/org/jamon/jamon-runtime/2.4.1/jamon-runtime-2.4.1.jarfile:/home/zjc/.m2/repository/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jarfile:/home/zjc/.m2/repository/org/apache/htrace/htrace-core/3.1.0-incubating/htrace-core-3.1.0-incubating.jarfile:/home/zjc/.m2/repository/com/lmax/disruptor/3.3.0/disruptor-3.3.0.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-common/2.5.1/hadoop-common-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-annotations/2.5.1/hadoop-annotations-2.5.1.jarfile:/usr/lib/jvm/java-8-oracle/lib/tools.jarfile:/home/zjc/.m2/repository/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jarfile:/home/zjc/.m2/repository/xmlenc/xmlenc/0.52/xmlenc-0.52.jarfile:/home/zjc/.m2/repository/commons-net/commons-net/3.1/commons-net-3.1.jarfile:/home/zjc/.m2/repository/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jarfile:/home/zjc/.m2/repository/org/codehaus/jettison/jettison/1.1/jettison-1.1.jarfile:/home/zjc/.m2/repository/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jarfile:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-xc/1.8.3/jackson-xc-1.8.3.jarfile:/home/zjc/.m2/repository/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jarfile:/home/zjc/.m2/repository/org/apache/httpcomponents/httpcore/4.1.2/httpcore-4.1.2.jarfile:/home/zjc/.m2/repository/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jarfile:/home/zjc/.m2/repository/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jarfile:/home/zjc/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jarfile:/home/zjc/.m2/repository/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jarfile:/home/zjc/.m2/repository/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jarfile:/home/zjc/.m2/repository/org/apache/avro/avro/1.7.4/avro-1.7.4.jarfile:/home/zjc/.m2/repository/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jarfile:/home/zjc/.m2/repository/org/xerial/snappy/snappy-java/1.0.4.1/snappy-java-1.0.4.1.jarfile:/home/zjc/.m2/repository/com/jcraft/jsch/0.1.42/jsch-0.1.42.jarfile:/home/zjc/.m2/repository/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jarfile:/home/zjc/.m2/repository/org/tukaani/xz/1.0/xz-1.0.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-auth/2.5.1/hadoop-auth-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/httpcomponents/httpclient/4.2.5/httpclient-4.2.5.jarfile:/home/zjc/.m2/repository/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jarfile:/home/zjc/.m2/repository/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jarfile:/home/zjc/.m2/repository/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jarfile:/home/zjc/.m2/repository/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-client/2.5.1/hadoop-client-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-app/2.5.1/hadoop-mapreduce-client-app-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-common/2.5.1/hadoop-mapreduce-client-common-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-client/2.5.1/hadoop-yarn-client-2.5.1.jarfile:/home/zjc/.m2/repository/com/sun/jersey/jersey-client/1.9/jersey-client-1.9.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-server-common/2.5.1/hadoop-yarn-server-common-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-shuffle/2.5.1/hadoop-mapreduce-client-shuffle-2.5.1.jarfile:/home/zjc/.m2/repository/org/fusesource/leveldbjni/leveldbjni-all/1.8/leveldbjni-all-1.8.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-api/2.5.1/hadoop-yarn-api-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-jobclient/2.5.1/hadoop-mapreduce-client-jobclient-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-core/2.5.1/hadoop-mapreduce-client-core-2.5.1.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-common/2.5.1/hadoop-yarn-common-2.5.1.jarfile:/home/zjc/.m2/repository/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jarfile:/home/zjc/.m2/repository/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jarfile:/home/zjc/.m2/repository/javax/activation/activation/1.1/activation-1.1.jarfile:/home/zjc/.m2/repository/javax/servlet/servlet-api/2.5/servlet-api-2.5.jarfile:/home/zjc/.m2/repository/com/google/inject/guice/3.0/guice-3.0.jarfile:/home/zjc/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jarfile:/home/zjc/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jarfile:/home/zjc/.m2/repository/com/sun/jersey/contribs/jersey-guice/1.9/jersey-guice-1.9.jarfile:/home/zjc/.m2/repository/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jarfile:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-hdfs/2.5.1/hadoop-hdfs-2.5.1.jarfile:/home/zjc/.m2/repository/commons-daemon/commons-daemon/1.0.13/commons-daemon-1.0.13.jarfile:/home/zjc/.m2/repository/junit/junit/4.12/junit-4.12.jarfile:/home/zjc/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-client/1.3.1/hbase-client-1.3.1.jarfile:/home/zjc/.m2/repository/org/apache/hbase/hbase-annotations/1.3.1/hbase-annotations-1.3.1.jarfile:/home/zjc/.m2/repository/org/jruby/jcodings/jcodings/1.0.8/jcodings-1.0.8.jarfile:/home/zjc/.m2/repository/org/jruby/joni/joni/2.1.2/joni-2.1.2.jar 结论启动器加载路径 安装目录/jre/lib/ 安装目录/jre/classes 扩展类加载器 安装目录/jre/lib/ext/ 应用类加载器 不指定情况下是./目录,即当前目录 类加载器的”辈份”类加载器的执行顺序1234567public class TestClassLoader &#123; public static void main(String[] args) &#123; System.out.println(\"当前类加载器是:\" + TestClassLoader.class.getClassLoader()); System.out.println(\"父类加载器是:\" + TestClassLoader.class.getClassLoader().getParent()); System.out.println(\"爷爷类加载器是:\" + TestClassLoader.class.getClassLoader().getParent().getParent()); &#125;&#125; 打印结果 123当前类加载器是:sun.misc.Launcher$AppClassLoader@73d16e93父类加载器是:sun.misc.Launcher$ExtClassLoader@15db9742爷爷类加载器是:null 也就是说三者顺序如下: 1启动类加载器 &gt; 扩展类加载器 &gt; 应用类加载器 启动类加载器打印为null说明 因为启动类加载器不是用java写的,因为执行完启动类加载器后才会将java的核心类加载. 也就是说,启动类加载器是用系统语言写的(比如是c++) 所以不可能打印出扩展类加载器或应用类加载器那样的java的类,只能是null 双亲委派机制 应用类加载器要加载环境变量classpath下的类 但不直接加载,而是交给父类加载器,即扩展类加载器加载 但不直接加载,而是交给父类加载器,即启动类加载器加载 如果启动类加载器能加载到则使用启动类加载到的类,否则返回null(返回null而不是抛出错误是因为此时不是java) 扩展类加载器收到null的情况下,才尝试加载,如果能加载到就使用扩展类加载器加载到的类,否则抛出异常 应用类加载器收到异常的情况下,才尝试加载,如果能加载到就使用应用类加载器加载到的类,否则抛出ClassNotFound异常","tags":[{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"}]},{"title":"Ubuntu中安装和删除字体","date":"2020-06-04T13:25:54.000Z","path":"2020/06/04/Ubuntu中安装和删除字体/","text":"通过命令管理字体安装字体linux系统的字体文件放在/usr/share/fonts/目录以及用户的/.fonts和/.local/share/fonts目录下，第一个位置为系统所用用户共享，将字体安装到这个目录需要管理员权限；后面两个位置则为当前登陆用户所有,安装字体到这个目录不需要管理员权限。 安装到 /usr/share/fonts/ (需要管理员权限) 1234567891011# 下载字体wget https://github.com/fangwentong/dotfiles/raw/master/ubuntu-gui/fonts/Monaco.ttf# 安装字体sudo mkdir -p /usr/share/fonts/customsudo mv Monaco.ttf /usr/share/fonts/customsudo chmod 744 /usr/share/fonts/custom/Monaco.ttfsudo mkfontscale #生成核心字体信息sudo mkfontdirsudo fc-cache -fv 安装到 ~/.fonts/ (安装到 ~/.local/share/fonts 原理相同) 1234567# 下载字体wget https://github.com/fangwentong/dotfiles/blob/ubuntu/fonts/Monaco.ttf?raw=true# 安装字体mkdir -p ~/.fontsmv Monaco.ttf ~/.fontsfc-cache -vf #刷新系统字体缓存 卸载字体若不再需要某个字体，可以删除相应字体文件，刷新系统字体缓存即可 1fc-cache -vf #刷新系统字体缓存 通过图形界面系统自带工具安装这种方法的优点是安装前能预览字体效果，安装过程简单便捷，动几下鼠标就完成了安装，非常适合在图形界面下安装; 缺点是安装借助图形化工具，无法通过自动化脚本安装。 123+ 首先到这里下载字体,这里用Monaco.ttf进行说明+ 然后在Ubuntu系统中，双击下载得到的Monaco.ttf文件，即用系统自带的字体查看器打开了该文件，点击面板上的安装按钮，即可完成安装+ 这种方法安装后，字体文件存放在~/.local/share/fonts目录下。 安装第三方工具 安装 1sudo apt-get install font-manager 界面 参考在ubuntu中，如何删除字体在linux中安装/卸载字体","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中安装Ganglia","date":"2020-06-04T10:19:34.000Z","path":"2020/06/04/Ubuntu中安装Ganglia/","text":"这里的系统是Ubuntu18.04 依赖安装安装apache2服务(cendos下的httpd服务)1sudo apt-get install apache2 安装php1sudo apt-get install php7.2 安装rrdtool 说明RRDtool用于数据存储和可视化，可以方便地对机器性能及系统运行状态进行可视化监控，广泛应用于对Hadoop，Spark等分布式系统的监测管理。轮询调度数据库，用于存储数据和可视化时间序列。RRD 也被用于生成用户界面的 web 前端。 安装 1sudo apt-get install rrdtool ganglia简介Ganglia的核心包含 gmond、gmetad 以及一个 Web 接界面。主要是用来监控系统性能，如：cpu 、mem、硬盘利用率， I/O 负载、网络流量情况等，通过曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。 GmodGanglia monitoring，它是一个守护进程，用于收集机器内的 metric，它还可以接受别的 node 发送过来的 metric，并且保存一小段时间（几十秒），运行在每一个需要监测的节点上，收集监测统计，发送和接受在同一个组播或单播通道上的统计信息。Gmond 可以扮演下面三种角色： 收集 metric 并发送出去，同时也接收别的 node 发送过来的 metric； 只采集 metric 并发送出去（关键字 deaf）； 只接收别的机器发送过来的 metric（关键字 mute）； 默认情况下，gmond 监听 8649 端口，用来发送和接收 udp，tcp 数据包。 GmetadGanglia meta daemon，也是一个守护进程，定期检查 gmonds ，从那里拉取数据，并将他们的指标存储在 RRD 存储引擎中。它可以查询多个集群并聚合指标。默认情况下 gmond 通过 multicast 的方式发送自己采集到的数据，整个 Multicast group 里的 node 都拥有整个 cluster 的全部 metrics。而 gmetad 可以从一个 cluster 的任意一个 node 拿到整个 cluster 的全部 metric 并记录到 rrd 数据库。 默认情况下，gmetad 监听 8651 端口，从这里可以拿到 gmetad 存放的最新 metric 数据，也可以给更高层的 gmetad 使用；监听 8652 端口，提供数据查询接口，供 web 使用。 安装ganglia主节点(master node)安装 安装ganglia-monitor 1sudo apt-get install ganglia-monitor 安装gmetad 1sudo apt-get install gmetad 安装ganglia-webfrontend 1sudo apt-get install ganglia-webfrontend 配置 修改/etc/ganglia/gmond.conf配置 1234567891011121314151617181920# 修改Cluster namecluster &#123; name = &quot;localhost&quot; ## use the name from gmetad.conf 需要和gmetad的配置文件名相同 owner = &quot;unspecified&quot; latlong = &quot;unspecified&quot; url = &quot;unspecified&quot;&#125;# 修改 udp_send_channel，添加 hostudp_send_channel = &#123; # mcast_join = xxx.xxx.xxx.xxx host = localhost port = 8649 ttl = 1&#125;# 修改 udp_recv_channel，注释掉 mcast_join, bindudp_recv_channel = &#123; # mcast_join = xxx.xxx.xxx.xxx port = 8649 bind = localhost&#125; 修改/etc/ganglia/gmetad.conf 123456789# data_source可以这样配置# data_source &quot;my cluster&quot; 10 localhost my.machine.edu:8649 1.2.3.5:8655# data_source &quot;my grid&quot; 50 1.3.4.7:8655 grid.org:8651 grid-backup.org:8651# data_source &quot;another source&quot; 1.3.4.7:8655 1.3.4.8# data_source &quot;ganglia&quot; localhost #&quot;群集名称(和前面配置保持一致)&quot; 轮询时间 ip地址或名称（名称需要可以解析）data_source &quot;localhost&quot; localhost # 需要配置和gmond.conf相同# gridname &quot;域名&quot; #任意写,也可不写 如果有多台主机则需要在数据源那行增加所有主机的ip 12data_source &quot;ganglia&quot; localhost #“群集名称” 轮询时间 ip地址或名称（名称需要可以解析）data_source &quot;web&quot; 192.168.2.146 192.168.2.98 重启 ganglia-monitor 和 gmetad 服务 12systemctl restart gmetad.servicesystemctl restart ganglia-monitor.service 配置ganglia-webfrontend(配置apache2) 查看apache2的默认访问目录1cat /etc/apache2/sites-enabled/000-default 找到DocumentRoot,我这里是 1DocumentRoot /var/www/html 我们需要将ganglia-webfronted的web相关代码链接到apache可以访问的位置或者移动到apache可以访问的目录 123sudo ln -s /usr/share/ganglia-webfrontend/ /var/www/html/ganglia或者sudo mv /usr/share/ganglia-webfrontend/ /var/www/html/ganglia 重启apache2 1systemctl restart apache2.service 配置完成,访问然后在浏览器输入http://serverIP/ganglia 即可访问 参考ubuntu安装gangliaubuntu16.04安装ganglia","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu开启smb协议与手机互联","date":"2020-05-29T15:44:23.000Z","path":"2020/05/29/Ubuntu开启smb协议与手机互联/","text":"samba的安装方式一:命令行安装12sudo apt-get insall sambasudo apt-get install smbfs 方式二:图形界面gnome中安装 在需要共享的目录中右键(这个也可以在属性中找到) 选择共享此目录后创建共享 如果没有安装smba会自动提示你需要安装 创建共享目录方式一:命令行创建 创建需要共享的目录 123# 注意：XXX为用户名mkdir /home/XXX/sharesudo chmod 777 /home/XXX/share 将上述创建的文件夹添加到配置文件中 12345678910sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.baksudo vim /etc/samba/smb.conf# 在smb.conf最后添加[share] path = /home/XXX/share available = yes browsealbe = yes public = yes writable = yes 方式二:图形界面gnome中创建 在需要共享的目录中右键(这个也可以在属性中找到) 选择共享此目录后创建共享 这样就共享了这个目录 配置其他设备连接时的用户名密码配置用户名和密码123sudo touch /etc/samba/smbpasswdsudo smbpasswd -a username然后会要求你输入samba帐户的密码 注意 如果没有配置目录，当你登录时会提示session setup failed: NT_STATUS_LOGON_FAILURE 前面添加的用户必须是系统中存在的用户,不能凭空乱写,否则也会报错 重启samba服务器1234567# ubuntu比较乱,有可能是老版本的sudo /etc/init.d/samba restart# 而ubuntu18.04是底下这个命令sudo service smbd restart# 也有可能使用systemctl,这个看自己的机子 测试一下1smbclient -L //localhost/share 配置防火墙(非必要步骤)我是ubuntu18.04,又我习惯让局域网内可以连接的,所以使用如下命令 1234567891011# 查看现有规则sudo ufw status numbered# 配置错了可以用如下命令删除sudo ufw delete 序号# 我本地添加的规则,让局域网内能够连接sudo ufw allow from 192.168.0.0/16 to any app Samba# 也可以直接关闭防火墙ufw enable/disable # 打开/关闭ufw 手机连接首先查看电脑的ip1ifconfig 手机连接 这里我们使用iphone自带的文件进行连接,如果iphone的文件没有如下功能则是ios版本太低,可以另外下app,比如FileExplorer等,只要能使用smb协议的都行 连接服务器 键入smb服务器地址,ip和我们前面查的保持一致 键入用户名和密码(如果是客人的不需要用户名密码,但目录的权限相对的需要更改) 可以看到,我们连接上了","tags":[{"name":"Ubuntu配置","slug":"Ubuntu配置","permalink":"https://zjinc36.github.io/tags/Ubuntu配置/"}]},{"title":"Ubuntu中wps英文版如何改为中文版","date":"2020-05-28T10:53:39.000Z","path":"2020/05/28/Ubuntu中wps英文版如何改为中文版/","text":"点击右上角那个A的标志进行切换","tags":[{"name":"Ubuntu配置","slug":"Ubuntu配置","permalink":"https://zjinc36.github.io/tags/Ubuntu配置/"}]},{"title":"Tampermonkey增加去除简书的推荐阅读脚本","date":"2020-05-21T23:05:44.000Z","path":"2020/05/22/Tampermonkey增加去除简书的推荐阅读脚本/","text":"123456789101112131415161718192021222324252627282930313233343536// ==UserScript==// @name 去除简书掘金的多余信息// @description 去除简书掘金的多余信息，比如推荐阅读，一言难尽, 并不想看到// @namespace http://tampermonkey.net/// @version 0.1// @author zjc// @match *://www.jianshu.com/p/*// @match *://juejin.im/post/*// @require https://code.jquery.com/jquery-2.2.4.min.js// @grant none// ==/UserScript==(function() &#123; // 等待 1s 后执行 // var timer = setTimeout(function()&#123;&#125;,1000); // 每 0.1s 执行 var interval = setInterval(function()&#123; // 简书 // 去除两个推荐阅读 (._3Z3nHf) if($(\"._3Z3nHf\").length === 2)&#123; $(\"._3Z3nHf\").remove(); clearInterval(interval); &#125; $(\"._gp-ck section\").last().hide(); $(\"._gp-ck .QxT4hD\").hide(); // 掘金 $(\".main-area.recommended-area.shadow\").hide(); $(\".sidebar-block.related-entry-sidebar-block.shadow\").hide(); $(\".index-book-collect\").hide(); $(\".tag-list-box\").hide(); $(\".article-banner\").hide(); $(\".sidebar-block.author-block.shadow\").hide(); &#125;,100);&#125;)();","tags":[{"name":"Tampermonkey","slug":"Tampermonkey","permalink":"https://zjinc36.github.io/tags/Tampermonkey/"}]},{"title":"Shell中no Login和login的区别","date":"2020-05-10T19:00:36.000Z","path":"2020/05/11/shell中nologin和login的区别/","text":"什么是nologin shell和login shell？按照bash文档的说法，login shell是第0个参数以-开头或者有一个参数为-login的shell。 A login shell is one whose first character of argument zero is a -, or one started with the –login option. 根据该定义，我们可以使用bash --login启动一个login shell或者通过echo $0的输出结果是否以-开头来判断一个shell是否为login shell。 经过测试 通过图形界面启动的终端为no login shell 通过ssh远程连接得到的shell为login shell。 为什么要关注是login shell还是no login shell？区分login shell和no login shell的主要原因是它们启动和退出时自动执行的脚本不同。 login shell对于login shell其启动时自动执行的脚本文件顺序如下 首先执行/etc/profile 再执行~/.bash_profile, ~/.bash_login, ~/.profile中第一个存在的脚本（按顺序搜索，只会执行其中一个） 如果shell启动时添加了--noprofile选项则不会执行上述文件。在login shell退出时，会执行~/.bash_logout no login shell对于no login shell，启动时会执行/etc/bash.bashrc和~/.bashrc，如果shell启动时添加了--norc选项则不会执行上述文件，如果添加了--rcfile &lt;filename&gt;选项则会执行指定的filename文件，也不会执行上述文件。no login shell退出时不会自动执行脚本文件。 总结 no login shell和login shell在启动和退出时会执行不同的脚本文件从而影响shell中的环境变量，本文根据bash的文档描述了两种shell启动时自动执行的脚本文件的区别。 login shell和no login shell启动时执行的脚本文件是完全不同的，因此，运行环境初始化脚本需要合理配置才能让login shell和no login shell都能执行，同时也可以为login shell和no login shell配置不同的运行环境初始化脚本。 参考资料 Linux man page(bash) no login shell和login shell","tags":[{"name":"Linux配置","slug":"Linux配置","permalink":"https://zjinc36.github.io/tags/Linux配置/"}]},{"title":"Getent命令:用来查看系统的数据库中的相关记录","date":"2020-05-10T18:43:50.000Z","path":"2020/05/11/getent命令-用来查看系统的数据库中的相关记录/","text":"简介getent命令帮助用户administrative databases中查找相关信息。administrative databases包括： passwd – can be used to confirm usernames, userids, home directories and full names of your users group – all the information about Unix groups known to your system services – all the Unix services configured on your system networks – networking information – what networks your system belongs to protocols – everything your system knows about network protocols 一般语法 getent database [key …] getent [选项…] 数据库 [键 …] getent会在上面数据库中产找key对应的value 选项 说明 -s, –service=CONFIG 要使用的服务配置 -?, –help 给出该系统求助列表 –usage 给出简要的用法信息 -V, –version 打印程序版本号 举例查找hostname对应的IP123ubuntu$ getent hosts ubuntu127.0.1.1 ubuntu192.168.0.2 ubuntu 执行反向DNS查询（即根据域名查找对应IP）12ubuntu$ getent hosts myhost.mydomain.com15.77.3.40 myhost.mydomain.com myhost 根据用户名查找UID12ubuntu$ getent passwd greysgreys:x:1000:1000:Gleb Reys,,,:/home/greys:/bin/bas 根据UID查找用户名12ubuntu$ getent passwd 1000greys:x:1000:1000:Gleb Reys,,,:/home/greys:/bin/bash 获取当前登陆用户的信息12ubuntu$ getent passwd `whoami`root:x:0:0:root:/root:/bin/bash 查找那个服务在使用特定端口123456$ getent services 22ssh 22/tcp$ getent services 21ftp 21/tcp$ getent services 25smtp 25/tcp mail","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"骑士周游问题","date":"2020-05-09T15:59:28.000Z","path":"2020/05/09/骑士周游问题/","text":"马踏棋盘算法介绍和游戏演示 马踏棋盘算法也被称为骑士周游问题 将马随机放在国际象棋的 8× 8 棋盘 Board[0～7][0～7]的某个方格中， 马按走棋规则(马走日字)进行移动。 要求每个方格只进入一次， 走遍棋盘上全部 64 个方格 游戏演示: http://www.4399.com/flash/146267_2.htm 马踏棋盘游戏分析 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。 如果使用回溯（就是深度优先搜索） 来解决， 假如马儿踏了 53 个点， 如图： 走到了第 53 个， 坐标（1,0） ， 发现已经走到尽头， 没办法， 那就只能回退了，查看其他的路径， 就在棋盘上不停的回溯……对第一种实现方式的思路图解 分析第一种方式的问题， 并使用贪心算法（greedyalgorithm） 进行优化。 解决马踏棋盘问题. 使用前面的游戏来验证算法是否正确。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package com.zjc.algorithm.horse;import java.awt.Point;import java.util.ArrayList;import java.util.Comparator;public class HorseChessboard &#123; private static int X; // 棋盘的列数 private static int Y; // 棋盘的行数 // 创建一个数组， 标记棋盘的各个位置是否被访问过 private static boolean visited[]; // 使用一个属性， 标记是否棋盘的所有位置都被访问 private static boolean finished; // 如果为 true,表示成功 public static void main(String[] args) &#123; System.out.println(\"骑士周游算法， 开始运行~~\"); // 测试骑士周游算法是否正确 X = 8; Y = 8; int row = 1; // 马儿初始位置的行， 从 1 开始编号 int column = 1; // 马儿初始位置的列， 从 1 开始编号 // 创建棋盘 int[][] chessboard = new int[X][Y]; visited = new boolean[X * Y];// 初始值都是 false // 测试一下耗时 long start = System.currentTimeMillis(); traversalChessboard(chessboard, row - 1, column - 1, 1); long end = System.currentTimeMillis(); System.out.println(\"共耗时: \" + (end - start) + \" 毫秒\"); // 输出棋盘的最后情况 for (int[] rows : chessboard) &#123; for (int step : rows) &#123; System.out.print(step + \"\\t\"); &#125; System.out.println(); &#125; &#125; /** * 完成骑士周游问题的算法 * @param chessboard 棋盘 * @param row 马儿当前的位置的行 从 0 开始 * @param column 马儿当前的位置的列 从 0 开始 * @param step 是第几步 ,初始位置就是第 1 步 */ public static void traversalChessboard(int[][] chessboard, int row, int column, int step) &#123; chessboard[row][column] = step; // row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36 visited[row * X + column] = true; // 标记该位置已经访问 // 获取当前位置可以走的下一个位置的集合 ArrayList&lt;Point&gt; ps = next(new Point(column, row)); // 对 ps 进行排序,排序的规则就是对 ps 的所有的 Point 对象的下一步的位置的数目， 进行非递减排序 sort(ps); // 遍历 ps while (!ps.isEmpty()) &#123; Point p = ps.remove(0);// 取出下一个可以走的位置 // 判断该点是否已经访问过 if (!visited[p.y * X + p.x]) &#123;// 说明还没有访问过 traversalChessboard(chessboard, p.y, p.x, step + 1); &#125; &#125; // 判断马儿是否完成了任务， 使用 step 和应该走的步数比较 ， // 如果没有达到数量， 则表示没有完成任务， 将整个棋盘置 0 // 说明: step &lt; X * Y 成立的情况有两种 // 1. 棋盘到目前位置,仍然没有走完 // 2. 棋盘处于一个回溯过程 if (step &lt; X * Y &amp;&amp; !finished) &#123; chessboard[row][column] = 0; visited[row * X + column] = false; &#125; else &#123; finished = true; &#125; &#125; /** * 功能： 根据当前位置(Point 对象)， 计算马儿还能走哪些位置(Point)， 并放入到一个集合中(ArrayList), 最多 有 8 * 个位置 * @param curPoint * @return */ public static ArrayList&lt;Point&gt; next(Point curPoint) &#123; // 创建一个 ArrayList ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;(); // 创建一个 Point Point p1 = new Point(); // 表示马儿可以走 5 这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; // 判断马儿可以走 6 这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; // 判断马儿可以走 7 这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; // 判断马儿可以走 0 这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; // 判断马儿可以走 1 这个位置 if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123; ps.add(new Point(p1)); &#125; // 判断马儿可以走 2 这个位置 if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123; ps.add(new Point(p1)); &#125; // 判断马儿可以走 3 这个位置 if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123; ps.add(new Point(p1)); &#125; // 判断马儿可以走 4 这个位置 if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123; ps.add(new Point(p1)); &#125; return ps; &#125; // 根据当前这个一步的所有的下一步的选择位置， 进行非递减排序, 减少回溯的次数 public static void sort(ArrayList&lt;Point&gt; ps) &#123; ps.sort(new Comparator&lt;Point&gt;() &#123; @Override public int compare(Point o1, Point o2) &#123; // 获取到 o1 的下一步的所有位置个数 int count1 = next(o1).size(); // 获取到 o2 的下一步的所有位置个数 int count2 = next(o2).size(); if (count1 &lt; count2) &#123; return -1; &#125; else if (count1 == count2) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; &#125;); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"弗洛伊德算法Floyd--最短路径问题","date":"2020-05-09T12:27:31.000Z","path":"2020/05/09/弗洛伊德算法Floyd-最短路径问题/","text":"弗洛伊德(Floyd)算法介绍 和 Dijkstra 算法一样， 弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。 该算法名称以创始人之一、 1978 年图灵奖获得者、 斯坦福大学计算机科学系教授罗伯特· 弗洛伊德命名 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 弗洛伊德算法 VS 迪杰斯特拉算法 迪杰斯特拉算法通过选定的被访问顶点， 求出从出发访问顶点到其他顶点的最短路径； 弗洛伊德算法中每一个顶点都是出发访问点， 所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。 弗洛伊德(Floyd)算法步骤 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik， 顶点 vk 到 vj 的最短路径已知为 Lkj， 顶点 vi 到 vj 的路径为 Lij，则 vi 到 vj 的最短路径为： min((Lik+Lkj),Lij)， vk 的取值为图中所有顶点， 则可获得 vi 到 vj 的最短路径 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj， 是以同样的方式获得 弗洛伊德(Floyd)算法图解分析 第一轮循环…第一轮循环中， 以 A(下标为： 0)作为中间顶点【即把 A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表 和 前驱关系】 ，距离表和前驱关系更新为： 分析如下 以 A 顶点作为中间顶点是， B-&gt;A-&gt;C 的距离由 N-&gt;12 以 A 顶点作为中间顶点是， G-&gt;A-&gt;C 的距离由 N-&gt;9 以 A 顶点作为中间顶点是， G-&gt;A-&gt;B 的距离为7,由于距离表中G-&gt;…-&gt;B已经存在距离为 3, 所以不进行替换 更换中间顶点， 循环执行操作， 直到所有顶点都作为中间顶点更新后， 计算结束 最短路径问题题目 战争时期， 胜利乡有 7 个村庄(A, B, C, D, E, F, G) ， 现在有六个邮差， 从 G 点出发， 需要分别把邮件分别送到A, B, C , D, E, F 六个村庄 各个村庄的距离用边线表示(权) ， 比如 A – B 距离 5 公里 问： 如何计算出 G 村庄到 其它各个村庄的最短距离? 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.zjc.algorithm.floyd;import java.util.Arrays;public class FloydAlgorithm &#123; public static void main(String[] args) &#123; // 测试看看图是否创建成功 char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; // 创建邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535; matrix[0] = new int[] &#123; 0, 5, 7, N, N, N, 2 &#125;; matrix[1] = new int[] &#123; 5, 0, N, 9, N, N, 3 &#125;; matrix[2] = new int[] &#123; 7, N, 0, N, 8, N, N &#125;; matrix[3] = new int[] &#123; N, 9, N, 0, N, 4, N &#125;; matrix[4] = new int[] &#123; N, N, 8, N, 0, 5, 4 &#125;; matrix[5] = new int[] &#123; N, N, N, 4, 5, 0, 6 &#125;; matrix[6] = new int[] &#123; 2, 3, N, N, 4, 6, 0 &#125;; // 创建 Graph 对象 Graph graph = new Graph(vertex.length, matrix, vertex); // 调用弗洛伊德算法 graph.floyd(); graph.show(); &#125;&#125;//创建图class Graph &#123; private char[] vertex; // 存放顶点的数组 private int[][] dis; // 保存， 从各个顶点出发到其它顶点的距离， 最后的结果， 也是保留在该数组 private int[][] pre;// 保存到达目标顶点的前驱顶点 // 构造器 /** * * * * @param length 大小 * @param matrix 邻接矩阵 * @param vertex 顶点数组 */ public Graph(int length, int[][] matrix, char[] vertex) &#123; this.vertex = vertex; this.dis = matrix; this.pre = new int[length][length]; // 对 pre 数组初始化, 注意存放的是前驱顶点的下标 for (int i = 0; i &lt; length; i++) &#123; Arrays.fill(pre[i], i); &#125; &#125; // 显示 pre 数组和 dis 数组 public void show() &#123; // 为了显示便于阅读， 我们优化一下输出 char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; for (int k = 0; k &lt; dis.length; k++) &#123; // 先将 pre 数组输出的一行 for (int i = 0; i &lt; dis.length; i++) &#123; System.out.print(vertex[pre[k][i]] + \" \"); &#125; System.out.println(); // 输出 dis 数组的一行数据 for (int i = 0; i &lt; dis.length; i++) &#123; System.out.print(\"(\" + vertex[k] + \"到\" + vertex[i] + \"的最短路径是\" + dis[k][i] + \") \"); &#125; System.out.println(); System.out.println(); &#125; &#125; // 弗洛伊德算法, 比较容易理解， 而且容易实现 public void floyd() &#123; int len = 0; // 变量保存距离 // 对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G] for (int k = 0; k &lt; dis.length; k++) &#123; // // 从 i 顶点开始出发 [A, B, C, D, E, F, G] for (int i = 0; i &lt; dis.length; i++) &#123; // 到达 j 顶点 // [A, B, C, D, E, F, G] for (int j = 0; j &lt; dis.length; j++) &#123; // =&gt; 求出从 i 顶点出发， 经过 k 中间顶点， 到达j 顶点距离 len = dis[i][k] + dis[k][j]; if (len &lt; dis[i][j]) &#123;// 如果 len 小于 dis[i][j] dis[i][j] = len;// 更新距离 pre[i][j] = pre[k][j];// 更新前驱顶点 &#125; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"迪克斯特拉算法Dijkstra--最短路径问题","date":"2020-05-09T10:28:17.000Z","path":"2020/05/09/迪克斯特拉算法Dijkstra-最短路径问题/","text":"迪克斯特拉算法Dijkstra算法基本介绍步骤 找出最便宜的点 对于该结点的邻居,检查是否有前往它们的更短路径,如果有,就更新其开销 重复这个过程,直到对图中的每个结点都这样做了 计算最终路径 手动演示 第一轮 从图中可知最便宜的点是乐谱 邻居是黑胶唱片和海报 此时可以更新表格如下 结点 开销 黑胶唱片 5 海报 0 第二轮 从上一轮的表格可知最便宜的点是海报 邻居是吉他和架子鼓 此时可以更新表格如下 结点 开销 黑胶唱片 5 海报 0 海报 -&gt; 吉他 0 + 30 = 30 海报 -&gt; 架子鼓 0 + 35 = 35 第三轮 从上一轮的表格可知最便宜的点是黑胶唱片 邻居是吉他和架子鼓 此时可以更新表格如下 结点 开销 黑胶唱片 5 海报 -&gt; 吉他 0 + 30 = 30 海报 -&gt; 架子鼓 0 + 35 = 35 黑胶唱片 -&gt; 吉他 5 + 15 = 20 黑胶唱片 -&gt; 架子鼓 5 + 20 = 25 第四轮 从上一轮的表格可知最便宜的点是黑胶唱片 -&gt; 吉他 邻居是钢琴(终点) 此时可以更新表格如下 结点 开销 黑胶唱片 5 海报 -&gt; 吉他 0 + 30 = 30 海报 -&gt; 架子鼓 0 + 35 = 35 黑胶唱片 -&gt; 吉他 5 + 15 = 20 黑胶唱片 -&gt; 架子鼓 5 + 20 = 25 黑胶唱片 -&gt; 吉他 -&gt; 钢琴 5 + 15 + 20 = 40 最后由于上一轮已经走到终点了,所以,需要对最后一个结点–架子鼓也需要计算一下开销,即黑胶唱片 -&gt; 架子鼓 -&gt; 钢琴 =&gt; 5 + 20 + 10 = 35,与前面黑胶唱片 -&gt; 吉他 -&gt; 钢琴 =&gt; 5 + 15 + 20 = 40进行比较,得到最终的路径为黑胶唱片 -&gt; 架子鼓 -&gt; 钢琴 缺点如果有负权边,就不能使用迪克斯特拉算法,可以使用贝尔曼--福德算法(Bellman-Fordalgorithm) 最短路径问题题目 战争时期， 胜利乡有 7 个村庄(A, B, C, D, E, F, G) ， 现在有六个邮差， 从 G 点出发， 需要分别把邮件分别送到A, B, C , D, E, F 六个村庄 各个村庄的距离用边线表示(权) ， 比如 A – B 距离 5 公里 问： 如何计算出 G 村庄到 其它各个村庄的最短距离? 分析 设置出发顶点为 v， 顶点集合 V{v1,v2,vi…}， v 到 V 中各顶点的距离构成距离集合 Dis， Dis{d1,d2,di…}， Dis集合记录着 v 到图中各顶点的距离(到自身可以看作 0， v 到 vi 距离对应为 di) 从 Dis 中选择值最小的 di 并移出 Dis 集合， 同时移出 V 集合中对应的顶点 vi， 此时的 v 到 vi 即为最短路径 更新 Dis 集合， 更新规则为： 比较 v 到 V 集合中顶点的距离值， 与 v 通过 vi 到 V 集合中顶点的距离值， 保留值较小的一个(同时也应该更新顶点的前驱节点为vi， 表明是通过 vi 到达的) 重复执行两步骤， 直到最短路径顶点为目标顶点即可结束 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203package com.zjc.algorithm.dijkstra;import java.util.Arrays;public class DijkstraAlgorithm &#123; public static void main(String[] args) &#123; char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; // 邻接矩阵 int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535;// 表示不可以连接 matrix[0] = new int[] &#123; N, 5, 7, N, N, N, 2 &#125;; matrix[1] = new int[] &#123; 5, N, N, 9, N, N, 3 &#125;; matrix[2] = new int[] &#123; 7, N, N, N, 8, N, N &#125;; matrix[3] = new int[] &#123; N, 9, N, N, N, 4, N &#125;; matrix[4] = new int[] &#123; N, N, 8, N, N, 5, 4 &#125;; matrix[5] = new int[] &#123; N, N, N, 4, 5, N, 6 &#125;; matrix[6] = new int[] &#123; 2, 3, N, N, 4, 6, N &#125;; // 创建 Graph 对象 Graph graph = new Graph(vertex, matrix); // 测试, 看看图的邻接矩阵是否 ok graph.showGraph(); // 测试迪杰斯特拉算法 graph.dsj(2);// C graph.showDijkstra(); &#125;&#125;class Graph &#123; private char[] vertex; // 顶点数组 private int[][] matrix; // 邻接矩阵 private VisitedVertex vv; // 已经访问的顶点的集合 // 构造器 public Graph(char[] vertex, int[][] matrix) &#123; this.vertex = vertex; this.matrix = matrix; &#125; // 显示结果 public void showDijkstra() &#123; vv.show(); &#125; // 显示图 public void showGraph() &#123; for (int[] link : matrix) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; /** * 迪杰斯特拉算法实现 * * @param index 表示出发顶点对应的下标 */ public void dsj(int index) &#123; vv = new VisitedVertex(vertex.length, index); update(index);// 更新 index 顶点到周围顶点的距离和前驱顶点 for (int j = 1; j &lt; vertex.length; j++) &#123; index = vv.updateArr();// 选择并返回新的访问顶点 update(index); // 更新 index 顶点到周围顶点的距离和前驱顶点 &#125; &#125; /** * 更新 index 下标顶点到周围顶点的距离和周围顶点的前驱顶点 * * @param index */ private void update(int index) &#123; int len = 0; // 根据遍历我们的邻接矩阵的 matrix[index]行 for (int j = 0; j &lt; matrix[index].length; j++) &#123; // len 含义是 : 出发顶点到 index 顶点的距离 + 从 index 顶点到 j 顶点的距离的和 len = vv.getDis(index) + matrix[index][j]; // 如果 j 顶点没有被访问过， 并且 len 小于出发顶点到 j 顶点的距离， 就需要更新 if (!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123; vv.updatePre(j, index); // 更新 j 顶点的前驱为 index 顶点 vv.updateDis(j, len); // 更新出发顶点到 j 顶点的距离 &#125; &#125; &#125;&#125;/** * 已访问顶点集合 */class VisitedVertex &#123; // 记录各个顶点是否访问过 1 表示访问过,0 未访问,会动态更新 public int[] already_arr; // 每个下标对应的值为前一个顶点下标, 会动态更新 public int[] pre_visited; // 记录出发顶点到其他所有顶点的距离,比如 G 为出发顶点， 就会记录 G 到其它顶点的距离， 会动态更新， 求的最短距离就会存放到 dis public int[] dis; /** * 构造器 * * @param length :表示顶点的个数 * @param index: 出发顶点对应的下标, 比如 G 顶点， 下标就是 6 */ public VisitedVertex(int length, int index) &#123; this.already_arr = new int[length]; this.pre_visited = new int[length]; this.dis = new int[length]; // 初始化 dis 数组 Arrays.fill(dis, 65535); this.already_arr[index] = 1; // 设置出发顶点被访问过 this.dis[index] = 0;// 设置出发顶点的访问距离为 0 &#125; /** * 功能: 判断 index 顶点是否被访问过 * * @param index * @return 如果访问过， 就返回 true, 否则访问 false */ public boolean in(int index) &#123; return already_arr[index] == 1; &#125; /** * 功能: 更新出发顶点到 index 顶点的距离 * * @param index * @param len */ public void updateDis(int index, int len) &#123; dis[index] = len; &#125; /** * 功能: 更新 pre 这个顶点的前驱顶点为 index 顶点 * * @param pre * @param index */ public void updatePre(int pre, int index) &#123; pre_visited[pre] = index; &#125; /** * 功能:返回出发顶点到 index 顶点的距离 * * @param index * @return */ public int getDis(int index) &#123; return dis[index]; &#125; /** * 继续选择并返回新的访问顶点， 比如这里的 G 完后， 就是 A 点作为新的访问顶点(注意不是出发顶点) * * @return */ public int updateArr() &#123; int min = 65535, index = 0; for (int i = 0; i &lt; already_arr.length; i++) &#123; if (already_arr[i] == 0 &amp;&amp; dis[i] &lt; min) &#123; min = dis[i]; index = i; &#125; &#125; // 更新 index 顶点被访问过 already_arr[index] = 1; return index; &#125; /** * 显示最后的结果 即将三个数组的情况输出 */ public void show() &#123; System.out.println(\"==========================\"); // 输出 already_arr for (int i : already_arr) &#123; System.out.print(i + \" \"); &#125; System.out.println(); // 输出 pre_visited for (int i : pre_visited) &#123; System.out.print(i + \" \"); &#125; System.out.println(); // 输出 dis for (int i : dis) &#123; System.out.print(i + \" \"); &#125; System.out.println(); // 为了好看最后的最短距离， 我们处理 char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; int count = 0; for (int i : dis) &#123; if (i != 65535) &#123; System.out.print(vertex[count] + \"(\" + i + \") \"); &#125; else &#123; System.out.println(\"N \"); &#125; count++; &#125; System.out.println(); &#125;&#125; 参考 《算法图解》的kindle版,第7章.作者: [美] Aditya Bhargava. 译者: 袁国忠.ISBN:978-7-115-44763-0","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"克鲁斯卡尔算法--公交站问题--最小生成树","date":"2020-05-08T16:22:14.000Z","path":"2020/05/09/克鲁斯卡尔算法-公交站问题-最小生成树/","text":"最小生成树(Minimum Cost Spanning Tree)简称MST。给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 N 个顶点， 一定有 N-1 条边 包含全部顶点 N-1 条边都在图中 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法 举例说明(如图)例如， 对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树 克鲁斯卡尔算法介绍基本说明 克鲁斯卡尔(Kruskal)算法， 是用来求加权连通图的最小生成树的算法。 基本思想： 按照权值从小到大的顺序选择 n-1 条边， 并保证这 n-1 条边不构成回路 具体做法： 首先构造一个只含 n 个顶点的森林， 然后依权值从小到大从连通网中选择边加入到森林中， 并使森林中不产生回路， 直至森林变成一棵树为止 克鲁斯卡尔算法图解在含有 n 个顶点的连通图中选择 n-1 条边， 构成一棵极小连通子图， 并使该连通子图中 n-1 条边上权值之和达到最小， 则称其为连通网的最小生成树。例如， 对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树 以上图 G4 为例， 来对克鲁斯卡尔进行演示(假设， 用数组 R 保存最小生成树结果)。 克鲁斯卡尔算法文字描述 将边&lt;E,F&gt;加入 R 中。边&lt;E,F&gt;的权值最小， 因此将它加入到最小生成树结果 R 中。 将边&lt;C,D&gt;加入 R 中。上一步操作之后， 边&lt;C,D&gt;的权值最小， 因此将它加入到最小生成树结果 R 中。 将边&lt;D,E&gt;加入 R 中。上一步操作之后， 边&lt;D,E&gt;的权值最小， 因此将它加入到最小生成树结果 R 中。 将边&lt;B,F&gt;加入 R 中。上一步操作之后， 边&lt;C,E&gt;的权值最小， 但&lt;C,E&gt;会和已有的边构成回路； 因此， 跳过边&lt;C,E&gt;。 同理， 跳过边&lt;C,F&gt;。 将边&lt;B,F&gt;加入到最小生成树结果 R 中。 将边&lt;E,G&gt;加入 R 中。上一步操作之后， 边&lt;E,G&gt;的权值最小， 因此将它加入到最小生成树结果 R 中。 将边&lt;A,B&gt;加入 R 中。上一步操作之后， 边&lt;F,G&gt;的权值最小， 但&lt;F,G&gt;会和已有的边构成回路； 因此， 跳过边&lt;F,G&gt;。 同理， 跳过边&lt;B,C&gt;。 将边&lt;A,B&gt;加入到最小生成树结果 R 中。 此时， 最小生成树构造完成！ 它包括的边依次是： &lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。 克鲁斯卡尔算法分析根据前面介绍的克鲁斯卡尔算法的基本思想和做法， 我们能够了解到， 克鲁斯卡尔算法重点需要解决的以下两个问题： 问题一 对图的所有边按照权值大小进行排序。( ==&gt; 很好解决， 采用排序算法进行排序即可) 问题二 将边添加到最小生成树中时， 怎么样判断是否形成了回路。( ==&gt; 解决如下) 如何判断是否构成回路-举例说明(如图)在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树 R 中之后， 这几条边的顶点就都有了终点： 1234(01) C 的终点是 F。(02) D 的终点是 F。(03) E 的终点是 F。(04) F 的终点是 F。 关于终点的说明： 就是将所有顶点按照从小到大的顺序排列好之后； 某个顶点的终点就是”与它连通的最大顶点”。 因此， 接下来， 虽然&lt;C,E&gt;是权值最小的边。 但是 C 和 E 的终点都是 F， 即它们的终点相同， 因此， 将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。 也就是说， 我们加入的边的两个顶点不能都指向同一个终点， 否则将构成回路。 应用场景-公交站问题问题 某城市新增 7 个站点(A, B, C, D, E, F, G) ， 现在需要修路把 7 个站点连通 各个站点的距离用边线表示(权) ， 比如 A – B 距离 12 公里 问： 如何修路保证各个站点都能连通， 并且总的修建公路总里程最短 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198package com.zjc.algorithm.kruskal;import java.util.Arrays;public class KruskalCase &#123; private int edgeNum; // 边的个数 private char[] vertexs; // 顶点数组 private int[][] matrix; // 邻接矩阵 // 使用 INF 表示两个顶点不能连通 private static final int INF = Integer.MAX_VALUE; public static void main(String[] args) &#123; char[] vertexs = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; // 克鲁斯卡尔算法的邻接矩阵 int matrix[][] = &#123; /* A *//* B *//* C *//* D *//* E *//* F *//* G */ /* A */ &#123; 0, 12, INF, INF, INF, 16, 14 &#125;, /* B */ &#123; 12, 0, 10, INF, INF, 7, INF &#125;, /* C */ &#123; INF, 10, 0, 3, 5, 6, INF &#125;, /* D */ &#123; INF, INF, 3, 0, 4, INF, INF &#125;, /* E */ &#123; INF, INF, 5, 4, 0, 2, 8 &#125;, /* F */ &#123; 16, 7, 6, INF, 2, 0, 9 &#125;, /* G */ &#123; 14, INF, INF, INF, 8, 9, 0 &#125; &#125;; // 大家可以在去测试其它的邻接矩阵， 结果都可以得到最小生成树. // 创建 KruskalCase 对象实例 KruskalCase kruskalCase = new KruskalCase(vertexs, matrix); // 输出构建的 kruskalCase.print(); kruskalCase.kruskal(); &#125; // 构造器 public KruskalCase(char[] vertexs, int[][] matrix) &#123; // 初始化顶点数和边的个数 int vlen = vertexs.length; // 初始化顶点, 复制拷贝的方式 this.vertexs = new char[vlen]; for (int i = 0; i &lt; vertexs.length; i++) &#123; this.vertexs[i] = vertexs[i]; &#125; // 初始化边, 使用的是复制拷贝的方式 this.matrix = new int[vlen][vlen]; for (int i = 0; i &lt; vlen; i++) &#123; for (int j = 0; j &lt; vlen; j++) &#123; this.matrix[i][j] = matrix[i][j]; &#125; &#125; // 统计边的条数 for (int i = 0; i &lt; vlen; i++) &#123; for (int j = i + 1; j &lt; vlen; j++) &#123; if (this.matrix[i][j] != INF) &#123; edgeNum++; &#125; &#125; &#125; &#125; public void kruskal() &#123; int index = 0; // 表示最后结果数组的索引 int[] ends = new int[edgeNum]; // 用于保存\"已有最小生成树\" 中的每个顶点在最小生成树中的终点 // 创建结果数组, 保存最后的最小生成树 EData[] rets = new EData[edgeNum]; // 获取图中 所有的边的集合 ， 一共有 12 边 EData[] edges = getEdges(); System.out.println( \"图的边的集合=\" + Arrays.toString(edges) + \" 共\" + edges.length); // 12 // 按照边的权值大小进行排序(从小到大) sortEdges(edges); // 遍历 edges 数组， 将边添加到最小生成树中时， 判断是准备加入的边否形成了回路， 如果没有， 就加入 rets,否则不能加入 for (int i = 0; i &lt; edgeNum; i++) &#123; // 获取到第 i 条边的第一个顶点(起点) int p1 = getPosition(edges[i].start); // p1=4 // 获取到第 i 条边的第 2 个顶点 int p2 = getPosition(edges[i].end); // p2 = 5 // 获取 p1 这个顶点在已有最小生成树中的终点 int m = getEnd(ends, p1); // m = 4 // 获取 p2 这个顶点在已有最小生成树中的终点 int n = getEnd(ends, p2); // n = 5 // 是否构成回路 if (m != n) &#123; // 没有构成回路 ends[m] = n; // 设置 m 在\"已有最小生成树\"中的终点 &lt;E,F&gt; // [0,0,0,0,5,0,0,0,0,0,0,0] rets[index++] = edges[i]; // 有一条边加入到 rets 数组 &#125; &#125; // &lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。 // 统计并打印 \"最小生成树\", 输出 rets System.out.println(\"最小生成树为\"); for (int i = 0; i &lt; index; i++) &#123; System.out.println(rets[i]); &#125; &#125; // 打印邻接矩阵 public void print() &#123; System.out.println(\"邻接矩阵为: \\n\"); for (int i = 0; i &lt; vertexs.length; i++) &#123; for (int j = 0; j &lt; vertexs.length; j++) &#123; System.out.printf(\"%12d\", matrix[i][j]); &#125; System.out.println();// 换行 &#125; &#125; /* * * 功能： 对边进行排序处理, 冒泡排序 * * @param edges 边的集合 */ private void sortEdges(EData[] edges) &#123; for (int i = 0; i &lt; edges.length - 1; i++) &#123; for (int j = 0; j &lt; edges.length - 1 - i; j++) &#123; if (edges[j].weight &gt; edges[j + 1].weight) &#123;// 交换 EData tmp = edges[j]; edges[j] = edges[j + 1]; edges[j + 1] = tmp; &#125; &#125; &#125; &#125; /* * * * * * @param ch 顶点的值， 比如'A','B' * * @return 返回 ch 顶点对应的下标， 如果找不到， 返回-1 */ private int getPosition(char ch) &#123; for (int i = 0; i &lt; vertexs.length; i++) &#123; if (vertexs[i] == ch) &#123;// 找到 return i; &#125; &#125; // 找不到,返回-1 return -1; &#125; /* * * 功能: 获取图中边， 放到 EData[] 数组中， 后面我们需要遍历该数组 是通过 matrix 邻接矩阵来获取 EData[] 形式 * [['A','B', 12], ['B','F',7], .....] * * @return */ private EData[] getEdges() &#123; int index = 0; EData[] edges = new EData[edgeNum]; for (int i = 0; i &lt; vertexs.length; i++) &#123; for (int j = i + 1; j &lt; vertexs.length; j++) &#123; if (matrix[i][j] != INF) &#123; edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]); &#125; &#125; &#125; return edges; &#125; /* * * 功能: 获取下标为 i 的顶点的终点(), 用于后面判断两个顶点的终点是否相同 * * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中， 逐步形成 * * @param i : 表示传入的顶点对应的下标 * * @return 返回的就是 下标为 i 的这个顶点对应的终点的下标, 一会回头还有来理解 */ private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0] while (ends[i] != 0) &#123; i = ends[i]; &#125; return i; &#125;&#125;//创建一个类 EData ， 它的对象实例就表示一条边class EData &#123; char start; // 边的一个点 char end; // 边的另外一个点 int weight; // 边的权值 // 构造器 public EData(char start, char end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125; // 重写 toString, 便于输出边信息 @Override public String toString() &#123; return \"EData [&lt;\" + start + \", \" + end + \"&gt;= \" + weight + \"]\"; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"普里姆算法--修路问题--最小生成树","date":"2020-05-08T16:06:51.000Z","path":"2020/05/09/普里姆算法-修路问题--最小生成树/","text":"最小生成树修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)， 简称 MST。给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 N 个顶点， 一定有 N-1 条边 包含全部顶点 N-1 条边都在图中 举例说明(如图:) 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法 普里姆算法介绍普利姆(Prim)算法求最小生成树， 也就是在包含 n 个顶点的连通图中， 找出只有(n-1)条边包含所有 n 个顶点的连通子图， 也就是所谓的极小连通子图普利姆的算法如下: 设 G=(V,E)是连通网， T=(U,D)是最小生成树， V,U 是顶点集合， E,D 是边的集合 若从顶点 u 开始构造最小生成树， 则从集合 V 中取出顶点 u 放入集合 U 中， 标记顶点 v 的 visited[u]=1 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边， 则寻找这些边中权值最小的边， 但不能构成回路， 将顶点 vj 加入集合 U 中， 将边（ui,vj） 加入集合 D 中， 标记 visited[vj]=1 重复步骤②， 直到 U 与 V 相等， 即所有顶点都被标记为访问过， 此时 D 中有 n-1 条边 提示: 单独看步骤很难理解， 我们通过代码来讲解， 比较好理解. 图解普利姆算法 应用场景-修路问题 问题 有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ， 现在需要修路把 7 个村庄连通 各个村庄的距离用边线表示(权) ， 比如 A – B 距离 5 公里 问： 如何修路保证各个村庄都能连通， 并且总的修建公路总里程最短? 思路 将 10 条边， 连接即可， 但是总的里程数不是最小(舍弃) 正确的思路， 就是尽可能的选择少的路线， 并且每条路线最小， 保证总里程数最少 使用普里姆算法解决修路问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.zjc.algorithm.prim;import java.util.Arrays;public class PrimAlgorithm &#123; public static void main(String[] args) &#123; // 测试看看图是否创建 ok char[] data = new char[] &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; int verxs = data.length; // 邻接矩阵的关系使用二维数组表示,10000 这个大数， 表示两个点不联通 int[][] weight = new int[][] &#123; &#123; 10000, 5, 7, 10000, 10000, 10000, 2 &#125;, &#123; 5, 10000, 10000, 9, 10000, 10000, 3 &#125;, &#123; 7, 10000, 10000, 10000, 8, 10000, 10000 &#125;, &#123; 10000, 9, 10000, 10000, 10000, 4, 10000 &#125;, &#123; 10000, 10000, 8, 10000, 10000, 5, 4 &#125;, &#123; 10000, 10000, 10000, 4, 5, 10000, 6 &#125;, &#123; 2, 3, 10000, 10000, 4, 6, 10000 &#125;, &#125;; // 创建 MGraph 对象 MGraph graph = new MGraph(verxs); // 创建一个 MinTree 对象 MinTree minTree = new MinTree(); minTree.createGraph(graph, verxs, data, weight); // 输出 minTree.showGraph(graph); // 测试普利姆算法 minTree.prim(graph, 1);// &#125;&#125;//创建最小生成树-&gt;村庄的图class MinTree &#123; // 创建图的邻接矩阵 /** * * * * @param graph 图对象 * @param verxs 图对应的顶点个数 * @param data 图的各个顶点的值 * @param weight 图的邻接矩阵 */ public void createGraph(MGraph graph, int verxs, char data[], int[][] weight) &#123; int i, j; for (i = 0; i &lt; verxs; i++) &#123;// 顶点 graph.data[i] = data[i]; for (j = 0; j &lt; verxs; j++) &#123; graph.weight[i][j] = weight[i][j]; &#125; &#125; &#125; // 显示图的邻接矩阵 public void showGraph(MGraph graph) &#123; for (int[] link : graph.weight) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; // 编写 prim 算法， 得到最小生成树 /** * * * * @param graph 图 * @param v 表示从图的第几个顶点开始生成'A'-&gt;0 'B'-&gt;1... */ public void prim(MGraph graph, int v) &#123; // visited[] 标记结点(顶点)是否被访问过 int visited[] = new int[graph.verxs]; // visited[] 默认元素的值都是 0, 表示没有访问过 // for(int i =0; i &lt;graph.verxs; i++) &#123; // visited[i] = 0; // &#125; // 把当前这个结点标记为已访问 visited[v] = 1; // h1 和 h2 记录两个顶点的下标 int h1 = -1; int h2 = -1; int minWeight = 10000; // 将 minWeight 初始成一个大数， 后面在遍历过程中， 会被替换 for (int k = 1; k &lt; graph.verxs; k++) &#123;// 因为有 graph.verxs 顶点， 普利姆算法结束后，有 graph.verxs-1 边 // 这个是确定每一次生成的子图 ， 和哪个结点的距离最近 for (int i = 0; i &lt; graph.verxs; i++) &#123;// i 结点表示被访问过的结点 for (int j = 0; j &lt; graph.verxs; j++) &#123;// j 结点表示还没有访问过的结点 if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123; // 替换 minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边) minWeight = graph.weight[i][j]; h1 = i; h2 = j; &#125; &#125; &#125; // 找到一条边是最小 System.out.println(\"边&lt;\" + graph.data[h1] + \",\" + graph.data[h2] + \"&gt; 权值:\" + minWeight); // 将当前这个结点标记为已经访问 visited[h2] = 1; // minWeight 重新设置为最大值 10000 minWeight = 10000; &#125; &#125;&#125;class MGraph &#123; int verxs; // 表示图的节点个数 char[] data;// 存放结点数据 int[][] weight; // 存放边， 就是我们的邻接矩阵 public MGraph(int verxs) &#123; this.verxs = verxs; data = new char[verxs]; weight = new int[verxs][verxs]; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"贪心算法(集合覆盖问题)","date":"2020-05-08T15:56:13.000Z","path":"2020/05/08/贪心算法--集合覆盖问题/","text":"贪心算法介绍 贪婪算法(贪心算法)是指在对问题进行求解时， 在每一步选择中都采取最好或者最优(即最有利)的选择， 从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)， 但是都是相对近似(接近)最优解的结果 贪心算法最佳应用-集合覆盖题目假设存在下面需要付费的广播台， 以及广播台信号可以覆盖的地区。 如何选择最少的广播台， 让所有的地区都可以接收到信号 思路分析方式一:穷举法如何找出覆盖所有地区的广播台的集合呢， 使用穷举法实现,列出每个可能的广播台的集合， 这被称为幂集。 假设总的有 n 个广播台， 则广播台的组合总共有2ⁿ -1个,假设每秒可以计算 10 个子集， 如图: 方式二:贪婪算法(效率高) 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法， 则可以得到非常接近的解， 并且效率高。 选择策略上， 因为需要覆盖全部地区的最小集合: 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区， 但没有关系） 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 重复第 1 步直到覆盖了全部的地区 贪婪算法代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.zjc.algorithm.greedy;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;public class GreedyAlgorithm &#123; public static void main(String[] args) &#123; // 创建广播电台,放入到 Map HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;String, HashSet&lt;String&gt;&gt;(); // 将各个电台放入到 broadcasts HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;(); hashSet1.add(\"北京\"); hashSet1.add(\"上海\"); hashSet1.add(\"天津\"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;(); hashSet2.add(\"广州\"); hashSet2.add(\"北京\"); hashSet2.add(\"深圳\"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;(); hashSet3.add(\"成都\"); hashSet3.add(\"上海\"); hashSet3.add(\"杭州\"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;(); hashSet4.add(\"上海\"); hashSet4.add(\"天津\"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;(); hashSet5.add(\"杭州\"); hashSet5.add(\"大连\"); // 加入到 map broadcasts.put(\"K1\", hashSet1); broadcasts.put(\"K2\", hashSet2); broadcasts.put(\"K3\", hashSet3); broadcasts.put(\"K4\", hashSet4); broadcasts.put(\"K5\", hashSet5); // allAreas 存放所有的地区 HashSet&lt;String&gt; allAreas = new HashSet&lt;String&gt;(); allAreas.add(\"北京\"); allAreas.add(\"上海\"); allAreas.add(\"天津\"); allAreas.add(\"广州\"); allAreas.add(\"深圳\"); allAreas.add(\"成都\"); allAreas.add(\"杭州\"); allAreas.add(\"大连\"); // 创建 ArrayList, 存放选择的电台集合 ArrayList&lt;String&gt; selects = new ArrayList&lt;String&gt;(); // 定义一个临时的集合， 在遍历的过程中， 存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集 HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;(); // 定义给 maxKey ， 保存在一次遍历过程中， 能够覆盖最大未覆盖的地区对应的电台的 key // 如果 maxKey 不为 null , 则会加入到 selects String maxKey = null; while (allAreas.size() != 0) &#123; // 如果 allAreas 不为 0, 则表示还没有覆盖到所有的地区 // 每进行一次 while,需要 maxKey = null; // 遍历 broadcasts, 取出对应 key for (String key : broadcasts.keySet()) &#123; // 每进行一次 for tempSet.clear(); // 当前这个 key 能够覆盖的地区 HashSet&lt;String&gt; areas = broadcasts.get(key); tempSet.addAll(areas); // 求出 tempSet 和 allAreas 集合的交集, 交集会赋给 tempSet tempSet.retainAll(allAreas); // 如果当前这个集合包含的未覆盖地区的数量， 比 maxKey 指向的集合地区还多 // 就需要重置 maxKey // tempSet.size() &gt;broadcasts.get(maxKey).size()) // 体现出贪心算法的特点,每次都选择最优的 if (tempSet.size() &gt; 0 &amp;&amp; (maxKey == null || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123; maxKey = key; &#125; &#125; // maxKey != null, 就应该将 maxKey 加入 selects if (maxKey != null) &#123; selects.add(maxKey); // 将 maxKey 指向的广播电台覆盖的地区， 从 allAreas 去掉 allAreas.removeAll(broadcasts.get(maxKey)); &#125; &#125; System.out.println(\"得到的选择结果是\" + selects);// [K1,K2,K3,K5] &#125;&#125; 贪心算法注意事项和细节 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)， 但是都是相对近似(接近)最优解的结果 比如上题的算法选出的是 K1, K2, K3, K5， 符合覆盖了全部的地区 但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区， 如果 K2 的使用成本低于 K1,那么我们上题的 K1, K2, K3,K5 虽然是满足条件， 但是并不是最优的","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"KMP算法(字符串查找算法)","date":"2020-05-08T14:43:14.000Z","path":"2020/05/08/KMP算法--字符串查找算法/","text":"应用场景-字符串匹配问题 有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD” 现在要判断 str1 是否含有 str2,如果存在，就返回第一次出现的位置,如果没有，则返回-1 解决方式一:暴力匹配算法思路如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有 如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++， j++，继续匹配下一个字符 如果匹配失败（即 str1[i]! = str2[j]） ， 令 i = i - (j - 1)， j = 0。 相当于每次匹配失败时， i 回溯， j 被置为 0。 有什么问题 用暴力方法解决的话就会有大量的回溯， 每次只移动一位， 若是不匹配， 移动到下一位接着判断， 浪费了大量的时间。 (不可行!) 代码实现12345678910111213141516171819202122232425262728293031323334353637package com.zjc.algorithm.kmp;public class ViolenceMatch &#123; public static void main(String[] args) &#123; // 测试暴力匹配算法 String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; int index = violenceMatch(str1, str2); System.out.println(\"index=\" + index); &#125; // 暴力匹配算法实现 public static int violenceMatch(String str1, String str2) &#123; char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i = 0; // i 索引指向 s1 int j = 0; // j 索引指向 s2 while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;// 保证匹配时， 不越界 if (s1[i] == s2[j]) &#123;// 匹配 ok i++; j++; &#125; else &#123; // 没有匹配成功 // 如果失配（即 str1[i]! = str2[j]） ， 令 i = i - (j - 1)， j = 0。 i = i - (j - 1); j = 0; &#125; &#125; // 判断是否匹配成功 if (j == s2Len) &#123; return i - j; &#125; else &#123; return -1; &#125; &#125;&#125; KMP 算法介绍 KMP 是一个解决模式串在文本串是否出现过， 如果出现过， 最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法， 简称为 “KMP 算法”， 常用于在一个文本串 S 内查找一个模式串 P 的出现位置， 这个算法由 Donald Knuth、 Vaughan Pratt、 James H. Morris 三人于 1977 年联合发表， 故取这 3 人的姓氏命名此算法. KMP 方法算法就利用之前判断过信息， 通过一个 next 数组， 保存模式串中前后最长公共子序列的长度， 每次回溯时， 通过 next 数组找到， 前面匹配过的位置，省去了大量的计算时间 参考资料： https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html 字符串匹配问题 有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”， 和一个子串 str2=”ABCDABD” 现在要判断 str1 是否含有 str2, 如果存在， 就返回第一次出现的位置, 如果没有， 则返回-1 要求： 使用 KMP 算法完成判断， 不能使用简单的暴力匹配算法. 思路分析图解举例来说， 有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”， 判断， 里面是否包含另一个字符串 Str2 =”ABCDABD”？ 首先， 用 Str1 的第一个字符和 Str2 的第一个字符去比较， 不符合， 关键词向后移动一位 重复第一步， 还是不符合， 再后移 一直重复， 直到 Str1 有一个字符与 Str2 的第一个字符符合为止 接着比较字符串和搜索词的下一个字符， 还是符合 遇到 Str1 有一个字符与 Str2 对应的字符不符合。 这时候， 想到的是继续遍历 Str1 的下一个字符， 重复第 1 步。 (其实是很不明智的， 因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时， 你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息， 不要把”搜索位置”移回已经比较过的位置，继续把它向后移， 这样就提高了效率。) 怎么做到把刚刚重复的步骤省略掉？ 可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍 已知空格与 D 不匹配时， 前面六个字符”ABCDAB”是匹配的。 查表可知， 最后一个匹配字符 B 对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：移动位数 = 已匹配的字符数 - 对应的部分匹配值因为 6 - 2 等于 4， 所以将搜索词向后移动 4 位 因为空格与Ｃ 不匹配， 搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为 0。所以，移动位数 = 2 - 0，结果为2，于是将搜索词向后移 2 位 因为空格与 A 不匹配， 继续后移一位。 逐位比较， 直到发现 C 与 D 不匹配。 于是， 移动位数 = 6 - 2， 继续将搜索词向后移动 4 位 逐位比较， 直到搜索词的最后一位， 发现完全匹配， 于是搜索完成。 如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0， 再将搜索词向后移动 7 位，这里就不再重复了 介绍《部分匹配表》 怎么产生的先介绍前缀， 后缀是什么 12345678&quot;部分匹配值&quot;就是&quot;前缀&quot;和&quot;后缀&quot;的最长的共有元素的长度。 以&quot;ABCDABD&quot;为例，==&gt; &quot;A&quot;的前缀和后缀都为空集， 共有元素的长度为 0；==&gt; &quot;AB&quot;的前缀为[A]， 后缀为[B]， 共有元素的长度为 0；==&gt; &quot;ABC&quot;的前缀为[A, AB]， 后缀为[BC, C]， 共有元素的长度 0；==&gt; &quot;ABCD&quot;的前缀为[A, AB, ABC]， 后缀为[BCD, CD, D]， 共有元素的长度为 0；==&gt; &quot;ABCDA&quot;的前缀为[A, AB, ABC, ABCD]， 后缀为[BCDA, CDA, DA, A]， 共有元素为&quot;A&quot;， 长度为 1；==&gt; &quot;ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]， 后缀为[BCDAB, CDAB, DAB, AB, B]， 共有元素为&quot;AB&quot;，长度为 2；==&gt; &quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]， 后缀为[BCDABD, CDABD, DABD, ABD, BD,D]， 共有元素的长度为 0。 “部分匹配”的实质是， 有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度-部分匹配值） ， 就可以来到第二个”AB”的位置。到此 KMP 算法思想分析完毕! 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.zjc.algorithm.kmp;import java.util.Arrays;public class KMPAlgorithm &#123; public static void main(String[] args) &#123; String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; // String str2 = \"BBC\"; int[] next = kmpNext(\"ABCDABD\"); // [0, 1, 2, 0] System.out.println(\"next=\" + Arrays.toString(next)); int index = kmpSearch(str1, str2, next); System.out.println(\"index=\" + index); // 15 了 &#125; /** * kmp 搜索算法 * * @param str1 源字符串 * @param str2 子串 * @param next 部分匹配表, 是子串对应的部分匹配表 * @return 如果是-1 就是没有匹配到， 否则返回第一个匹配的位置 */ public static int kmpSearch(String str1, String str2, int[] next) &#123; // 遍历 for (int i = 0, j = 0; i &lt; str1.length(); i++) &#123; // 需要处理 str1.charAt(i) ！ = str2.charAt(j), 去调整 j 的大小 // KMP 算法核心点, 可以验证... while (j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123; j = next[j - 1]; &#125; if (str1.charAt(i) == str2.charAt(j)) &#123; j++; &#125; if (j == str2.length()) &#123;// 找到了 // j = 3 i return i - j + 1; &#125; &#125; return -1; &#125; /** * 获取到一个字符串(子串) 的部分匹配值表 * * @param dest 目标字符串 * @return */ public static int[] kmpNext(String dest) &#123; // 创建一个 next 数组保存部分匹配值 int[] next = new int[dest.length()]; next[0] = 0; // 如果字符串是长度为 1 部分匹配值就是 0 for (int i = 1, j = 0; i &lt; dest.length(); i++) &#123; // 当 dest.charAt(i) != dest.charAt(j) ， 我们需要从 next[j-1]获取新的 j // 直到我们发现 有 dest.charAt(i) == dest.charAt(j)成立才退出 // 这是 kmp 算法的核心点 while (j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123; j = next[j - 1]; &#125; // 当 dest.charAt(i) == dest.charAt(j) 满足时， 部分匹配值就是+1 if (dest.charAt(i) == dest.charAt(j)) &#123; j++; &#125; next[i] = j; &#125; return next; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"动态规划算法--背包问题","date":"2020-05-08T14:12:34.000Z","path":"2020/05/08/动态规划算法--背包问题/","text":"动态规划算法介绍 动态规划(Dynamic Programming)算法的核心思想是： 将大问题划分为小问题进行解决， 从而一步步获取最优解的处理算法 动态规划算法与分治算法类似， 其基本思想也是将待求解问题分解成若干个子问题， 先求解子问题， 然后从这些子问题的解得到原问题的解。 与分治法不同的是， 适合于用动态规划求解的问题， 经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上， 进行进一步的求解 ) 动态规划可以通过填表的方式来逐步推进， 得到最优解 背包问题 背包问题主要是指一个给定容量的背包、 若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分 0-1背包 完全背包(完全背包指的是： 每种物品都有无限件可用, 无限背包可以转化为 01 背包) 0-1背包问题背包问题： 有一个背包， 容量为 4 磅 ， 现有如下物品 要求达到的目标为装入的背包的总价值最大， 并且重量不超出 要求装入的物品不能重复 0-1背包问题的解决思路算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品,即对于给定的 n 个物品， 设 v[i]、 w[i]分别为第 i 个物品的价值和重量， C 为背包的容量。 再令 v[i][j]表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。 则我们有下面的结果： v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0 当 w[i]&gt; j时： v[i][j]=v[i-1][j] ==&gt; 当准备加入新增的商品的容量大于 当前背包的容量时， 就直接使用上一个单元格的装入策略 当 j&gt;=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} ==&gt; 当准备加入的新增的商品的容量小于等于当前背包的容量12345// 装入的方式:v[i-1][j]： 就是上一个单元格的装入的最大值v[i] : 表示当前商品的价值v[i-1][j-w[i]] ： 装入 i-1 商品， 到剩余空间 j-w[i]的最大值当 j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; 图解分析 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.zjc.algorithm.dynamic;public class KnapsackProblem &#123; public static void main(String[] args) &#123; int[] w = &#123; 1, 4, 3 &#125;;// 物品的重量 int[] val = &#123; 1500, 3000, 2000 &#125;; // 物品的价值 这里 val[i] 就是前面讲的 v[i] int m = 4; // 背包的容量 int n = val.length; // 物品的个数 // 创建二维数组， // v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值 int[][] v = new int[n + 1][m + 1]; // 为了记录放入商品的情况， 我们定一个二维数组 int[][] path = new int[n + 1][m + 1]; // 初始化第一行和第一列, 这里在本程序中， 可以不去处理， 因为默认就是 0 for (int i = 0; i &lt; v.length; i++) &#123; v[i][0] = 0; // 将第一列设置为 0 &#125; for (int i = 0; i &lt; v[0].length; i++) &#123; v[0][i] = 0; // 将第一行设置 0 &#125; // 根据前面得到公式来动态规划处理 for (int i = 1; i &lt; v.length; i++) &#123; // 不处理第一行 i 是从 1 开始的 for (int j = 1; j &lt; v[0].length; j++) &#123;// 不处理第一列, j 是从 1 开始的 // 公式 if (w[i - 1] &gt; j) &#123; // 因为我们程序 i 是从 1 开始的， 因此原来公式中的 w[i] 修改成 // w[i-1] v[i][j] = v[i - 1][j]; &#125; else &#123; // 说明: // 因为我们的 i 从 1 开始的， 因此公式需要调整成 // v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]); // v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - // w[i - 1]]); // 为了记录商品存放到背包的情况， 我们不能直接的使用上面的公式， 需要使用 if-else 来体现公式 if (v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123; v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]]; // 把当前的情况记录到 path path[i][j] = 1; &#125; else &#123; v[i][j] = v[i - 1][j]; &#125; &#125; &#125; &#125; // 输出一下 v 看看目前的情况 for (int i = 0; i &lt; v.length; i++) &#123; for (int j = 0; j &lt; v[i].length; j++) &#123; System.out.print(v[i][j] + \" \"); &#125; System.out.println(); &#125; System.out.println(\"============================\"); // 输出最后我们是放入的哪些商品 // 遍历 path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入// for (int i = 0; i &lt; path.length; i++) &#123;// for (int j = 0; j &lt; path[i].length; j++) &#123;// if (path[i][j] == 1) &#123;// System.out.printf(\"第%d 个商品放入到背包\\n\", i);// &#125;// &#125;// &#125; // 动脑筋 int i = path.length - 1; // 行的最大下标 int j = path[0].length - 1; // 列的最大下标 while (i &gt; 0 &amp;&amp; j &gt; 0) &#123; // 从 path 的最后开始找 if (path[i][j] == 1) &#123; System.out.printf(\"第%d 个商品放入到背包\\n\", i); j -= w[i - 1]; // w[i-1] &#125; i--; &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"分治算法--汉诺塔问题","date":"2020-05-08T14:04:39.000Z","path":"2020/05/08/分治算法--汉诺塔问题/","text":"分治算法介绍 分治法是一种很重要的算法。 字面上的解释是“分而治之” ， 就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解， 原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础， 如排序算法(快速排序， 归并排序)， 傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 分治算法的基本步骤分治法在每一层递归上都有三个步骤：1) 分解： 将原问题分解为若干个规模较小， 相互独立， 与原问题形式相同的子问题2) 解决： 若子问题规模较小而容易被解决则直接解， 否则递归地解各个子问题3) 合并： 将各个子问题的解合并为原问题的解。 分治(Divide-and-Conquer(P))算法设计模式 分治算法最佳实践-汉诺塔汉诺塔的传说汉诺塔： 汉诺塔（又称河内塔） 问题是源于印度一个古老传说的益智玩具。 大梵天创造世界的时候做了三根金刚石柱子， 在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。 并且规定， 在小圆盘上不能放大圆盘，三根柱子之间一次只能移动一个圆盘。假如每秒钟一次， 共需多长时间呢？ 移完这些金片需要 5845.54 亿年以上，太阳系的预期寿命据说也就是数百亿年。 真的过了 5845.54 亿年， 地球上的一切生命， 连同梵塔、 庙宇等， 都早已经灰飞烟灭。 汉诺塔游戏的演示和思路分析 如果是有一个盘， A-&gt;C, 如果我们有 n &gt;= 2 情况， 我们总是可以看做是两个盘 最下边的盘 上面的盘 先把最上面的盘 A-&gt;B 把最下边的盘 A-&gt;C 把 B 塔的所有盘 从 B-&gt;C 汉诺塔游戏的代码实现123456789101112131415161718192021222324252627282930package com.zjc.algorithm.dac;public class Hanoitower &#123; public static void main(String[] args) &#123; hanoiTower(5, 'A', 'B', 'C'); &#125; /** * 汉诺塔的移动的方法 * 使用分治算法 * @param num 盘的数量 * @param a a柱子 * @param b b柱子 * @param c c柱子 */ public static void hanoiTower(int num, char a, char b, char c) &#123; //如果只有一个盘 if (num == 1) &#123; System.out.println(\"第 1 个盘从 \" + a + \"-&gt;\" + c); &#125; else &#123; // 如果我们有 n &gt;= 2 情况， 我们总是可以看做是两个盘 1.最下边的一个盘 2. 上面的所有盘 // 1. 先把 最上面的所有盘 A-&gt;B， 移动过程会使用到 c hanoiTower(num - 1, a, c, b); // 2. 把最下边的盘 A-&gt;C System.out.println(\"第\" + num + \"个盘从 \" + a + \"-&gt;\" + c); // 3. 把 B 塔的所有盘 从 B-&gt;C , 移动过程使用到 a 塔 hanoiTower(num - 1, b, a, c); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"二分查找算法--非递归","date":"2020-05-08T13:58:42.000Z","path":"2020/05/08/二分查找算法-非递归/","text":"二分查找算法(非递归)介绍 前面我们讲过了二分查找算法， 是使用递归的方式， 下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)， 将数列排序后再进行查找 二分查找法的运行时间为对数时间O(㏒₂ n)， 即查找到需要的目标位置最多只需要㏒₂ n 步， 假设从[0,99]的队列(100 个数， 即 n=100)中寻到目标数 30，则需要查找步数为㏒₂ 100 , 即最多需要查找 7 次( 2^6 &lt; 100 &lt; 2^7) 二分查找算法(非递归)代码实现数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成. 代码实现 1234567891011121314151617181920212223242526272829303132333435package com.zjc.algorithm.binarysearchnorecursion;public class BinarySearchNoRecur &#123; /** * 测试 * @param args */ public static void main(String[] args) &#123; int[] arr = &#123; 1, 3, 8, 10, 11, 67, 100 &#125;; int index = binarySearch(arr, 100); System.out.println(\"index=\" + index);// &#125; // 二分查找的非递归实现 /** * @param arr 待查找的数组, arr 是升序排序 * @param target 需要查找的数 * @return 返回对应下标， -1 表示没有找到 */ public static int binarySearch(int[] arr, int target) &#123; int left = 0; int right = arr.length - 1; while (left &lt;= right) &#123; // 说明继续查找 int mid = (left + right) / 2; if (arr[mid] == target) &#123; return mid; &#125; else if (arr[mid] &gt; target) &#123; right = mid - 1;// 需要向左边查找 &#125; else &#123; left = mid + 1; // 需要向右边查找 &#125; &#125; return -1; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"图的基本介绍与深度和广度优先遍历算法","date":"2020-05-07T10:39:28.000Z","path":"2020/05/07/图的基本介绍与深度和广度优先遍历算法/","text":"图基本介绍为什么要有图 前面我们学了线性表和树 线性表局限于一个直接前驱和一个直接后继的关系 树也只能有一个直接前驱也就是父节点 当我们需要表示多对多的关系时，这里我们就用到了图 图的举例说明图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。如图 图的常用概念 顶点(vertex) 边(edge) 路径 无向图 有向图 带权图 图的表示方式图的表示方式有两种 二维数组表示（邻接矩阵）； 链表表示（邻接表）。 邻接矩阵邻接矩阵是表示图形中顶点之间相邻关系的矩阵， 对于 n 个顶点的图而言， 矩阵是的 row 和 col 表示的是 1….n个点 邻接表 邻接矩阵需要为每个顶点都分配 n 个边的空间， 其实有很多边都是不存在,会造成空间的一定损失. 邻接表的实现只关心存在的边， 不关心不存在的边。 因此没有空间浪费， 邻接表由数组+链表组成 举例说明 图的代码实现创建图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.zjinc36.graph;import java.util.ArrayList;import java.util.Arrays;public class Graph &#123; private ArrayList&lt;String&gt; vertexList; // 存储顶点集合 private int[][] edges; // 存储图对应的邻接矩阵 private int numOfEdges; // 表示边的数目 public static void main(String[] args) &#123; ///////////////////////// // 创建图 ///////////////////////// int n = 5; // 顶点个数 String Vertexs[] = &#123;\"A\", \"B\", \"C\", \"D\", \"E\"&#125;; // 创建图对象 Graph graph = new Graph(n); // 循环添加顶点 for (String vertex : Vertexs) &#123; graph.insertVertex(vertex); &#125; // 添加边 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); // 显示邻接矩阵 graph.showGraph(); &#125; // 构造器 public Graph(int n) &#123; // 初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); numOfEdges = 0; &#125;///////////////////////////////创建图///////////////////////////// /** * 插入顶点 * * @param vertex 顶点 */ public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; /** * 添加边 * * @param v1 表示第一个顶点的下标 * @param v2 表示第二个顶点的下标 * @param weight 权重 */ public void insertEdge(int v1, int v2, int weight) &#123; // 因为是无向图,所以两个方向都要添加 edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125; /////////////////////////////// 图中常用方法///////////////////////////// /** * 得到结点的个数 * * @return */ public int getNumOfVertex() &#123; return vertexList.size(); &#125; /** * 得到边的数目 * * @return */ public int getNumOfEdges() &#123; return numOfEdges; &#125; /** * 返回下标为i对应的数据 0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" * * @param i 下标 * @return */ public String getValueByIndex(int i) &#123; return vertexList.get(i); &#125; /** * 返回v1和v2的权值 * * @param v1 * @param v2 * @return */ public int getWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; /** * 显示图对应的矩阵 */ public void showGraph() &#123; for (int[] link : edges) &#123; System.out.println(Arrays.toString(link)); &#125; &#125;&#125; 深度优先搜索(DFS)规则深度优先搜索算法有如下规则： 规则1：如果可能，访问一个邻接的未访问顶点，标记它，并将它放入栈中。 规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。 规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。 对于上图，应用深度优先搜索如下：假设选取 A 顶点为起始点，并且按照字母优先顺序进行访问，那么应用规则 1 ，接下来访问顶点 B，然后标记它，并将它放入栈中；再次应用规则 1，接下来访问顶点 F，再次应用规则 1，访问顶点 H。我们这时候发现，没有 H 顶点的邻接点了，这时候应用规则 2，从栈中弹出 H，这时候回到了顶点 F，但是我们发现 F 也除了 H 也没有与之邻接且未访问的顶点了，那么再弹出 F，这时候回到顶点 B，同理规则 1 应用不了，应用规则 2，弹出 B，这时候栈中只有顶点 A了，然后 A 还有未访问的邻接点，所有接下来访问顶点 C，但是 C又是这条线的终点，所以从栈中弹出它，再次回到 A，接着访问 D,G,I，最后也回到了 A，然后访问 E，但是最后又回到了顶点 A，这时候我们发现 A没有未访问的邻接点了，所以也把它弹出栈。现在栈中已无顶点，于是应用规则 3，完成了整个搜索过程。 深度优先搜索在于能够找到与某一顶点邻接且没有访问过的顶点。这里以邻接矩阵为例，找到顶点所在的行，从第一列开始向后寻找值为1的列；列号是邻接顶点的号码，检查这个顶点是否未访问过，如果是这样，那么这就是要访问的下一个顶点，如果该行没有顶点既等于1（邻接）且又是未访问的，那么与指定点相邻接的顶点就全部访问过了。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package com.zjinc36.graph;import java.util.ArrayList;import java.util.Arrays;public class Graph &#123; private ArrayList&lt;String&gt; vertexList; // 存储顶点集合 private int[][] edges; // 存储图对应的邻接矩阵 private int numOfEdges; // 表示边的数目 private boolean[] isVisited; // 保存已经访问过的结点 /** * 测试 */ public static void main(String[] args) &#123; ///////////////////////// // 创建图 ///////////////////////// int n = 5; // 顶点个数 String Vertexs[] = &#123;\"A\", \"B\", \"C\", \"D\", \"E\"&#125;; // 创建图对象 Graph graph = new Graph(n); // 循环添加顶点 for (String vertex : Vertexs) &#123; graph.insertVertex(vertex); &#125; // 添加边 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); // 显示邻接矩阵 graph.showGraph(); ///////////////////////// // 深度遍历 ///////////////////////// System.out.println(\"深度遍历\"); graph.dfs(); &#125; // 构造器 public Graph(int n) &#123; // 初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); numOfEdges = 0; isVisited = new boolean[n]; &#125;///////////////////////////////深度优先遍历///////////////////////////// /** * 得到第一个邻接结点的下标 * * @param index 邻接矩阵的行的下标 * @return 如果存在就返回对应的下标，否则返回-1 */ public int getFirstNeighbor(int index) &#123; for (int j = 0; j &lt; vertexList.size(); j++) &#123; if (edges[index][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; /** * 根据前一个邻接结点的下标来获取下一个邻接结点 * * @param v1 邻接矩阵的行的下标 * @param v2 邻接矩阵的列(上一个被访问的矩阵的列的下标) * @return */ public int getNextNeighbor(int v1, int v2) &#123; for (int j = v2 + 1; j &lt; vertexList.size(); j++) &#123; if (edges[v1][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; /** * 深度优先遍历算法 * ==&gt; 规则1：如果可能，访问一个邻接的未访问顶点，标记它，并将它放入栈中。 * ==&gt; 规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。 * ==&gt; 规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。 * @param isVisited 是否访问过 * @param i 邻接矩阵的行的下标 */ public void dfs(boolean[] isVisited, int i) &#123; // 0. 访问顶点 // ==&gt; 首先我们访问该结点 =&gt; 这里表现为输出 System.out.print(getValueByIndex(i) + \"-&gt;\"); // ==&gt; 将结点设置为已经访问 isVisited[i] = true; // 1. 访问一个邻接的未访问顶点，标记它，并将它放入栈中 // ==&gt; 查找结点i的第一个邻接结点w int firstNeighbor = getFirstNeighbor(i); while (firstNeighbor != -1) &#123; // 不等于-1,说明找到邻接结点 // ==&gt; 判断这个邻接结点是否访问过 if (!isVisited[firstNeighbor]) &#123; // ==&gt; 如果没有访问过,则以当前这个邻接结点开始,继续寻找下一个邻接结点 // ==&gt; 也就是进行深度优先遍历 dfs(isVisited, firstNeighbor); &#125; // ==&gt; 如果firstNeighbor结点已经被访问过 // ==&gt; 访问下一个邻接的未访问顶点 firstNeighbor = getNextNeighbor(i, firstNeighbor); &#125; &#125; // 对dfs进行一个重载,遍历我们所有的结点,并进行dfs public void dfs() &#123; // 遍历所有的结点,进行dfs[回溯] for (int i = 0; i &lt; getNumOfVertex(); i++) &#123; // 只有未被访问过才需要进行深度优先遍历 if (!isVisited[i]) &#123; dfs(isVisited, i); &#125; &#125; &#125;///////////////////////////////创建图///////////////////////////// /** * 插入顶点 * * @param vertex 顶点 */ public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; /** * 添加边 * * @param v1 表示第一个顶点的下标 * @param v2 表示第二个顶点的下标 * @param weight 权重 */ public void insertEdge(int v1, int v2, int weight) &#123; // 因为是无向图,所以两个方向都要添加 edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125; /////////////////////////////// 图中常用方法///////////////////////////// /** * 得到结点的个数 * * @return */ public int getNumOfVertex() &#123; return vertexList.size(); &#125; /** * 得到边的数目 * * @return */ public int getNumOfEdges() &#123; return numOfEdges; &#125; /** * 返回下标为i对应的数据 0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" * * @param i 下标 * @return */ public String getValueByIndex(int i) &#123; return vertexList.get(i); &#125; /** * 返回v1和v2的权值 * * @param v1 * @param v2 * @return */ public int getWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; /** * 显示图对应的矩阵 */ public void showGraph() &#123; for (int[] link : edges) &#123; System.out.println(Arrays.toString(link)); &#125; &#125;&#125; 广度优先搜索(BFS) 深度优先搜索要尽可能的远离起始点，而广度优先搜索则要尽可能的靠近起始点，它首先访问起始顶点的所有邻接点，然后再访问较远的区域，这种搜索不能用栈实现，而是用队列实现。 规则 规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。 规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点。 规则3：如果因为队列为空而不能执行规则 2，则搜索结束。 对于上面的图，应用广度优先搜索：以A为起始点，首先访问所有与 A 相邻的顶点，并在访问的同时将其插入队列中，现在已经访问了 A,B,C,D和E。这时队列（从头到尾）包含 BCDE，已经没有未访问的且与顶点 A 邻接的顶点了，所以从队列中取出B，寻找与B邻接的顶点，这时找到F，所以把F插入到队列中。已经没有未访问且与B邻接的顶点了，所以从队列列头取出C，它没有未访问的邻接点。因此取出 D 并访问 G，D也没有未访问的邻接点了，所以取出E，现在队列中有 FG，在取出 F，访问 H，然后取出 G，访问 I，现在队列中有 HI，当取出他们时，发现没有其它为访问的顶点了，这时队列为空，搜索结束。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178package com.zjinc36.graph;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;public class Graph &#123; private ArrayList&lt;String&gt; vertexList; // 存储顶点集合 private int[][] edges; // 存储图对应的邻接矩阵 private int numOfEdges; // 表示边的数目 private boolean[] isVisited; // 保存已经访问过的结点 /** * 测试 */ public static void main(String[] args) &#123; ///////////////////////// // 创建图 ///////////////////////// int n = 5; // 顶点个数 String Vertexs[] = &#123;\"A\", \"B\", \"C\", \"D\", \"E\"&#125;; // 创建图对象 Graph graph = new Graph(n); // 循环添加顶点 for (String vertex : Vertexs) &#123; graph.insertVertex(vertex); &#125; // 添加边 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); // 显示邻接矩阵 graph.showGraph(); ///////////////////////// // 广度优先遍历 ///////////////////////// System.out.println(); System.out.println(\"广度优先遍历\"); graph.bfs(); &#125; // 构造器 public Graph(int n) &#123; // 初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); numOfEdges = 0; isVisited = new boolean[n]; &#125;///////////////////////////////广度优先遍历///////////////////////////// private void bfs(boolean[] isVisited, int i) &#123; int u; // 表示队列的头结点对应下标 int w; // 邻接结点 w // 队列， 记录结点访问的顺序 LinkedList queue = new LinkedList(); // 访问结点， 输出结点信息 System.out.print(getValueByIndex(i) + \"=&gt;\"); // 标记为已访问 isVisited[i] = true; // 将结点加入队列 queue.addLast(i); while (!queue.isEmpty()) &#123; // 取出队列的头结点下标 u = (Integer) queue.removeFirst(); // 得到第一个邻接结点的下标 w w = getFirstNeighbor(u); while (w != -1) &#123;// 找到 // 是否访问过 if (!isVisited[w]) &#123; System.out.print(getValueByIndex(w) + \"=&gt;\"); // 标记已经访问 isVisited[w] = true; // 入队 queue.addLast(w); &#125; // 以 u 为前驱点， 找 w 后面的下一个邻结点 w = getNextNeighbor(u, w); // 体现出我们的广度优先 &#125; &#125; &#125; /** * 遍历所有结点,都进行广度优先搜索 */ public void bfs() &#123; for (int i = 0; i &lt; getNumOfVertex(); i++) &#123; if (!isVisited[i]) &#123; bfs(isVisited, i); &#125; &#125; &#125;///////////////////////////////创建图///////////////////////////// /** * 插入顶点 * * @param vertex 顶点 */ public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; /** * 添加边 * * @param v1 表示第一个顶点的下标 * @param v2 表示第二个顶点的下标 * @param weight 权重 */ public void insertEdge(int v1, int v2, int weight) &#123; // 因为是无向图,所以两个方向都要添加 edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125; /////////////////////////////// 图中常用方法///////////////////////////// /** * 得到结点的个数 * * @return */ public int getNumOfVertex() &#123; return vertexList.size(); &#125; /** * 得到边的数目 * * @return */ public int getNumOfEdges() &#123; return numOfEdges; &#125; /** * 返回下标为i对应的数据 0-&gt;\"A\" 1-&gt;\"B\" 2-&gt;\"C\" * * @param i 下标 * @return */ public String getValueByIndex(int i) &#123; return vertexList.get(i); &#125; /** * 返回v1和v2的权值 * * @param v1 * @param v2 * @return */ public int getWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; /** * 显示图对应的矩阵 */ public void showGraph() &#123; for (int[] link : edges) &#123; System.out.println(Arrays.toString(link)); &#125; &#125;&#125; 参考 算法|深度优先搜索（DFS）与广度优先搜索（BFS）的Java实现 Java实现图的深度和广度优先遍历算法","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"多路查找树","date":"2020-05-06T15:19:11.000Z","path":"2020/05/06/多路查找树/","text":"B 树的引出二叉树的问题分析二叉树的操作效率较高，但是也存在问题,请看下面的二叉树 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)，就存在如下问题: 问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响 问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度 多叉树 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree） 后面我们讲解的 2-3 树， 2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。 举例说明(下面 2-3 树就是一颗多叉树) 2-节点 3-节点 B 树的基本介绍B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。 如图 B 树通过重新组织节点，降低了树的高度. 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为 4k)，这样每个节点只需要一次 I/O 就可以完全载入 将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素, B 树(B+)广泛应用于文件存储系统以及数据库系统中 2-3 树2-3 树是最简单的 B 树结构,具有如下特点: 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点. 2-3 树是由二节点和三节点构成的树 2-3 树应用案例将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20}构建成 2-3 树，并保证数据插入的大小顺序。 (演示一下构建 2-3树的过程.) 插入规则: 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件。 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则 其它说明除了 2-3 树，还有 2-34-树等，概念和 23-树类似，也是一种 B 树。如图 B 树、 B+树和 B*树B 树的介绍 B-tree树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上， B-tree 就是指的 B 树。 前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语： B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:对上图的说明: B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3， 2-3-4 树的阶是 4 B 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中,即叶子节点和非叶子节点都存放数据. 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 B+树的介绍B+树是 B 树的变体，也是一种多路搜索树。 对上图的说明: B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层 更适合文件索引系统 B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然. 稀疏索引与稠密索引说明 稠密索引定义：它是由键值和指针(指向记录本身地址)组成的一系列存储块，该存储块的键值与文件的逻辑顺序一致 特性：每个存储块的每一个键对应的指针都指向每个数据块每一条记录，当要查找指定键K时，采用二分查找即可找到键K对应的记录，复杂度为log2n。 稀疏索引定义：它是由键值和指针(指向记录本身地址)组成的一系列存储块，该存储块的键值与文件的逻辑顺序单调性一致。 特性：每个存储块的每一个键对应的指针都指向每个数据块的第一条记录，当要查找指定建K时，先采用二分查找找到&lt;=K的键S，如果S=K，则命中记录，如果S&lt;K，则顺序查找=K的键，复杂度大于log2n，小于n。 比较： 稀疏索引占用的索引存储空间比较小，但是查找时间较长； 稠密索引查找时间较短，索引存储空间较大。 B*树的介绍B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针 B*树的说明: B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的1/2。 从第 1 个特点我们可以看出， B*树分配新结点的概率比 B+树要低，空间使用率更高 参考 稀疏索引与稠密索引 2-3树与红黑树","tags":[]},{"title":"红黑树的插入和删除与Java实现","date":"2020-05-05T20:37:47.000Z","path":"2020/05/06/红黑树的插入和删除与Java实现/","text":"普通的二叉查找树在极端情况下可退化成链表，此时的增删查效率都会比较低下。 为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。 什么是红黑树 红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。 这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。 它的统计性能要好于平衡二叉树（AVL树），因此，红黑树在很多地方都有应用。比如在 Java 集合框架中，很多部分(HashMap, TreeMap, TreeSet 等)都有红黑树的应用，这些集合均提供了很好的性能。 红黑树的 5 个特性 每个节点要么是红色，要么是黑色； 根节点永远是黑色的； 所有的叶子节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）； 每个红色节点的两个子节点一定都是黑色；（从每个叶子到根的所有路径上不能有两个连续的红色节点,黑色结点是可以连续的） 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（简称黑高） 注意： 性质 3 中指定红黑树的每个叶子节点都是空节点，而且并叶子节点都是黑色。但 Java 实现的红黑树将使用 null 来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的。 性质 4 的意思是：从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点是可以连续的。因此若给定黑色节点的个数 N，最短路径的情况是连续的 N 个黑色，树的高度为 N - 1;最长路径的情况为节点红黑相间，树的高度为 2(N - 1) 。 性质 5 是成为红黑树最主要的条件，后序的插入、删除操作都是为了遵守这个规定。 红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。 红黑树的左旋右旋具体在平衡二叉树的基本介绍与Java实现有具体说明,不再赘述 左旋1234567891011121314151617private void rotateLeft(Entry p) &#123; if (p != null) &#123; Entry r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋123456789101112131415private void rotateRight(Entry p) &#123; if (p != null) &#123; Entry l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 红黑树的平衡插入要插入的结点是红色还是黑色? 要插入的结点是红色 如果插入的节点是黑色，那么这个节点所在路径比其他路径多出一个黑色节点，这个调整起来会比较麻烦（参考红黑树的删除操作，就知道为啥多一个或少一个黑色节点时，调整起来这么麻烦了）。 如果插入的节点是红色，此时所有路径上的黑色节点数量不变，仅可能会出现两个连续的红色节点的情况。这种情况下，通过变色和旋转进行调整即可，比之前的简单多了。 将染红的结点插入后的调整有 2 种情况情况1.父亲节点和叔叔节点都是红色 假设插入的结点是 N,看图可知,此时父结点 P 和叔叔结点 U 都是红色,爷爷结点 G 一定是黑色 由性质4可知,红色结点不能连续,所以图中的情况需要调整 调整:只需要将不管 N 是 P 的左孩子还是右孩子，只要同时把 P 和 U 染成黑色，G 染成红色即可,此时经过 G 的路径上的黑色节点数量不变，性质5仍然满足。 需要注意的是 G 被染成红色后，可能会和它的父节点形成连续的红色节点，此时需要递归向上调整。 简记: 叔叔结点为红色,则变色 情况2.父亲节点为红色，叔叔节点为黑色(N 在父亲节点 P 的左孩子位置) 假设插入的是节点 N，由图可知,这时父亲节点 P 是红色，叔叔节点 U 是黑色，爷爷节点 G 一定是黑色 红色节点的孩子不能是红色，但是直接把父亲节点 P 涂成黑色也不行，这条路径多了个黑色节点。 可以使用右旋，通过把 爷爷节点 G 右旋，P 变成了这个子树的根节点，G 变成了 P 的右子树。 右旋后 G 跑到了右子树上，这时把 P 变成黑的，多了一个黑节点，再把 G 变成红的，就平衡了 此时性质4,红色结点不能有红色子结点得到满足 且没有破坏原本的黑高,原本的黑高从左边看是1,右边看是2,调整后左边的黑高仍旧是1,右边的黑高仍旧是2 简记: 叔叔结点为黑色,N 在父结点 P 的左孩子,则右旋 =&gt; 变色 情况3.父亲节点为红色，叔叔节点为黑色(N 在父亲节点 P 的右孩子位置)上面讲的是插入节点 N 在父亲节点 P 的左孩子位置，如果 N 是 P 的右孩子，就需要多进行一次左旋，把情况化解成上述情况。 简记: 叔叔结点为黑色,N 在父结点 P 的右孩子,则左旋 =&gt; 右旋 =&gt; 变色 插入总结三种情况的区别在于叔叔节点的颜色，如果叔叔节点为红色，直接变色即可。如果叔叔节点为黑色，则需要选选择，再交换颜色。当把这三种情况的图画在一起就区别就比较容易观察了，如下图 验证: Java 中的 TreeMap 源码下面是 TreeMap 在插入后进行调整的代码，可以看出来跟我们分析的一致。 123456789101112131415161718192021222324252627282930313233343536373839404142private void fixAfterInsertion(Entry x) &#123; x.color = RED; //直接染成红色，少点麻烦 //这里分析的都是父亲节点为红色的情况，不是红色就不用调整了 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; // 插入节点 x 的父亲节点位于左孩子 Entry y = rightOf(parentOf(parentOf(x))); // y 是 x 的叔叔节点 if (colorOf(y) == RED) &#123; //如果 y 也是红色，只要把父亲节点和 y 都变成黑色，爷爷节点变成红的，就 Ok 了 setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; //如果叔叔节点 y 不是红色，就需要右旋，让父亲节点变成根节点，爷爷节点去右子树去，然后把父亲节点变成黑色、爷爷节点变成红色 //特殊情况：x 是父亲节点的右孩子，需要对父亲节点进行左旋，把 x 移动到左子树 if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; //和上面对称的操作 Entry y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK;&#125; 红黑树的平衡删除红黑树的删除也是分两步 二叉查找树的删除(查看:二叉排序树的删除) 结构调整 如何进行调整 删除修复操作是针对删除黑色节点才有的 当黑色节点被删除后会让整个树不符合RBTree的定义的第四条(第四条:每个叶子到根的所有路径上不能有两个连续的红色节点)。 需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义 总体思想 删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡 如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整 删除修复操作分为四种情况(删除黑节点后)： 待删除的节点的兄弟节点是红色的节点。 待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。 待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。 待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。 case1:待删除的节点的兄弟节点是红色的节点 由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。 case 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。 上升操作需要对C做一个左旋操作(如果是镜像结构的树只需要做对应的右旋操作即可) 之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。 case2:待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的 case 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。 case 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。 case3:待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的 case 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。 之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4. case4:待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的 Case 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。 Case 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。 删除后调整的全部逻辑流程图红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。 对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。 对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。 红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。 java 中 TreeMap 的源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void fixAfterDeletion(Entry x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry sib = rightOf(parentOf(x)); //左旋，把黑色节点移到左边一个 if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; //处理的节点在 右边，相同逻辑，只不过旋转的方向相反 Entry sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK);&#125; 红黑树的Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585public class RBTreeNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T value;//node value private RBTreeNode&lt;T&gt; left;//left child pointer private RBTreeNode&lt;T&gt; right;//right child pointer private RBTreeNode&lt;T&gt; parent;//parent pointer private boolean red;//color is red or not red public RBTreeNode()&#123;&#125; public RBTreeNode(T value)&#123;this.value=value;&#125; public RBTreeNode(T value,boolean isRed)&#123;this.value=value;this.red = isRed;&#125; public T getValue() &#123; return value; &#125; void setValue(T value) &#123; this.value = value; &#125; RBTreeNode&lt;T&gt; getLeft() &#123; return left; &#125; void setLeft(RBTreeNode&lt;T&gt; left) &#123; this.left = left; &#125; RBTreeNode&lt;T&gt; getRight() &#123; return right; &#125; void setRight(RBTreeNode&lt;T&gt; right) &#123; this.right = right; &#125; RBTreeNode&lt;T&gt; getParent() &#123; return parent; &#125; void setParent(RBTreeNode&lt;T&gt; parent) &#123; this.parent = parent; &#125; boolean isRed() &#123; return red; &#125; boolean isBlack()&#123; return !red; &#125; /** * is leaf node **/ boolean isLeaf()&#123; return left==null &amp;&amp; right==null; &#125; void setRed(boolean red) &#123; this.red = red; &#125; void makeRed()&#123; red=true; &#125; void makeBlack()&#123; red=false; &#125; @Override public String toString()&#123; return value.toString(); &#125;&#125;public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123; private final RBTreeNode&lt;T&gt; root; //node number private java.util.concurrent.atomic.AtomicLong size = new java.util.concurrent.atomic.AtomicLong(0); //in overwrite mode,all node's value can not has same value //in non-overwrite mode,node can have same value, suggest don't use non-overwrite mode. private volatile boolean overrideMode=true; public RBTree()&#123; this.root = new RBTreeNode&lt;T&gt;(); &#125; public RBTree(boolean overrideMode)&#123; this(); this.overrideMode=overrideMode; &#125; public boolean isOverrideMode() &#123; return overrideMode; &#125; public void setOverrideMode(boolean overrideMode) &#123; this.overrideMode = overrideMode; &#125; /** * number of tree number * @return */ public long getSize() &#123; return size.get(); &#125; /** * get the root node * @return */ private RBTreeNode&lt;T&gt; getRoot()&#123; return root.getLeft(); &#125; /** * add value to a new node,if this value exist in this tree, * if value exist,it will return the exist value.otherwise return null * if override mode is true,if value exist in the tree, * it will override the old value in the tree * * @param value * @return */ public T addNode(T value)&#123; RBTreeNode&lt;T&gt; t = new RBTreeNode&lt;T&gt;(value); return addNode(t); &#125; /** * find the value by give value(include key,key used for search, * other field is not used,@see compare method).if this value not exist return null * @param value * @return */ public T find(T value)&#123; RBTreeNode&lt;T&gt; dataRoot = getRoot(); while(dataRoot!=null)&#123; int cmp = dataRoot.getValue().compareTo(value); if(cmp&lt;0)&#123; dataRoot = dataRoot.getRight(); &#125;else if(cmp&gt;0)&#123; dataRoot = dataRoot.getLeft(); &#125;else&#123; return dataRoot.getValue(); &#125; &#125; return null; &#125; /** * remove the node by give value,if this value not exists in tree return null * @param value include search key * @return the value contain in the removed node */ public T remove(T value)&#123; RBTreeNode&lt;T&gt; dataRoot = getRoot(); RBTreeNode&lt;T&gt; parent = root; while(dataRoot!=null)&#123; int cmp = dataRoot.getValue().compareTo(value); if(cmp&lt;0)&#123; parent = dataRoot; dataRoot = dataRoot.getRight(); &#125;else if(cmp&gt;0)&#123; parent = dataRoot; dataRoot = dataRoot.getLeft(); &#125;else&#123; if(dataRoot.getRight()!=null)&#123; RBTreeNode&lt;T&gt; min = removeMin(dataRoot.getRight()); //x used for fix color balance RBTreeNode&lt;T&gt; x = min.getRight()==null ? min.getParent() : min.getRight(); boolean isParent = min.getRight()==null; min.setLeft(dataRoot.getLeft()); setParent(dataRoot.getLeft(),min); if(parent.getLeft()==dataRoot)&#123; parent.setLeft(min); &#125;else&#123; parent.setRight(min); &#125; setParent(min,parent); boolean curMinIsBlack = min.isBlack(); //inherit dataRoot's color min.setRed(dataRoot.isRed()); if(min!=dataRoot.getRight())&#123; min.setRight(dataRoot.getRight()); setParent(dataRoot.getRight(),min); &#125; //remove a black node,need fix color if(curMinIsBlack)&#123; if(min!=dataRoot.getRight())&#123; fixRemove(x,isParent); &#125;else if(min.getRight()!=null)&#123; fixRemove(min.getRight(),false); &#125;else&#123; fixRemove(min,true); &#125; &#125; &#125;else&#123; setParent(dataRoot.getLeft(),parent); if(parent.getLeft()==dataRoot)&#123; parent.setLeft(dataRoot.getLeft()); &#125;else&#123; parent.setRight(dataRoot.getLeft()); &#125; //current node is black and tree is not empty if(dataRoot.isBlack() &amp;&amp; !(root.getLeft()==null))&#123; RBTreeNode&lt;T&gt; x = dataRoot.getLeft()==null ? parent :dataRoot.getLeft(); boolean isParent = dataRoot.getLeft()==null; fixRemove(x,isParent); &#125; &#125; setParent(dataRoot,null); dataRoot.setLeft(null); dataRoot.setRight(null); if(getRoot()!=null)&#123; getRoot().setRed(false); getRoot().setParent(null); &#125; size.decrementAndGet(); return dataRoot.getValue(); &#125; &#125; return null; &#125; /** * fix remove action * @param node * @param isParent */ private void fixRemove(RBTreeNode&lt;T&gt; node,boolean isParent)&#123; RBTreeNode&lt;T&gt; cur = isParent ? null : node; boolean isRed = isParent ? false : node.isRed(); RBTreeNode&lt;T&gt; parent = isParent ? node : node.getParent(); while(!isRed &amp;&amp; !isRoot(cur))&#123; RBTreeNode&lt;T&gt; sibling = getSibling(cur,parent); //sibling is not null,due to before remove tree color is balance //if cur is a left node boolean isLeft = parent.getRight()==sibling; if(sibling.isRed() &amp;&amp; !isLeft)&#123;//case 1 //cur in right parent.makeRed(); sibling.makeBlack(); rotateRight(parent); &#125;else if(sibling.isRed() &amp;&amp; isLeft)&#123; //cur in left parent.makeRed(); sibling.makeBlack(); rotateLeft(parent); &#125;else if(isBlack(sibling.getLeft()) &amp;&amp; isBlack(sibling.getRight()))&#123;//case 2 sibling.makeRed(); cur = parent; isRed = cur.isRed(); parent=parent.getParent(); &#125;else if(isLeft &amp;&amp; !isBlack(sibling.getLeft()) &amp;&amp; isBlack(sibling.getRight()))&#123;//case 3 sibling.makeRed(); sibling.getLeft().makeBlack(); rotateRight(sibling); &#125;else if(!isLeft &amp;&amp; !isBlack(sibling.getRight()) &amp;&amp; isBlack(sibling.getLeft()) )&#123; sibling.makeRed(); sibling.getRight().makeBlack(); rotateLeft(sibling); &#125;else if(isLeft &amp;&amp; !isBlack(sibling.getRight()))&#123;//case 4 sibling.setRed(parent.isRed()); parent.makeBlack(); sibling.getRight().makeBlack(); rotateLeft(parent); cur=getRoot(); &#125;else if(!isLeft &amp;&amp; !isBlack(sibling.getLeft()))&#123; sibling.setRed(parent.isRed()); parent.makeBlack(); sibling.getLeft().makeBlack(); rotateRight(parent); cur=getRoot(); &#125; &#125; if(isRed)&#123; cur.makeBlack(); &#125; if(getRoot()!=null)&#123; getRoot().setRed(false); getRoot().setParent(null); &#125; &#125; //get sibling node private RBTreeNode&lt;T&gt; getSibling(RBTreeNode&lt;T&gt; node,RBTreeNode&lt;T&gt; parent)&#123; parent = node==null ? parent : node.getParent(); if(node==null)&#123; return parent.getLeft()==null ? parent.getRight() : parent.getLeft(); &#125; if(node==parent.getLeft())&#123; return parent.getRight(); &#125;else&#123; return parent.getLeft(); &#125; &#125; private boolean isBlack(RBTreeNode&lt;T&gt; node)&#123; return node==null || node.isBlack(); &#125; private boolean isRoot(RBTreeNode&lt;T&gt; node)&#123; return root.getLeft() == node &amp;&amp; node.getParent()==null; &#125; /** * find the successor node * @param node current node's right node * @return */ private RBTreeNode&lt;T&gt; removeMin(RBTreeNode&lt;T&gt; node)&#123; //find the min node RBTreeNode&lt;T&gt; parent = node; while(node!=null &amp;&amp; node.getLeft()!=null)&#123; parent = node; node = node.getLeft(); &#125; //remove min node if(parent==node)&#123; return node; &#125; parent.setLeft(node.getRight()); setParent(node.getRight(),parent); //don't remove right pointer,it is used for fixed color balance //node.setRight(null); return node; &#125; private T addNode(RBTreeNode&lt;T&gt; node)&#123; node.setLeft(null); node.setRight(null); node.setRed(true); setParent(node,null); if(root.getLeft()==null)&#123; root.setLeft(node); //root node is black node.setRed(false); size.incrementAndGet(); &#125;else&#123; RBTreeNode&lt;T&gt; x = findParentNode(node); int cmp = x.getValue().compareTo(node.getValue()); if(this.overrideMode &amp;&amp; cmp==0)&#123; T v = x.getValue(); x.setValue(node.getValue()); return v; &#125;else if(cmp==0)&#123; //value exists,ignore this node return x.getValue(); &#125; setParent(node,x); if(cmp&gt;0)&#123; x.setLeft(node); &#125;else&#123; x.setRight(node); &#125; fixInsert(node); size.incrementAndGet(); &#125; return null; &#125; /** * find the parent node to hold node x,if parent value equals x.value return parent. * @param x * @return */ private RBTreeNode&lt;T&gt; findParentNode(RBTreeNode&lt;T&gt; x)&#123; RBTreeNode&lt;T&gt; dataRoot = getRoot(); RBTreeNode&lt;T&gt; child = dataRoot; while(child!=null)&#123; int cmp = child.getValue().compareTo(x.getValue()); if(cmp==0)&#123; return child; &#125; if(cmp&gt;0)&#123; dataRoot = child; child = child.getLeft(); &#125;else if(cmp&lt;0)&#123; dataRoot = child; child = child.getRight(); &#125; &#125; return dataRoot; &#125; /** * red black tree insert fix. * @param x */ private void fixInsert(RBTreeNode&lt;T&gt; x)&#123; RBTreeNode&lt;T&gt; parent = x.getParent(); while(parent!=null &amp;&amp; parent.isRed())&#123; RBTreeNode&lt;T&gt; uncle = getUncle(x); if(uncle==null)&#123;//need to rotate RBTreeNode&lt;T&gt; ancestor = parent.getParent(); //ancestor is not null due to before before add,tree color is balance if(parent == ancestor.getLeft())&#123; boolean isRight = x == parent.getRight(); if(isRight)&#123; rotateLeft(parent); &#125; rotateRight(ancestor); if(isRight)&#123; x.setRed(false); parent=null;//end loop &#125;else&#123; parent.setRed(false); &#125; ancestor.setRed(true); &#125;else&#123; boolean isLeft = x == parent.getLeft(); if(isLeft)&#123; rotateRight(parent); &#125; rotateLeft(ancestor); if(isLeft)&#123; x.setRed(false); parent=null;//end loop &#125;else&#123; parent.setRed(false); &#125; ancestor.setRed(true); &#125; &#125;else&#123;//uncle is red parent.setRed(false); uncle.setRed(false); parent.getParent().setRed(true); x=parent.getParent(); parent = x.getParent(); &#125; &#125; getRoot().makeBlack(); getRoot().setParent(null); &#125; /** * get uncle node * @param node * @return */ private RBTreeNode&lt;T&gt; getUncle(RBTreeNode&lt;T&gt; node)&#123; RBTreeNode&lt;T&gt; parent = node.getParent(); RBTreeNode&lt;T&gt; ancestor = parent.getParent(); if(ancestor==null)&#123; return null; &#125; if(parent == ancestor.getLeft())&#123; return ancestor.getRight(); &#125;else&#123; return ancestor.getLeft(); &#125; &#125; private void rotateLeft(RBTreeNode&lt;T&gt; node)&#123; RBTreeNode&lt;T&gt; right = node.getRight(); if(right==null)&#123; throw new java.lang.IllegalStateException(\"right node is null\"); &#125; RBTreeNode&lt;T&gt; parent = node.getParent(); node.setRight(right.getLeft()); setParent(right.getLeft(),node); right.setLeft(node); setParent(node,right); if(parent==null)&#123;//node pointer to root //right raise to root node root.setLeft(right); setParent(right,null); &#125;else&#123; if(parent.getLeft()==node)&#123; parent.setLeft(right); &#125;else&#123; parent.setRight(right); &#125; //right.setParent(parent); setParent(right,parent); &#125; &#125; private void rotateRight(RBTreeNode&lt;T&gt; node)&#123; RBTreeNode&lt;T&gt; left = node.getLeft(); if(left==null)&#123; throw new java.lang.IllegalStateException(\"left node is null\"); &#125; RBTreeNode&lt;T&gt; parent = node.getParent(); node.setLeft(left.getRight()); setParent(left.getRight(),node); left.setRight(node); setParent(node,left); if(parent==null)&#123; root.setLeft(left); setParent(left,null); &#125;else&#123; if(parent.getLeft()==node)&#123; parent.setLeft(left); &#125;else&#123; parent.setRight(left); &#125; setParent(left,parent); &#125; &#125; private void setParent(RBTreeNode&lt;T&gt; node,RBTreeNode&lt;T&gt; parent)&#123; if(node!=null)&#123; node.setParent(parent); if(parent==root)&#123; node.setParent(null); &#125; &#125; &#125; /** * debug method,it used print the given node and its children nodes, * every layer output in one line * @param root */ public void printTree(RBTreeNode&lt;T&gt; root)&#123; java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; queue =new java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt;(); java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; queue2 =new java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt;(); if(root==null)&#123; return ; &#125; queue.add(root); boolean firstQueue = true; while(!queue.isEmpty() || !queue2.isEmpty())&#123; java.util.LinkedList&lt;RBTreeNode&lt;T&gt;&gt; q = firstQueue ? queue : queue2; RBTreeNode&lt;T&gt; n = q.poll(); if(n!=null)&#123; String pos = n.getParent()==null ? \"\" : ( n == n.getParent().getLeft() ? \" LE\" : \" RI\"); String pstr = n.getParent()==null ? \"\" : n.getParent().toString(); String cstr = n.isRed()?\"R\":\"B\"; cstr = n.getParent()==null ? cstr : cstr+\" \"; System.out.print(n+\"(\"+(cstr)+pstr+(pos)+\")\"+\"\\t\"); if(n.getLeft()!=null)&#123; (firstQueue ? queue2 : queue).add(n.getLeft()); &#125; if(n.getRight()!=null)&#123; (firstQueue ? queue2 : queue).add(n.getRight()); &#125; &#125;else&#123; System.out.println(); firstQueue = !firstQueue; &#125; &#125; &#125; public static void main(String[] args) &#123; RBTree&lt;String&gt; bst = new RBTree&lt;String&gt;(); bst.addNode(\"d\"); bst.addNode(\"d\"); bst.addNode(\"c\"); bst.addNode(\"c\"); bst.addNode(\"b\"); bst.addNode(\"f\"); bst.addNode(\"a\"); bst.addNode(\"e\"); bst.addNode(\"g\"); bst.addNode(\"h\"); bst.remove(\"c\"); bst.printTree(bst.getRoot()); &#125;&#125; 代码调试的时候，printTree输出格式如下:d(B)b(B d LE) g(R d RI)a(R b LE) e(B g LE) h(B g RI)f(R e RI) 括号左边表示元素的内容。括号内的第一个元素表示颜色，B表示black，R表示red；第二个元素表示父元素的值；第三个元素表示左右，LE表示在父元素的左边。RI表示在父元素的右边。 第一个元素d是root节点，由于它没有父节点，所以括号内只有一个元素。 总结作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。作为平衡二叉查找树，旋转是一个必不可少的操作。通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。 红黑树里面的插入和删除的操作比较难理解，这时要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的。在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。 整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。 参考 面试旧敌之红黑树（直白介绍深入理解） 红黑树详细分析，看了都说好 红黑树深入剖析及Java实现","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"平衡二叉树的基本介绍与Java实现","date":"2020-05-05T16:13:17.000Z","path":"2020/05/06/平衡二叉树的基本介绍与Java实现/","text":"基本介绍 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树，可以保证查询效率较高。 具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 举例说明,看看下面哪些 AVL 树,为什么? 单旋转左旋转 要求: 给你一个数列， 创建出对应的平衡二叉树.数列 {4, 3, 6, 5, 7, 8} 思路分析(示意图) 代码实现1234567891011121314151617/** * 左旋转 */private void leftRotate() &#123; // 创建新的结点， 以当前根结点的值 Node newNode = new Node(value); // 把新的结点的左子树设置成当前结点的左子树 newNode.left = left; // 把新的结点的右子树设置成带你过去结点的右子树的左子树 newNode.right = right.left; // 把当前结点的值替换成右子结点的值 value = right.value; // 把当前结点的右子树设置成当前结点右子树的右子树 right = right.right; // 把当前结点的左子树(左子结点)设置成新的结点 left = newNode;&#125; 右旋转 要求: 给你一个数列， 创建出对应的平衡二叉树.数列 {10, 12, 8, 9, 7, 6} 思路分析(示意图) 代码实现1234567891011/** * 右旋转 */private void rightRotate() &#123; Node newNode = new Node(value); newNode.right = right; newNode.left = left.right; value = left.value; left = left.left; right = newNode;&#125; 双旋转前面的两个数列， 进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下， 单旋转不能完成平衡二叉树的转换。 比如数列 int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到， 并没有转成 AVL 树. int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到， 并没有转成 AVL 树 问题分析 解决思路分析 当符合右旋转的条件时 如果它的左子树的右子树高度大于它的左子树的高度 先对当前这个结点的左子树进行左旋转 在对当前结点进行右旋转的操作即可 代码实现[AVL 树的汇总代码(完整代码)] 结点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203package com.zjinc36.tree.avltree;/** * 二叉排序树结点 */class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Node [value=\" + value + \"]\"; &#125;///////////////////////////////////////////////////////////////////////////////////旋转/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 左旋转 */ private void leftRotate() &#123; // 创建新的结点， 以当前根结点的值 Node newNode = new Node(value); // 把新的结点的左子树设置成当前结点的左子树 newNode.left = left; // 把新的结点的右子树设置成带你过去结点的右子树的左子树 newNode.right = right.left; // 把当前结点的值替换成右子结点的值 value = right.value; // 把当前结点的右子树设置成当前结点右子树的右子树 right = right.right; // 把当前结点的左子树(左子结点)设置成新的结点 left = newNode; &#125; /** * 右旋转 */ private void rightRotate() &#123; Node newNode = new Node(value); newNode.right = right; newNode.left = left.right; value = left.value; left = left.left; right = newNode; &#125; /** * 返回左子树的高度 */ public int leftHeight() &#123; if (left == null) &#123; return 0; &#125; return left.height(); &#125; /** * 返回右子树的高度 */ public int rightHeight() &#123; if (right == null) &#123; return 0; &#125; return right.height(); &#125; /** * 返回以该结点为根结点的树的高度 */ public int height() &#123; return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; &#125;///////////////////////////////////////////////////////////////////////////////////删除结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 查找要删除的结点 * @param value 希望删除的结点的值 * @return 如果找到则返回该结点,否则返回null */ public Node search(int value) &#123; if (value == this.value) &#123; // 找到该结点 return this; &#125; else if (value &lt; this.value) &#123; // 如果查找的值小于当前结点,则向左子树递归查找 // 如果左子结点为空 if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; // 如果查找的值不小于当前结点,向右子树递归查找 if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; /** * 查找要删除结点的父结点 * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点,如果没有就返回null */ public Node searchParent(int value) &#123; // 如果当前结点就是要删除的结点的父结点,就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; // 如果查找的值小于当前结点,并且当前结点的左子结点不为空 if (value &lt; this.value &amp;&amp; this.left != null) &#123; return this.left.searchParent(value); // 向左子树递归查找 &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; return this.right.searchParent(value); // 向右子树递归查找 &#125; else &#123; return null; //没有找到父结点 &#125; &#125; &#125;///////////////////////////////////////////////////////////////////////////////////添加结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 添加结点方法 递归的形式添加结点,注意需要满足二叉排序树的要求 * * @param node 要添加的结点 */ public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断传入结点的值和当前子树的根结点的值的关系 if (node.value &lt; this.value) &#123; // 如果当前结点左子树结点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的结点的值大于当前结点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归向右子树添加 this.right.add(node); &#125; &#125; /////////////////////////////////////////////// ///旋转//////////////////////////////////////// ////////////////////////////////////////////// // 当添加完一个结点后， 如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转 if (rightHeight() - leftHeight() &gt; 1) &#123; // 如果它的右子树的左子树的高度大于它的右子树的右子树的高度 if (right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123; // 先对右子结点进行右旋转 right.rightRotate(); // 然后在对当前结点进行左旋转 leftRotate(); // 左旋转.. &#125; else &#123; // 直接进行左旋转即可 leftRotate(); &#125; return; // 必须要!!! &#125; // 当添加完一个结点后， 如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转 if (leftHeight() - rightHeight() &gt; 1) &#123; // 如果它的左子树的右子树高度大于它的左子树的高度 if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123; // 先对当前结点的左结点(左子树)-&gt;左旋转 left.leftRotate(); // 再对当前结点进行右旋转 rightRotate(); &#125; else &#123; // 直接进行右旋转即可 rightRotate(); &#125; &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125;&#125; AVLTree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.zjinc36.tree.avltree;/** * 二叉排序树 */public class AVLTree &#123; private Node root; public Node getRoot() &#123; return root; &#125;///////////////////////////////////////////////////////////////////////////////////添加结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 添加结点的方法 * @param node 要添加的结点 */ public void add(Node node) &#123; if (root == null) &#123; root = node; // 如果root为空则直接让root指向node &#125; else &#123; root.add(node); &#125; &#125;///////////////////////////////////////////////////////////////////////////////////删除结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 查找要删除的结点 */ public Node search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; /** * 查找父结点 * @param value * @return */ public Node searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; /** * 1. 返回的以node为根结点的二叉排序树的最小结点的值 * 2. 删除node为根结点的二叉排序树的最小结点 * @param node 传入的结点(当作二叉排序树的根结点) * @return 返回以node为根结点的二叉排序树的最小结点的值 */ /** * 删除结点 * @param value */ public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; // 1. 需求先去找到要删除的结点 targetNode Node targetNode = search(value); // 如果没有找到要删除的结点 if (targetNode == null) &#123; return; &#125; // 如果当我们发现当前这棵二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; // 2. 去找 targetNode 的父结点 Node parent = searchParent(value); // 3. 判断要删除的结点的类型 // ==&gt; 3.1 要删除的结点有0棵子树(即叶子结点) // ==&gt; ==&gt; 基本思路:找到targetNode,删除 if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; // 判断 targetNode 是父结点的左子结点还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) &#123; // 是左子结点 parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; // 是右子结点 parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode != null) &#123; // ==&gt; 3.2 要删除的结点有2棵子树 // ==&gt; ==&gt; 基本思路:targetNode要删除,删除后用targetNode的右子树的最小值进行填充 Node target = targetNode.right; // 循环查找左子结点,就会找到最小值 while (target.left != null) &#123; target = target.left; &#125; // 这时target就指向了最小结点 // 删除这个最小结点 delNode(target.value); targetNode.value = target.value; &#125; else &#123; // ==&gt; 3.3 要删除的结点有1棵子树 // ==&gt; ==&gt; 基本思路:因为只有一棵子树,所以用子树填充删除的结点的位置 if (targetNode.left != null) &#123; // 如果要删除的结点有左子结点 if (parent != null) &#123; // 如果 targetNode 是parent的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是 parent 的右子结点 parent.right = targetNode.left; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; // 如果删除的结点有右子结点 if (parent != null) &#123; // 如果 targetNode 是 parent 的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; // 如果targetNode是parent右子结点 parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println(\"二叉排序树为空,不能遍历\"); &#125; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930313233package com.zjinc36.tree.avltree;import org.junit.Before;import org.junit.Test;public class AVLTreeTest &#123; @Before public void setUp() throws Exception &#123; &#125; @Test public void test() &#123; // int[] arr = &#123;4,3,6,5,7,8&#125;; // int[] arr = &#123; 10, 12, 8, 9, 7, 6 &#125;; int[] arr = &#123; 10, 11, 7, 6, 8, 9 &#125;; // 创建一个 AVLTree 对象 AVLTree avlTree = new AVLTree(); // 添加结点 for (int i = 0; i &lt; arr.length; i++) &#123; avlTree.add(new Node(arr[i])); &#125; // 遍历 System.out.println(\"中序遍历\"); avlTree.infixOrder(); System.out.println(\"在平衡处理~~\"); System.out.println(\"树的高度=\" + avlTree.getRoot().height()); // 3 System.out.println(\"树的左子树高度=\" + avlTree.getRoot().leftHeight()); // 2 System.out.println(\"树的右子树高度=\" + avlTree.getRoot().rightHeight()); // 2 System.out.println(\"当前的根结点=\" + avlTree.getRoot());// 8 &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"二叉排序树的基本介绍与Java实现","date":"2020-05-05T08:33:12.000Z","path":"2020/05/05/二叉排序树的基本介绍与Java实现/","text":"先看一个需求需求给你一个数列 (7, 3, 10, 12, 5, 1, 9)， 要求能够高效的完成对数据的查询和添加 解决方案分析 使用数组数组未排序， 优点： 直接在数组尾添加， 速度快。 缺点： 查找速度慢.数组排序， 优点： 可以使用二分查找， 查找速度快， 缺点： 为了保证数组有序， 在添加新数据时， 找到插入位置后， 后面的数据需整体移动， 速度慢。 使用链式存储-链表不管链表是否有序， 查找速度都慢， 添加数据速度比数组快， 不需要数据整体移动。 使用二叉排序树 二叉排序树介绍 二叉排序树： BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点， 要求左子节点的值比当前节点的值小， 右子节点的值比当前节点的值大。 特别说明： 如果有相同的值， 可以将该节点放在左子节点或右子节点 比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ， 对应的二叉排序树为： 二叉排序树创建和遍历一个数组创建成对应的二叉排序树， 并使用中序遍历二叉排序树， 比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创建成对应的二叉排序树为: 代码实现创建结点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.zjinc36.tree.binarysorttree;/** * 二叉排序树结点 */class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Node [value=\" + value + \"]\"; &#125; /** * 添加结点方法 递归的形式添加结点,注意需要满足二叉排序树的要求 * * @param node 要添加的结点 */ public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断传入结点的值和当前子树的根结点的值的关系 if (node.value &lt; this.value) &#123; // 如果当前结点左子树结点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的结点的值大于当前结点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归向右子树添加 this.right.add(node); &#125; &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125;&#125; 二叉排序树–创建和遍历12345678910111213141516171819202122232425262728293031package com.zjinc36.tree.binarysorttree;/** * 二叉排序树 */public class BinarySortTree &#123; private Node root; /** * 添加结点的方法 * @param node 要添加的结点 */ public void add(Node node) &#123; if (root == null) &#123; root = node; // 如果root为空则直接让root指向node &#125; else &#123; root.add(node); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println(\"二叉排序树为空,不能遍历\"); &#125; &#125;&#125; 测试123456789101112131415161718192021222324252627package com.zjinc36.tree.binarysorttree;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;public class BinarySortTreeTest &#123; @Before public void setUp() throws Exception &#123; &#125; @Test public void test() &#123; int[] arr = &#123;7, 3, 10, 12, 5, 1, 9&#125;; BinarySortTree binarySortTree = new BinarySortTree(); // 循环添加结点到二叉树 for (int i = 0; i &lt; arr.length; i++) &#123; binarySortTree.add(new Node(arr[i])); &#125; // 中序遍历二叉排序树 System.out.println(\"中序遍历二叉排序树\"); binarySortTree.infixOrder(); // 1,3,5,7,9,10,12 &#125;&#125; 二叉排序树的删除操作的思路分析分三种情况考虑 要删除结点的子结点有0棵子树(即叶子结点)(比如： 2, 5, 9, 12) 要删除结点的子结点有1棵子树(比如： 1) 要删除结点的子结点有2棵子树(比如： 7, 3， 10 ) 对删除结点的各种情况思路分析 要删除结点的子结点有0棵子树(即叶子结点)(比如： 2, 5, 9, 12) 需求先去找到要删除的结点 targetNode 找到 targetNode 的 父结点 parent 确定 targetNode 是 parent 的左子结点还是右子结点 根据前面的情况来对应删除12==&gt; 左子结点 parent.left = null==&gt; 右子结点 parent.right = null 删除只有一颗子树的节点 比如 1 需求先去找到要删除的结点 targetNode 找到 targetNode 的 父结点 parent 确定 targetNode 的子结点是左子结点还是右子结点 targetNode 是 parent 的左子结点还是右子结点 如果 targetNode 有左子结点 1234==&gt; 5. 1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.left;==&gt; 5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left; 如果 targetNode 有右子结点 1234==&gt; 6.1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.right;==&gt; 6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right 删除有两颗子树的节点. (比如： 7, 3， 10 ) 需求先去找到要删除的结点 targetNode 找到 targetNode 的 父结点 parent 从 targetNode 的右子树找到最小的结点(也可以是左子树找最大的结点) 用一个临时变量， 将最小结点的值保存 temp = 11 删除该最小结点 targetNode.value = temp 小结 要删除的节点正好是叶子节点，直接删除就 OK 了； 只有左孩子或者右孩子，直接把这个孩子上移放到要删除的位置就好了； 有两个孩子，就需要选一个合适的孩子节点作为新的根节点，该节点称为 继承节点。 代码实现结点–添加删除结点需要的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.zjinc36.tree.binarysorttree;/** * 二叉排序树结点 */class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Node [value=\" + value + \"]\"; &#125;///////////////////////////////////////////////////////////////////////////////////删除结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 查找要删除的结点 * @param value 希望删除的结点的值 * @return 如果找到则返回该结点,否则返回null */ public Node search(int value) &#123; if (value == this.value) &#123; // 找到该结点 return this; &#125; else if (value &lt; this.value) &#123; // 如果查找的值小于当前结点,则向左子树递归查找 // 如果左子结点为空 if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; // 如果查找的值不小于当前结点,向右子树递归查找 if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; /** * 查找要删除结点的父结点 * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点,如果没有就返回null */ public Node searchParent(int value) &#123; // 如果当前结点就是要删除的结点的父结点,就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; // 如果查找的值小于当前结点,并且当前结点的左子结点不为空 if (value &lt; this.value &amp;&amp; this.left != null) &#123; return this.left.searchParent(value); // 向左子树递归查找 &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; return this.right.searchParent(value); // 向右子树递归查找 &#125; else &#123; return null; //没有找到父结点 &#125; &#125; &#125;///////////////////////////////////////////////////////////////////////////////////添加结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 添加结点方法 递归的形式添加结点,注意需要满足二叉排序树的要求 * * @param node 要添加的结点 */ public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断传入结点的值和当前子树的根结点的值的关系 if (node.value &lt; this.value) &#123; // 如果当前结点左子树结点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的结点的值大于当前结点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归向右子树添加 this.right.add(node); &#125; &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125;&#125; 二叉排序树–添加删除方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.zjinc36.tree.binarysorttree;/** * 二叉排序树 */public class BinarySortTree &#123; private Node root;///////////////////////////////////////////////////////////////////////////////////添加结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 添加结点的方法 * @param node 要添加的结点 */ public void add(Node node) &#123; if (root == null) &#123; root = node; // 如果root为空则直接让root指向node &#125; else &#123; root.add(node); &#125; &#125;///////////////////////////////////////////////////////////////////////////////////删除结点//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 查找要删除的结点 */ public Node search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; /** * 查找父结点 * @param value * @return */ public Node searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; /** * 1. 返回的以node为根结点的二叉排序树的最小结点的值 * 2. 删除node为根结点的二叉排序树的最小结点 * @param node 传入的结点(当作二叉排序树的根结点) * @return 返回以node为根结点的二叉排序树的最小结点的值 */ /** * 删除结点 * @param value */ public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; // 1. 需求先去找到要删除的结点 targetNode Node targetNode = search(value); // 如果没有找到要删除的结点 if (targetNode == null) &#123; return; &#125; // 如果当我们发现当前这棵二叉排序树只有一个结点 if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; // 2. 去找 targetNode 的父结点 Node parent = searchParent(value); // 3. 判断要删除的结点的类型 // ==&gt; 3.1 要删除的结点有0棵子树(即叶子结点) // ==&gt; ==&gt; 基本思路:找到targetNode,删除 if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; // 判断 targetNode 是父结点的左子结点还是右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) &#123; // 是左子结点 parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; // 是右子结点 parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode != null) &#123; // ==&gt; 3.2 要删除的结点有2棵子树 // ==&gt; ==&gt; 基本思路:targetNode要删除,删除后用targetNode的右子树的最小值进行填充 Node target = targetNode.right; // 循环查找左子结点,就会找到最小值 while (target.left != null) &#123; target = target.left; &#125; // 这时target就指向了最小结点 // 删除这个最小结点 delNode(target.value); targetNode.value = target.value; &#125; else &#123; // ==&gt; 3.3 要删除的结点有1棵子树 // ==&gt; ==&gt; 基本思路:因为只有一棵子树,所以用子树填充删除的结点的位置 if (targetNode.left != null) &#123; // 如果要删除的结点有左子结点 if (parent != null) &#123; // 如果 targetNode 是parent的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是 parent 的右子结点 parent.right = targetNode.left; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; // 如果删除的结点有右子结点 if (parent != null) &#123; // 如果 targetNode 是 parent 的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; // 如果targetNode是parent右子结点 parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println(\"二叉排序树为空,不能遍历\"); &#125; &#125;&#125; 测试123456789101112131415161718192021222324252627282930313233package com.zjinc36.tree.binarysorttree;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;public class BinarySortTreeTest &#123; @Before public void setUp() throws Exception &#123; &#125; @Test public void test() &#123; int[] arr = &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;; BinarySortTree binarySortTree = new BinarySortTree(); // 循环添加结点到二叉树 for (int i = 0; i &lt; arr.length; i++) &#123; binarySortTree.add(new Node(arr[i])); &#125; // 中序遍历二叉排序树 System.out.println(\"中序遍历二叉排序树\"); binarySortTree.infixOrder(); // 1,3,5,7,9,10,12 // 测试一下删除结点// binarySortTree.delNode(2); binarySortTree.delNode(10); System.out.println(\"删除结点后\"); binarySortTree.infixOrder(); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"赫夫曼编码与解码","date":"2020-05-04T22:52:31.000Z","path":"2020/05/05/赫夫曼编码/","text":"基本介绍 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)， 又称霍夫曼编码， 是一种编码方式, 属于一种程序算法 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 赫夫曼编码广泛地用于数据文件压缩。 其压缩率通常在 20%～90%之间 赫夫曼码是可变字长编码(VLC)的一种。 Huffman 于 1952 年提出一种编码方法， 称之为最佳编码 通信领域中信息的处理方式1-定长编码说明 缺点没有进行压缩 2-变长编码说明 缺点 前缀编码：设计长短不等的编码，必须是任一字符的编码都不是另一个字符编码的前缀，这种编码称为前缀编码 变长编码的编码长短不等,却无法保证任一字符的编码都不是另一个字符编码的前缀,也就是说变长编码不是前缀编码,这就会导致我们使用码表翻译编码时,并不能翻译出唯一结果的字符 3-赫夫曼编码说明 传输的字符串:i like like like java do you like a java d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值12345构成赫夫曼树的步骤：1) 从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树2) 取出根节点权值最小的两颗二叉树3) 组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和4) 再将这颗新的二叉树，以根节点的权值大小 再次排序，不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 根据赫夫曼树， 给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码如下: 123o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001l: 001 (空格): 01 按照上面的赫夫曼编码， 我们的”i like like like java do you like a java” 字符串对应的编码为 (注意这里我们使用的无损压缩) 12// 通过赫夫曼编码处理 长度为 1331010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 长度为：133 原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% 此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 赫夫曼编码是无损处理方案 注意事项注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是 wpl 是一样的，都是最小的,后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为: 数据压缩(编码)代码实现(利用赫夫曼树) 结点 123456789101112131415161718192021222324252627282930313233343536373839404142package com.zjinc36.tree.huffmancode;/** * 创建结点类 * =&gt; 为了让 Node 对象持续排序 Collections 集合排序 * =&gt; 让 Node 实现 Comparable 接口 */public class Node implements Comparable&lt;Node&gt; &#123; Byte data; // 存放数据 int weight; // 结点权值,表示字符出现的次数 Node left; // 指向左子结点 Node right; // 指向右子结点 public Node(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; /** * 前序遍历自身的子树 */ public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; @Override public String toString() &#123; return \"Node [data = \" + data + \" weight=\" + weight + \"]\"; &#125; @Override public int compareTo(Node o) &#123; // 表示从小到大排序 return this.weight - o.weight; &#125;&#125; 赫夫曼编码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217package com.zjinc36.tree.huffmancode;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 我们已经生成了 赫夫曼树, 下面我们继续完成任务 * 1) 生成赫夫曼树对应的赫夫曼编码 , 如下表: * =01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011 * 2) 使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码， 将\"i like like like java do you like a java\" * 字符串生成对应的编码数据, 形式如下. * 10101000101111111100100010111111110010001011111111001001010011011100011100000110111010001111001010 * 00101111111100110001001010011011100 */public class HuffmanCode &#123; /** * 测试 * @param args */ public static void main(String[] args) &#123; String content = \"i like like like java do you like a java\"; // 将所有字符转成ASCII码 byte[] contentBytes = content.getBytes(); for (byte b : contentBytes) &#123; System.out.print(b + \" \"); &#125; System.out.println(); System.out.println(\"=========================\"); System.out.println(contentBytes.length); // 40 byte[] System.out.println(\"=========================\"); // contentBytes里保存的ASCII码如下 // 105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 // 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 byte[] huffmanCodesBytes = huffmanZip(contentBytes); System.out.println(\"压缩后的结果是:\" + Arrays.toString(huffmanCodesBytes)); System.out.println(\"压缩后的长度是:\" + huffmanCodesBytes.length); &#125; /** * 赫夫曼压缩 * =&gt; 将分步骤的所有方法封装起来，便于我们的调用. * @param bytes 原始的字符串对应的字节数组 * @return 是经过赫夫曼编码处理后的字节数组(压缩后的数组) */ private static byte[] huffmanZip(byte[] bytes) &#123; List&lt;Node&gt; nodes = getNodes(bytes); // 根据 nodes (里面所有的数字)创建的赫夫曼树 Node huffmanTreeRoot = createHuffmanTree(nodes); // 对应的赫夫曼编码(根据赫夫曼树) Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); // 根据生成的赫夫曼编码， 压缩得到压缩后的赫夫曼编码字节数组 byte[] huffmanCodeBytes = zip(bytes, huffmanCodes); return huffmanCodeBytes; &#125; /** * 四.将经过赫夫曼树编码过后的编码,按每8位一分割变成一个字符数组 * 举例： * =&gt; String content = \"i like like like java do you like a java\"; ==&gt; byte[] contentBytes = content.getBytes(); * =&gt; 返回的是字符串 \"1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000 * 101111111100110001001010011011100\" * =&gt; 对应的 byte[] huffmanCodeBytes,即 8 位对应一个 byte,放入到 huffmanCodeBytes huffmanCodeBytes[0] = * 10101000(补码) * =&gt; byte huffmanCodeBytes[1] = -88 * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码 map * @return 返回赫夫曼编码处理后的 byte[] */ private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; // 利用 huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); // 遍历 bytes 数组 for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; System.out.println(\"测试 stringBuilder~~~=\" + stringBuilder.toString()); // 将 \"1010100010111111110...\" 转成 byte[] // 统计返回 byte[] huffmanCodeBytes 长度// int len;// if (stringBuilder.length() % 8 == 0) &#123;// len = stringBuilder.length() / 8;// &#125; else &#123;// len = stringBuilder.length() / 8 + 1;// &#125; int len = (stringBuilder.length() + 7) / 8; // 创建 存储压缩后的 byte 数组 byte[] huffmanCodeBytes = new byte[len]; // 记录是第几个 byte int index = 0; // 因为是每 8 位对应一个byte,所以步长 +8 for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; if (i + 8 &gt; stringBuilder.length()) &#123; // 不够 8 位 strByte = stringBuilder.substring(i); &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); &#125; // 将 strByte 转成一个 byte,放入到 huffmanCodeBytes // 用二进制进行解析 // 推导 10101000(补码) =&gt; 10101000(补码) - 1 =&gt; 10100111(反码) =&gt; 11011000(原码) = -88(十进制) huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; return huffmanCodeBytes; &#125; /** * 三.为了调用方便，我们重载 getCodes * @param root * @return */ private static Map&lt;Byte, String&gt; getCodes(Node root) &#123; if (root == null) &#123; return null; &#125; // 处理 root 的左子树 getCodes(root.left, \"0\", new StringBuilder()); // 处理 root 的右子树 getCodes(root.right, \"1\", new StringBuilder()); return huffmanCodes; &#125; /** * 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式 * 生成的赫夫曼编码表 &#123;32=01, 97=100, 100=11000, 117=11001, 101=1110,118=11011, 105=101,121=11010,106=0010,107=1111,108=000,111=0011&#125; */ static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); /** * 三.将传入的 node 结点的所有叶子结点的赫夫曼编码得到，并放入到 huffmanCodes 集合 * * @param node 传入结点 * @param code 路径： 左子结点是 0, 右子结点 1 * @param stringBuilder 用于拼接路径 */ private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123; StringBuilder sb = new StringBuilder(stringBuilder); sb.append(code); if (node != null) &#123; // 判断当前结点是否是叶子结点 // 如果不是叶子结点,则说明该结点有左右子结点 if (node.data == null) &#123; // 非叶子结点 // 向左递归 getCodes(node.left, \"0\", sb); // 向右递归 getCodes(node.right, \"1\", sb); &#125; else &#123; // 是叶子结点 // 说明不需要继续递归 // 只需要将当前的递归得到的sb值保存就行 huffmanCodes.put(node.data, sb.toString()); &#125; &#125; &#125; /** * 二.创建赫夫曼树 =&gt; 可以通过 List 创建对应的赫夫曼树 * * @param nodes * @return */ private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; // 排序, 从小到大 Collections.sort(nodes); // 取出第一颗最小的二叉树 Node leftNode = nodes.get(0); // 取出第二颗最小的二叉树 Node rightNode = nodes.get(1); // 创建一颗新的二叉树,它的根节点 没有 data, 只有权值 Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; // 将已经处理的两颗二叉树从 nodes 删除 nodes.remove(leftNode); nodes.remove(rightNode); // 将新的二叉树， 加入到 nodes nodes.add(parent); &#125; // nodes 最后的结点， 就是赫夫曼树的根结点 return nodes.get(0); &#125; /** * 一.将字符串的每个字符转成对应的ASCII码数组,并记录获取权重 * 105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 * 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 * 变成如下形式 * [Node[date = 97 ,weight = 5], Node[date = 32,weight = 9]......] * @param bytes 接受字节数组 * @return 返回的就是List形式 [Node[date = 97 ,weight = 5], Node[date = 32,weight = 9]......] */ private static List&lt;Node&gt; getNodes(byte[] bytes) &#123; // 1 创建一个 ArrayList ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); // 遍历 bytes , 统计 每一个 byte 出现的次数-&gt;map[key,value] Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; Integer count = counts.get(b); if (count == null) &#123; // Map 还没有这个字符数据,第一次 counts.put(b, 1); &#125; else &#123; counts.put(b, count + 1); &#125; &#125; // 把每一个键值对转成一个 Node 对象， 并加入到 nodes 集合 // 遍历 map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; return nodes; &#125;&#125; 赫夫曼解压缩(解码)代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320package com.zjinc36.tree.huffmancode;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 我们已经生成了 赫夫曼树, 下面我们继续完成任务 * 1) 生成赫夫曼树对应的赫夫曼编码 , 如下表: * =01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011 * 2) 使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码， 将\"i like like like java do you like a java\" * 字符串生成对应的编码数据, 形式如下. * 10101000101111111100100010111111110010001011111111001001010011011100011100000110111010001111001010 * 00101111111100110001001010011011100 */public class HuffmanCode &#123; /** * 测试 * @param args */ public static void main(String[] args) &#123; String content = \"i like like like java do you like a java\"; // 将所有字符转成ASCII码 byte[] contentBytes = content.getBytes(); for (byte b : contentBytes) &#123; System.out.print(b + \" \"); &#125; System.out.println(); System.out.println(\"=========================\"); System.out.println(contentBytes.length); // 40 byte[] System.out.println(\"=========================\"); // contentBytes里保存的ASCII码如下 // 105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 // 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 byte[] huffmanCodesBytes = huffmanZip(contentBytes); System.out.println(\"压缩后的结果是:\" + Arrays.toString(huffmanCodesBytes)); System.out.println(\"压缩后的长度是:\" + huffmanCodesBytes.length); System.out.println(\"=======================\"); byte[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes); System.out.println(\"原来的字符串=\" + new String(sourceBytes)); &#125;////////////////////////////////////////////////////////////////////////////////////////////////赫夫曼解压缩//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 赫夫曼解压缩 * @param huffmanCodes 赫夫曼编码表 * @param huffmanBytes 字符串对应的byte数组信息 * @return */ private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123; // 1. 先得到 huffmanBytes 对应的二进制的字符串 ， 形式 1010100010111... StringBuilder stringBuilder = new StringBuilder(); // 将 byte 数组转成二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) &#123; byte b = huffmanBytes[i]; // 判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, b)); &#125; // System.out.println(stringBuilder.toString()); // 把字符串按照指定的赫夫曼编码进行 // 对赫夫曼编码表进行反向(和编码相反)，因为反向查询a-&gt;100 100-&gt;a Map&lt;String, Byte&gt; map = new HashMap&lt;String, Byte&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123; map.put(entry.getValue(), entry.getKey()); &#125; // 创建集合,用以存放byte List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); // i 可以理解成就是索引,扫描stringBuilder for (int i = 0; i &lt; stringBuilder.length(); ) &#123; int count = 1; //小的计数器 boolean flag = true; Byte b = null; while (flag) &#123; // 递增的取出key String key = stringBuilder.substring(i, i + count); // i不动,让count移动,指定匹配到一个字符 b = map.get(key); if (b == null) &#123; // 说明没有匹配到 count++; &#125; else &#123; // 匹配到 flag = false; &#125; &#125; list.add(b); i += count; //i 直接移动到count &#125; // 当for循环结束后,我们list中就存放了所有字符\"i like like like java do you like a java\" // 把list中的数据放入到byte[] 并返回 byte b[] = new byte[list.size()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i]= list.get(i); &#125; return b; &#125; /** * 将一个 byte 转成一个8位二进制的字符串 * @param b 传入的 byte * @param flag 标志是否需要补高位如果是 true，表示需要补高位，如果是 false 表示不补, 如果是最后一个字节， 无需补高位 * 为什么需要补高位? * =&gt; 因为我们是8位二进制进行编码,那么我们解码解出来也需要是8位的二进制数 * =&gt; 但是Integer.toBinaryString(temp),如果是高位全部是0的话就不会输出 * =&gt; 比如 10 这个数,通过Integer.toBinaryString(10)获取二进制码,只会显示 1010 * =&gt; =&gt; 所以正数需要补高位 * =&gt; =&gt; 负数不需要补高位,因为负数的符号位是1,所以不会被省略 * =&gt; =&gt; 最后一个字节， 无需补高位,因为最后一个字节本身就可能无法满足8位 * @return 是该 b 对应的二进制的字符串（注意是按补码返回） */ private static String byteToBitString(boolean flag, byte b) &#123;// int a= 10;// for (int i=0; i &lt; 32; i++) &#123; // 整数有32位,所以要做32次循环// // 0x80000000 表示最高位为1的数字// int t = (a &amp; 0x80000000 &gt;&gt;&gt; i) &gt;&gt;&gt; (31 - i);// System.out.print(t);// &#125;// // 使用变量保存b int temp = b; // 将b转成int if (flag) &#123; temp |= 256; //按位或256 : 1 0000 0000 | 0000 0001 =&gt; 1 0000 0001 &#125; String str = Integer.toBinaryString(temp); // 返回的是temp对应的二进制的补码 if (flag) &#123; return str.substring(str.length() - 8); &#125; else &#123; return str; &#125; &#125; ////////////////////////////////////////////////////////////////////////////////////////////////赫夫曼压缩////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// /** * 赫夫曼压缩 * =&gt; 将分步骤的所有方法封装起来，便于我们的调用. * @param bytes 原始的字符串对应的字节数组 * @return 是经过赫夫曼编码处理后的字节数组(压缩后的数组) */ private static byte[] huffmanZip(byte[] bytes) &#123; List&lt;Node&gt; nodes = getNodes(bytes); // 根据 nodes (里面所有的数字)创建的赫夫曼树 Node huffmanTreeRoot = createHuffmanTree(nodes); // 对应的赫夫曼编码(根据赫夫曼树) Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); // 根据生成的赫夫曼编码， 压缩得到压缩后的赫夫曼编码字节数组 byte[] huffmanCodeBytes = zip(bytes, huffmanCodes); return huffmanCodeBytes; &#125; /** * 将经过赫夫曼树编码过后的编码,按每8位一分割变成一个字符数组 * 举例： * =&gt; String content = \"i like like like java do you like a java\"; ==&gt; byte[] contentBytes = content.getBytes(); * =&gt; 返回的是字符串 \"1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000 * 101111111100110001001010011011100\" * =&gt; 对应的 byte[] huffmanCodeBytes,即 8 位对应一个 byte,放入到 huffmanCodeBytes huffmanCodeBytes[0] = * 10101000(补码) * =&gt; byte huffmanCodeBytes[1] = -88 * @param bytes 这时原始的字符串对应的 byte[] * @param huffmanCodes 生成的赫夫曼编码 map * @return 返回赫夫曼编码处理后的 byte[] */ private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; // 利用 huffmanCodes 将 bytes 转成 赫夫曼编码对应的字符串 StringBuilder stringBuilder = new StringBuilder(); // 遍历 bytes 数组 for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; System.out.println(\"测试 stringBuilder~~~=\" + stringBuilder.toString()); // 将 \"1010100010111111110...\" 转成 byte[] // 统计返回 byte[] huffmanCodeBytes 长度// int len;// if (stringBuilder.length() % 8 == 0) &#123;// len = stringBuilder.length() / 8;// &#125; else &#123;// len = stringBuilder.length() / 8 + 1;// &#125; int len = (stringBuilder.length() + 7) / 8; // 创建 存储压缩后的 byte 数组 byte[] huffmanCodeBytes = new byte[len]; // 记录是第几个 byte int index = 0; // 因为是每 8 位对应一个byte,所以步长 +8 for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; if (i + 8 &gt; stringBuilder.length()) &#123; // 不够 8 位 strByte = stringBuilder.substring(i); &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); &#125; // 将 strByte 转成一个 byte,放入到 huffmanCodeBytes // 用二进制进行解析 // 推导 10101000(补码) =&gt; 10101000(补码) - 1 =&gt; 10100111(反码) =&gt; 11011000(原码) = -88(十进制) huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; return huffmanCodeBytes; &#125; /** * 为了调用方便，我们重载 getCodes * @param root * @return */ private static Map&lt;Byte, String&gt; getCodes(Node root) &#123; if (root == null) &#123; return null; &#125; // 处理 root 的左子树 getCodes(root.left, \"0\", new StringBuilder()); // 处理 root 的右子树 getCodes(root.right, \"1\", new StringBuilder()); return huffmanCodes; &#125; /** * 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式 * 生成的赫夫曼编码表 &#123;32=01, 97=100, 100=11000, 117=11001, 101=1110,118=11011, 105=101,121=11010,106=0010,107=1111,108=000,111=0011&#125; */ static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); /** * 功能： 将传入的 node 结点的所有叶子结点的赫夫曼编码得到， 并放入到 huffmanCodes 集合 * * @param node 传入结点 * @param code 路径： 左子结点是 0, 右子结点 1 * @param stringBuilder 用于拼接路径 */ private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123; StringBuilder sb = new StringBuilder(stringBuilder); sb.append(code); if (node != null) &#123; // 判断当前结点是否是叶子结点 // 如果不是叶子结点,则说明该结点有左右子结点 if (node.data == null) &#123; // 非叶子结点 // 向左递归 getCodes(node.left, \"0\", sb); // 向右递归 getCodes(node.right, \"1\", sb); &#125; else &#123; // 是叶子结点 // 说明不需要继续递归 // 只需要将当前的递归得到的sb值保存就行 huffmanCodes.put(node.data, sb.toString()); &#125; &#125; &#125; /** * 将字符串对应的字符数组 * 105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 * 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 * 变成如下形式 * [Node[date = 97 ,weight = 5], Node[date = 32,weight = 9]......] * @param bytes 接受字节数组 * @return 返回的就是List形式 [Node[date = 97 ,weight = 5], Node[date = 32,weight = 9]......] */ private static List&lt;Node&gt; getNodes(byte[] bytes) &#123; // 1 创建一个 ArrayList ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); // 遍历 bytes , 统计 每一个 byte 出现的次数-&gt;map[key,value] Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; Integer count = counts.get(b); if (count == null) &#123; // Map 还没有这个字符数据,第一次 counts.put(b, 1); &#125; else &#123; counts.put(b, count + 1); &#125; &#125; // 把每一个键值对转成一个 Node 对象， 并加入到 nodes 集合 // 遍历 map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; return nodes; &#125; /** * 创建赫夫曼树 =&gt; 可以通过 List 创建对应的赫夫曼树 * * @param nodes * @return */ private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; // 排序, 从小到大 Collections.sort(nodes); // 取出第一颗最小的二叉树 Node leftNode = nodes.get(0); // 取出第二颗最小的二叉树 Node rightNode = nodes.get(1); // 创建一颗新的二叉树,它的根节点 没有 data, 只有权值 Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; // 将已经处理的两颗二叉树从 nodes 删除 nodes.remove(leftNode); nodes.remove(rightNode); // 将新的二叉树， 加入到 nodes nodes.add(parent); &#125; // nodes 最后的结点， 就是赫夫曼树的根结点 return nodes.get(0); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"赫夫曼树(最优二叉树)与赫夫曼树的JAVA实现","date":"2020-05-03T15:50:28.000Z","path":"2020/05/03/赫夫曼树(最优二叉树)与赫夫曼树的JAVA实现/","text":"基础概念 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 树的带权路径长度： 树的带权路径长度规定为所有叶子结点的带权路径长度之和， 记为WPL(weighted pathlength) 什么是赫夫曼树 定义:给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree),还有的书翻译为霍夫曼树 ==&gt; WPL 最小的就是赫夫曼树。 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近(权值越大的结点离根结点越近的二叉树才是最优二叉树) 下面第二图是赫夫曼树 赫夫曼树创建思路图解给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树 构成赫夫曼树的步骤 从小到大进行排序, 将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树， 以根节点的权值大小再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 构成赫夫曼树的图解 将{13, 7, 8, 3, 29, 6, 1}排序变成{1, 3, 6, 7, 8, 13, 29} 取出根结点权值最小的两棵二叉树 ==&gt; 1,3 组成一棵新的二叉树,根结点的权值是前面两棵二叉树的根结点权值的和 ==&gt; 即1 + 3 = 4 经过上一步,数列变成{4, 6, 7, 8, 13, 29} 取出根结点权值最小的两棵二叉树 ==&gt; 4, 6 组成一棵新的二叉树,根结点的权值是前面两棵二叉树的根结点权值的和 ==&gt; 即4 + 6 = 10 经过上一步,数列变成{10, 7, 8, 13, 29},排序后变成{7, 8, 10, 13, 29} 取出根结点权值最小的两棵二叉树 ==&gt; 7, 8 组成一棵新的二叉树,根结点的权值是前面两棵二叉树的根结点权值的和 ==&gt; 即7 + 8 = 15 经过上一步,数列变成{15, 10, 13, 29},排序后变成{10, 13, 15, 29} 取出根结点权值最小的两棵二叉树 ==&gt; 10, 13 组成一棵新的二叉树,根结点的权值是前面两棵二叉树的根结点权值的和 ==&gt; 即10 + 13 = 23 经过上一步,数列变成{23, 15, 29},排序后变成{15, 23, 29} 取出根结点权值最小的两棵二叉树 ==&gt; 15, 23 组成一棵新的二叉树,根结点的权值是前面两棵二叉树的根结点权值的和 ==&gt; 即15 + 23 = 38 经过上一步,数列变成{38, 29},排序后变成{29, 38} 取出根结点权值最小的两棵二叉树 ==&gt; 29, 38 组成一棵新的二叉树,根结点的权值是前面两棵二叉树的根结点权值的和 ==&gt; 即29 + 38 = 67 实现上述赫夫曼树 创建结点类 1234567891011121314151617181920212223242526272829303132333435363738/** * 创建结点类 * =&gt; 为了让 Node 对象持续排序 Collections 集合排序 * =&gt; 让 Node 实现 Comparable 接口 */class Node implements Comparable&lt;Node&gt; &#123; int value; // 结点权值 Node left; // 指向左子结点 Node right; // 指向右子结点 public Node(int value) &#123; this.value = value; &#125; /** * 前序遍历自身的子树 */ public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; @Override public String toString() &#123; return \"Node [value=\" + value + \"]\"; &#125; @Override public int compareTo(Node o) &#123; // 表示从小到大排序 return this.value - o.value; &#125;&#125; 实现赫夫曼树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.zjinc36.tree;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class HuffmanTree &#123; /** * 测试 */ public static void main(String[] args) &#123; int arr[] = &#123; 13, 7, 8, 3, 29, 6, 1 &#125;; Node root = createHuffmanTree(arr); root.preOrder(); &#125; /** * 创建一棵赫夫曼树 * @param int[] arr 要创建的数组 * @return 返回赫夫曼树的根结点 */ public static Node createHuffmanTree(int[] arr) &#123; // 第一步为了操作方便 // 1. 遍历 arr 数组 // 2. 将 arr 的每个元素构成成一个 Node // 3. 将 Node 放入到 ArrayList 中 List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); for (int value : arr) &#123; Node node = new Node(value); nodes.add(node); &#125; // 构成赫夫曼树的步骤 // =&gt; 从小到大进行排序, 将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树 // =&gt; 取出根节点权值最小的两颗二叉树 // =&gt; 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 // =&gt; 再将这颗新的二叉树， 以根节点的权值大小再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 while (nodes.size() &gt; 1) &#123; // (0) 从小到大进行排序 Collections.sort(nodes); // (1) 取出权值最小的结点（二叉树） Node leftNode = nodes.get(0); // 取出根节点权值最小的两颗二叉树 // (2) 取出权值第二小的结点（二叉树） Node rightNode = nodes.get(1); // (3) 构建一颗新的二叉树 Node parentNode = new Node(leftNode.value + rightNode.value); parentNode.left = leftNode; parentNode.right = rightNode; // (4) 从 ArrayList 删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); // (5) 将 parent 加入到 nodes nodes.add(parentNode); // (0) 从小到大进行排序 // ... 循环 &#125; // 返回赫夫曼树的根结点 return nodes.get(0); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"堆的基本介绍与堆排序的Java实现","date":"2020-05-02T18:03:40.000Z","path":"2020/05/03/堆的基本介绍与堆排序的Java实现/","text":"参考什么是堆？看这一篇就够了！ 堆的基本介绍 堆是一颗完全二叉树 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 从堆的特点可知，下图中，1，2 是大顶堆，3 是小顶堆， 4 不是堆（不是完全二叉树） 插入堆元素12345678910111213//插入一个元素时，将其插入堆的尾部，让后向上冒泡public static void heapInsert(int[] arr,int index)&#123; while (index!=0) &#123; int parent=(index-1)/2; if (arr[parent]&lt;arr[index]) swap(arr,index,parent); else break; index=parent; &#125;&#125; 堆化往堆中插入元素后（如下图示），我们需要继续满足堆的特性，所以需要不断调整元素的位置直到满足堆的特点为止（堆中节点的值都大于等于（或小于等于）其子节点的值）,我们把这种调整元素以让其满足堆特点的过程称为堆化（heapify）,建堆的时间复杂度：O(n) 12345678910111213141516171819202122232425262728public class Heap &#123; private int[] arr; // 堆是完全二叉树，底层用数组存储 private int capacity; // 堆中能存储的最大元素数量 private int n; // 当前堆中元素数量 public Heap(int count) &#123; capacity = count; arr = new int[capacity+1]; n = 0; &#125; public void insert(int value) &#123; if (n &gt;= capacity) &#123; // 超过堆大小了，不能再插入元素 return; &#125; n++; // 先将元素插入到队尾中 arr[n] = value; int i = n; // 由于我们构建的是一个大顶堆，所以需要不断调整以让其满足大顶堆的条件 while (i/2 &gt; 0 &amp;&amp; arr[i] &gt; arr[i/2]) &#123; swap(arr, i, i/2); i = i / 2; &#125; &#125;&#125; 删除堆元素删除堆元素会遇到数组空洞问题假设我们要操作的堆是大顶堆，则删除堆顶元素后，要找到原堆中第二大的元素以填补堆顶元素，而第二大的元素无疑是在根节点的左右子节点上，假设是左节点，则用左节点填补堆顶元素之后，左节点空了，此时需要从左节点的左右节点中找到两者的较大值填补左节点…，不断迭代此过程，直到调整完毕，调整过程如下图示：如上图所示，在最终调整后的堆中，出现了数组空洞，对应的数组如下 如何解决数组空洞问题我们可以用最后一个元素覆盖堆顶元素，然后再自上而下地调整堆，让其满足大顶堆的要求，这样即可解决数组空洞的问题。 删除堆元素的代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 移除堆顶元素 */public void removeTopElement() &#123; if (n == 0) &#123; // 堆中如果没有元素，也就是不存在移除堆顶元素的情况了 return; &#125; int count = n; arr[1] = arr[count]; --count; heapify(1, count);&#125;/** * 自上而下堆化以满足大顶堆的条件 */public void heapify(int index, int n) &#123; while (true) &#123; int maxValueIndex = index; if (2 * index &lt;= n &amp;&amp; arr[index] &lt; arr[2 * index]) &#123; // 左节点比其父节点大 maxValueIndex = 2 * index; &#125; if (2 * index + 1 &lt;= n &amp;&amp; arr[maxValueIndex] &lt; arr[2 * index + 1]) &#123; // 右节点比左节点或父节点大 maxValueIndex = 2 * index + 1; &#125; if (maxValueIndex == index) &#123; // 说明当前节点值为最大值，无需再往下迭代了 break; &#125; swap(arr, index, maxValueIndex); index = maxValueIndex; &#125;&#125;/** * 交换数组第 i 和第 j 个元素 */public static void swap(int[] arr, int i, int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 删除堆元素的时间复杂度时间复杂度和插入堆中元素一样，也是树的高度，所以为 O(logn)。 堆排序 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 O(nlogn)，它也是不稳定排序。 基本思路 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序 图解步骤一:构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。原始的数组 [4, 6, 8, 5, 9] 假设给定无序序列结构如下 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，最后一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整 找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6 此时，我们就将一个无序序列构造成了一个大顶堆 步骤二:将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。 将堆顶元素 9 和末尾元素 4 进行交换 重新调整结构，使其继续满足堆定义 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序 代码实现方式一:使用递归实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.zjinc36.tree;import java.util.Arrays;public class HeapSort &#123; private int[] arr; public HeapSort(int[] arr) &#123; this.arr = arr; &#125; /** * 堆排序的主要入口方法，共两步。 */ public void sort() &#123; // 第一步：将数组堆化 // 从最后一个分支结点(非叶子结点)开始 // beginIndex = (arr.length / 2)- 1 // 叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。 int len = arr.length - 1; int beginIndex = (arr.length &gt;&gt; 1) - 1; // ==&gt; (arr.length / 2)- 1 for (int i = beginIndex; i &gt;= 0; i--) &#123; maxHeapify(i, len); &#125; // 第二步：对堆化数据排序 // 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1 // 然后从新整理被换到根节点的末尾元素，使其符合堆的特性 // 直至未排序的堆长度为 0 for (int i = len; i &gt; 0; i--) &#123; swap(0, i); maxHeapify(0, i - 1); &#125; &#125; /** * 调整索引为 index 处的数据，使其符合堆的特性。 * * @param index 需要堆化处理的数据的索引 * @param len 未排序的堆（数组）的长度 */ private void maxHeapify(int index, int len) &#123; int li = (index &lt;&lt; 1) + 1; // 左子节点索引 ==&gt; (index * 2) + 1 int ri = li + 1; // 右子节点索引 int cMax = li; // 假设树的最大值的索引为左子节点 if (li &gt; len) &#123; // 左子节点索引超出计算范围，直接返回。 return; &#125; if (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) &#123; // 先判断右子结点是否大于左子结点 cMax = ri; &#125; if (arr[cMax] &gt; arr[index]) &#123; // 在判断左右子结点的最大值是否大于父结点 swap(cMax, index); // 如果父节点被子节点调换， maxHeapify(cMax, len); // 则需要继续判断换下后的父节点是否符合堆的特性。 &#125; &#125; private void swap(int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; /** * 测试用例 */ public static void main(String[] args) &#123; int[] arr = new int[] &#123; 4, 9, 8, 5, 10, 11, 2, 7, 1, 6, 3 &#125;; new HeapSort(arr).sort(); System.out.println(Arrays.toString(arr)); &#125;&#125; 方式二:使用循环实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.zjinc36.tree;import java.util.Arrays;public class HeapSort2 &#123; public static void main(String[] args) &#123; System.out.println(\"堆排序!!\"); int arr[] = &#123; 4, 6, 8, 5, 9, 3, 10, 2, 7, 11, 1 &#125;; // 将无序序列构建成一个堆， 根据升序降序需求选择大顶堆或小顶堆 // 这里构建大顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, arr.length); &#125; // 1. 将堆顶元素与末尾元素交换， 将最大元素\"沉\"到数组末端; // 2. 排除数组末尾已经排序的数,对剩余的数构建一个大顶堆 // 3. 然后继续交换堆顶元素与当前末尾元素 // 4. 反复执行调整+交换步骤， 直到整个序列有序 int temp = 0; for (int j = arr.length - 1; j &gt; 0; j--) &#123; //将堆顶元素与末尾元素交换， 将最大元素\"沉\"到数组末端; temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; // 排除数组末尾已经排序的数,对剩余的数构建一个大顶堆 adjustHeap(arr, 0, j); &#125; System.out.println(\"数组=\" + Arrays.toString(arr)); &#125; /** * 将一个二叉树(数组),调整成一个大顶堆 ==&gt; 将以i为父结点的树调整为大顶堆 * * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中的索引 * @param length 表示对多少个元素继续调整,length是在逐渐减少 */ public static void adjustHeap(int arr[], int i, int length) &#123; int temp = arr[i]; // 先取出当前元素的值,保存在临时变量 // 开始调整 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; // 比较左子结点与右子结点哪个大 if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; // 说明左子结点的值小于右子结点的值 k++; // 将k指向右子结点 &#125; // 比较左右子结点中较大的数与父结点中的数哪个大 if (arr[k] &gt; temp) &#123; arr[i] = arr[k]; // 左右子结点中较大的数与父结点的数进行交换 // 将k赋值给i是为了下一轮for循环中,i指向左右结点中被替换的那一个 // 而k在下一轮for循环中,指向i所指向结点的左子结点 i = k; &#125; else &#123; break; &#125; &#125; // 当for循环结束后,我们已经将i为父结点的树的最大值,放在了最顶 arr[i] = temp; // 将temp值放到调整后的位置 &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现线索化二叉树与线索化二叉树的遍历","date":"2020-05-02T17:51:38.000Z","path":"2020/05/03/Java中实现线索化二叉树与线索化二叉树的遍历/","text":"什么是二叉树线索化 线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。 由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程 为什么要对二叉树线索化 二叉树是一种非线性结构，遍历二叉树几乎都是通过递归或者用栈辅助实现非递归的遍历。 用二叉树作为存储结构时，取到一个节点，只能获取节点的左孩子和右孩子，不能直接得到节点的任一遍历序列的前驱或者后继。 为了保存这种在遍历中需要的信息，我们利用二叉树中指向左右子树的空指针来存放节点的前驱和后继信息 线索二叉树基本介绍 n 个结点的二叉链表中含有 n+1个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） n+1 ==&gt;【公式 2n-(n-1)=n+1 ==&gt; 总共n个节点,所以有2n个指针,除了第一个节点,其余每个节点需要占用一个指针,所以是(n-1)】 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 案例应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的结果：{8, 3, 10, 1, 14, 6},所以3的前驱结点为8,后继结点为10,其余同理 当然,当二叉树线索化后，Node 结点的 属性 left 和 right 就有有如下情况: left 有可能指向的是左子树，也有可能指向前驱节点. right 有可能指向的是右子树，也有可能指向后继节点. 中序遍历的方式实现线索化二叉树 英雄结点 1234567891011121314151617181920212223242526272829303132package com.zjinc36.tree;import lombok.Data;@Data/** * 这里HeroNode2中的2没有任何意义 * 纯粹是代码多了,又没实际意义,名字很难取 */public class HeroNode2 &#123; private int no; private String name; private HeroNode2 left; // 默认null private HeroNode2 right; // 默认null // 说明 // 1. 如果leftType == 0 表示指向的是左子树,如果1则表示指向的是前驱结点 // 2. 如果rightType == 0 表示指向的是右子树,如果1则表示指向的是后继结点 private int leftType; private int rightType; public HeroNode2(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; @Override public String toString() &#123; return \"HeroNode[no=]\" + no + \", name=\" + name + \"]\"; &#125;&#125; 二叉树线索化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zjinc36.tree;import lombok.Data;/** * 定义ThreadedBinaryTree实现了线索化功能的二叉树 */@Datapublic class ThreadedBinaryTree &#123; private HeroNode2 root; // 为了实现线索化,需要创建一个指针,指向当前结点的前驱结点 // 在递归进行线索化时,pre总是保留前一个结点 private HeroNode2 pre = null; // 重载threadNodes方法 public void threadedNodes() &#123; this.threadedNodes(root); &#125; // 编写对二叉树进行中序线索化的方法 public void threadedNodes(HeroNode2 node) &#123; // 如果node==null,不能线索化 if (node == null) &#123; return; &#125; // 1. 先线索化左子树 threadedNodes(node.getLeft()); // 2. 线索化当前结点(重点) // 先处理当前结点的前驱结点 if (node.getLeft() == null) &#123; // 让当前结点的左指针指向前驱结点 node.setLeft(pre); // 修改当前结点的左指针的类型 node.setLeftType(1); &#125; // 处理后继结点 // ==&gt; 处理当前结点的后继结点是前一结点的指针指向当前结点时才进行处理 // ==&gt; 因为如果直接处理\"node.getRight() == null\" // ==&gt; 那么无法知道node.setRight(?)要填什么 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让前驱结点的右指针指向当前结点 pre.setRight(node); // 修改前驱结点的右指针类型 pre.setRightType(1); &#125; // !!!每处理一个结点后,让当前结点是下一个结点的前驱结点 pre = node; // 3. 再线索化右子树 threadedNodes(node.getRight()); &#125;&#125; 测试 123456789101112131415161718192021222324252627282930313233343536373839package com.zjinc36.tree;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;public class ThreadedBinaryTreeTest &#123; @Before public void setUp() throws Exception &#123; &#125; @Test public void test() &#123; //测试一把中序线索二叉树的功能 HeroNode2 root = new HeroNode2(1, \"tom\"); HeroNode2 node2 = new HeroNode2(3, \"jack\"); HeroNode2 node3 = new HeroNode2(6, \"smith\"); HeroNode2 node4 = new HeroNode2(8, \"mary\"); HeroNode2 node5 = new HeroNode2(10, \"king\"); HeroNode2 node6 = new HeroNode2(14, \"dim\"); //二叉树， 后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); //测试: 以 10 号节点测试 HeroNode2 leftNode = node5.getLeft(); HeroNode2 rightNode = node5.getRight(); System.out.println(\"10 号结点的前驱结点是 =\" + leftNode); //3 System.out.println(\"10 号结点的后继结点是=\" + rightNode); //1 &#125;&#125; 线索化二叉树的中序遍历说明 说明： 对前面的中序线索化的二叉树， 进行遍历 分析： 因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。遍历的次序应当和中序遍历保持一致。 代码 英雄结点 ==&gt; 和前面相同 遍历线索化二叉树 ==&gt; 看threadedList()函数,其余和前面一样 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.zjinc36.tree;import lombok.Data;/** * 定义ThreadedBinaryTree实现了线索化功能的二叉树 */@Datapublic class ThreadedBinaryTree &#123; private HeroNode2 root; // 为了实现线索化,需要创建一个指针,指向当前结点的前驱结点 // 在递归进行线索化时,pre总是保留前一个结点 private HeroNode2 pre = null; // 重载threadNodes方法 public void threadedNodes() &#123; this.threadedNodes(root); &#125; // 编写对二叉树进行中序线索化的方法 public void threadedNodes(HeroNode2 node) &#123; // 如果node==null,不能线索化 if (node == null) &#123; return; &#125; // 1. 先线索化左子树 threadedNodes(node.getLeft()); // 2. 线索化当前结点(重点) // 先处理当前结点的前驱结点 if (node.getLeft() == null) &#123; // 让当前结点的左指针指向前驱结点 node.setLeft(pre); // 修改当前结点的左指针的类型 node.setLeftType(1); &#125; // 处理后继结点 // ==&gt; 处理当前结点的后继结点是前一结点的指针指向当前结点时才进行处理 // ==&gt; 因为如果直接处理\"node.getRight() == null\",那么无法知道node.setRight(?)要填什么 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让前驱结点的右指针指向当前结点 pre.setRight(node); // 修改前驱结点的右指针类型 pre.setRightType(1); &#125; // !!!每处理一个结点后,让当前结点是下一个结点的前驱结点 pre = node; // 3. 再线索化右子树 threadedNodes(node.getRight()); &#125; /** * 中序遍历线索化二叉树 */ public void threadedList() &#123; // 定义一个变量,存储当前遍历的结点,从root开始 HeroNode2 node = root; // 说明 // 1. 如果leftType == 0 表示指向的是左子树,如果1则表示指向的是前驱结点 // 2. 如果rightType == 0 表示指向的是右子树,如果1则表示指向的是后继结点 while (node != null) &#123; // 1. 找到起始结点 // ==&gt; 有左子树,则向左边寻找 while(node.getLeftType() == 0) &#123; node = node.getLeft(); &#125; // ==&gt; 打印起始结点 System.out.println(node); // 2. 判断是否有后继结点 // ==&gt; 2.1 有后继结点则一直输出 while(node.getRightType() == 1) &#123; // 获取到当前结点的后继结点并打印 node = node.getRight(); System.out.println(node); &#125; // ==&gt; 2.2 无后继结点表示线索断了 // ==&gt; 但我们观察可以发现,每当线索断了,对于中序遍历,都是右子树还没遍历 // ==&gt; 那么,我们将当前结点替换成右子结点进行上述相同的操作 // ==&gt; ==&gt; 找到起始结点 // ==&gt; ==&gt; 顺着线索(后继结点)摸下去 // ==&gt; 这样就能将线索接起来 node = node.getRight(); &#125; &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zjinc36.tree;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;public class ThreadedBinaryTreeTest &#123; @Before public void setUp() throws Exception &#123; &#125; @Test public void test() &#123; //测试一把中序线索二叉树的功能 HeroNode2 root = new HeroNode2(1, \"tom\"); HeroNode2 node2 = new HeroNode2(3, \"jack\"); HeroNode2 node3 = new HeroNode2(6, \"smith\"); HeroNode2 node4 = new HeroNode2(8, \"mary\"); HeroNode2 node5 = new HeroNode2(10, \"king\"); HeroNode2 node6 = new HeroNode2(14, \"dim\"); //二叉树， 后面我们要递归创建, 现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试中序线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); //测试: 以 10 号节点测试// HeroNode2 leftNode = node5.getLeft();// HeroNode2 rightNode = node5.getRight();// System.out.println(\"10 号结点的前驱结点是 =\" + leftNode); //3// System.out.println(\"10 号结点的后继结点是=\" + rightNode); //1 // 测试遍历 threadedBinaryTree.threadedList(); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现顺序存储二叉树","date":"2020-05-02T16:03:40.000Z","path":"2020/05/03/Java中实现顺序存储二叉树/","text":"基本说明 二叉树的顺序存储，就是用一组连续的存储单元存放二叉树中的结点 从数据存储上看,数据存储方式和树的存储方式可以相互转换,即数组可以转换成树,树也可以转换成数组 存储方式用编号的方法从树根起，自上层至下层，每层自左至右地给所有结点编号 好用在哪完全二叉树和满二叉树采用顺序存储比较合适, 树中结点的序号可以唯一地反映出结点之间的逻辑关系，这样既能够最大可能地节省存储空间，又可以利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系 不好用在哪对于一般的二叉树，如果仍按从上至下和从左到右的顺序将树中的结点顺序存储在一维数组中，则数组元素下标之间的关系不能够反映二叉树中结点之间的逻辑关系,只有增添一些并不存在的空结点，使之成为一棵完全二叉树的形式，然后再用一维数组顺序存储,这种存储对于需增加许多空结点才能将一棵二叉树改造成为一棵完全二叉树的存储时，会造成空间的大量浪费 案例问题 现有一数组为arr:[1, 2, 3, 4, 5, 6] 将这个数组看成一个顺序存储的二叉树,对这个二叉树以前序遍历,中序遍历,后序遍历的方式完成结点的遍历 前序中序后序遍历的区别 前序遍历:先输出父结点,再遍历左子树和右子树 中序遍历:先遍历左子树,再输出父结点,再遍历右子树 后序遍历:先遍历左子树,再遍历右子树,最后输出父结点小结:看输出父结点的顺序,就确定前序,中序还是后序 顺序存储二叉树的特点 顺序二叉树通常只考虑完全二叉树 第n个元素的左子结点2*n + 1 第n个元素的右子结点2*n + 2 第n个元素的父结点为(n - 1) / 2 n表示二叉树的第n个元素(按0开始编号) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.zjinc36.tree;/** * 需求:给你一个数组&#123;1,2,3,4,5,6,7&#125;,要求以二叉树前序遍历的方式进行道历。前序遍历的结果应当为1,2,4,5,3,6,7 * 1)顺序存储通常只考虑完全二叉树 * 2)第n个元素的左子节点为2*n+1 * 3)第n个元素的右子节点为2*n+2 * 4)第n个元素的父节点为(n-1)12 * 5)n:表示二叉树中的第几个元素(按0开始编号如图所示) */public class ArrBinaryTree &#123; private int[] arr; //存储数据节点的数组 public ArrBinaryTree(int[] arr) &#123; this.arr = arr; &#125; /** * 重载前序遍历 */ public void preOrder() &#123; this.preOrder(0); &#125; /** * 重载中序遍历 */ public void inOrder() &#123; this.inOrder(0); &#125; /** * 重载后序遍历 */ public void postOrder() &#123; this.postOrder(0); &#125; /** * 编写一个方法,完成顺序存储二叉树的前序遍历 * @param index 数组的下标 */ public void preOrder(int index) &#123; // 如果数组为空,或者arr.length=0 if (arr == null || arr.length == 0) &#123; System.out.println(\"数组为空,不能进行二叉树的前序遍历\"); &#125; // 输出当前这个元素 System.out.println(arr[index]); // 向左递归遍历 if (index * 2 + 1 &lt; arr.length) &#123; this.preOrder(2*index + 1); &#125; // 向右递归遍历 if (index * 2 + 2 &lt; arr.length) &#123; this.preOrder(2*index + 2); &#125; &#125; /** * 编写一个方法,完成顺序存储二叉树的中序遍历 * @param index 数组的下标 */ public void inOrder (int index) &#123; // 如果数组为空,或者arr.length=0 if (arr == null || arr.length == 0) &#123; System.out.println(\"数组为空,不能进行二叉树的中序遍历\"); &#125; // 遍历左子树 if (index * 2 + 1 &lt; arr.length) &#123; this.inOrder(2 * index + 1); &#125; System.out.println(arr[index]); // 遍历右子树 if (index * 2 + 2 &lt; arr.length) &#123; this.inOrder(2 * index + 2); &#125; &#125; /** * 编写一个方法,完成顺序存储二叉树的后序遍历 * @param index 数组的下标 */ public void postOrder(int index) &#123; // 如果数组为空,或者arr.length=0 if (arr == null || arr.length == 0) &#123; System.out.println(\"数组为空,不能进行二叉树的中序遍历\"); &#125; // 遍历左子树 if (index * 2 + 1 &lt; arr.length) &#123; this.postOrder(index * 2 + 1); &#125; // 遍历右子树 if (index * 2 + 2 &lt; arr.length) &#123; this.postOrder(index * 2 + 2); &#125; System.out.println(arr[index]); &#125;&#125; 测试1234567891011121314151617package com.zjinc36.tree;import org.junit.Test;public class ArrBinaryTreeTest &#123; @Test public void test() &#123; int[] arr = &#123;1,2,3,4,5,6,7&#125;; ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); System.out.println(\"====前序遍历====\"); arrBinaryTree.preOrder(); System.out.println(\"====中序遍历====\"); arrBinaryTree.inOrder(); System.out.println(\"====后序遍历====\"); arrBinaryTree.postOrder(); &#125;&#125; 参考顺序存储二叉树","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Ubuntu中安装流程图工具Dia","date":"2020-04-29T09:44:24.000Z","path":"2020/04/29/Ubuntu中安装流程图工具Dia/","text":"参考ubuntu安装dia完美解决Dia无法输入中文的问题解决Dia在Linux上的输入法问题 作用跨平台流程工具Dia。 安装 打开终端(快捷键：ctrl+alt+t) 输入命令 1$ sudo apt-get install dia 输入y，等待，安装完成。 卸载此工具： 输入命令 1$ sudo apt-get autoremove dia. 输入y，等待，卸载完成。 问题:无法输入中文方案一假入无法输入中文，修改一个选项： 随便画一个图 右键 选择Input Methods 点击x input method 此时有可能发现还是无法使用中文输入，原因可能是因为打开.dia文件的时候，直接右键打开了。所以，此时应该在命令行输入： 1$ dia 打开dia软件之后，再打开所要打开的.dia文件。 方案二上述方案就是每次打开都必须设置一次,接下去我们要跳过这一个步骤 从桌面文件直接打开修改/usr/share/applications/dia.desktop文件 1把Exec=dia %F 改为Exec=env GTK_IM_MODULE=xim dia %F 这个设置解决了从启动栏的快捷方式中启动Dia后，输入中文的问题。 从终端打开 启动命令dia 前边增加env GTK_IM_MODULE=xim，即用env GTK_IM_MODULE=xim dia来启动Dia 为了避免每次启动都要输入这么一长串，我们设置别名alias，1执行命令`alias dia=&quot;env GTK_IM_MODULE=xim dia&quot;`，以后再启动Dia时还是使用dia就可以了。","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"二叉树的相关概念及在Java中实现二叉树的遍历、查找和删除","date":"2020-04-27T11:58:02.000Z","path":"2020/04/27/二叉树的相关概念及在Java中实现二叉树的遍历查找和删除/","text":"为什么需要树这种数据结构数组存储方式的分析 优点:通过下标方式访问元素,速度快.对于有序数组,还可以使用二分查找提高检索速度 缺点:如果要检索具体某个值,或者按一定顺序插入值,则会整体移动,效率低 链式存储方式的分析 优点:在一定程度上对数组存储方式有优化,插入一个数值节点只需要将插入节点链接到链表中即可,删除效率也很好 缺点:在进行检索时,效率仍然较低,检索某个值时,需要从头节点开始遍历 树存储方式分析能提高数据存储,读取的效率,比如利用二叉树排序(Binary Sort Tree),既可以保证数据的检索速度,同时可以保证数据的插入,删除,修改的速度 树的常用术语 空树:不包含任何结点的二叉树 单点树:只包含一个结点的二叉树 父结点 子结点 边:父结点到子结点的连线 祖先/子孙关系 兄弟结点:父结点相同的两个结点互为兄弟结点 树叶结点(叶子结点):对于二叉树,两棵子树都为空的结点(没有子结点的结点) 分支结点:树中除了树叶以外的结点 路径:从祖先结点找到该结点的路线(从一个结点到其子结点有一条长度为1的路径,每个结点到自身有一条长度为0的路径) 度数:一个结点的子结点个数称为该结点的度数 层(规定二叉树根的层数为0) &lt;==&gt; 貌似也有规定为1的情况 树的高度(也称深度):最大层数,也是树里最长路径的长度 森林(多棵子树构成森林) 二叉树的概念 树有很多种，每个结点最多只有两个子结点的一种形式称为二叉树 二叉树的子结点分为左结点和右结点 示意图 满二叉树 定义: 所有分支结点的度数为2 ==&gt; 这个定义出自【机械工业出版社《数据结构与算法（Python语言描述）》–北京大学 裘宗燕著】一书第179页 注意 国内定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 也就是说，如果一个二叉树的层数为k ，且结点总数是(2^(k+1)) -1，则它就是满二叉树。(2^(k+1)) -1可由等比数列前n项和公式得到网上经常看到公式是(2^k) -1,是因为将根结点算作第一层,本质上没区别 国外定义：满二叉树的结点要么是叶子结点，度为0，要么是分支结点,度为2，不存在度为1的结点。 扩充二叉树将一个二叉树扩充成一个满二叉树,此时这个满二叉树即为扩充二叉树 原树的结点称为内部结点 新增的结点称为外部结点 注意:空树的扩充二叉树为空树 完全二叉树树的高度为h,第0层到第h-1层的结点都满(即:对于所有0 &lt;= i &lt;= h-1,第i层有2^i个结点),最后一层在最左边连续排列,空位都在右边 二叉树遍历的说明使用前序,中序和后序对二叉树进行遍历 前序遍历:先输出父结点,再遍历左子树和右子树 中序遍历:先遍历左子树,再输出父结点,在遍历右子树 后序遍历:先遍历左子树,再遍历右子树,最后输出父结点 小结:看输出父结点的顺序,就确定前序,中序还是后序 遍历如下二叉树 代码实现 英雄对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.zjinc36.tree;import lombok.Data;@Datapublic class HeroNode &#123; private int no; private String name; private HeroNode left; // 默认null private HeroNode right; // 默认null public HeroNode(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; @Override public String toString() &#123; return \"HeroNode[no=]\" + no + \", name=\" + name + \"]\"; &#125; /** * 前序遍历 */ public void preOrder() &#123; System.out.println(this); // 先输出父结点 // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; // 递归向右子树谦虚遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; // 递归向左子树中序遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; // 输出父结点 System.out.println(this); // 递归向右子树中序遍历 if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; if (this.left != null) &#123; this.left.postOrder(); &#125; if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this); &#125;&#125; 二叉树 1234567891011121314151617181920212223242526272829303132333435363738394041package com.zjinc36.tree;import lombok.Data;@Datapublic class BinaryTree &#123; private HeroNode root; /** * 前序遍历 */ public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println(\"二叉树为空,无法遍历\"); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; else &#123; System.out.println(\"二叉树为空,无法遍历\"); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println(\"二叉树为空,无法遍历\"); &#125; &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637383940package com.zjinc36.tree;import static org.junit.Assert.*;import org.junit.Test;public class BinaryTreeTest &#123; @Test public void test() &#123; // 先创建一棵二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的结点 HeroNode heroNode1 = new HeroNode(1, \"宋江\"); HeroNode heroNode2 = new HeroNode(2, \"卢俊义\"); HeroNode heroNode3 = new HeroNode(3, \"吴用\"); HeroNode heroNode4 = new HeroNode(4, \"林冲\"); HeroNode heroNode5 = new HeroNode(5, \"关胜\"); // 现在我们先手动创建二叉树 heroNode1.setLeft(heroNode2); heroNode1.setRight(heroNode3); heroNode3.setRight(heroNode4); heroNode3.setLeft(heroNode5); binaryTree.setRoot(heroNode1); // 测试 System.out.println(\"前序遍历\"); binaryTree.preOrder(); System.out.println(\"中序遍历\"); binaryTree.infixOrder(); System.out.println(\"后序遍历\"); binaryTree.postOrder(); &#125;&#125; 二叉树查找指定结点要求 编写前序查找,中序查找,后序查找的方法 并分别使用三种查找方式,查找”关胜”的结点 思路分析前序查找思路 先判断当前结点是否等于要查找的 如果相等,则返回当前结点 如果不等,则判断当前结点的左子结点是否为空,如果不为空,则递归前序查找 如果左递归前序查找能找到结点,则返回,否则继续判断当前结点的右子结点是否为空,如果不空,则继续向右递归前序查找 中序查找思路 判断当前结点的左子结点是否为空,如果不为空,则递归中序查找 如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点,否则继续进行右递归中序查找 如果右递归中序查找能找到,就返回,否则返回null 后序查找思路 判断当前结点的左子结点是否为空,如果不为空,则递归后序查找 如果找到,则返回,如果没有找到,就判断当前结点的右子结点是否为空,如果不为空,则右递归进行后续查找,如果找到,就返回 和当前结点进行比较,如果是则返回,否则返回null 代码 英雄对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.zjinc36.tree;import static org.hamcrest.CoreMatchers.nullValue;import lombok.Data;@Datapublic class HeroNode &#123; private int no; private String name; private HeroNode left; // 默认null private HeroNode right; // 默认null public HeroNode(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; @Override public String toString() &#123; return \"HeroNode[no=]\" + no + \", name=\" + name + \"]\"; &#125; /** * 前序遍历查找 * @param no 查找的序号 * @return 如果找到就返回该结点,如果没有找到返回null */ public HeroNode preOrderSearch(int no) &#123; System.out.println(\"进入前序遍历\"); // 比较当前节点是不是 if (this.no == no) &#123; return this; &#125; // 判断当前结点的左子结点是否为空,如果不为空,则递归前序查找 // 如果左递归前序查找能找到结点,则返回 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; // 说明左子树找到 return resNode; &#125; if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; /** * 中序遍历查找 * @param no 查找的序号 * @return 如果找到就返回该结点,如果没有找到返回null */ public HeroNode infixOrderSearch(int no) &#123; // 判断当前结点的左子结点是否为空,如果不为空,则递归中序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println(\"进入中序查找\"); // 如果找到,则返回,如果没有找到,就和当前结点比较,如果是则返回当前结点 if (this.no == no) &#123; return this; &#125; // 否则继续进行右递归的中序查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; /** * 后序遍历查找 * @param no 查找的序号 * @return 如果找到就返回该结点,如果没有找到返回null */ public HeroNode postOrderSearch(int no) &#123; // 判断当前结点的左子结点是否为空,如果不为空,则递归后序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; // 说明在左子树找到 return resNode; &#125; // 如果左子树没有找到,则向右子树递归进行后序遍历查找 if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; System.out.println(\"进入后序查找\"); // 如果左右子树都没有找到,就比较当前结点是不是 if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125; 二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zjinc36.tree;import lombok.Data;@Datapublic class BinaryTree &#123; private HeroNode root; /** * 前序遍历查找 * @param no 查找的序号 * @return 如果找到就返回该结点,如果没有找到返回null */ public HeroNode preOrderSearch(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; /** * 中序遍历查找 * @param no 查找的序号 * @return 如果找到就返回该结点,如果没有找到返回null */ public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; /** * 后序遍历查找 * @param no 查找的序号 * @return 如果找到就返回该结点,如果没有找到返回null */ public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.zjinc36.tree;import static org.junit.Assert.*;import org.junit.Test;public class BinaryTreeTest &#123; /** * 测试查找 */ @Test public void searchTest() &#123; // 先创建一棵二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的结点 HeroNode heroNode1 = new HeroNode(1, \"宋江\"); HeroNode heroNode2 = new HeroNode(2, \"卢俊义\"); HeroNode heroNode3 = new HeroNode(3, \"吴用\"); HeroNode heroNode4 = new HeroNode(4, \"林冲\"); HeroNode heroNode5 = new HeroNode(5, \"关胜\"); // 现在我们先手动创建二叉树 heroNode1.setLeft(heroNode2); heroNode1.setRight(heroNode3); heroNode3.setRight(heroNode4); heroNode3.setLeft(heroNode5); binaryTree.setRoot(heroNode1); // 测试 System.out.println(\"前序遍历查找\"); HeroNode resNode = binaryTree.preOrderSearch(5); if (resNode != null) &#123; System.out.printf(\"找到了,信息为 no = %d name = %s\", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.println(\"没有找到\"); &#125;// System.out.println(\"中序遍历查找\");// resNode = binaryTree.infixOrderSearch(5);// if (resNode != null) &#123;// System.out.printf(\"找到了,信息为 no = %d name = %s\", resNode.getNo(), resNode.getName());// &#125; else &#123;// System.out.println(\"没有找到\");// &#125;//// System.out.println(\"后序遍历查找\");// resNode = binaryTree.postOrderSearch(5);// if (resNode != null) &#123;// System.out.printf(\"找到了,信息为 no = %d name = %s\", resNode.getNo(), resNode.getName());// &#125; else &#123;// System.out.println(\"没有找到\");// &#125; &#125;&#125; 二叉树删除指定结点要求 如果删除的结点是叶子结点,则删除该结点 如果删除的结点是非叶子结点,则删除该子树(注意这里,先从最简单的开始) 思路分析首先处理考虑树是否是空树,如果只有一个root结点,则等价于将二叉树置空 接下去进行下面步骤 因为我们的二叉树是单向的,所以我们是判断当前结点的子结点是否需要删除结点,而不能去判断当前这个结点是不是需要删除 如果当前结点的左子结点不为空,并且左子结点就是要删除的结点,就将this.left = null;并且返回(结束递归删除) 如果当前结点的右子结点不为空,并且右子结点就是要删除的结点,就将this.right = null;并且就返回(结束递归删除) 如果第2和第3步没有删除结点,那么我们就需要向左子树进行递归删除 如果第4步也没有删除结点,则应当向右子树进行递归删除 代码 英雄对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.zjinc36.tree;import static org.hamcrest.CoreMatchers.nullValue;import lombok.Data;@Datapublic class HeroNode &#123; private int no; private String name; private HeroNode left; // 默认null private HeroNode right; // 默认null public HeroNode(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; @Override public String toString() &#123; return \"HeroNode[no=]\" + no + \", name=\" + name + \"]\"; &#125; /** * 前序遍历 */ public void preOrder() &#123; System.out.println(this); // 先输出父结点 // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; // 递归向右子树谦虚遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; /** * 递归删除结点 * -&gt; 如果删除的结点是叶子结点,则删除该结点 * -&gt; 如果删除的结点是非叶子结点,则删除该子树(注意这里,先从最简单的开始) * @param no 需要删除的序号 */ public void delNode(int no) &#123; if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; if (this.left != null) &#123; this.left.delNode(no); &#125; if (this.right != null) &#123; this.right.delNode(no); &#125; &#125;&#125; 二叉树删除功能 123456789101112131415161718192021222324252627282930313233343536373839404142package com.zjinc36.tree;import static org.hamcrest.CoreMatchers.nullValue;import lombok.Data;@Datapublic class BinaryTree &#123; private HeroNode root; /** * 前序遍历 */ public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println(\"二叉树为空,无法遍历\"); &#125; &#125; /** * 删除结点 * -&gt; 如果删除的结点是叶子结点,则删除该结点 * -&gt; 如果删除的结点是非叶子结点,则删除该子树(注意这里,先从最简单的开始) * @param no 需要删除的序号 */ public void delNode(int no) &#123; if (root != null) &#123; // 如果只有一个root结点,这里立即判断root是不是就是要删除结点 if (root.getNo() == no) &#123; root = null; &#125; else &#123; // 递归删除 root.delNode(no); &#125; &#125; else &#123; System.out.println(\"空树,不能删除\"); &#125; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.zjinc36.tree;import static org.junit.Assert.*;import org.junit.Test;public class BinaryTreeTest &#123; /** * 测试删除 */ @Test public void delSearch() &#123; // 先创建一棵二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的结点 HeroNode heroNode1 = new HeroNode(1, \"宋江\"); HeroNode heroNode2 = new HeroNode(2, \"卢俊义\"); HeroNode heroNode3 = new HeroNode(3, \"吴用\"); HeroNode heroNode4 = new HeroNode(4, \"林冲\"); HeroNode heroNode5 = new HeroNode(5, \"关胜\"); // 现在我们先手动创建二叉树 heroNode1.setLeft(heroNode2); heroNode1.setRight(heroNode3); heroNode3.setRight(heroNode4); heroNode3.setLeft(heroNode5); binaryTree.setRoot(heroNode1); // 测试 System.out.println(\"删除前,遍历\"); binaryTree.preOrder(); int no = 5; System.out.printf(\"删除结点 no = %d\", no); binaryTree.delNode(no); System.out.println(\"删除后,遍历\"); binaryTree.preOrder(); &#125;&#125; 更改删除规则如果要删除的结点是非叶子结点,现在我们不希望将该非叶子结点为根结点的子树删除,需要执行规则 如果该非叶子结点A只有一个子结点B,则子结点B替代结点A 如果该非叶子结点A有左子结点B和右子结点C,则让左子结点B替代结点A","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现哈希表","date":"2020-04-26T16:25:01.000Z","path":"2020/04/27/Java中实现哈希表/","text":"哈希表的基本介绍散列表(Hash Table,也叫哈希表),是根据关键码值(Key Value)而直接进行访问的数据结构.也就是说,它通过把关键码值映射到表中一个位置来访问记录,以加快查找的速度. 这个映射函数叫做散列函数 存放记录的数组叫做散列表 一个问题有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id, 性别, 年龄 …),当输入该员工的id时,要求找到该员工的所有信息. 不使用数据库,速度越快越好 -&gt; 哈希表 添加时,保证按照id从低到高插入 使用链表来实现哈希表,该链表不带表头(即:链表第一个节点就存放雇员信息) 解决 雇员对象 123456789101112131415161718192021222324252627package com.zjinc36.hash;import lombok.Data;/** * 雇员对象 */@Datapublic class Employee &#123; private int id; private String name; private Employee next; public Employee(int id, String name) &#123; super(); this.id = id; this.name = name; &#125; /** * 为了显示方便,重写toString */ @Override public String toString() &#123; return \"Employee[id=\" + id + \" name=\" + name + \"]\"; &#125;&#125; 雇员构成的链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.zjinc36.hash;/** * 雇员链表 */public class EmployeeLinkedList &#123; private Employee head; /** * 添加到雇员链表 * @param employee 雇员 */ public void add(Employee employee) &#123; // 添加第一个雇员 if (head == null) &#123; head = employee; return; &#125; // 如果不是第一个雇员,则使用一个辅助指针,帮助定位到最后 Employee currentEmployee = head; while (true) &#123; if (currentEmployee.getNext() == null) &#123; break; &#125; currentEmployee = currentEmployee.getNext(); &#125; currentEmployee.setNext(employee); &#125; /** * 遍历链表的雇员信息 * @param no 第几条链表 */ public void list(int no) &#123; if (head == null) &#123; System.out.println(\"第 \" + (no + 1) + \" 链表为空\"); return; &#125; System.out.print(\"第 \" + (no + 1) + \" 链表的信息为\"); // 因为头节点不能动,所以需要辅助指针 Employee currentEmployee = head; while (true) &#123; // 判断是否已经到链表最后 if (currentEmployee == null) &#123; break; &#125; System.out.printf(\"=&gt;id=%d name=%s\\t\", currentEmployee.getId(), currentEmployee.getName()); currentEmployee = currentEmployee.getNext(); &#125; System.out.println(); &#125; /** * 根据id查找雇员 * @param id 雇员id * @return 如果找到就返回雇员,如果没有找到,就返回null */ public Employee findEmployeeById(int id) &#123; // 判断链表是否为空 if (head == null) &#123; System.out.println(\"链表为空\"); return null; &#125; // 辅助指针 Employee currentEmployee = head; while (true) &#123; if (currentEmployee.getId() == id) &#123; // 找到 break; // 此时currentEmployee就指向要查找的雇员 &#125; // 退出 if (currentEmployee.getNext() == null) &#123; // 说明遍历当前链表没有找到该雇员 currentEmployee = null; break; &#125; currentEmployee = currentEmployee.getNext(); &#125; return currentEmployee; &#125;&#125; 雇员链表构成的雇员哈希表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.zjinc36.hash;/** * 雇员哈希表 * -&gt; 管理多条链表 */public class EmployeeHashTable &#123; // 数组中每个元素都是EmployeeLinkedList链表 private EmployeeLinkedList[] employeeLinkedListArray; // 表示有多少条链表 private int size; public EmployeeHashTable(int size) &#123; this.size = size; // 初始化employeeLinkedListArray employeeLinkedListArray = new EmployeeLinkedList[size]; for (int i = 0; i &lt; size; i++) &#123; employeeLinkedListArray[i] = new EmployeeLinkedList(); &#125; &#125; /** * 添加雇员 * @param employee 雇员 */ public void add(Employee employee) &#123; // 根据雇员的id,计算雇员应该添加到哪条链表 int employeeLinkedListNo = hashFunction(employee.getId()); // 将雇员添加到对应的链表中 employeeLinkedListArray[employeeLinkedListNo].add(employee); &#125; /** * 遍历所有链表 */ public void list() &#123; for (int i = 0; i &lt; size; i++) &#123; employeeLinkedListArray[i].list(i); &#125; &#125; /** * 根据输入的id,查找雇员 * @param id */ public void findEmployeeById (int id) &#123; // 使用散列函数确定需要在哪条链表上进行查找 int employeeLinkedListNo = hashFunction(id); Employee employee = employeeLinkedListArray[employeeLinkedListNo].findEmployeeById(id); if (employee != null) &#123; // 找到 System.out.printf(\"在第%d条链表中找到 雇员id=%d\\n\", (employeeLinkedListNo + 1), id); &#125; else &#123; System.out.println(\"在哈希表中,没有找到该雇员~\"); &#125; &#125; /** * 散列函数,使用一个简单取模法 * @param id * @return */ public int hashFunction(int id) &#123; return id % size; &#125;&#125; 调试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.zjinc36.hash;import static org.junit.Assert.*;import java.util.Scanner;import org.junit.Test;public class EmployeeHashTableTest &#123; @Test public void test() &#123; // 创建哈希表 EmployeeHashTable employeeHashTable = new EmployeeHashTable(7); // 写一个简单的菜单 String key = \"\"; Scanner scanner = new Scanner(System.in); while (true) &#123; System.out.println(\"add: 添加雇员\"); System.out.println(\"list: 显示雇员\"); System.out.println(\"find: 查找雇员\"); System.out.println(\"exit: 退出系统\"); key = scanner.next(); switch (key) &#123; case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); // 创建雇员 Employee employee = new Employee(id, name); employeeHashTable.add(employee); break; case \"list\": employeeHashTable.list(); break; case \"find\": System.out.println(\"请输入要查找的id\"); id = scanner.nextInt(); employeeHashTable.findEmployeeById(id); break; case \"exit\": scanner.close(); System.exit(0); break; default: break; &#125; &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现基数排序","date":"2020-04-24T17:43:24.000Z","path":"2020/04/25/Java中实现基数排序/","text":"基数排序(桶排序)介绍 基数排序(radix sort)属于”分配式排序(distribution sort)”,又称”桶子法(bucket sort或bin sort)”,顾名思义,它是通过键值的各个位的值,将要排序的元素分配至某些”桶”中,达到排序的作用 基数排序法属于稳定的排序,基数排序法是效率高的稳定性排序法 基数排序(Radix Sort)是桶排序的扩展 基数排序是1887年赫夫曼何乐礼发明的.它是这样实现的:将整数按位分割成不同的数字,然后按每个位数分别比较 基数排序基本思想将所有待比较数值统一为同样的数位长度,数位较短的数前面补零.然后,从最低位开始,依次进行一次排序.这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列 按照个位数字的值,放入对应的桶中,比如278的个位是8,则放入8这个桶,其他同理,排序完成之后,重新组成一组,桶中有多个数据时,按照先进先出原则取出来 接下去排十位数,比如930的十位数是3,就放入3这个桶,其他同理,排序完成之后,重新组成一组,桶中有多个数据时,按照先进先出原则取出来 接下去排百位数,比如505的百位数是5,就放入5这个桶,其他同理,排序完成之后,重新组成一组,桶中有多个数据时,按照先进先出原则取出来 代码实现手动实现上述逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.zjinc36.sort;import java.util.Arrays;public class RadixSort &#123; public void radixSort(int[] arr) &#123; // 1.得到数组中最大的数的位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; // 2. 得到最大的数是几位数 int maxLength = (max + \"\").length(); // 3.定义一个二维数组,表示10个桶,每个桶就是一个一维数组 // 说明 // -&gt; 二维数组包含10个一维数组 // -&gt; 为了防止在放入数的时候,数据溢出,则每个一维数组(桶),大小定为arr.length // -&gt; 基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; // 为了记录每个桶中,实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入数据个数 // bucketElementCounts[0],记录的就是bucket[0]桶的放入数据个数 int[] bucketElementCounts = new int[10]; // 第一轮 for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的个位的值 int digitOfElement = arr[j] / 1 % 10; // 放入对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组) int index = 0; // 遍历每一桶,并将桶中的数据放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中有数据,我们才放入到原数组 if (bucketElementCounts[k]!= 0) &#123; // 循环该桶即第k个桶(即第k个一维数组),放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; // 第i+1轮处理后,需要将每个bucketElementCounts[k]=0!!!! bucketElementCounts[k] = 0; &#125; System.out.println(\"第一轮,对个位的排序处理arr = \" + Arrays.toString(arr)); // 第二轮 for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的个位的值 int digitOfElement = arr[j] / 10 % 10; // 放入对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组) index = 0; // 遍历每一桶,并将桶中的数据放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中有数据,我们才放入到原数组 if (bucketElementCounts[k]!= 0) &#123; // 循环该桶即第k个桶(即第k个一维数组),放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; // 第i+1轮处理后,需要将每个bucketElementCounts[k]=0!!!! bucketElementCounts[k] = 0; &#125; System.out.println(\"第二轮,对个位的排序处理arr = \" + Arrays.toString(arr)); // 第三轮 for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的个位的值 int digitOfElement = arr[j] / 100 % 10; // 放入对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组) index = 0; // 遍历每一桶,并将桶中的数据放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中有数据,我们才放入到原数组 if (bucketElementCounts[k]!= 0) &#123; // 循环该桶即第k个桶(即第k个一维数组),放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; // 第i+1轮处理后,需要将每个bucketElementCounts[k]=0!!!! bucketElementCounts[k] = 0; &#125; System.out.println(\"第三轮,对个位的排序处理arr = \" + Arrays.toString(arr)); &#125;&#125; 添加循环123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zjinc36.sort;import java.util.Arrays;public class RadixSort &#123; public void radixSort(int[] arr) &#123; // 1.得到数组中最大的数的位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; // 2. 得到最大的数是几位数 int maxLength = (max + \"\").length(); // 3.定义一个二维数组,表示10个桶,每个桶就是一个一维数组 // 说明 // -&gt; 二维数组包含10个一维数组 // -&gt; 为了防止在放入数的时候,数据溢出,则每个一维数组(桶),大小定为arr.length // -&gt; 基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; // 为了记录每个桶中,实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入数据个数 // bucketElementCounts[0],记录的就是bucket[0]桶的放入数据个数 int[] bucketElementCounts = new int[10]; // 第一轮 for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的个位的值 int digitOfElement = arr[j] / n % 10; // 放入对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据,放入原来数组) int index = 0; // 遍历每一桶,并将桶中的数据放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中有数据,我们才放入到原数组 if (bucketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(即第k个一维数组),放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; // 第i+1轮处理后,需要将每个bucketElementCounts[k]=0!!!! bucketElementCounts[k] = 0; &#125; System.out.println(\"第\" + (i + 1) + \"轮,对个位的排序处理arr = \" + Arrays.toString(arr)); &#125; &#125;&#125; 测试12345678910111213141516package com.zjinc36.sort;import static org.junit.Assert.*;import org.junit.Test;public class RadixSortTest &#123; @Test public void test() &#123; int arr[] = &#123;53, 3, 542, 748, 14, 214&#125;; RadixSort radixSort = new RadixSort(); radixSort.radixSort(arr); &#125;&#125; 基数排序说明 基数排序是对传统桶排序的扩展,速度很快 基数排序是经典的空间换时间的方式,占内存很大,当对海量数据排序时,容易造成OutOfMemoryError 基数排序是稳定的(假定在待排序的记录序列中,存在多个具有相同的关键字的记录,若经过排序,这些记录的相对次序保持不变,即在原序列中,r[i]=r[j],且r[i]在r[j]之前,而在排序后的序列中,r[i]仍在r[j]之前,则称这种排序算法是稳定的,否则称为不稳定的) 有负数的数组,我们不用基数排序来进行排序,入股要支持负数,参考https://code.i-harness.com/zh-CN/q/e98fa9","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现归并排序","date":"2020-04-24T11:55:52.000Z","path":"2020/04/24/Java中实现归并排序/","text":"归并排序介绍归并排序(MERGE-SORT)是利用归并思想实现的排序方法,该算法采用经典的分治(divide-and-conquer)策略(分治法将问题分(divide)成一些小的问题,然后递归求解,而治(conquer)阶段则将分的阶段得到的各答案”修补”在一起,即分而治之) 归并排序思想图示 具体的治阶段我们将两个已经有序的自序列合并成一个有序序列,比如上图中的最后一次合并,我们将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列,合并最终序列[1,2,3,4,5,6,7,8],以下是实现步骤 代码 归并排序代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.zjinc36.sort;import java.util.Arrays;public class MergeSort &#123; public void sort() &#123; int arr[] = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int[] temp = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, temp); System.out.println(Arrays.toString(arr)); &#125; public void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; // 递归这里实现规模减少 int mid = (left + right) / 2; // 向左递归分解 mergeSort(arr, left, mid, temp); // 向右递归分解 mergeSort(arr, mid + 1, right, temp); // 合并 merge(arr, left, mid, right, temp); &#125; &#125; /** * 将逻辑上两个待合并的数组合并为一个数组 * @param arr 排序的原始数组 * @param left 有序序列的最左边索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; // 初始化i,左边有序序列的初始索引 int j = mid + 1; // 初始化j,右边有序序列的初始索引 int t = 0; // 执行temp数组的当前索引 // (一) // 先把左右两边(有序)的数组按照规则填充到temp数组 // 直到左右两边的有序序列中有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; // 如果左边的有序序列的当前元素小于等于右边有序序列的当前元素 // 即将左边的当前元素填充到 temp 数组 if (arr[i] &lt;= arr[j]) &#123;// temp[t] = arr[i];// t++;// i++; temp[t++] = arr[i++]; &#125; else &#123; // 反之,则将右边有序序列的当前元素填充到temp数组 temp[t++] = arr[j++]; &#125; &#125; // (二) // 把剩余数据的一边的数据依次填充到temp while (i &lt;= mid) &#123; // 左边的有序序列还有剩余的元素,就全部填充到temp temp[t++] = arr[i++]; &#125; while (j &lt;= right) &#123; // 右边的有序序列还有剩余的元素,就全部填充到temp temp[t++] = arr[j++]; &#125; // (三) // 将temp数组的元素拷贝到arr // 注意,并不是每次都拷贝所有 t = 0; int tempLeft = left; while (tempLeft &lt;= right) &#123; arr[tempLeft++] = temp[t++]; &#125; &#125;&#125; 对照图解,代码的执行顺序如下 测试 123456789101112131415package com.zjinc36.sort;import static org.junit.Assert.*;import org.junit.Test;public class MergeSortTest &#123; @Test public void test() &#123; MergeSort mergeSort = new MergeSort(); mergeSort.sort(); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现快速排序","date":"2020-04-22T16:54:24.000Z","path":"2020/04/23/Java中实现快速排序/","text":"快速排序算法介绍快速排序算法(QuickSort)是对冒泡排序的一种改进 基本思想是 通过一趟排序将要排序的数据分割成独立的两部分,其中一部分的所有数据都比另外一部分的所有数据都要小 然后按照此方法对这两部分数据分别进行快速排序,这个排序过程可以递归进行,以此达到整个数据变成有序序列 快速排序图解 代码实现 算法实现,这里以中间值为枢纽值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.zjinc36.sort;import java.util.Arrays;public class QuickSort &#123; /** * 快速排序 * @param arr 待排序数组 * @param left 数组的最左边下标 * @param right 数组的最右边下标 * @return */ public void quickSort(int[] arr, int left, int right) &#123; // 左下标 int l = left; // 右下标 int r = right; // 中轴值 int pivot = arr[(left + right) / 2]; int temp = 0; // 临时变量,作为交换时使用 while (l &lt; r) &#123; // 当while退出时,此时l下标对应的值大于中轴值 while (arr[l] &lt; pivot) &#123; l += 1; &#125; // 当while退出时,此时r下标对应的值小于中轴值 while (arr[r] &gt; pivot ) &#123; r -= 1; &#125; // 如果 l &gt;= r 说明pivot的左右两的值,已经按照左边全是小于等于pivot值,右边全部是大于等于pivot值 if (l &gt;= r) &#123; break; &#125; // 交换pivot两边的值 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; // 如果交换完之后,发现 arr[l] == pivot 值 // 是因为前面写的代码中,当arr[l] == pivot的时候,r的规模并不会减少,即无法向循环的退出条件靠近 if (arr[l] == pivot) &#123; r--; &#125; // 和上述同理 // 需要减小l的规模 if (arr[r] == pivot ) &#123; l++; &#125; // 如果 l == r,则必须l++和r--,否则会出现栈溢出,即要向循环的退出条件靠近 if (l == r) &#123; l++; r--; &#125; // 向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; // 向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125; &#125;&#125; 测试 1234567891011121314151617181920package com.zjinc36.sort;import static org.junit.Assert.*;import java.util.Arrays;import org.junit.Test;public class QuickSortTest &#123; @Test public void test() &#123;// int[] arr = &#123;-9, 78, 0, 23, -567, 70, -1&#125;; int[] arr = &#123;78, 23, 23&#125;; QuickSort quickSort = new QuickSort(); quickSort.quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Ubuntu中安装番茄工作法软件gnome-Shell-Pomodoro","date":"2020-04-21T11:17:05.000Z","path":"2020/04/21/Ubuntu中安装番茄工作法软件gnome-shell-pomodoro/","text":"作用 This GNOME app helps to manage time according to Pomodoro Technique. It intends to improve productivity and quality of work by reminding you to take short breaks. Pomodoro Technique is based on two principles: focusing on work for limited time, about half an hour, clearing your mind during breaks.This workflow can improve focus, physical health and mental agility depending on how you spend your breaks and how strictly you follow the routine. 安装最好去官网看 官网地址:https://gnomepomodoro.org/ Ubuntu18.04安装1sudo apt-get install gnome-shell-pomodoro 安装后软件运行效果图","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Java中实现希尔排序(插入排序的改良版)","date":"2020-04-20T18:19:39.000Z","path":"2020/04/21/Java中实现希尔排序(插入排序的改良版)/","text":"希尔排序法介绍 希尔排序是希尔(Donald Shell)与1959年提出的一种排序算法 希尔也是一种插入排序,是简单插入排序经过改进之后的一个更高效的版本,也称为缩小增量排序 希尔排序法的基本思想 希尔排序是把记录按下标的一定增量分组,对每组使用直接插入排序算法排序 随着增量逐渐减少,每组包含的关键字越来越多,当增量减至1时,整个文件恰被分成一组,算法便终止 希尔排序示意图第一轮 首先它把较大的数据集合分割成若干个小组（逻辑上分组,分割长度为arr.length/2），然后对每一个小组分别进行插入排序 由于分割成小组,插入排序所作用的数据量比较小（每一个小组）,所以插入的效率比较高 下面有颜色的是逻辑上的分组，并没有实际地进行分组操作，在数组中的位置还是原来的样子，只是将他们看成这么几个分组（逻辑上分组） 可以看出，它是按下标相隔距离为arr.length/2 = 8/2 = 4分的组，也就是说把下标相差4的分到一组 比如这个例子中a[0]与a[4]是一组、a[1]与a[5]是一组…， 这里的差值（距离）被称为增量 每个分组进行插入排序后，各个分组就变成了有序的了（整体不一定有序）此时，整个数组变的部分有序了（有序程度可能不是很高） 第二轮 然后缩小增量为上个增量的一半:(arr.length/2)/2 = (8/2)/2 = 2，继续划分分组，此时，每个分组元素个数多了，但是，数组变的部分有序了，插入排序效率同样比较高 同理对每个分组进行排序（插入排序），使其每个分组各自有序 第三轮 最后设置增量为上一个增量的一半：1，则整个数组被分为一组，此时，整个数组已经接近有序了，插入排序效率高 同理，对这仅有的一组数据进行排序，排序完成 希尔排序代码实现对有序序列在插入时采用交换法效率差,可以忽略 1234567891011121314151617181920212223242526272829303132package com.zjinc36.sort;import java.util.Arrays;public class ShellSort &#123; private int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 6&#125;; /** * 希尔排序之交换式 */ public void shellSortByExchangeType() &#123; int temp = 0; int count = 0; // 每轮的增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 将数组进行分组 for (int i = gap; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素,步长gap for (int j = i - gap; j &gt;= 0; j -= gap) &#123; // 如果当前元素大于加上步长后的那个元素,说明交换 if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; System.out.println(\"希尔排序第\" + (++count) + \"轮=\" + Arrays.toString(arr)); &#125; &#125;&#125; 对有序序列在插入时采用移动法12345678910111213141516171819202122232425262728293031323334353637383940package com.zjinc36.sort;import java.util.Arrays;public class ShellSort &#123; private int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 6&#125;; public void shellSortByShiftType() &#123; int count = 0; // 每轮的增量 for (int gap = arr.length; gap &gt; 0; gap /= 2) &#123; // 理解上说是分组,但代码中实际实现并不会\"创造\"分组,而是如下进行操作 // -&gt; 从增量长度开始遍历(即跳过每个分组的第一个数) // -&gt; 比如数组: 1 2 4 3 5 7 8 6 // -&gt; 逻辑上分组: 1 4 5 8 // -&gt; 2 3 7 6 // -&gt; 那么从 4 开始遍历 // -&gt; -&gt; 比较 4 和 1,将较小的放前面,此时不需要改变 // -&gt; -&gt; 接下去比较 3 和 2,将较小的放前面,此时不需要改变 // -&gt; -&gt; -&gt; 接下去比较 5 和 4,将较小的放前面,此时不需要改变 // -&gt; -&gt; -&gt; 接下去比较 7 和 3,将较小的放前面,此时不需要改变 // -&gt; -&gt; -&gt; 接下去比较 8 和 5,将较小的放前面,此时不需要改变 // -&gt; -&gt; -&gt; 接下去比较 6 和 7,将较小的放前面,由于6比7小,所以交换位置 // -&gt; -&gt; -&gt; -&gt; -&gt; 由于交换了位置,所以,6还要继续和前面的数字3进行比较,将较小的放前面,此时不需要改变 for (int i = gap; i &lt; arr.length; i++) &#123; int temp = arr[i]; // -&gt; 2. 当增量长度 while (i - gap &gt;= 0 &amp;&amp; temp &lt; arr[i - gap]) &#123; arr[i] = arr[i - gap]; i -= gap; &#125; // 当退出while之后,就给temp找到插入的位置 arr[i] = temp; &#125; System.out.println(\"希尔排序第\" + (++count) + \"轮=\" + Arrays.toString(arr)); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现插入排序","date":"2020-04-20T16:15:28.000Z","path":"2020/04/21/Java中实现插入排序/","text":"插入排序法介绍 插入式排序属于内部排序法,是对于欲排序的元素以插入的方式寻找该元素的适当位置,以达到排序的目的 就像是抽扑克牌,从无序的牌堆中抽取牌,插入手上有序的牌组中12345678910111213想象一下:==&gt; 扑克牌中的抓牌==&gt; 从牌堆(无序数组)中抽牌,插入到手牌上(有序数组)==&gt; 要插入的牌,按顺序和手牌进行比较==&gt; ==&gt; 1. 和手牌(最右边 - 0)的牌进行比较==&gt; ==&gt; ==&gt; 插入的牌较大,退出循环,然后将牌插入被比较牌的右边==&gt; ==&gt; ==&gt; 插入的牌较小,则将被比较的牌向右边移动一位==&gt; ==&gt; 2. 和手牌(最右边 - 1)的牌进行比较==&gt; ==&gt; ==&gt; 插入的牌较大,退出循环,然后将牌插入被比较牌的右边(前一次循环右移了一位,所以被插入牌右边永远有空位)==&gt; ==&gt; ==&gt; 插入的牌较小,则将被比较的牌向右边移动一位==&gt; ==&gt; 3. 和手牌(最右边 - 2)的牌进行比较==&gt; ==&gt; ==&gt; 插入的牌较大,退出循环,然后将牌插入被比较牌的右边(前一次循环右移了一位,所以被插入牌右边永远有空位)==&gt; ==&gt; ==&gt; 插入的牌较小,则将被比较的牌向右边移动一位 插入排序法思想 把n个待排序的元素看成为一个有序表和一个无序表 开始时有序表中只包含一个元素,无序表中包含n-1个元素 排序过程中每次从无序表中取出第一个元素,把它的排序码依次与有序表元素的排序码进行比较,将它插入到有序表中的适当位置,使之成为新的有序表 代码手动实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.zjinc36.sort;import java.util.Arrays;public class InsertSort &#123; private int arr[] = &#123;101, 34, 119, 1&#125;; public void sort() &#123; // 第一轮插入 // 定义待插入的数 int insertVal = arr[1]; int insertIndex = (1 - 1); // 即arr[1]的前面这个数的下标 // 给 insertVal 找到插入的位置 // -&gt; insertIndex &gt;= 0 保证在给insertVal找插入位置,不越界 // -&gt; 将需要插入有序数组的数与有序数组中的每个数字进行比较 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; arr[insertIndex + 1] = insertVal; System.out.println(\"第1轮插入\"); System.out.println(Arrays.toString(arr)); // 第二轮插入 // 定义待插入的数 insertVal = arr[2]; insertIndex = (2 - 1); // 即arr[2]的前面这个数的下标 // 给 insertVal 找到插入的位置 // -&gt; insertIndex &gt;= 0 保证在给insertVal找插入位置,不越界 // -&gt; 将需要插入有序数组的数与有序数组中的每个数字进行比较 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; arr[insertIndex + 1] = insertVal; System.out.println(\"第2轮插入\"); System.out.println(Arrays.toString(arr)); // 第三轮插入 // 定义待插入的数 insertVal = arr[3]; insertIndex = (3 - 1); // 即arr[3]的前面这个数的下标 // 给 insertVal 找到插入的位置 // -&gt; insertIndex &gt;= 0 保证在给insertVal找插入位置,不越界 // -&gt; 将需要插入有序数组的数与有序数组中的每个数字进行比较 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; arr[insertIndex + 1] = insertVal; System.out.println(\"第3轮插入\"); System.out.println(Arrays.toString(arr)); &#125;&#125; 代码手动部分改为循环12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zjinc36.sort;import java.util.Arrays;public class InsertSort &#123; private int arr[] = &#123;101, 34, 119, 1&#125;; public void sort() &#123; for (int i = 1; i &lt; arr.length; i++) &#123; // 想象一下: // ==&gt; 扑克牌中的抓牌 // ==&gt; 从牌堆(无序数组)中抽牌,插入到手牌上(有序数组) // ==&gt; 要插入的牌,按顺序和手牌进行比较 // ==&gt; ==&gt; 1. 和手牌(最右边 - 0)的牌进行比较 // ==&gt; ==&gt; ==&gt; 插入的牌较大,退出循环,然后将牌插入被比较牌的右边 // ==&gt; ==&gt; ==&gt; 插入的牌较小,则将被比较的牌向右边移动一位 // ==&gt; ==&gt; 2. 和手牌(最右边 - 1)的牌进行比较 // ==&gt; ==&gt; ==&gt; 插入的牌较大,退出循环,然后将牌插入被比较牌的右边(前一次循环右移了一位,所以被插入牌右边永远有空位) // ==&gt; ==&gt; ==&gt; 插入的牌较小,则将被比较的牌向右边移动一位 // ==&gt; ==&gt; 3. 和手牌(最右边 - 2)的牌进行比较 // ==&gt; ==&gt; ==&gt; 插入的牌较大,退出循环,然后将牌插入被比较牌的右边(前一次循环右移了一位,所以被插入牌右边永远有空位) // ==&gt; ==&gt; ==&gt; 插入的牌较小,则将被比较的牌向右边移动一位 int insertVal = arr[i]; // 要插入的牌 int insertIndex = (i - 1); // 手牌数组的最大长度 // 给 insertVal(要插入的牌) 找到插入的位置 // ==&gt; insertIndex &gt;= 0 保证在给insertVal找插入位置,不越界 // ==&gt; 将需要插入有序数组的数与有序数组中的每个数字进行比较 // ==&gt; insertVal &lt; arr[insertIndex] 判断要插入的牌比手牌上哪一张牌小 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; // 插入的牌较小,则将被比较的牌向右边移动一位,当前位置被空出来 arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; // 插入的牌较大,退出循环,然后将牌插入被比较牌的右边(前一次循环右移了一位,所以被插入牌右边永远有空位) arr[insertIndex + 1] = insertVal; System.out.println(\"第\" + i + \"轮插入\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现选择排序","date":"2020-04-20T15:20:09.000Z","path":"2020/04/20/Java中实现选择排序/","text":"基本介绍选择排序也属于内部排序法,是从欲排序的数据中,按指定的规则选出某一元素,再依规定交换位置后达到排序的目的 选择排序的思想原始的数组101, 34, 119, 1 第一轮排序对于数组101, 34, 119, 1来说,假定第一个元素101为最小,即设定min=101 用101与34比较,因为101 不小于 34,所以最小值为34,即min=34 用34与119比较,因为34 小于 119,继续 用34与1比较,因为34 不小于 1,所以最小值为1,即min=1 将数组的第一位与最小值所在位置进行交换,所以得到数组1, 34, 119, 101 第二轮排序对于数组1, 34, 119, 101来说,假定第二个元素34为最小,即设定min=34 用34与119比较,因为34 小于 119,继续 用34与101比较,因为34 小于 101,继续 将数组的第二位与最小值所在位置进行交换(这一轮不交换),所以得到数组1, 34, 119, 101 第三轮排序对于数组1, 34, 119, 101来说,假定第三个元素119为最小,即设定min=119 用119与101比较,因为119 不小于 101,所以最小值为101,即min=101 将数组的第三位与最小值所在位置进行交换,所以得到数组1, 34, 101, 119 说明 选择排序一共需要进行数组大小 - 1轮排序 每一轮排序,又是一个循环 第n轮则假定数组中第n位置的这个数是最小的数 然后和n后的每个数进行比较,如果发现当前数更小的数,就重新确定最小数,并得到下标 当遍历到数组最后的时,就得到第n轮时的最小数和下标 交换,第n轮就将当前的最小值与数组中的第n个数交换 代码代码具体演示上述过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.zjinc36.sort;import java.util.Arrays;public class SelectSort &#123; private int arr[] = &#123;101, 34, 119, 1&#125;; /** * 用选择排序将数组从小到大进行排序 */ public void sort() &#123; // 第一轮排序 // 假定最小值与最小值的下标 int minIndex = 0; int min = arr[0]; // 找到数组中最小的数 // 从最小数的后一个数开始比较 for (int j = 0 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; // 第一轮排序,所以将最小值,与第一位数字交换 if (minIndex != 0) &#123; arr[minIndex] = arr[0]; arr[0] = min; &#125; System.out.println(\"第一轮后~~\"); System.out.println(Arrays.toString(arr)); // 第二轮排序 // 由于数组中的第一个数已经排好了,接下去是在剩下的数据中找到最小的数 // 假定最小值是数字中的第二个数字 minIndex = 1; min = arr[1]; // 找到数组中最小的数 // 从最小数的后一个数开始比较 for (int j = 1 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; // 第二轮排序,所以将最小值,与第二位数字交换 if (minIndex != 0) &#123; arr[minIndex] = arr[1]; arr[1] = min; &#125; System.out.println(\"第二轮后~~\"); System.out.println(Arrays.toString(arr)); // 第三轮排序 // 由于数组中的第一个数和第二个数已经排好了,接下去是在剩下的数据中找到最小的数 // 假定最小值是数字中的第三个数字 minIndex = 2; min = arr[2]; // 找到数组中最小的数 // 从最小数的后一个数开始比较 for (int j = 2 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; // 第三轮排序,所以将最小值,与第三位数字交换 if (minIndex != 0) &#123; arr[minIndex] = arr[2]; arr[2] = min; &#125; System.out.println(\"第三轮后~~\"); System.out.println(Arrays.toString(arr)); &#125;&#125; 手动部分用循环表示12345678910111213141516171819202122232425262728293031323334353637package com.zjinc36.sort;import java.util.Arrays;public class SelectSort &#123; private int arr[] = &#123;101, 34, 119, 1&#125;; /** * 用选择排序将数组从小到大进行排序 */ public void sort() &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; // 第一轮排序 // 假定最小值与最小值的下标 int minIndex = i; int min = arr[i]; // 找到数组中最小的数 // 从最小数的后一个数开始比较 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; // 第一轮排序,所以将最小值,与第一位数字交换 if (minIndex != 0) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; System.out.println(\"第\" + i + \"轮后~~\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现冒泡排序","date":"2020-04-16T10:19:51.000Z","path":"2020/04/16/Java中实现冒泡排序/","text":"冒泡排序思路通过对待排序序列从前向后(从下标较小的元素开始),依次比较相邻元素的值,若发现逆序则交换,使较大的元素逐渐从前移向后部,就像水底下的气泡一样逐渐向上冒 冒泡排序(未优化)手动冒泡排序待排序序列: 3, 9, -1, 10, 20 第一趟排序 3, 9, -1, 10, 20 ==&gt; 比较3和9 3, 9, -1, 10, 20 ==&gt; 比较9和-1,逆序所以交换 ==&gt; 3, -1, 9, 10, 20 3, -1, 9, 10, 20 ==&gt; 比较9和10 3, -1, 9, 10, 20 ==&gt; 比较10和20,第一趟结束后,序列的最后一个(此时为20)为最大元素 第二趟排序 3, -1, 9, 10, 20 ==&gt; 比较3和-1,逆序所以交换 ==&gt; -1, 3, 9, 10, 20 -1, 3, 9, 10, 20 // … -1, 3, 9, 10, 20 // 比较9和10,第二趟结束后,序列的倒数第二个(此时为10)为倒数第二大元素 第三趟排序 -1, 3, 9, 10, 20 -1, 3, 9, 10, 20 -1, 3, 9, 10, 20 // 比较3和9,第三趟结束后,9是倒数第三大元素 第四趟排序 -1, 3, 9, 10, 20 // 比较-1和3,第四趟结束,全部排好了 总结 一共进行(数组大小 - 1)次大的循环 每一趟排序的次数在逐渐减少 用代码演示一下演变过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.zjinc36.sort;import java.util.Arrays;public class BubbleSort &#123; int arr[] = &#123;3, 9, -1, 10, 20&#125;; // 为了容易理解,演示一下冒泡排序的演变过程 public void sort() &#123; int temp; // 第1趟排序后的数组 for (int j = 0; j &lt; arr.length - 1 - 0; j++) &#123; // 如果前面数比后面数大,则交换 if (arr[j] &gt; arr[j+1] ) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.println(\"第1趟排序后的数组\"); System.out.println(Arrays.toString(arr)); // 第2趟排序后的数组 for (int j = 0; j &lt; arr.length - 1 - 1; j++) &#123; // 如果前面数比后面数大,则交换 if (arr[j] &gt; arr[j+1] ) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.println(\"第2趟排序后的数组\"); System.out.println(Arrays.toString(arr)); // 第3趟排序后的数组 for (int j = 0; j &lt; arr.length - 1 - 2; j++) &#123; // 如果前面数比后面数大,则交换 if (arr[j] &gt; arr[j+1] ) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.println(\"第3趟排序后的数组\"); System.out.println(Arrays.toString(arr)); // 第4趟排序后的数组 for (int j = 0; j &lt; arr.length - 1 - 3; j++) &#123; // 如果前面数比后面数大,则交换 if (arr[j] &gt; arr[j+1] ) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.println(\"第4趟排序后的数组\"); System.out.println(Arrays.toString(arr)); &#125;&#125; 实现冒泡排序(未优化) 实现 123456789101112131415161718192021222324252627282930313233343536373839package com.zjinc36.sort;import java.util.Arrays;public class BubbleSort &#123; int needSortArray[] = null; // 为了容易理解,演示一下冒泡排序的演变过程 public BubbleSort(int[] needSortArray) &#123; super(); this.needSortArray = needSortArray; &#125; public void sort() &#123; int temp; System.out.println(\"================排序前数组================\"); System.out.println(Arrays.toString(needSortArray)); for (int i = 0; i &lt; needSortArray.length - 1; i++) &#123; // 第i趟排序后的数组 for (int j = 0; j &lt; needSortArray.length - 1 - i; j++) &#123; // 如果前面数比后面数大,则交换 if (needSortArray[j] &gt; needSortArray[j+1] ) &#123; temp = needSortArray[j]; needSortArray[j] = needSortArray[j+1]; needSortArray[j+1] = temp; &#125; &#125;// System.out.println(\"第\" + (i + 1) + \"趟排序后的数组\");// System.out.println(Arrays.toString(needSortArray)); &#125; System.out.println(\"================排序后数组================\"); System.out.println(Arrays.toString(needSortArray)); System.out.println(\"========================================\"); &#125;&#125; 测试 1234567891011121314151617181920package com.zjinc36.sort;import static org.junit.Assert.*;import org.junit.Test;public class BubbleSortTest &#123; @Test public void test() &#123; int arr[] = new int[8]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random()*800000); // 生成一个[0,800000)的数 &#125; BubbleSort bubbleSort = new BubbleSort(arr); bubbleSort.sort(); &#125;&#125; 优化上述代码因为排序的过程中,各元素不断接近自己的位置,如果一趟比较下来没有进行过交换,就说明序列有序,因此可以在排序过程中设置一个flag判断元素是否进行过交换.从而减少不必要的比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.zjinc36.sort;import java.util.Arrays;public class BubbleSort &#123; int needSortArray[] = null; // 为了容易理解,演示一下冒泡排序的演变过程 public BubbleSort(int[] needSortArray) &#123; super(); this.needSortArray = needSortArray; &#125; public void sort() &#123; int temp = 0; // 临时变量 boolean flag = false; // 标识变量,表示是否进行过交换 System.out.println(\"================排序前数组================\"); System.out.println(Arrays.toString(needSortArray)); for (int i = 0; i &lt; needSortArray.length - 1; i++) &#123; // 第i趟排序后的数组 for (int j = 0; j &lt; needSortArray.length - 1 - i; j++) &#123; // 如果前面数比后面数大,则交换 if (needSortArray[j] &gt; needSortArray[j+1] ) &#123; flag = true; temp = needSortArray[j]; needSortArray[j] = needSortArray[j+1]; needSortArray[j+1] = temp; &#125; &#125;// System.out.println(\"第\" + (i + 1) + \"趟排序后的数组\");// System.out.println(Arrays.toString(needSortArray)); if (!flag) &#123; // 在一趟排序中,一次交换都没有发生过 break; &#125; else &#123; flag = false; // 重置flag!!!,进行下次判断 &#125; &#125; System.out.println(\"================排序后数组================\"); System.out.println(Arrays.toString(needSortArray)); System.out.println(\"========================================\"); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"排序算法的与分类","date":"2020-04-15T16:58:46.000Z","path":"2020/04/16/排序算法的与分类/","text":"排序算法的介绍排序也称排序算法(Sort Algorithm),排序是将一组数据,依指定的顺序进行排列的过程 排序的分类： 内部排序: 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。 常见的排序算法分类如下:","tags":[]},{"title":"尾递归","date":"2020-04-14T17:03:08.000Z","path":"2020/04/15/尾递归/","text":"要说尾递归先理解尾调用尾调用定义 来自尾调用维基百科 在计算机学里，尾调用是指一个函数里的最后一个动作是返回一个函数的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果 代码形式上表现为一个函数执行的最后是调用另一个函数 123456//仅举例,没有使用特定语言的语法function f(x) &#123; a(x); b(x); return g(x); //函数执行的最后调用另一个函数&#125; 核心理解就是看一个函数在调用另一个函数得时候，本身是否可以被“释放” 判断:下列那种调用时尾调用12345678910111213141516171819202122// 情况一function f(x)&#123; int a = g(x); return a;&#125;// 情况二function f(x)&#123; return 3+g(x);&#125;// 情况三function f(x)&#123; if (x &gt; 0) &#123; return g(x); &#125; return r(x);&#125; 答案 情况一是调用函数g(x)之后，还有别的操作，所以不属于尾调用，即使语义一样，因为要得到a得结果，需要等待g(x)函数，所以f(x)无法释放。 情况二在调用后也有别的操作，所以不属于尾调用，同理f(x)也是无法释放，即使写在同一行。 情况三中，不管x取什么值，最后一步操作都是函数调用，所以属于尾调用。 尾调用有什么好处先看普通调用的过程123456789101112131415161718//用如下三个函数举例function f(x)&#123; res = g(x); return res+1;&#125;function g(x)&#123; res = r(x); return res + 1;&#125;function r(x)&#123; res = x + 1; return res + 1;&#125; 文字描述函数调用 调用f(x)，在内存形成一个调用记录，又称调用帧（call frame），保存调用位置和内部变量等信息。 函数f(x)内调用函数g(x)，那么在f(x)的调用帧上方会形成一个g(x)的调用帧 函数g(x)内部还调用函数r(x)，所以在g(x)的调用帧上方会形成一个r(x)的调用帧 函数r(x)调用结束，将结果返回给g(x)，同时函数r(x)结束并“消失” 同理，g(x)调用结束并“消失” 最后到f(x)，结束并消失（图中没有体现）上述调用过程中，所有的调用帧会在一个调用栈（call stack）中 上述过程维基百科中的描述 在程序运行时，计算机会为应用程序分配一定的内存空间；应用程序则会自行分配所获得的内存空间，其中一部分被用于记录程序中正在调用的各个函数的运行情况，这就是函数的调用栈。常规的函数调用总是会在调用栈最上层添加一个新的堆栈帧（stack frame，也翻译为“栈帧”或简称为“帧”），这个过程被称作“入栈”或“压栈”（意即把新的帧压在栈顶）。 上述调用过程中有什么风险如下图，当函数的调用层数非常多时，调用栈会消耗不少内存，甚至会撑爆内存空间（栈溢出），造成程序严重卡顿或意外崩溃。 尾调用解决上述风险12345678910111213141516//这是一个尾调用function f() &#123; m = 1; n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上述代码,我们可以看到，我们调用g之后，和f就没有任何关系了，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录， 尾调用的意义如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧为一，这将大大节省内存 什么是尾递归尾递归 = 尾调用 + 递归 递归：函数调用自身，称为递归 尾调用：函数最后是调用另一个函数所以，尾递归可以总结为：一个函数在其内部最后一步调用其自身1234567#用python举例def tailrecsum(x, running_total=0): if x == 0: return running_total else: #tailrecsum函数得最后一步是调用另一个函数，其中这个“另一个函数”是其自身 return tailrecsum(x - 1, running_total + x) 参考尾调用尾调用优化Tail Calls, Default Arguments, and Excessive Recycling in ES-6什么是尾调用漫谈递归：从斐波那契开始了解尾递归","tags":[]},{"title":"Java中实现递归","date":"2020-04-14T16:22:56.000Z","path":"2020/04/15/Java中实现递归/","text":"递归的概念 简单的说,递归就是方法自己调用自己,每次调用时传入不同的变量 递归的好处 递归有助于编程者解决复杂的问题,同时可以让代码变得简洁 递归调用规则 当程序执行到一个方法时,就会开辟一个独立的空间(栈) 每个空间的数据(局部变量),是独立的 代码演示 12345678910111213141516171819202122232425262728package com.young.recursion;public class RecursionTest &#123; public static void main(String[] args) &#123; // test(10); int factorial = factorial(3); System.out.println(factorial); &#125; //打印问题 public static void test(int n) &#123; if (n &gt; 2) &#123; test(n - 1); &#125;//else &#123; System.out.println(\"n=\" + n); //&#125; &#125; //阶乘问题 public static int factorial(int n) &#123; if (n == 1) &#123; return n; &#125; else &#123; return factorial(n - 1) * n; &#125; &#125;&#125; 递归能解决什么样的问题 各种数学问题 八皇后问题 汉诺塔 阶乘问题 迷宫问题 球和篮子的问题(google变成大赛) 各种算法中也会使用到递归 快排 归并排序 二分查找 分治算法 将用栈解决的问题,用递归代码会比较简洁 递归需要遵守的重要规则 执行一个方法时,就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的,不会相互影响 如果方法中使用的是引用类型变量(比如数组),就会共享该引用类型的数据 递归必须向退出递归的条件逼近,否则就是无限递归,会出现StackOverflowError错误 当一个方法执行完毕,或者遇到return,就会返回,遵守谁调用就将结果返回给谁,同时当方法执行完毕或者返回时,该方法也就执行完毕 迷宫问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class MiGong &#123; public static void main(String[] args) &#123; //先创建一个二维数组，模拟迷宫地图 int[][] map = new int[8][7]; //使用1表示墙 //上下全部置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; //左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置挡板, 1表示 map[3][1] = 1; map[3][2] = 1; //输出地图 System.out.println(\"地图的情况\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; // 使用递归回溯给小球找路 setWay(map, 1, 1); // 输出新的地图,小球走过,并标识过的递归 System.out.println(\"小球走过,并标识过地图的情况\"); for (int i=0; i&lt;8; i++) &#123; for (int j=0; j&lt;7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; /** //使用递归回溯来给小球找路 //说明 //1. map表示地图 //2. i,j 表示从地图的哪个位置开始出发(1,1) //3. 如果小球能到map[6][5]位置，则说明通路找到. . //4. 约定:当map[i][j] 为0表示该点没有走过当为1表示墙; 2表示通路可以走; 3表示该点已经走过，但是走不通 //5. 在走迷宫时，需要确定-个策略(方法)：下-&gt;右-&gt;上-&gt;左 ，如果该点走不通，再回溯 * @param map 表示地图 * @param i 从哪个位置开始找 * @param j 从哪个位置开始找 * @return 如果找到通路,就返回true, 否则返回false */ public static boolean setWay(int[][] map, int i, int j) &#123; //小球的位置是(6,5) 对应数组则是map[6][5] if(map[6][5] == 2) &#123; //到map[6][5]位置,说明球已找到 return true; &#125; else &#123; //判断到地图map[i][j]是0，则代表这个点还没有走过 if (map[i][j] == 0) &#123; //假设这个点是可以走通的，然后按照策略：下一&gt;右-&gt;上-&gt;左走 map[i][j] = 2; if (setWay(map, i + 1, j)) &#123;//向下走 return true; &#125; else if (setWay(map, i, j + 1)) &#123; //向右走 return true; &#125; else if (setWay(map, 1 - 1, j)) &#123; //向上 return true; &#125; else if (setWay(map, i, j - 1)) &#123; //向左走 return true; &#125;else &#123; //说明该点是走不通，已经走过，是死路 map[i][j] =3; return false; &#125; &#125; else&#123; //如果map[i][j] != 0 ,可能是1, 2, 3 //当为1表示墙; 2表示通路可以走; 3表示该点已经走过 return false; &#125; &#125; &#125;&#125; 八皇后问题问题介绍八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 思路分析 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列,然后判断是否OK,如果不OK,继续放在第二列,第三列,依次把所有列都放完,找到一个合适 继续放第三个皇后,还是第一列,第二列…,知道第八个皇后也能放在一个不冲突的位置,算是找到了一个正确解 当得到一个正确解时,在栈回退到上一个栈时,就会开始回溯,即将第一个皇后,放到第一列的所有正确解全部得到 然后回头继续第一个皇后放第二列,后面继续循环执行1,2,3,4的步骤 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class WolfQueen &#123; /** * 一共有多少个皇后（此时设置为8皇后在8X8棋盘，可以修改此值来设置N皇后问题） */ int max = 8; /** * 该数组保存结果，第一个皇后摆在array[0]列，第二个摆在array[1]列 */ int[] array = new int[max]; public static void main(String[] args) &#123; new WolfQueen().check(0); &#125; /** * n代表当前是第几个皇后 * @param n * 皇后n在array[n]列 */ private void check(int n) &#123; //终止条件是最后一行已经摆完，由于每摆一步都会校验是否有冲突，所以只要最后一行摆完，说明已经得到了一个正确解 if (n == max) &#123; print(); return; &#125; //从第一列开始放值，然后判断是否和本行本列本斜线有冲突，如果OK，就进入下一行的逻辑 for (int i = 0; i &lt; max; i++) &#123; array[n] = i; if (judge(n)) &#123; check(n + 1); &#125; &#125; &#125; /** * 判断我们放置的第n个皇后是否和前面已经摆放的皇后有冲突 * @param n 表示第n个皇后 * @return */ private boolean judge(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; // array[i] == array[n] // -&gt; 判断第n个皇后和前面的皇后是否在同一列 // Math.abs(n - i) == Math.abs(array[n] - array[i] // -&gt; 判断第n个皇后和前面的皇后是否在同一斜线 // -&gt; 这是一个一次函数 // -&gt; 总共数据就只有7个,所以只需满足|y1 - y2| == |x1 - x2|就能保证是一条斜线了 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; private void print() &#123; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + 1 + \" \"); &#125; System.out.println(); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Ubuntu中安装kchmviewer用以打开chm文件","date":"2020-04-09T08:55:53.000Z","path":"2020/04/09/Ubuntu中安装kchmviewer用以打开chm文件/","text":"软件名称1KchmViewer 软件介绍 http://www.ulduzsoft.com/linux/kchmviewer/ Kchmviewer is a free, open-source CHM (aka MS HTML help) and EPUB viewer written in C++ for Unix, Mac and Windows systems. Unlike most existing CHM viewers for Unix, it uses Trolltech Qt widget library, and could optionally be compiled for better KDE integration. It does not require KDE, but may be compiled with KDE widget support. Since version 5.0 it uses the Webkit API to show the content. The main advantage of kchmviewer is the best support for non-English languages. Unlike other viewers, kchmviewer in most cases is able to correctly detect the chm file encoding and show it. It correctly shows the index and table of context in Russian, Spanish, Romanian, Korean, Chinese and Arabic help files, and with new search engine is able to search in any chm file no matter what language it is written. kchmviewer is written by George Yunaev, and is licensed under GNU General Public License version 3. It uses chmlib to handle the CHM files, and some ideas from xchm. 作用用以打开.chm文件 安装方法1sudo apt-get install kchmviewer 出现乱码如何处理","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Java中栈的「前缀」「中缀」「后缀」表达式","date":"2020-04-02T21:06:47.000Z","path":"2020/04/03/Java中栈的「前缀」「中缀」「后缀」表达式/","text":"前缀表达式(波兰表达式)什么是前缀表达式 前缀表达式又称之为波兰式,前缀表达式的运算符位于操作数之前 举例说明:(3+4)*5-6对应的前缀表达式就是- * + 3 4 5 6 前缀表达式的计算机求值思路 从右至左扫描表达式 遇到数字时,将数字压入堆栈 遇到运算符时,弹出栈顶的两个数,用运算符对它们做相应的计算(栈顶元素和次栈顶元素),并将结果入栈 重复上述过程,直到表达式最左端 最后运算得出的值即为表达式的结果 举例举例说明:(3+4)*5-6对应的前缀表达式就是- * + 3 4 5 6,针对前缀表达式求值步骤如下: 从右至左扫描 遇到数字6,5,4,3,将数字压入栈 遇到+运算符,因此弹出3和4(3为栈顶元素,4为次栈顶元素),计算出3+4的值,得7,再将7入栈 接下来,是*运算符,因此弹出7和5,计算出7*5=35,将35入栈 最后是-运算符,计算出35-6的值,即29,由此得出最终结果 中缀表达式什么是中缀表达式 中缀表达式就是常见的运算表达式,如(3+4)*5-6 中缀表达式的求值是我们人最熟悉的,但是对计算机来说却不好操作(如下案例),因此,在计算结果时,往往会将中缀表达式转成其他表达式来操作(一般转成后缀表达式) 使用栈(中缀表达式)来实现综合计算器计算:7*2*2-5+1-5+3-3 思路分析 通过一个index来遍历我们的表达式 如果我们发现是一个数字,就直接入数栈 如果发现扫描到一个符号,就分如下情况 如果当前符号栈为空,就直接入栈 如果当前符号栈有符号,就进行比较 如果当前的操作符号优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,从符号栈中pop出一个符号,进行运算,将得到的结果入数栈.然后将当前的操作符入符号栈 如果当前的操作符的优先级大于栈中的操作符,就直接入符号栈 当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号,并运行 最后在数栈中只有一个数字,就是表达式的结果 代码用数组模拟栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.zjinc36.stack;public class ArrayStack &#123; private int maxSize; // 栈的大小 private int[] stack; // 模拟栈用数组 private int top = -1; // top表示栈顶,初始化为-1 public ArrayStack(int maxSize) &#123; super(); this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; /** * 栈满 * @return */ public boolean isFull() &#123; return top == maxSize - 1; &#125; /** * 栈空 * @return */ public boolean isEmpty() &#123; return top == -1; &#125; /** * 入栈 * @param value */ public void push(int value) &#123; // 先判断栈是否已满 if (isFull()) &#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] = value; &#125; /** * 出栈 * @return */ public int pop() &#123; // 先判断栈是否为空 if (isEmpty()) &#123; throw new RuntimeException(\"栈空\"); &#125; // 获取此时栈顶的值 int value = stack[top]; // 将栈顶的值置为默认 stack[top] = 0; top--; return value; &#125; /** * 显示栈 */ public void list() &#123; if (isEmpty()) &#123; System.out.println(\"栈空\"); return; &#125; // 需要从栈顶开始遍历 for (int i = top; i &gt;= 0; i--) &#123; System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); &#125; &#125; /** * 查看当前栈顶的值 * @return */ public int peek() &#123; return stack[top]; &#125;&#125; 计算器类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package com.zjinc36.stack;public class Calculator &#123; // String expression = \"5-3+3\"; private String expression = \"\"; public Calculator(String expression) &#123; super(); this.expression = expression; &#125; /** * 进行计算 * 思路 * 1.通过一个index来遍历我们的表达式 * 2.如果我们发现是一个数字,就直接入数栈 * 3.如果发现扫描到一个符号,就分如下情况 * -&gt; 3.1 如果当前符号栈为空,就直接入栈 * -&gt; 3.2 如果当前符号栈有符号,就进行比较 * -&gt; -&gt; 3.3 如果当前的操作符号优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数, * -&gt; -&gt; 从符号栈中pop出一个符号,进行运算,将得到的结果入数栈.然后将当前的操作符入符号栈 * -&gt; -&gt; 3.4 如果当前的操作符的优先级大于栈中的操作符,就直接入符号栈 * 4.当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号,并运行 * 5.最后在数栈中只有一个数字,就是表达式的结果 */ public void calResult() &#123; // 创建两个栈,数栈和符号栈 ArrayStack numStack = new ArrayStack(10); ArrayStack operStack = new ArrayStack(10); // 定义需要的相关变量 int index = 0; // 用于扫描 int num1 = 0; // 先出栈的数 int num2 = 0; // 后出栈的数 int oper = 0; int res = 0; char ch = ' '; //将每次扫描的到的char保存到ch String keepNum = \"\"; //用于拼接多位数 // 扫描数字和符号进行入栈 while (true) &#123; // 1.通过一个index来遍历我们的表达式 ch = expression.substring(index, index+1).charAt(0); // 判断是数字还是字符 // 2.如果我们发现是一个数字,就直接入数栈 // 3.如果发现扫描到一个符号,就分如下情况 if (isOper(ch)) &#123; // 3.1 如果当前符号栈为空,就直接入栈 // 3.2 如果当前符号栈有符号,就进行比较 if (operStack.isEmpty()) &#123; operStack.push(ch); &#125; else &#123; // 3.3 如果当前的操作符号优先级小于或者等于栈中的操作符, // 就需要从数栈中pop出两个数,从符号栈中pop出一个符号,进行运算, // 将得到的结果入数栈.然后将当前的操作符入符号栈 // 3.4 如果当前的操作符的优先级大于栈中的操作符,就直接入符号栈 if (priority(ch) &lt;= priority(operStack.peek())) &#123; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = cal(num1, num2, oper); // 把运算结果入数栈 numStack.push(res); // 然后将当前的操作符号入符号栈 operStack.push(ch); &#125; else &#123; operStack.push(ch); &#125; &#125; &#125; else &#123; // 如果是数,则直接入栈 // -&gt; 这里需要处理数字是不是多位数 // 思路: // -&gt; 1.当处理多位数时,不能当前字符是数就立即入栈,因为它后一位也可能是数字 // -&gt; 2.在处理数时,需要向expression的表达式的index后再看一位,如果是数就进行扫描,如果是符号才入栈 // -&gt; 3.因此,我们需要定义一个变量字符串,用于拼接 // 处理多位数 keepNum += ch; // 如果ch已经是expression的最后一位,就直接入栈 if (index == expression.length() - 1) &#123; numStack.push(Integer.parseInt(keepNum)); &#125; else &#123; // 判断下一个字符是不是数字,如果是数字,就继续扫描,如果是运算符,则入栈 if (isOper(expression.substring(index+1, index+2).charAt(0))) &#123; numStack.push(Integer.parseInt(keepNum)); // keepNum要记得清空 keepNum = \"\"; &#125; &#125; &#125; // 让index + 1, 并判断是否扫描到expression最后 index++; if (index &gt;= expression.length()) &#123; break; &#125; &#125; // 4.当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号,并运行 while (true) &#123; // 如果符号栈为空,则计算到最后的结果,数栈中只有一个数字 if (operStack.isEmpty()) &#123; break; &#125; num1 = numStack.pop(); num2 = numStack.pop(); oper = operStack.pop(); res = cal(num1, num2, oper); numStack.push(res); &#125; // 5.最后在数栈中只有一个数字,就是表达式的结果 int calRes = numStack.pop(); System.out.printf(\"表达式%s = %d\", expression, calRes); &#125; /** * 判断是不是一个运算符 * * @param val * @return */ private boolean isOper(char val) &#123; return val == '+' || val == '-' || val == '*' || val == '/'; &#125; /** * 计算 * * @param num1 * @param num2 * @param oper * @return */ private int cal(int num1, int num2, int oper) &#123; int res = 0; // 用于存放计算结果 switch (oper) &#123; case '+': res = num1 + num2; break; case '-': res = num2 - num1; // 注意参数的顺序 break; case '*': res = num2 * num1; break; case '/': res = num2 / num1; break; default: break; &#125; return res; &#125; /** * 返回运算符的优先级 * -&gt; 暂时只考虑四则运算(+,-,*,/) * -&gt; 这里使用数字表示优先级 * -&gt; 数字越大,则优先级越高 * @param oper * @return */ public int priority(int oper) &#123; if (oper == '*' || oper == '/') &#123; return 1; &#125; else if (oper == '+' || oper == '-') &#123; return 0; &#125; else &#123; return -1; &#125; &#125;&#125; 测试结果1234567891011121314151617181920package com.zjinc36.stack;import static org.junit.Assert.*;import java.util.Scanner;import org.junit.Test;public class ArrayStackTest &#123; /** * 计算表达式的值 */ @Test public void testCalculator() &#123; String expression = \"5-3*3\"; Calculator calculator = new Calculator(expression); calculator.calResult(); &#125;&#125; 后缀表达式什么是后缀表达式 后缀表达式又称之为逆波兰表达式,与前缀表达式相似,只是运算符位于操作数之后 后缀表达式举例说明:(3+4)*5-6对应的后缀表达式就是3 4 + 5 * 6 - 再比如 正常的表达式 逆波兰表达式 a + b a b + a + (b - c) a b c - + a + (b - c) * d a b c - d * + a + d * (b - c) a d b c - * + a = 1 + 3 a 1 3 + = 后缀表达式的计算机求值思路 从左至右扫描表达式 遇到数字时,将数字压入栈顶 遇到运算符时,弹出栈顶的两个数,用运算符对它们做相应的运算(次栈顶元素和栈顶元素),并将结果入栈 重复上述过程直到表达式最右端 最后运算得出的值即为表达式的结果 举例例如:(3+4)*5-6对应的后缀表达式就是3 4 + 5 * 6 -,针对后缀表达式求值步骤如下: 从左至右扫描,将3和4压入堆栈 遇到+运算符,因此弹出4和3(4为栈顶元素,3为次栈顶元素),计算出3+4的值,得7,再将7入栈 将5入栈 接下来是*运算符,因此弹出5和7,计算出7*5=35,将35入栈 将6入栈 最后是-运算符,计算出35-6的值,即29,由此得出最终结果 实现逆波兰计算器目标实现一个逆波兰计算器,要求完成如下任务 输入一个逆波兰表达式(后缀表达式),使用Java的栈(Stack),计算结果. 这里暂时输入的是逆波兰表达式 后面会说明如何用中缀表达式转后缀表达式 支持小括号和多位整数 这里主要为了说明数据结构,因此计算器进行简化,只支持整数的计算 代码 实现逆波兰表达式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.zjinc36.stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation &#123; private String suffixExpression; public PolandNotation(String suffixExpression) &#123; super(); this.suffixExpression = suffixExpression; &#125; public void calResult() &#123; // 先定义一个逆波兰表达式 // (3+4)*5-6 =&gt; 3 4 + 5 * 6 - // 为了说明方便,逆波兰表达式的数字和符号使用空格隔开// String suffixExpression = \"3 4 + 5 * 6 - \"; List&lt;String&gt; suffixList = getListString(suffixExpression); int res = calculate(suffixList); System.out.println(\"计算的结果是 = \" + res); &#125; /** * 将一个逆波兰表达式字符串进行分割后,依次将数据和运算符放入 ArrayList 中 * @param suffixExpression * @return */ public List&lt;String&gt; getListString(String suffixExpression) &#123; // 将 suffixExpression 分割 String[] split = suffixExpression.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String element : split) &#123; list.add(element); &#125; return list; &#125; /** * 完成对逆波兰表达式的运算 * 思路 * 例如:(3+4)*5-6对应的后缀表达式就是3 4 + 5 * 6 -,针对后缀表达式求值步骤如下: * 1. 从左至右扫描,将3和4压入堆栈 * 2. 遇到+运算符,因此弹出4和3(4为栈顶元素,3为次栈顶元素),计算出3+4的值,得7,再将7入栈 * 3. 将5入栈 * 4. 接下来是*运算符,因此弹出5和7,计算出7*5=35,将35入栈 * 5. 将6入栈 * 6. 最后是-运算符,计算出35-6的值,即29,由此得出最终结果 * @param suffixlist * @return */ public int calculate(List&lt;String&gt; suffixList) &#123; // 创建一个栈(这里只需要一个栈) Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); // 遍历 suffixList // 即 -&gt; 1.从左至右扫描 for (String item : suffixList) &#123; // 这里使用正则表达式来取出数 // 即 -&gt; 1. 将 3 4 压入栈 if (item.matches(\"\\\\d+\")) &#123; // 匹配的是多位数 // 入栈 stack.push(item); &#125; else &#123; // 2.遇到+运算符... int stackTopElement = Integer.parseInt(stack.pop()); // 栈顶元素 int stackNextTopElement = Integer.parseInt(stack.pop()); // 次栈顶元素 int res = 0; if (item.equals(\"+\")) &#123; res = stackTopElement + stackNextTopElement; &#125; else if (item.equals(\"-\")) &#123; res = stackNextTopElement - stackTopElement; &#125; else if (item.equals(\"*\")) &#123; res = stackTopElement * stackNextTopElement; &#125; else if (item.equals(\"/\")) &#123; res = stackNextTopElement / stackTopElement; &#125; else &#123; throw new RuntimeException(); &#125; // 2.计算出3+4的值,得7,在将7入栈 stack.push(\"\" + res); // 这里需要将数字转换成字符串 &#125; &#125; // 最后留在stack中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125; 测试 123456789101112131415package com.zjinc36.stack;import static org.junit.Assert.*;import org.junit.Test;public class PolandNotationTest &#123; @Test public void testCalResult() &#123; String suffixExpression = \"3 4 + 5 * 6 - \"; PolandNotation polandNotation = new PolandNotation(suffixExpression); polandNotation.calResult(); &#125;&#125; 中缀表达式转后缀表达式从上述代码中可以看出,后缀表达式适合计算式进行计算,但是人却不太容易写出来,尤其是在表达式很长的情况下,因此,在开发中,我们需要将中缀表达式转成后缀表达式 中缀表达式转后缀表达式的思路 初始化两个栈:运算符栈s1和储存中间结果的栈s2 从左至右扫描中缀表达式 遇到操作数(数字)时,将其压入s2 遇到运算符时,比较其与s1栈顶运算符的优先级 如果s1为空,或栈顶运算符为左括号”(“,则直接将此运算符入栈 否则,若优先级比栈顶运算符的高,将运算符压入s1 否则,将s1栈顶的运算符弹出并压入到s2中,再次转到步骤4与s1中新的栈顶运算符相比较 遇到括号时 如果是左括号”(“,则直接压入s1 如果是右括号”)”,则依次弹出s1栈顶的运算符,并压入s2,直到遇到左括号为止,此时将这一对括号丢弃 重复步骤2至5,知道表达式的最右边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出,结果的逆序即为中缀表达式对应的后缀表达式 举例说明将中缀表达式1+((2+3)*4)-5转换为后缀表达式,结果为1 2 3 + 4 * + 5 -,过程如下: 扫描到的元素 s2(栈底-&gt;栈顶) s1(栈底-&gt;栈顶) 说明 1 1 空 数字,直接入s2栈 + 1 + s1为空,运算符直接入s1栈 ( 1 + ( 左括号,直接入s1栈 ( 1 + ( ( 左括号,直接入s1栈 2 1 2 + ( ( 数字,直接入s2栈 + 1 2 + ( ( + s1栈顶为左括号,运算符直接入栈 3 1 2 3 + ( ( + 数字 ) 1 2 3 + + ( 右括号,弹出运算符直至遇到左括号 * 1 2 3 + + ( * s1栈顶元素为左括号,运算符直接入栈 4 1 2 3 + 4 + ( * 数字 ) 1 2 3 + 4 * + 右括号,弹出运算符直至遇到左括号 - 1 2 3 + 4 * + - -与+优先级相同,因此弹出+,在压入- 5 1 2 3 + 5 * + 5 - 数字 到达最右端 1 2 3 + 5 * + 5 - 空 s1中剩余的运算符 代码实现 上述思路实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218package com.zjinc36.stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;import lombok.Data;@Datapublic class PolandNotation &#123; private String infixExpression; public void calResult() &#123; // 获取输入的中缀表达式,并放入List中 List&lt;String&gt; infixExpressionList = convertInfixExpressionToList(infixExpression); System.out.println(\"中缀表达式对应的 List = \" + infixExpressionList); // 将中缀表达式转成后缀表达式 List&lt;String&gt; suffixExpressionList = parseSuffixExpreesionList(infixExpressionList); System.out.println(\"后缀表达式对应的 List = \" + suffixExpressionList); int res = calculate(suffixExpressionList); System.out.printf(\"expression=%d\", res); &#125; /** * 将中缀表达式转成对应的List * @return */ public List&lt;String&gt; convertInfixExpressionToList(String s) &#123; // 定义一个List,存放中缀表达式 List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i = 0; // 这是一个指针,用于遍历中缀表达式字符串 String str; // 对多位数的拼接 char c; // 每遍历到一个字符,就放入到c do &#123; // 如果c是一个非数字,就加入到ls if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) &#123; ls.add(\"\" + c); i++; // i需要后移 &#125; else &#123; // 如果是一个数字,就需要考虑这个数字是否是多位数 str = \"\"; // 先将str置为\"\" '0'[48]-&gt;'9'[57] while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) &#123; str += c; // 拼接 i++; &#125; ls.add(str); &#125; &#125; while (i &lt; s.length()); return ls; // 返回 &#125; /** * 将得到的中缀表达式对应的List转成后缀表达式对应的List * 思路 * 1.初始化两个栈:运算符栈s1和储存中间结果的栈s2 * 2.从左至右扫描中缀表达式 * 3.遇到操作数(数字)时,将其压入s2 * 4.遇到运算符时,比较其与s1栈顶运算符的优先级 * -&gt; -&gt; 4.1 如果s1为空,或栈顶运算符为左括号”(“,则直接将此运算符入栈 * -&gt; -&gt; 4.2 否则,若优先级比栈顶运算符的高,将运算符压入s1 * -&gt; -&gt; 4.3 否则,将s1栈顶的运算符弹出并压入到s2中,再次转到步骤4与s1中新的栈顶运算符相比较 * 5.遇到括号时 * -&gt; -&gt; 5.1 如果是左括号”(“,则直接压入s1 * -&gt; -&gt; 5.2 如果是右括号”)”,则依次弹出s1栈顶的运算符,并压入s2,直到遇到左括号为止,此时将这一对括号丢弃 * 6.重复步骤2至5,知道表达式的最右边 * 7.将s1中剩余的运算符依次弹出并压入s2 * 8.依次弹出s2中的元素并输出,结果的逆序即为中缀表达式对应的后缀表达式 * @param ls * @return */ public List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123; // 1.初始化两个栈:运算符栈s1和储存中间结果的栈s2 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈 // -&gt; 理论上需要定义两个栈 // -&gt; 因为s2这个栈在整个转换过程中,没有pop操作,而且后面我们还需要逆序输出 // -&gt; 所以,我们这里不用Stack&lt;String&gt; s2,而是直接使用 List&lt;String&gt; s2 // -&gt; 即,不使用 Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); ArrayList&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); // 2.从左至右扫描中缀表达式 for (String item : ls) &#123; // 3.遇到操作数(数字)时,将其压入s2 if (item.matches(\"\\\\d+\")) &#123; s2.add(item); &#125; else if (item.equals(\"(\")) &#123; // 5.1 如果是左括号”(“,则直接压入s1 s1.push(item); &#125; else if (item.equals(\")\")) &#123; //5.2 如果是右括号”)”,则依次弹出s1栈顶的运算符,并压入s2,直到遇到左括号为止,此时将这一对括号丢弃 while (!s1.peek().equals(\"(\")) &#123; s2.add(s1.pop()); &#125; s1.pop(); // 弹出\"(\",消除小括号 &#125; else &#123; // 4.遇到运算符时,比较其与s1栈顶运算符的优先级 // 4.3 当item的优先级小于等于s1栈顶运算符,将s1栈顶的运算符弹出并加入到s2中,在次转到4与s1中新的栈顶运算符相比较 while (s1.size() != 0 &amp;&amp; operatorPrecedence(s1.peek()) &gt;= operatorPrecedence(item)) &#123; s2.add(s1.pop()); &#125; // 4.1 如果s1为空,或栈顶运算符为左括号”(“,则直接将此运算符入栈 // 4.2 否则,若优先级比栈顶运算符的高,将运算符压入s1 s1.push(item); &#125; &#125; // 7.将s1中剩余的运算符依次弹出并压入s2 while (s1.size() != 0) &#123; s2.add(s1.pop()); &#125; // 注意因为是存放到List,因此按顺序输出就是对应的后缀表达式对应的List return s2; &#125; /** * 将一个逆波兰表达式字符串进行分割后,依次将数据和运算符放入 ArrayList 中 * @param suffixExpression * @return */ public List&lt;String&gt; getListString(String suffixExpression) &#123; // 将 suffixExpression 分割 String[] split = suffixExpression.split(\" \"); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (String element : split) &#123; list.add(element); &#125; return list; &#125; /** * 完成对逆波兰表达式的运算 * 思路 * 例如:(3+4)*5-6对应的后缀表达式就是3 4 + 5 * 6 -,针对后缀表达式求值步骤如下: * 1. 从左至右扫描,将3和4压入堆栈 * 2. 遇到+运算符,因此弹出4和3(4为栈顶元素,3为次栈顶元素),计算出3+4的值,得7,再将7入栈 * 3. 将5入栈 * 4. 接下来是*运算符,因此弹出5和7,计算出7*5=35,将35入栈 * 5. 将6入栈 * 6. 最后是-运算符,计算出35-6的值,即29,由此得出最终结果 * @param suffixlist * @return */ public int calculate(List&lt;String&gt; suffixList) &#123; // 创建一个栈(这里只需要一个栈) Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); // 遍历 suffixList // 即 -&gt; 1.从左至右扫描 for (String item : suffixList) &#123; // 这里使用正则表达式来取出数 // 即 -&gt; 1. 将 3 4 压入栈 if (item.matches(\"\\\\d+\")) &#123; // 匹配的是多位数 // 入栈 stack.push(item); &#125; else &#123; // 2.遇到+运算符... int stackTopElement = Integer.parseInt(stack.pop()); // 栈顶元素 int stackNextTopElement = Integer.parseInt(stack.pop()); // 次栈顶元素 int res = 0; if (item.equals(\"+\")) &#123; res = stackTopElement + stackNextTopElement; &#125; else if (item.equals(\"-\")) &#123; res = stackNextTopElement - stackTopElement; &#125; else if (item.equals(\"*\")) &#123; res = stackTopElement * stackNextTopElement; &#125; else if (item.equals(\"/\")) &#123; res = stackNextTopElement / stackTopElement; &#125; else &#123; throw new RuntimeException(); &#125; // 2.计算出3+4的值,得7,在将7入栈 stack.push(\"\" + res); // 这里需要将数字转换成字符串 &#125; &#125; // 最后留在stack中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125; /** * 返回运算符号的优先级 * -&gt; 优先级用数字表示 * @param operation * @return */ public int operatorPrecedence(String operation) &#123; int result = 0; switch (operation) &#123; case \"+\": result = 1; break; case \"-\": result = 1; break; case \"*\": result = 2; break; case \"/\": result = 2; break; default: System.out.println(\"不存在该运算符\"); break; &#125; return result; &#125;&#125; 测试 12345678910111213141516package com.zjinc36.stack;import static org.junit.Assert.*;import org.junit.Test;public class PolandNotationTest &#123; @Test public void testCalResult() &#123; String infixExpression = \"1+((2+3)*4)-5\"; PolandNotation polandNotation = new PolandNotation(); polandNotation.setInfixExpression(infixExpression); polandNotation.calResult(); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现栈","date":"2020-04-02T16:27:59.000Z","path":"2020/04/03/Java中实现栈/","text":"什么是栈 栈的英文是stack 栈是先入后出(FILO-First In Last Out)的有序列表 栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表 允许插入和删除的一端为变化的一端,称为栈顶(Top),另一端为固定的一端,称之为栈底(Bottom) 根据栈的定义可知,最先放入栈中元素在栈底,最后放入的元素在栈顶,而删除元素刚好相反,最后放入的元素最先删除,最先放入的元素最后删除 栈的应用场景 子程序的调用:在跳往子程序前,会先将下个指令的地址存到堆栈中,知道子程序执行完后再将地址取出,以回到原来的程序中 处理递归调用:和子程序的调用类似,只是除了存储下一个指令的地址外,也将参数,区域变量等数据存入堆栈中 表达式的转换[中缀表达式转后缀表达式]与求值 二叉树的遍历 图形的深度优化(depth - first)搜索法 用数组模拟栈思路 定义一个数组stack 定义一个top来表示栈顶,初始化为-1 入栈的操作:当有数据加入到栈时,top++,同时stack[top] = data; 出栈的操作:先 先获得栈顶的数据 value = stack[top] 将top向下移动top-- 返回栈顶数据 return value 代码实现实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.zjinc36.stack;import com.fasterxml.jackson.annotation.JsonFormat.Value;public class ArrayStack &#123; private int maxSize; // 栈的大小 private int[] stack; // 模拟栈用数组 private int top = -1; // top表示栈顶,初始化为-1 public ArrayStack(int maxSize) &#123; super(); this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; /** * 栈满 * @return */ public boolean isFull() &#123; return top == maxSize - 1; &#125; /** * 栈空 * @return */ public boolean isEmpty() &#123; return top == -1; &#125; /** * 入栈 * @param value */ public void push(int value) &#123; // 先判断栈是否已满 if (isFull()) &#123; System.out.println(\"栈满\"); return; &#125; top++; stack[top] = value; &#125; /** * 出栈 * @return */ public int pop() &#123; // 先判断栈是否为空 if (isEmpty()) &#123; throw new RuntimeException(\"栈空\"); &#125; int value = stack[top]; top--; return value; &#125; /** * 显示栈 */ public void list() &#123; if (isEmpty()) &#123; System.out.println(\"栈空\"); return; &#125; // 需要从栈顶开始遍历 for (int i = top; i &gt;= 0; i--) &#123; System.out.printf(\"stack[%d]=%d\\n\", i, stack[i]); &#125; &#125;&#125; 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.zjinc36.stack;import static org.junit.Assert.*;import java.util.Scanner;import org.junit.Test;public class ArrayStackTest &#123; @Test public void test() &#123; ArrayStack stack = new ArrayStack(4); String key = \"\"; boolean loop = true; Scanner scanner = new Scanner(System.in); while (loop) &#123; System.out.println(\"show:表示显示栈\"); System.out.println(\"exit:退出程序\"); System.out.println(\"push:入栈\"); System.out.println(\"pop:出栈\"); System.out.println(\"请输入你的选择\"); key = scanner.next(); switch (key) &#123; case \"show\": stack.list(); break; case \"push\": System.out.println(\"请输入一个数\"); int value = scanner.nextInt(); stack.push(value); break; case \"pop\": try &#123; int res = stack.pop(); System.out.printf(\"出栈的数据%d\\n\", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case \"exit\": scanner.close(); loop = false; break; default: break; &#125; System.out.println(\"程序退出~~\"); &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现链表之用环形链表解决约瑟夫问题","date":"2020-04-01T22:23:58.000Z","path":"2020/04/02/Java中实现链表之用环形链表解决约瑟夫问题/","text":"循环链表 参考维基百科:循环链表 循环链表是一种链式存储结构，它的最后一个结点指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表的操作和单链表的操作基本一致，差别仅仅在于算法中的循环条件有所不同。 约瑟夫问题 设编号为1,2,3,…,n的n个人围坐一圈 约定编号为k(1&lt;=k&lt;=n)的人从1开始报数数到m的那个人出列 然后出列的人的下一个人又从1开始报数,数到m的哪个人出列 然后出列的人的下一个人又从1开始报数,数到m的哪个人出列… 直到所有人都出列为止 使用单向环形链表解决约瑟夫问题创建单向环形列表1. 第一个节点构成环形链表 当前只有一个节点,所以需要指定一下first指针,而first指针就指向第一个节点 当前只有一个节点,所以尾指针也是指向第一个节点 当前只有一个节点,为了要构成环,所以当前节点的下一个节点指向当前节点 2. 向上述一个节点的环形链表添加节点 因为要在链表的最后增加节点,所以只需要添加在尾指针(last指针)后(即设置last.next = newNode) 而要构成环形链表,最新添加的节点需要指向第一个节点(即,newNode.next = first) 尾指针指向最后一个节点(last = newNode) 出列 思路: -&gt; 1.需要有一个first指针指向环形链表的第一个节点 -&gt; 2.需要创建一个last指针指向环形链表的最后一个节点 -&gt; 3.由于是从第k个节点开始数数,则first和last指针先移动(k - 1)次,此时first指向第k个节点 -&gt; 4.报数为m,则first和last指针同时移动 m-1次(因为自己要先数,此时为1) -&gt; 5.移动后first指向的节点就是需要移除的节点 -&gt; 6.移除节点 -&gt; -&gt; first = first.next -&gt; -&gt; last.next = first -&gt; 7.要移除的节点没有被任何引用,会被回收 代码小孩对象(节点对象)12345678910111213package com.zjinc36.linkedlist.circlesinglelinkedlist;import lombok.Data;@Datapublic class Boy &#123; private int no; //标号 private Boy next; //指向下一个节点,默认为null public Boy(int no) &#123; this.no = no; &#125;&#125; 单向环形链表解决约瑟夫问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.zjinc36.linkedlist.circlesinglelinkedlist;public class CircleSingleLinkedList &#123; // 创建一个first节点,当前没有编号 private Boy first = null; /** * 添加小孩节点,构成一个环形的链表 * @param nums */ public void addBoy(int nums) &#123; if (nums &lt; 1) &#123; System.out.println(\"nums的值不正确\"); return; &#125; // 辅助指针,帮助构建环形链表 // 这个指针是一个尾指针 Boy last = null; // 使用for来创建我们的环形链表 for (int i = 1; i &lt;= nums; i++) &#123; // 根据编号,创建小孩节点 Boy boy = new Boy(i); if (i == 1) &#123; // 第一个节点比较特殊 // 第一个节点构成环形链表 // 1.目前只有一个节点,所以需要指定一下first first = boy; // 2.目前只有一个节点,所以尾指针也是指向boy last = boy; // 3.目前只有一个节点,要构成环,所以当前节点指向当前节点 first.setNext(first); &#125; else &#123; // 非第一个节点构成环形链表 // 1.因为要在链表的最后增加节点,所以只需要添加在尾指针后 last.setNext(boy); // 2.而要构成环形链表,最新添加的节点需要指向第一个节点 boy.setNext(first); // 3.尾指针指向最后一个节点(最新添加的节点) last = boy; &#125; &#125; &#125; /** * 遍历当前的环形链表 */ public void showBoy() &#123; // 判断当前是否为空 if (first == null) &#123; System.out.println(\"没有任何小孩~\"); return; &#125; // 因为first不能动,所以我们用一个辅助指针 Boy temp = first; while (true) &#123; System.out.printf(\"小孩编号 %d \\n\", temp.getNo()); if (temp.getNext() == first) &#123; break; &#125; temp = temp.getNext(); &#125; &#125; /** * 根据用户的输入,计算出小孩出圈的顺序 * 思路: * -&gt; 1.需要有一个first指针指向环形链表的第一个节点 * -&gt; 2.需要创建一个last指针指向环形链表的最后一个节点 * -&gt; 3.由于是从第k个节点开始数数,则first和last指针先移动(k - 1)次,此时first指向第k个节点 * -&gt; 4.报数为m,则first和last指针同时移动 m-1次(因为自己要先数,此时为1) * -&gt; 5.移动后first指向的节点就是需要移除的节点 * -&gt; 6.移除节点 * -&gt; -&gt; first = first.next * -&gt; -&gt; last.next = first * -&gt; 7.要移除的节点没有被任何引用,会被回收 * @param startNo 表示从第几个节点开始数数 * @param countNum 表示数几下 * @param nums 表示最初有多少小孩在圈中 */ public void countBoy(int startNo, int countNum, int nums) &#123; // 先对数据进行校验 if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123; System.out.println(\"参数输入有误,请重新输入\"); return; &#125; Boy last = first; // 1.将first和last指向链表的第一个节点和最后一个节点 while (true) &#123; if (last.getNext() == first) &#123; break; &#125; last = last.getNext(); &#125; // 将first指针指向 startNo // 也就是说 first 和 last 要移动 startNo - 1 次 for (int i = 0; i &lt; startNo - 1; i++) &#123; first = first.getNext(); last = last.getNext(); &#125; while (true) &#123; if (last == first) &#123; // 说明环形链表中只有一个节点 break; &#125; // 报数,第countNum删除 // 即first和last指针同时移动(countNum - 1)次 // 也就是移动后,first会指向需要删除的节点 for (int i = 0; i &lt; countNum - 1; i++) &#123; first = first.getNext(); last = last.getNext(); &#125; // 移除节点 System.out.printf(\"删除第%d个节点\\n\",first.getNo()); first = first.getNext(); last.setNext(first); &#125; System.out.printf(\"最后还在环形链表中的节点编号为%d\\n\", first.getNo()); &#125;&#125; 测试123456789101112131415161718package com.zjinc36.linkedlist.circlesinglelinkedlist;import static org.junit.Assert.*;import org.junit.Test;public class CircleSingleLinkedListTest &#123; @Test public void test() &#123; CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList(); circleSingleLinkedList.addBoy(5); circleSingleLinkedList.showBoy(); circleSingleLinkedList.countBoy(1, 2, 5); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现链表之双向链表","date":"2020-03-31T21:00:01.000Z","path":"2020/04/01/Java中实现链表之双向链表/","text":"单链表存在什么缺点 单链表查找的方向只能是一个方向 单链表不能自我删除,需要靠辅助节点 双向链表 双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。 双向链表可以向前或向后查找 双向链表可以自我删除 实现双向链表思路遍历和单链表一样,只是可以向前,也可以向后 添加(默认添加到双链表最后) 先找到双向链表的最后节点 temp.next = newNode newNode.pre = temp; 修改思路和单链表一样 删除 因为是双向链表,因此,我们可以实现自我删除某个节点 直接找到要删除的这个节点,比如temp temp.pre.next = temp.next temp.next.pre = temp.pre 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.zjinc36.linkedlist.doublylinkedlist;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;import com.zjinc36.linkedlist.singlylinkedlist.HeroNode;import com.zjinc36.linkedlist.singlylinkedlist.SingleLinkedList;public class DoubleLinkedListTest &#123; // 被测试类 private SingleLinkedList doubleLinkedList; // \"英雄\"数组 private HeroNode[] heros; @Before public void setUp () &#123; // 初始化被测试类 doubleLinkedList = new SingleLinkedList(); heros = new HeroNode[4]; heros[0] = new HeroNode(1, \"宋江\", \"及时雨\"); heros[1] = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); heros[2] = new HeroNode(3, \"吴用\", \"智多星\"); heros[3] = new HeroNode(4, \"林冲\", \"豹子头\"); &#125; /** * 添加 */ @Test public void testAdd() &#123; // 加入节点 doubleLinkedList.addNode(heros[0]); doubleLinkedList.addNode(heros[1]); doubleLinkedList.addNode(heros[2]); doubleLinkedList.addNode(heros[3]); // 显示链表 doubleLinkedList.list(); &#125; /** * 修改 */ @Test public void testUpdate() &#123; // 加入节点 doubleLinkedList.addNode(heros[0]); doubleLinkedList.addNode(heros[1]); doubleLinkedList.addNode(heros[2]); doubleLinkedList.addNode(heros[3]); HeroNode heroNode = new HeroNode(4, \"公孙胜\", \"入云龙\"); doubleLinkedList.updateNode(heroNode); System.out.println(\"修改后的链表情况\"); doubleLinkedList.list(); &#125; /** * 删除 */ @Test public void testDel() &#123; // 加入节点 doubleLinkedList.addNode(heros[0]); doubleLinkedList.addNode(heros[1]); doubleLinkedList.addNode(heros[2]); doubleLinkedList.addNode(heros[3]); doubleLinkedList.deleteNode(3); System.out.println(\"删除后的链表情况\"); doubleLinkedList.list(); &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现链表之单链表","date":"2020-03-28T02:31:44.000Z","path":"2020/03/28/Java中实现链表之单链表/","text":"链表(LinkedList)介绍 链表是有序列表,但是它在内存中的存储如下 链表是以节点方式来存储,是链式存储 每个节点包含data域,保存具体的数据;next域,指向下一个节点 如上图,链表中的各个节点不一定是连续存储 链表分为带头节点的链表和没有带头节点的链表,根据实际的需求来确定 单链表(带头节点)的逻辑结构图如下 实现使用带head头的单链表,实现对水浒英雄任务的增删改查 英雄类1234567891011121314151617181920212223242526272829303132package com.zjinc36.linkedlist;import lombok.Data;@Datapublic class HeroNode &#123; // 英雄编号 private int no; // 英雄名字 private String name; // 英雄称号 private String nickname; // 指向下一个结点 private HeroNode next; public HeroNode(int no, String name, String nickname) &#123; super(); this.no = no; this.name = name; this.nickname = nickname; &#125; /** * 为了显示方便,重写toString */ @Override public String toString() &#123; return \"HeroNode [no=\" + no + \", name=\" + name + \", nickname=\" + nickname + \"]\"; &#125;&#125; 水浒英雄排行榜的单链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170package com.zjinc36.linkedlist;public class SingleLinkedList &#123; // 先初始化一个头节点,头节点不要动,不存放具体的数据 private HeroNode head = new HeroNode(0, \"\", \"\"); /** * 添加节点到单向链表(当然这肯定是添加到末尾了) * 思路: * 当不考虑编号顺序时 * -&gt; 1.找到当前链表的最后节点 * -&gt; 2.将最后这个节点的next指向新的节点 * @param heroNode */ public void addNode (HeroNode heroNode) &#123; // 因为head节点不能动,因此我们需要一个辅助遍历temmp // 不能直接使用head HeroNode temp = head; // 要在链表最后插入,所以首先要找到链表的最后 while (true) &#123; // 当next为null时,则表示没有下一个 if (temp.getNext() == null) &#123; break; &#125; // 如果没有找到最后,将temp后移 temp = temp.getNext(); &#125; // 当退出while循环时,temp就指向了链表的最后 temp.setNext(heroNode); &#125; /** * 根据英雄排名,将英雄插入到指定位置 * -&gt; 这里的指定位置有\"英雄的序号决定\" * -&gt; 如果链表中已经存在这个英雄了(序号存在),则显示添加失败 * @param heroNode */ public void addNodeByOrder(HeroNode heroNode) &#123; // 头节点不能动,所以我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置 HeroNode temp = head; boolean flag = false; // 用于标志添加的编号是否存在,默认为false while (true) &#123; if (temp.getNext() == null) &#123; // 说明temp已经在链表的最后了 break; &#125; // 因为单链表,所以我们需要找的是位于\"添加位置的前一个节点\",否则插入不了 // -&gt; 当前节点指向的下一个节点的编号比当前节点大,说明找到了 // -&gt; 此时的temp就是\"添加位置的前一个节点\" if (temp.getNext().getNo() &gt; heroNode.getNo()) &#123; break; &#125; else if (temp.getNext().getNo() == heroNode.getNo()) &#123; // 说明希望添加的heroNode的编号已经存在 flag = true; // 说明编号已经存在 break; &#125; temp = temp.getNext(); // 后移,遍历当前链表 &#125; if (flag) &#123; System.out.printf(\"准备插入的英雄编号 %d 已经存在了,不能加入\\n\", heroNode.getNo()); &#125; else &#123; if (temp.getNext() == null) &#123; // 说明temp已经在链表的最后了 temp.setNext(heroNode); &#125; else &#123; // 将temp的指向交给heroNode的指向 heroNode.setNext(temp.getNext()); // 而temp应指向heroNode temp.setNext(heroNode); &#125; &#125; &#125; /** * 修改节点信息 * -&gt; 根据编号来修改 * @param heroNode */ public void updateNode(HeroNode heroNode) &#123; // 判断是否为空 // -&gt; 即头节点之后没有任何节点 if (head.getNext() == null) &#123; System.out.println(\"链表为空\"); &#125; // 根据节点编号,找到需要修改的节点 HeroNode temp = head.getNext(); boolean flag = false; // 表示是否找到该节点 // 1.找到节点 while (true) &#123; if (temp == null) &#123; break; // 已经遍历完链表 &#125; // 找到 if (temp.getNo() == heroNode.getNo()) &#123; flag = true; break; &#125; temp = temp.getNext(); &#125; // 2.修改节点 if (flag) &#123; // 找到 temp.setName(heroNode.getName()); temp.setNickname(heroNode.getNickname()); &#125; else &#123; // 没有找到 System.out.printf(\"没有找到编号%d的节点,不能修改\\n\", heroNode.getNo()); &#125; &#125; /** * 删除节点 * -&gt; 根据英雄编号删除英雄 * @param number 英雄编号 */ public void deleteNode(int number) &#123; HeroNode temp = head; boolean flag = false; // 标志是否找到待删除节点 while (true) &#123; if (temp.getNext() == null) &#123; // 已经在链表的最后了 break; &#125; if (temp.getNext().getNo() == number) &#123; // 找到待删除节点的前一个节点 flag = true; break; &#125; temp = temp.getNext(); &#125; if (flag) &#123; //有找到要删除节点的前一个节点,可以删除 // 只需要将要删除节点的前一个节点的指针指向要删除节点的后一个节点 temp.setNext(temp.getNext().getNext()); &#125; else &#123; System.out.printf(\"要删除的%d节点不存在\\n\", number); &#125; &#125; /** * 显示链表[遍历] */ public void list() &#123; // 判断链表是否为空 if (head.getNext() == null) &#123; System.out.println(\"链表为空\"); return; &#125; // 因为是头节点,不能动,因此需要一个辅助变量来遍历 HeroNode temp = head.getNext(); while (true) &#123; // 判断是否到链表最后 if (temp == null) &#123; break; &#125; // 输出节点信息 System.out.println(temp); // 将temp后移 temp = temp.getNext(); &#125; &#125;&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.zjinc36.linkedlist;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;public class SingleLinkedListTest &#123; // 被测试类 private SingleLinkedList singleLinkedList; // \"英雄\"数组 private HeroNode[] heros; @Before public void setUp () &#123; // 初始化被测试类 singleLinkedList = new SingleLinkedList(); heros = new HeroNode[4]; heros[0] = new HeroNode(1, \"宋江\", \"及时雨\"); heros[1] = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); heros[2] = new HeroNode(3, \"吴用\", \"智多星\"); heros[3] = new HeroNode(4, \"林冲\", \"豹子头\"); &#125; /** * 向链表中添加节点 */ @Test public void testAddNode() &#123; // 加入节点 singleLinkedList.addNode(heros[0]); singleLinkedList.addNode(heros[1]); singleLinkedList.addNode(heros[2]); singleLinkedList.addNode(heros[3]); // 显示链表 singleLinkedList.list(); &#125; /** * 向链表中插入节点 * -&gt; 会按照链表顺序插入 */ @Test public void testAddNodeByOrder() &#123; // 加入节点 singleLinkedList.addNodeByOrder(heros[1]); singleLinkedList.addNodeByOrder(heros[0]); singleLinkedList.addNodeByOrder(heros[3]); singleLinkedList.addNodeByOrder(heros[2]); // 显示链表 singleLinkedList.list(); &#125; @Test public void testUpdateNode() &#123; // 加入节点 singleLinkedList.addNodeByOrder(heros[1]); singleLinkedList.addNodeByOrder(heros[0]); singleLinkedList.addNodeByOrder(heros[3]); singleLinkedList.addNodeByOrder(heros[2]); HeroNode heroNode = new HeroNode(2, \"lujunyi\", \"yuqilin\"); singleLinkedList.updateNode(heroNode); // 显示链表 singleLinkedList.list(); &#125; @Test public void testDeleteNode() &#123; // 加入节点 singleLinkedList.addNodeByOrder(heros[1]); singleLinkedList.addNodeByOrder(heros[0]); singleLinkedList.addNodeByOrder(heros[3]); singleLinkedList.addNodeByOrder(heros[2]); singleLinkedList.deleteNode(1); singleLinkedList.deleteNode(4); singleLinkedList.deleteNode(2); // 显示链表 singleLinkedList.list(); &#125;&#125; 一些常见的算法代码是基于上述代码加的 问题获取单链表有效节点个数(不计算头节点)1234567891011121314151617181920212223242526272829public class SingleLinkedList &#123;/////////////////////////////////////////这里是上面出现的代码////////////////////////////////////////////////////////////////////////////////////////////获取单链表有效节点个数(不计算头节点)/////////////////////////////////////////////////// /** * 获取单链表有效节点个数(不计算头节点) * @param head */ public int getLength(HeroNode head) &#123; if (head.getNext() == null) &#123; // 空链表 return 0; &#125; int length = 0; HeroNode current = head.getNext(); while (current != null) &#123; length++; current = current.getNext(); &#125; return length; &#125;&#125; 查找单链表中倒数第k个节点方法一:利用到上述获取单链表有效节点个数时写的函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class SingleLinkedList &#123;/////////////////////////////////////////这里是上面出现的代码////////////////////////////////////////////////////////////////////////////////// 查找单链表中的倒数第k个节点///////////////////////////////////////// /** * 查找单链表中的倒数第k个节点 * 思路 * 1. 编写一个方法,接收head节点,同时接受一个index * 2. 其中,index表示的是倒数index节点 * 3. 先把链表从头到尾遍历,得到链表的总长度 (我们已经有getLength)方法了 * 4. 得到链表长度 size = getLength(...) 之后,我们从链表的第一个开始遍历到第 size - index 个,就是我们想要的节点 * 5. 如果找到了,则返回该节点,否则返回null */ public HeroNode findLastIndexNode1(HeroNode heroNode, int index) &#123; // 单链表为空 if (heroNode.getNext() == null) &#123; return null; &#125; // 获取链表长度(取出头节点的链表节点个数) int size = getLength(heroNode); // 对index进行校验 if (index &lt;= 0) &#123; throw new RuntimeException(\"索引\" + index + \"不能是负数\"); &#125; if (index &gt; size) &#123; return null; &#125; // 定义辅助变量,for循环定位到倒数的index HeroNode current = head.getNext(); // 链表最后一个是倒是第1个(即:要注意最后一个不是倒数第0个) // -&gt; 假设链表长度size = 4 // -&gt; 要取出倒数第一个 index = 3 // -&gt; 那么 size - index = 4 - 1 = 3 for (int i = 0; i &lt; (size - index); i++) &#123; current = current.getNext(); &#125; return current; &#125;&#125; 方法二:使用快慢指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SingleLinkedList &#123;/////////////////////////////////////////这里是上面出现的代码////////////////////////////////////////////////////////////////////////////////////////////获取单链表有效节点个数(不计算头节点)////////////////////////////////////////////////////** * 查找单链表中的倒数第 index 个节点 * -&gt; 使用快慢指针实现 * 思路: * 1. 可以定义两个指针,第一个指针从链表的头指针开始遍历向前走 index-1 步,第二个指针保持不动; * 2. 从第 index 步开始,第二个指针也开始从链表的头指针开始遍历. * 3. 由于两个指针的距离保持在 index-1 ,当第一个指针到达链表的尾节点时候,第二个指针正好是倒数第 index 个节点. * @return */ public HeroNode findLastIndexNode2(HeroNode heroNode, int index) &#123; // 单链表为空 if (heroNode.getNext() == null) &#123; return null; &#125; // 对index进行校验 if (index &lt;= 0) &#123; throw new RuntimeException(\"索引\" + index + \"不能是负数\"); &#125; // 定义辅助变量,for循环定位到倒数的index HeroNode currentFast = head.getNext(); HeroNode currentSlow = head.getNext(); int count = 0; while (currentFast.getNext() != null) &#123; if (count &gt;= index - 1) &#123; // 因为此时currentSlow已经是第一个节点了,所以是(index - 1) currentSlow = currentSlow.getNext(); &#125; count++; currentFast = currentFast.getNext(); &#125; return currentSlow; &#125;&#125; 单链表的反转123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SingleLinkedList &#123;/////////////////////////////////////////这里是上面出现的代码//////////////////////////////////////////////////////////////////////////////////////////////// 单链表的反转/////////////////////////////////////////////////////// /** * 单链表的反转 * 思路: * -&gt; 先定义一个头节点 reverseHead = new HeroNode(); * -&gt; 从头到尾遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表reverseHead的最前端 * @param head */ public void reversetList(HeroNode head) &#123; // 如果当前链表为空,或者只有一个节点,无需反转,直接返回 if (head.getNext() == null || head.getNext().getNext() == null) &#123; return; &#125; // 现在是有头链表,所以我们需要一个头 HeroNode reversetHead = new HeroNode(0, \"\", \"\"); // 当前节点 HeroNode current = head.getNext(); HeroNode currentNext = null; while (current != null) &#123; // 获取旧链表当前节点的下一个节点的指针 currentNext = current.getNext(); // 处理\"当前节点\" // -&gt; 由于当前节点要插入新链表的\"头节点\"和\"第一节点\"之间 // -&gt; 所以\"当前节点\"应指向\"第一节点\",如下 current.setNext(reversetHead.getNext()); // -&gt; 此时 current 是 \"当前节点\" -&gt; \"第一节点\" ... 这样的状态 // -&gt; 故只需要将\"头节点\"的下一个节点指向\"当前节点\"就行 reversetHead.setNext(current); // 由于是对current进行遍历,故指针应是 旧链表 的下一个节点 current = currentNext; &#125; // 最后将 head 指向新链表的第一个节点 head.setNext(reversetHead.getNext()); &#125;&#125; 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class SingleLinkedListTest &#123; // 被测试类 private SingleLinkedList singleLinkedList; // \"英雄\"数组 private HeroNode[] heros; @Before public void setUp () &#123; // 初始化被测试类 singleLinkedList = new SingleLinkedList(); heros = new HeroNode[4]; heros[0] = new HeroNode(1, \"宋江\", \"及时雨\"); heros[1] = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); heros[2] = new HeroNode(3, \"吴用\", \"智多星\"); heros[3] = new HeroNode(4, \"林冲\", \"豹子头\"); &#125;/////////////////////////////////////////////////////////////////////////////////// 上面的其他代码 ////////////////////////////////////////////////////////////////////////////////// /** * 测试获取链表长度 */ @Test public void testGetLength() &#123; // 加入节点 singleLinkedList.addNodeByOrder(heros[1]); singleLinkedList.addNodeByOrder(heros[0]); singleLinkedList.addNodeByOrder(heros[3]); singleLinkedList.addNodeByOrder(heros[2]); // 显示链表 singleLinkedList.list(); // 显示长度 int length = singleLinkedList.getLength(singleLinkedList.getHead()); System.out.printf(\"链表长度为%d\", length); &#125; /** * 获取到链表倒数第 index 个节点,方案一 */ @Test public void testFindLastIndexNode1() &#123; // 加入节点 singleLinkedList.addNodeByOrder(heros[1]); singleLinkedList.addNodeByOrder(heros[0]); singleLinkedList.addNodeByOrder(heros[3]); singleLinkedList.addNodeByOrder(heros[2]); // 显示链表 singleLinkedList.list(); HeroNode head = singleLinkedList.getHead(); HeroNode findLastIndexNode = singleLinkedList.findLastIndexNode1(head, 1); System.out.println(findLastIndexNode); &#125; /** * 获取到链表倒数第 index 个节点,方案二 */ @Test public void testFildLastIndexNode2() &#123; // 加入节点 singleLinkedList.addNodeByOrder(heros[1]); singleLinkedList.addNodeByOrder(heros[0]); singleLinkedList.addNodeByOrder(heros[3]); singleLinkedList.addNodeByOrder(heros[2]); // 显示链表 singleLinkedList.list(); HeroNode head = singleLinkedList.getHead(); HeroNode findLastIndexNode = singleLinkedList.findLastIndexNode2(head, 4); System.out.println(findLastIndexNode); &#125; /** * 链表反转 */ @Test public void testReversetList () &#123; // 加入节点 singleLinkedList.addNode(heros[3]); singleLinkedList.addNode(heros[1]); singleLinkedList.addNode(heros[2]); singleLinkedList.addNode(heros[0]); // 显示链表 singleLinkedList.list(); HeroNode head = singleLinkedList.getHead(); singleLinkedList.reversetList(head); singleLinkedList.list(); &#125;&#125; 问题:合并两个有序的单链表,合并后仍然有序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 合并两个有序的单链表,合并后仍然有序 * @return */@Testpublic void testMergeLinkedList () &#123; HeroNode[] heros1 = new HeroNode[4]; heros1[0] = new HeroNode(1, \"宋江\", \"及时雨\"); heros1[1] = new HeroNode(2, \"卢俊义\", \"玉麒麟\"); heros1[2] = new HeroNode(3, \"吴用\", \"智多星\"); heros1[3] = new HeroNode(4, \"林冲\", \"豹子头\"); SingleLinkedList singleLinkedList1 = new SingleLinkedList(); singleLinkedList1.addNodeByOrder(heros1[0]); singleLinkedList1.addNodeByOrder(heros1[1]); singleLinkedList1.addNodeByOrder(heros1[2]); singleLinkedList1.addNodeByOrder(heros1[3]); singleLinkedList1.list(); HeroNode[] heros2 = new HeroNode[4]; heros2[0] = new HeroNode(1, \"刘备\", \"玄德\"); heros2[1] = new HeroNode(2, \"关羽\", \"云长\"); heros2[2] = new HeroNode(3, \"张飞\", \"翼德\"); heros2[3] = new HeroNode(4, \"赵云\", \"子龙\"); SingleLinkedList singleLinkedList2 = new SingleLinkedList(); singleLinkedList2.addNodeByOrder(heros2[0]); singleLinkedList2.addNodeByOrder(heros2[1]); singleLinkedList2.addNodeByOrder(heros2[2]); singleLinkedList2.addNodeByOrder(heros2[3]); singleLinkedList2.list(); /** * 合并两个有序的单链表,合并后仍然有序 * @return */ HeroNode headFirst = singleLinkedList1.getHead(); HeroNode headSecond = singleLinkedList2.getHead(); if (headFirst.getNext() == null) &#123; singleLinkedList1.list(); &#125; if (headSecond.getNext() == null) &#123; singleLinkedList2.list(); &#125; HeroNode currentFirst = headFirst.getNext(); HeroNode currentSecond = headSecond.getNext(); // 链表 // 链表的头节点 HeroNode mergeListHead = new HeroNode(0, \"\", \"\"); HeroNode currentMerge = mergeListHead; while (currentFirst != null &amp;&amp; currentSecond != null) &#123; if (currentFirst.getNo() &lt;= currentSecond.getNo()) &#123; currentMerge.setNext(currentFirst); currentFirst = currentFirst.getNext(); &#125; else &#123; currentMerge.setNext(currentSecond); currentSecond = currentSecond.getNext(); &#125; currentMerge = currentMerge.getNext(); &#125; if (currentFirst != null) &#123; currentMerge.setNext(currentFirst); &#125; if (currentSecond != null) &#123; currentMerge.setNext(currentSecond); &#125; // 打印合并后的链表 HeroNode temp = mergeListHead.getNext(); System.out.println(\"===============打印合并后的链表=========================\"); while (true) &#123; // 判断是否到链表最后 if (temp == null) &#123; break; &#125; // 输出节点信息 System.out.println(temp); // 将temp后移 temp = temp.getNext(); &#125; System.out.println(\"====================================================\");&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Java中实现队列","date":"2020-03-27T10:48:21.000Z","path":"2020/03/27/Java中实现队列/","text":"什么是队列 队列是一个有序列表,可以用数组或是链表来实现 遵循先入先出的原则 数组模拟队列思路思路 队列本身是有序列表,若使用数组的结构来存储队列中的数据,则队列数组的声明如下 因为队列的输入,输出是分别从数组的最前和最后来处理的,因此需要两个变量front和rear分别记录队列前后端的下标,front会随着数据输出而改变,而rear则是随着数据输入而改变 当我们将数据存入队列是称为addQueue,addQueue的处理需要有如下步骤 将尾指针往后移,即rear + 1 若尾指针rear小于队列的最大下标maxSize - 1,则将数据存入rear所指的数组元素中,否则无法存入数据 队列空front == rear 队列满rear == maxSize - 1 代码实现 队列代码的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.zjinc36.queue;public class ArrayQueue &#123; private int maxSize; // 表示数组的最大容量 private int front; // 队列头 private int rear; // 队列尾 private int[] arr; // 该数组用于模拟队列,存放数据 /** * 构造器 * @param maxSize 队列长度 */ public ArrayQueue(int maxSize) &#123; // 指定队列长度 this.maxSize = maxSize; // 初始化 arr = new int[maxSize]; front = -1; // 指向队列头部,分析出 front 是指向队列头的前一个位置 rear = -1; // 指向队列尾部,是队列最后一个数据 &#125; /** * 判断队列是否已满 * @return */ public boolean isFull() &#123; return rear == maxSize - 1; &#125; /** * 判断队列是否为空 * @return */ public boolean isEmpty() &#123; return rear == front; &#125; /** * 添加数据到队列(入队列) * -&gt; 这里的代码只是掩饰用,实际的生产中,这里改成泛型实用性高 * @param n 需要加入队列中的数据 */ public void addQueue(int n) &#123; if (isFull()) &#123; System.out.println(\"队列满,不能加入数据~\"); return; &#125; rear++; //让rear后移 arr[rear] = n; &#125; /** * 获取队列中的数据(出队列) * @return */ public int getQueue() &#123; // 队列空的时候,要抛异常 if (isEmpty()) &#123; throw new RuntimeException(\"队列空,不能取数据\"); &#125; front++; // front后移 return arr[front]; &#125; /** * 显示队列中的所有数据 */ public void showQueue() &#123; if (isEmpty()) &#123; System.out.println(\"队列空,没有数据~\"); return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.printf(\"arr[%d]=%d\\n\",i, arr[i]); &#125; &#125; /** * 显示队列的头数据,注意不是取出数据 * @return */ public int headQueue() &#123; if (isEmpty()) &#123; throw new RuntimeException(\"队列空,没有数据\"); &#125; return arr[front + 1]; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.zjinc36.queue;import static org.junit.Assert.*;import java.util.Scanner;import org.junit.After;import org.junit.Before;import org.junit.Test;public class ArrayQueueTest &#123; private ArrayQueue arrayQueue; private Scanner scanner; @Before public void setUp () &#123; // 创建一个队列 arrayQueue = new ArrayQueue(3); &#125; @Test public void test() &#123; char key = ' '; //接受用户输入 scanner = new Scanner(System.in); boolean loop = true; // 输出一个菜单 while (loop) &#123; System.out.println(\"============================\"); System.out.println(\"s(show):显示队列\"); System.out.println(\"e(exit):退出程序\"); System.out.println(\"a(add):添加数据到队列\"); System.out.println(\"g(get):从队列取出数据\"); key = scanner.next().charAt(0); //接收第一个字符 switch (key) &#123; case 's': arrayQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': System.out.println(\"输入一个数字\"); int value = scanner.nextInt(); arrayQueue.addQueue(value); break; case 'g': System.out.println(\"-----------------------------\"); try &#123; int res = arrayQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; &#125; @After public void setOut() &#123; if (scanner != null) &#123; scanner.close(); &#125; &#125;&#125; 存在的问题 目前数组使用一次就不能用了 如何优化 将这个数组改造成环形的队列 数组模拟环形队列前面代码在使用过程中发现,这个数组只能使用一次,无法充分利用数组,为此,思路是将数组看成是一个环形的 分析说明对前面代码进行如下改造 front变量的含义做一个调整:front指向队列的第一个元素,初始值为0 rear变量的含义也做调整:rear指向队列的最后一个元素,初始值为0 数组中空出一个空间不存放队列的数据(有其他用途) 那么此时 队列满条件:(rear+1)%maxSize == front 队列空条件:rear == front 数据入队列,rear位置向前移动1,由于是环形队列,移动完后的rear指向的位置为:(rear+1)%maxSize 数据出队列,front位置向前移动1,由于是环形队列,移动完后的front指向的位置为:(front+1)%maxSize 队列中有效个数:(rear+maxSize-front)%maxSize (这里要加maxSize是因为rear-front有可能为负数,加上数组长度就能保证是正的) 代码 环形队列实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.zjinc36.queue;/** * 用数组构建环形队列 * */public class CircleArrayQueue &#123; // 数组的最大容量 private int maxSize; // 指向队列第一个元素 private int front; // 指向队列尾 private int rear; // 该数组用以模拟队列,存放数据 private int[] arr; public CircleArrayQueue(int maxSize) &#123; this.maxSize = maxSize; arr = new int[maxSize]; &#125; /** * 判断队列是否满 * @return */ public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; /** * 判断队列是否为空 * @return */ public boolean isEmpty() &#123; return rear == front; &#125; /** * 将数据添加到队列 * @param n */ public void addQueue(int n) &#123; // 判断队列是否已满 if (isFull()) &#123; System.out.println(\"队列已满,不能加入输入~\"); return; &#125; arr[rear] = n; // 将 rear 后移一位,由于是环形队列,所以要取模 rear = (rear + 1) % maxSize; &#125; /** * 从队列中取数据 * @return */ public int getQueue() &#123; // 判断队列是否为空 if (isEmpty()) &#123; throw new RuntimeException(\"队列为空\"); &#125; // 取数据,front设定上就是第一个数据的位置 int value = arr[front]; // 第一个数据取出后,front要向后移动一位 // 由于是环形,所以需要 front = (front + 1) % maxSize; return value; &#125; /** * 显示队列中所有数据 */ public void showQueue() &#123; // 遍历 if (isEmpty()) &#123; System.out.println(\"队列中没有数据\"); return; &#125; for (int i = front; i &lt; front + size(); i++) &#123; System.out.printf(\"arr[%d]=%d\\n\", i%maxSize, arr[i%maxSize]); &#125; &#125; /** * 计算数组中元素个数 * @return */ private int size() &#123; return (rear + maxSize - front) % maxSize; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.zjinc36.queue;import static org.junit.Assert.*;import java.util.Queue;import java.util.Scanner;import org.junit.Before;import org.junit.Test;public class CircleArrayQueueTest &#123; private CircleArrayQueue circleArrayQueue; @Before public void setUp () &#123; circleArrayQueue = new CircleArrayQueue(5); &#125; @Test public void test() &#123; char key = ' '; //接受用户输入 Scanner scanner = new Scanner(System.in); boolean loop = true; // 输出一个菜单 while (loop) &#123; System.out.println(\"============================\"); System.out.println(\"s(show):显示队列\"); System.out.println(\"e(exit):退出程序\"); System.out.println(\"a(add):添加数据到队列\"); System.out.println(\"g(get):从队列取出数据\"); key = scanner.next().charAt(0); //接收第一个字符 switch (key) &#123; case 's': circleArrayQueue.showQueue(); break; case 'e': scanner.close(); loop = false; break; case 'a': System.out.println(\"输入一个数字\"); int value = scanner.nextInt(); circleArrayQueue.addQueue(value); break; case 'g': System.out.println(\"-----------------------------\"); try &#123; int res = circleArrayQueue.getQueue(); System.out.printf(\"取出的数据是%d\\n\", res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; default: break; &#125; &#125; &#125;&#125;","tags":[{"name":"数据结构与算法(Java实现)","slug":"数据结构与算法-Java实现","permalink":"https://zjinc36.github.io/tags/数据结构与算法-Java实现/"}]},{"title":"Ubuntu中安装防火墙管理的图形界面Gufw","date":"2020-03-25T22:21:38.000Z","path":"2020/03/26/Ubuntu中安装防火墙管理的图形界面Gufw/","text":"作用 Gufw 为您提供了一种简单直观的方式来管理 Linux 防火墙。 它支持常见的任务，例如允许和拦截预先配置的、常用的 p2p 端口或单独的端口，以及许多别的规则。 软件界面 安装Ubuntu软件里有","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中安装全局搜索软件Synapse","date":"2020-03-25T22:07:51.000Z","path":"2020/03/26/Ubuntu中安装全局搜索软件Synapse/","text":"作用 Synapse is a graphical launcher enabling you to start applications and also to quickly find and access relevant documents and files (by making use of the Zeitgeist engine). Synapse是一个图形启动器，使您可以启动应用程序，也可以快速查找和访问相关文档和文件（通过使用Zeitgeist引擎）。 效果图 搜索你想要的 安装Ubuntu软件里有","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中KeePass使用快捷键自动输入用户名密码无效","date":"2020-03-24T15:22:19.000Z","path":"2020/03/24/Ubuntu中KeePass无法自动输入/","text":"问题 按自动键入快捷键ctrl + v 出现the xdotool utility/package is required for auto-type install this package and try again错误即,keepass无法自动键入用户名和密码 解决首先安装xdotool软件包在Debian / Ubuntu / etc上只需运行： 1sudo apt-get安装xdotool 接下来找出系统中安装了keepass2可执行文件的位置最简单的方法是运行： 1which keepass2 在我的系统上，这将返回/usr/bin/keepass2。该文件实际上不是程序本身，而是引导程序的脚本。因此，找出真正的可执行文件在哪里运行： 1cat /usr/bin/keepass2 在我的系统上，这返回 12#!/bin/shexec /usr/bin/cli/usr /lib/keepass2/KeePass.exe &quot;$@&quot; 因此，程序本身实际上位于/usr/lib/keepass2/KeePass.exe 创建自定义键盘快捷键根据您所运行的发行版，此过程将有所不同，但通常在“键盘”设置下。对于命令，输入以下内容： 1mono /usr/lib/keepass2/KeePass.exe --auto-type 现在，只要键入快捷键(通常是ctrl + v)，KeePass会自动键入配置的用户名和密码","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu修改时区","date":"2020-03-21T11:09:46.000Z","path":"2020/03/21/Ubuntu修改时区/","text":"查看当前系统时间 修改时区原来在东京,是东九区,现在要使用东八区的时间,可以如下更改","tags":[{"name":"Ubuntu配置","slug":"Ubuntu配置","permalink":"https://zjinc36.github.io/tags/Ubuntu配置/"}]},{"title":"算法的复杂度","date":"2020-03-20T17:09:02.000Z","path":"2020/03/21/算法的复杂度/","text":"度量一个程序(算法)执行时间的两种方法事后统计的方法这种方法可行,但是有两个问题 要想对设计的算法的运行性能进行评测,需要实际运行该程序 所得时间的统计量依赖于计算机硬件,软件等环境因素 事前估算的方法通过某个算法的时间复杂度来判断哪个算法更优 时间频度 时间频度:一个算法花费时间与算法中语句的执行次数成正比例,哪个算法中语句执行次数多,它花费时间就多 一个算法中的语句执行次数称为语句频度或时间频度,记为T(n) 时间复杂度什么是时间复杂度 一般情况下,算法中的基本操作语句的重复执行次数是问题规模n的某个函数,用T(n)表示,若某个辅助函数f(n),使得当n趋于无穷大时,T(n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)=O(f(n)),称为O(f(n))为算法的渐进时间复杂度,简称时间复杂度 T(n)不同,但时间复杂度可能相同 如:T(n)=n^2+7n+6与T(n)=3n^2+2n+2它们的T(n)不同,但时间复杂度相同,都为O(n^2) 计算时间复杂度的方法计算时间复杂度的方法 用常数1代替运行时间中所有加法常数T(n)=n^2+7n+6 =&gt; T(n)=n^2+7n+1 修改后的运行次数函数中,只保留最高阶项T(n)=n^2+7n+1 =&gt; T(n)=n^2 去除最高项的系数T(n)=n^2 =&gt; T(n)=n^2 常见的时间复杂度 常数阶O(1) 对数阶O(log2(n)) 线性阶O(n) 线性对数阶O(nlog2(n)) 平方阶O(n^2) 立方阶O(n^3) k 次方阶O(n^k) 指数阶O(2^n) 常见的时间复杂度对应的图 说明 常见的算法时间复杂度由小到大一次为:O(1) &lt; O(log2(n)) &lt; O(n) &lt; O(nlog2(n)) &lt; O(n^2) &lt; O(n^3) &lt; O(n^k) &lt; O(2^n) 随着问题规模n的不断增大,上述时间复杂度不断增大,算法的执行效率越低 常见时间复杂度说明常数阶O(1)无论代码执行多少行,只要是没有循环等复杂结构,那这个代码的时间复杂度都是O(1) 12345int i = 1;int j = 2;++i;j++;int m = i + j; 对数阶O(log2(n))1234int i = 1;while (i &lt; n) &#123; i = i * 2;&#125; 在while循环里面,每次都将i乘以2,乘完之后,i距离n就越来越近.假设循环x次之后,i就大于2了,此时这个循环就退出了,也就是说2的x次方等于n,那么x=log2(n)也就是说当循环log2(n)次以后,这个代码就结束了.因此这个代码的时间复杂度为O(log2(n)) 线性阶O(n)1234for (i = 1; i &lt;= n; i++) &#123; j = i; j++;&#125; 这段代码,for循环里面的代码会执行n遍,因此它消耗的时间是随着n的变化而变化的,因此这类代码都可以用O(n)来表示它的时间复杂度 线性对数阶O(nlogN)123456for (m=1; m&lt;n; m++) &#123; i = 1; while(i &lt; n) &#123; i = i * 2; &#125;&#125; 将时间复杂度为O(log2(n))的代码循环n遍的花,它的时间复杂度就是n*O(log2(n)),也就是O(nlog2(n)) 平方阶123456for (x = 1; i &lt;= n, i++) &#123; for (i = 1; i &lt;= n; i++) &#123; j = i; j++; &#125;&#125; 如果把O(n)的代码循环以便,它的时间复杂度就是O(n^2) 如果将其中一层循环的n改成m,那么它的时间复杂度就变成了O(m*n) 平均时间复杂度和最坏时间复杂度 平均时间复杂度指所有可能的输入实例均以等概率出现的情况下,该算法的运行时间 最坏情况下的时间复杂度称最坏时间复杂度,一般讨论的时间复杂度均是最坏情况下的时间复杂度,这样做原因是:最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限,这就保证了算法的运行时间不会比最坏情况更长 平均时间复杂度和最坏时间复杂度是否一致,和算法有关:表中涉及的相关术语解释 稳定:如果a原本在b前面,而a=b,排序之后a仍然在b前面 不稳定:如果a原本在b的前面,而a=b,排序之后,a可能会出现在b的后面 内排序:所有排序操作都是在内存中完成 外排序:由于数据太大,因此把数据放在磁盘中,而排序通过磁盘和内存的数据传输才能进行 时间复杂度:一个算法执行所耗费的时间 空间复杂度:运行完一个程序所需内存的大小 n:数据规模 k:”桶”的个数 In-palce:不占用额外内存 Out-place:占用额外内存 空间复杂度 类似于时间复杂度,一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间,它也是问题规模n的函数 空间复杂度是对一个算法在运行时中临时占用存储空间大小的量度.有的算法需要占用的临时工作单元数与解决的问题的规模n有关,它随着n的增大而增大,当n较大时,将占用较多的存储单元,例如快速排序和规并排序算法,基数排序就属于这种情况 在做算法分析时,主要讨论的是时间复杂度.从用户体验上看,更看重的程序执行的速度.一些缓存产品(redis,memcache)和算法(基数排序)本质就是用空间换时间","tags":[]},{"title":"企业家思想进化与全球格局","date":"2020-03-20T10:54:59.000Z","path":"2020/03/20/notes_企业家思想进化与全球格局/","text":"视频地址https://www.bilibili.com/video/av97442520?t=248 笔记基本判断:百年未有之大变局 四个角度 新的国际格局正在形成国际格局从西方主导转向东西方平衡,国际格局指的是国家间的力量对比 新的现代化模式得到承认 荷兰模式 英国模式(英美模式) 德国模式 瑞典模式 中国模式(新) 新的工业革命正在到来 第四次工业革命中美竞争,且中国的赢面大 新的全球问题正在出现结论四大新都与中国有关,中国是主要变量.第四次工业革命是中国最伟大的机遇","tags":[{"name":"视频笔记","slug":"视频笔记","permalink":"https://zjinc36.github.io/tags/视频笔记/"}]},{"title":"中西方文化差异的渊源","date":"2020-03-11T18:32:44.000Z","path":"2020/03/12/notes_中西方文化差异的渊源/","text":"视频地址【王德峰】中西方文化差异的渊源 笔记 柏拉图理念论 世界可以被改造 历史进步论 如来说:世界 绝非世界 名世界 缘起性空 复性工夫 大学之道,在明明德,在亲民,在止于致善 本心会起念,起妄念就会有烦恼 应无所住而生其心 住 就是相 相是存在 善相,净相也不应住 无烦恼就无所谓智慧,没有烦恼要智慧干嘛 天道在人民生活中,众生的烦恼就是天道之体现 不要害怕烦恼,烦恼即修行 西方 第一等级 理性 第二等级 意志 第三等级 情感 中国 《诗》三百，一言以蔽之，曰‘思无邪’ 反者道之动 你要得到什么事物,必须从这个事物的反面开始 你要比较长久的保持一个事物,必须让这个事物保持它的对立面 困难是我们的恩人,敌人是我们的老师 一路顺风顺水则马上要灭亡 五伦 君仁臣义 父慈子孝 夫妻有别(夫妻共命运,但夫妻有区别,各司其职) 长幼有序 朋友有信","tags":[{"name":"视频笔记","slug":"视频笔记","permalink":"https://zjinc36.github.io/tags/视频笔记/"}]},{"title":"深入理解浮点数与浮点数的精度问题","date":"2020-03-09T22:06:28.000Z","path":"2020/03/10/深入理解浮点数与浮点数的精度问题/","text":"参考 单精度浮点数 深入理解浮点数有效位 为什么会有精度问题 在数学中,与浮点数对应的是小数 数学上区间[0,1]之间的小数有无穷多个 计算机中,32位浮点数最多可以表示2^32个数 所以,计算机是不可能描述得尽的,必然会有一些近似,一些精度所示 计算机中如何表示浮点数浮点数的格式当前，计算机中浮点数采用的是IEEE 754标准。浮点数分为单精度浮点数(32位)和双精度浮点数(64位)。浮点数的基本格式如下： 各部分含义如下： sign：符号位，0表示正，1表示负 exponent：阶码，浮点数的幂次。一般采用移码表示。 fraction：浮点数的小数部分 二进制的浮点数转十进制上述格式描述的浮点数的十进制值为value = (-1)^S * (1.fraction) * 2^(exponent - 偏差) (-1)^S表示符号 1.fraction是二进制的小数 由于除0外的所有小数都可以写成1.fractionX2^E的形式，因而，在表示浮点数时，省略掉了前面的整数部分1 2^(exponent - 偏差)表示幂次，类似于二进制的科学计数法 单精度情况下2^(exponent - 127) 双精度情况下2^(exponent - 1023) exponent - 127或者exponent - 1023是因为指数有正有负,单精度情况下,阶码有8位,即表示(2^8 - 1)个数,正数负数对半分,就是减去127(双精度同理) 非规范化小数上面描述的是规格化的浮点数，如果浮点数的阶码部分全0或者全1，则表示非规格化的浮点数。 阶码不是全0或全1，规格化浮点数。 阶码全0：表示0.fraction * 2^ (1-127)次。注意，此时指数部分是1-127.这一类表示了接近0的小数部分。 阶码全1：如果小数部分全0，表示正负无穷大。如果出现1，表示不是一个数NaN。 举例说明 浮点数的精度通过上面的介绍可以发现，浮点数的精度取决于二进制小数部分的精度。对于单精度浮点数，小数部分有23位，对应十进制小数见下表 二进制小数 十进制小数 2^-23 0.00000011920928955078125 2^-22 0.0000002384185791015625 2^-21 0.000000476837158203125 2^-20 0.00000095367431640625 2^-19 0.0000019073486328125 2^-18 0.000003814697265625 由于是规格化的浮点数，所以小数部分都要加上1，可以知道，单精度浮点数的小数部分最小是1.00000011920928955078125，其次是1.0000002384185791015625，注意到这两个小数之间的间隔 那么,要表示1.0000001和1.0000002之间的小数，则单精度浮点数无能为力，1.0000001已经是23位小数部分描述的最小值了 通过这样的分析可以发现，23位只能描述到小数点后第7位，即1.0000001，1.0000002，1.0000004，1.0000009对应了二进制的小数值，其他要通过上面几个的组合来表示 事实上，如果考虑保留前7位,而第8位的四舍五入，1.0000004，1.0000009本身的表示也是不准确的。 类似的分析，双精度浮点数能准确表示到小数点后第15位，第16位部分准确 一个整数用float来存储时保存的精度有多少思路: 将整数转化为二进制科学计数法形式，然后再对应到规格化浮点数中 在处理小数部分时，多余的数位即为损失的精度 结论 一般来说，无论是整数或者小数，用float表示时，从左边第一个非0的数字算起，从高到低的7位是准确的。此后的数位是不能保证精确的。 相应的，从1到0x1FFFFFFFFFFFFF(53位全1，18014398509481983)均可以准确用double来表示。其他整数，只有在转化为double时小数部分不超过52位才可以精确表示。否则，会有一定的精度损失。无论整数或者小数，用double表示时，从左边第一个非0的数字起，从高到低的16位是准确的，此后的数位不一定精确。 浮点数分布通过上面的分析可以发现，尽管浮点数表示的范围很广，但由于精度损失的存在，加上幂次的放大作用，一个浮点数实际上是表示了周围的一个有理数区间。如果将浮点数绘制到一个数轴上，直观上看，靠近0的部分，浮点数出现较密集。越靠近无穷大，浮点数分布越稀疏，一个浮点值代表了周围一片数据。如下图所示。从这个意义上来说，浮点数不宜直接比较相等，它们是代表了一个数据范围。实际应用中，如果要使用浮点数计算，一定要考虑精度问题。在满足精度要求的前提下，计算结果才是有效的。在计算精度要求情形下，例如商业计算等，应该避免使用浮点数，严格采取高精度计算。","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://zjinc36.github.io/tags/计算机组成原理/"}]},{"title":"原码反码与补码","date":"2020-03-09T15:49:27.000Z","path":"2020/03/09/原码反码与补码/","text":"正数补码 和原码相同 负数补码 原码第一位为符号位(0为正数,1为负数) 反码符号位不动,原码取反 负数补码符号位不动,反码加1 十进制数字用原码,反码,补码表示 12345678910111213141516171819202122// 十进制5// 二进制0000 0101----------------------------// 十进制-6// 二进制原码:1000 0110反码:1111 1001补码:1111 1010---------------------------// 十进制-1// 二进制原码:1000 0001反码:1111 1110补码:1111 1111 打印整数的二进制表示 1234567891011121314// 这里打印6的二进制数int a = 6;for (int i=0; i&lt;32; i++) &#123; // 整数有32位,所以要做32次循环 // 0x80000000 表示最高位为1的数字 int t = (a &amp; 0x80000000 &gt;&gt;&gt; i) &gt;&gt;&gt; (31 - i); System.out.print(t);&#125;说明:+ 0x80000000是数的十六进制表示，转成二进制表示为10000000000000000000000000000000+ 运算的优先级，移位运算高于逻辑运算，&gt;&gt;&gt; 高于 &amp;+ 位逻辑与运算 1&amp;1 = 1 ，0&amp;1 = 0+ &gt;&gt;&gt;无符号右移，移出部分舍弃，左边位补0；+ &gt;&gt;有符号、&gt;&gt;&gt;无符号看的就是二进制的符号位，无符号:就不管符号位，右移只填充0；有符号，就是符号位是啥，我就填充啥 无符号右移和无符号右移&gt;&gt;有符号、&gt;&gt;&gt;无符号看的就是二进制的符号位 无符号:就不管符号位，右移只填充0 有符号:就是符号位是啥，我就填充啥 为什么要用补码 为了统一+0和-0 为了将减法转换成加法 1.统一+0和-0 用原码表示0,则0会出现两个数字 12340原码正数0:0000 0000原码负数0:1000 0000 用补码表示,则不管是+0还是-0,表现是唯一的 12345678// +0的补码补码:0000 0000// -0的补码原码:1000 0000反码:1111 1111补码:0000 0000 2.使用补码计算加法,可以不用考虑符号位(符号位参与运算),直接加就行 1234567891011121314151617181920-6 + 5 1111 1010+0000 0101=1111 1111------------------------4 + 5 1111 1100+0000 0101=0000 0001-------------------------3 + 5 1111 1101+0000 0101=0000 0010","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://zjinc36.github.io/tags/计算机组成原理/"}]},{"title":"Git合并分支","date":"2020-03-01T19:57:34.000Z","path":"2020/03/02/Git合并分支/","text":"预备知识 Git底层逻辑 Git之三路合并(3-Way Merge) Git Merge当前分支图 进行合并 执行如下命令 12# 在master分支执行git merge bugFix 上述命令要将bugFix分支合并到master分支,首先要查找共同祖先,即找到C0 根据三路合并的说明,说明这个C0提交的地位是三路合并中的Base 对&lt;C0，C1，C4&gt;进行三路合并,合并完之后会有新文件产生(不管是增加内容还是减少内容) 此时对文件构建Blob,Tree Object,Commit Object 这样就得到一个包含更改的新提交 合并完之后的分支图 Git Cheery-Pickcherry-pick 和它的名称一样，精心挑选，挑选一个我们需要的 commit 进行操作。它可以用于将在其他分支上的 commit 修改，移植到当前的分支。 当前分支图 进行合并 执行如下命令 1git cherry-pick &lt;C4&gt; 计算C4引入的更改：C4-C2 应用更改：C3 +（C4-C2） 创建一个包含更改的新提交。 实际上是（C2，C3，C4）的三向合并,这里C2的地位是Base 合并完之后的分支图 Git Rebas当前分支图 进行合并 执行如下命令 1git rebase master 寻找共同祖先 确定要选择的提交：C2，C4 前换到master分支 cherry-pick C2 cherry-pick C4 合并完之后的分支图就是上图 Merge和Rebase比较Merge 提交历史被保留 生成一个额外的提交 历史不是线性的 Rebase 提交历史被重写 没有额外的提交 历史是线性的 Rebase需要注意不要Rebase公共分支 最后强调一下可能看这篇文章的人,并不会看预备知识的文章,所以在这里强调一下3-way Merge 不等于 Diff-Apply 12345678910111213141516171819$ git diff bugFix~ bugFix &gt; x.patch$ cat x.patchdiff --git a/x.txt b/x.txtindex 8026076..5a49123 100644--- a/x.txt+++ b/x.txt@@ -1 +1,2 @@ Base Line+Line below$ git apply x.patcherror: patch failed: x.txt:1error: x.txt: patch does not apply$ git cherry-pick bugFix[master a25402c] bugFix: modified Date: Wed Jul 26 12:17:28 2017 +0800 1 file changed, 1 insertion(+)","tags":[{"name":"Git","slug":"Git","permalink":"https://zjinc36.github.io/tags/Git/"}]},{"title":"Git之三路合并(3-Way Merge)","date":"2020-03-01T12:33:16.000Z","path":"2020/03/01/Git之三路合并/","text":"三路合并(3-way merge)其实我也不知道正统是不是这样翻译,看英文单词,这个不重要,重要的是三路合并的想法,接下去对三路合并进行简要说明 首先先弄清楚Diff的时候发生了什么 要比较的字符串如下 12345# 字符串一a b c d f g h j q z# 字符串二a b c d e f g i j k r x y z 查找最长的公共子序列(维基百科:LCS(最长公共子序列)) 12# 使用肉眼观察,明显最长公共子序列是如下字符串(计算机中如何找出来不再此次讨论范围)a b c d e f g i j k r x y z 将字符串一对齐到最长的公共子序列(LCS) 12a b c d f g h j q za b c d e f g i j k r x y z 可以得到字符串一与最长公共子序列的不同 12e h i q k r x y+ - + - + + + + 其次说说二路合并(2-way merge) 现在有如下两个文件,其中”你”和”我”的文件中,第37行有冲突 为了将”你”和”我”的文件进行合并,需要回答如下问题 上述两个文件中,如何知道到底是谁修改了第37行？ “你”还是”我”? 亦或是”你”和”我”都进行修改了? 如何解决上述问题? “你”和”我”都必须记住所有更改 所有差异都应手动解决。 最后说明什么是三路合并(3-way merge)过程在二路合并中的说明中,我们知道,有两件事需要解决,但事实上,记住所有的更改和所有差异都手动解决是非常繁琐的,如果文件非常多,甚至是不可能的,为了解决这两个”不可能”,设计了如下的三路合并 现有如下三个文件Base,Yours,Mine 对三个文件互相比较(一般情况下,是一行一行进行比较),按如下规则进行合并 在3个文件中都相同: 不变 -&gt; 说明Yours和Mine都没有进行修改 在2个文件中相同,第3个文件不相同: 输出与Base不同的内容 -&gt; 和Base不同,说明这个文件进行了修改,在上图中,应是Yours进行了修改 丢弃与Base相同的那个 -&gt; 和Base相同,说明这个文件没有进行修改,在上图中,应是Mine,也就是这个文件比较旧 在3个文件中都不同 冲突 -&gt; 说明需要合并的两个文件都比Base文件”新”,而两个文件又正好改到同一行,此时,计算机肯定是没有办法判断的,就要手动进行解决 依照上述规则,我们试着合并下述文件一般情况下,我们是一行一行进行比较 比较37行,将Yours,Mine与Base进行比较,发现是在2个文件中相同,第3个文件不相同,所以合并之后的文件中的第37行应是print(“hello”) 比较50行,由于在三个文件文件中都不同,说明Yours和Mine都进行了修改,这时候计算机无法判断,就有冲突(conflict),这时候需要手动解决 比较75行,由于Yours和Base相同而Mine和Base不同,在2个文件中相同,第3个文件不相同,所以第75行应是print(“end”) 这样我们就能得到如下的合并之后的文件 12345678937: print(“bye”)&lt;&lt;&lt;&lt;Yours50: for i in 0..10====50: for i in 0..20&gt;&gt;&gt;&gt;Mine75: print(“end”) 最后再将冲突解决,合并就完成了 再次强调一下规则 对三个文件进行比较(一般情况下,是一行一行进行比较),按如下规则进行合并 在3个文件中都相同: 不变 -&gt; 说明Yours和Mine都没有进行修改 在2个文件中相同,第3个文件不相同: 输出与Base不同的内容 -&gt; 和Base不同,说明这个文件进行了修改,在上图中,应是Yours进行了修改 丢弃与Base相同的那个 -&gt; 和Base相同,说明这个文件没有进行修改,在上图中,应是Mine,也就是这个文件比较旧 在3个文件中都不同 冲突 -&gt; 说明需要合并的两个文件都比Base文件”新”,而两个文件又正好改到同一行,此时,计算机肯定是没有办法判断的,就要手动进行解决 在深入一点,我们该如何对三个文件进行比较前面说明的过程中,对文件进行比较的时候都是使用肉眼进行比较,那么具体算法上又是如何进行比较的呢?这里为了说明,就简单一点,三个文件中的每行都只有一个数字 参考这里:diff3-short 按照行,我们可以为每个文件创建一个多维向量如下, 123X: [1, 4, 5, 2, 4, 6]B: [1, 2, 3, 4, 5, 6]Y: [1, 2, 4, 5, 3, 6] 计算差异 12345X: [1, 4, 5, 2, 3, 6]B: [1, 2, 3, 4, 5, 6]B: [1, 2, 3, 4, 5, 6]Y: [1, 2, 4, 5, 3, 6] 以B为标准,可以得到如下矩阵 输出差异 总结上述过程就是所谓的三路合并 三路合并中比二路合并中多出了一个Base文件,这个文件的作用就是为了解决上述的&quot;你&quot;和&quot;我&quot;都必须记住所有更改的问题 而对于所有差异都应手动解决问题,我们可以通过与Base文件进行比较,最后将手动解决的行压缩到冲突这种情况,其他都能自动解决","tags":[{"name":"Git","slug":"Git","permalink":"https://zjinc36.github.io/tags/Git/"}]},{"title":"Excel冻结窗格以锁定行和列","date":"2020-02-29T01:41:56.000Z","path":"2020/02/29/Excel冻结窗格以锁定行和列/","text":"若要使工作表的某一区域在滚动到工作表的另一区域时仍保持可见，请转到“视图”选项卡，在此选项卡中，可以“冻结窗格”，将特定的行和列锁定到位 冻结行或列冻结首列选择“视图” -&gt; “冻结窗格” -&gt; “冻结首列” 冻结前两列 选择第三列。 选择“视图” -&gt; “冻结窗格” &gt; “冻结窗格”。 冻结列和行 选择在滚动时要保持其可见的行下方和列右侧的单元格。 选择“视图” -&gt; “冻结窗格” -&gt; “冻结窗格”。 取消冻结行或列单击“视图”选项卡 -&gt; “窗口” -&gt; “取消冻结窗格”。","tags":[{"name":"Excel","slug":"Excel","permalink":"https://zjinc36.github.io/tags/Excel/"}]},{"title":"Ubuntu中点击外部应用的链接后跳转到Chrome却无法打开应用的问题","date":"2020-02-27T22:33:04.000Z","path":"2020/02/28/Ubuntu中点击外部应用的链接后跳转到Chrome却无法打开应用的问题/","text":"参考External links are opened as blank tabs in new browser window in Chrome 解决方法As unfulvio said, the issue is with google-chrome.desktop, and it is missing the %U argument . Open file: $HOME/.local/share/applications/google-chrome.desktop Find the line: 1Exec=/opt/google/chrome/chrome Add a space and %U: 1Exec=/opt/google/chrome/chrome %U Then save the file. 翻译过来就是 打开文件 1vim $HOME/.local/share/applications/google-chrome.desktop 找到如下行 1Exec=/opt/google/chrome/chrome 在该行后面添加一个空格和%U 1Exec=/opt/google/chrome/chrome %U 保存文件即可","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Git底层逻辑","date":"2020-02-22T19:15:51.000Z","path":"2020/02/23/Git底层逻辑/","text":"两种存储文件的方式直接拷贝存储一份新的(快照)直接拷贝的方式,类似如下的命令方式 12345678#1cp test.txt ~/backup/test-v1.txt#2cp test.txt ~/backup/test-v2.txt#3cp test.txt ~/backup/test-v3.txt 这是Git的存储方式 更小的存储空间增量存储的方式,类似如下的命令方式操作 12345678#1cp test.txt .../test-initial.txt#2diff text.txt .../test-initial.txt &gt; .../test-delta-v2.txt#3diff text.txt .../test-delta-v2.txt &gt; .../test-delta-v3.txt 这是SVN的存储方式 如何给存储中的每一个文件命名 使用时间戳命名的方式 使用版本号方式 使用hash值的方式 使用时间戳命名的方式有什么好处 易于推理的修改 容易产生名字 旧版本难以引用 分布式系统中可能会发生冲突 类似如下的命令操作 123456# cp test.txt test.txt-$(date +%s%N)$ cp test.txt test.txt-1500621805384048282$ cp test.txt test.txt-1500622605384048291$ cp test.txt-1500622605384048291 test.txt$ cp test.txt text.txt-1500622905384049812 使用版本号的方式 旧版本易于引用 需要维护一个全局计数器以生成新名称 难以避免分布式系统中的冲突 类似如下的命令操作 1234$ cp test.txt test.txt-v1$ cp test.txt test.txt-v2$ cp test.txt-v2 test.txt$ cp test.txt text.txt-v4 这也是SVN的文件命名方式 使用hash值的方式 分布式系统的Hash 在分布式系统中一致 易于生成名称（SHA-1） 很难参考旧版本 文件名被丢弃(原始文件名找不到) 类似如下的命令操作 1234$ cat test.txt | git hash-object --stdind670460b4b4aece5915caf5c68d12f560a9fe3e4$ cp test.txt ~/.git/object/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 这是Git的文件的命名方式 具体看看Git中如何进行构造和标识引入名词BlobBlob的定义 Blob的定义:文件名为内容的SHA-1值的文件,具体来说,如下图, 更具体一点来说,应该是如下图,文件名 == SHA-1 ( zip (类型 + 内容长度 + \\0 + 内容 ) ) Blob的文件类型 我们看一下Header里面有什么东西,如下图,其中type用以表示该Blob文件的类型,这样就能区分下文将要说明的Tree Object,Commit Object等 git中如何查看Blob文件的类型 123456789101112131415$ git cat-file commit HEADtree 414408a42cf018b7205f6ea8e1ccafd31ef3cd7aparent 064a052c9ccf06f6a347b7a06f3e8d2496e11a65author zhang_ji &lt;zhang_ji@worksap.co.jp&gt; 1500537698 +0800committer zhang_ji &lt;zhang_ji@worksap.co.jp&gt; 1500537698 +0800update POM version. refs #300039from 17.06.hr-SNAPSHOT to 17.07.recruiting-SNAPSHOT$ git cat-file -t 414408tree$ git cat-file -t 064a05commit Blob文件的内容是什么 下文会说明:Blob文件的内容 Blob文件在哪里可以找到 Blob文件可以在.git/objects下找到1234567$ find .git/objects.git/objects....git/objects/info.git/objects/pack 想知道目录的具体作用参考这里:10.2 Git 内部原理 - Git 对象 用Blob标识文件每个Git管理的文件,在.git录下,都有一个文件与之对应,而这个与之对应的文件称为Blob,同时这个与之对应的文件的文件名为内容的SHA-1值 现在我们已经知道Git如何标识被跟踪的每个文件,接下去说明如何构造目录结构 构造目录结构引入名词Tree树对象:首先是一个Blob文件,比上述Blob多出来的是该文件里有内容,其中内容的每一行是一个”孩子”的信息 用树对象标识文件 Git中可以使用如下命令进行查看,上述图片即如下查看结果 1234567$ git ls-tree HEAD100644 blob 125c07f222601136b7b6291002e3a9f59ee99bfe .gitignore100644 blob 8fc149a7e3053c2b7adeb94e5bdd68bad7d48331 README.md100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 batch.release040000 tree 6714dd5129fa87f9bf55d9f7944a8764cf6424b1 hue-hr-recruiting-batch040000 tree 8150ff62850cf4d154876c2c498954d029fa5bf6 hue-hr-recruiting-biz... 可以看到,tree对象是一个文件,并且文件的文件名是SHA-1值,接下去我们在看看tree对象 123$ git ls-tree 6714dd5129fa87f9bf55d9f7944a8764cf6424b1100644 blob f4f5a0b2397e2afa2e285507d2af6014015c6b35 pom.xml040000 tree bebf8118906f2a08c3c2f1ab54f5e9b657f03451 src 可以看到,tree对象表示目录,而tree对象的内容的每一行表示被标识目录里的每一个文件所对应的Blob文件的SHA-1值 其他元信息我们已经知道如何标识文件,也已经知道如何构造目录信息,也就是说我们已经有办法构造一个快照了,那么当我们commit一个快照的时候 这个快照和前一个快照如何建立联系? commit的时候写的日志信息又该怎么表示? 什么时候提交的?等等这些信息又该如何处理 引入名词commitCommit Object：Blob包含提交的元信息,也就是说,一个commit对象也是一个Blob文件,而这个Blob文件的内容包含的是提交的元信息 说明一下commit文件git中可以如下进行查看某一commit的元信息 1234567$ git cat-file commit HEADtree 414408a42cf018b7205f6ea8e1ccafd31ef3cd7a -&gt; 当前目录的树对象parent 064a052c9ccf06f6a347b7a06f3e8d2496e11a65 -&gt; 当前commit的前一个commit的SHA-1值author zhang_ji &lt;zhang_ji@worksap.co.jp&gt; 1500537698 +0800 -&gt; 作者与时间戳committer zhang_ji &lt;zhang_ji@worksap.co.jp&gt; 1500537698 +0800 -&gt; 提交者与时间戳(一般来说作者与提交者是同一个人,但万事总有例外,即作者是一个账户,提交的时候切换账户的)update POM version. refs #300039 from 17.06.hr-SNAPSHOT to 17.07.recruiting-SNAPSHOT -&gt; 日志信息 其中parent就可以画出类似如下的版本图 Blob文件的内容依据Blob文件的类型的不同而不同 当类型是最基本的Blob时,内容是zip(header + 被管理文件的内容)(这里的zip是前面图中(Blob的文件类型)的Compress with zlib) 当类型是tree时,内容是header + 孩子的SHA-1值 当类型是commit时,内容是header + 其他元信息 Git引用(Git References)为什么需要Git引用问题在我们上述的讨论中,我们知道 当一个项目中的所有文件被git管理之后,项目中每一个文件(文件增删改都算一个新文件)都会在.git目录下创建一个对应的Blob 项目中文件的目录结构我们使用Tree Object进行记录 其他日志信息,commit信息(例如:commit的前一个commit)等,我们使用Commit Object进行记录,通过Commit Object的记录,我们能够一步一步进行回溯 那么,就只剩最后一个问题:为了能遍历那段历史从而找到所有相关对象，我们必须记住最后一个提交的SHA-1值 也就是说,最终问题为:我们要如何记住最后一个Commit的SHA-1值 解决用一个文件来保存SHA-1值,并给文件起一个简单的名字,然后用这个名字指针来替代原始的SHA-1值 什么是Git引用上述解决方案,可以知道我们需要如下东西 一个文件，文件内容是包含一个指向Blob的SHA-1密钥 那么,这个东西,我们称之为Git引用,可以在.git/refs下找到 在git中具体有哪些是”引用”因为引用是放在.git/refs目录下的,我们看看.git/refs下有什么东西 1234567$ find .git/refs.git/refs.git/refs/heads.git/refs/heads/master.git/refs/tags... 顺便查看一下这些文件里有什么 12$ cat .git/refs/heads/master5b474b21cebf1385bfe8f3d1470c5d89c7c964b5 # SHA-1值,即指向Blob文件 总结一下,从上述目录底下和定义可以知道,以下这些都应是Git References Branches Tags Remotes the HEAD更具体可以看这:Git 内部原理 - Git 引用 进行一次commit,来说明上述概念 现在我们有一个引用.git/refs/heads/master,这个文件内指向的Blob文件是a7d59c...,而a7d59c...是一个commit a7d59ccommit文件内包含了本次提交的树的根节点信息,指向36055这个Blob文件(树对象) 36055树对象文件内容有两个SHA-1值,一个代表e9c055树对象,一个指向e84556Blob文件 e9c055树对象文件内容也有两个SHA-1值,分别指向1f4824Blob文件和eaa5faBlob文件 修改b.txt文件 这时,由于b.txt的文件内容发生了变化,那么b.txt就是一个新文件了,此时这个新文件有一个与之对应的新的Blob文件7e0616 由于出现新文件,那么要重新构建树对象,此时创建一个新的树对象文件,文件名为9fee6e,文件内容为7e0616和eaa5fa(由于a.txt文件没有修改,所以对于a.txt还是指向原来的Blob文件) 接着在往上,自然仍需要重新构建树对象,此时创建一个新的树对象文件,文件名为a0714d,文件内容为9fee6a和e84556(因为README文件没有修改,所以仍指向原Blob文件) 将这个树对象已经全部构建完成了,需要提交commit了,这个新的commit5b474b的tree值就是a0714d,parent值就是a7d59c,日志信息为”update b.txt” 最后,将.git/refs/heads/master文件的值改为5b47b,则提交完成","tags":[{"name":"Git","slug":"Git","permalink":"https://zjinc36.github.io/tags/Git/"}]},{"title":"正则表达式之前瞻断言与后瞻断言","date":"2020-01-24T11:58:09.000Z","path":"2020/01/24/正则表达式之前瞻断言与后瞻断言/","text":"有时候我们需要匹配后面跟着特定模式的一段模式。比如，我们要从 1 turkey costs 30€ 这段字符中匹配价格数值。 我们需要获取 € 符号前面的数值（假设价格是整数）。 那就是前瞻断言要做的事情。 前瞻断言前瞻肯定断言 语法为：x(?=y)，它表示 “匹配 x, 仅在后面是 y 的情况” 那么对于一个后面跟着 € 的整数金额，它的正则表达式应该为：\\d+(?=€)。 举例123let str = \"1 turkey costs 30€\";alert(str.match(/\\d+(?=€)/)); // 30 （正确地跳过了单个的数字 1） 前瞻否定断言 语法为：x(?!y)，意思是 “查找 x, 但是仅在不被 y 跟随的情况下匹配成功” 那么当我们想要一个不被 € 跟着的数值时，它的正则表达式应该为：\\d+(?!€)。 举例123let str = \"2 turkeys cost 60€\";alert( str.match(/\\d+(?!€)/) ); // 2（正确地跳过了价格） 后瞻断言 前瞻断言允许添加一个“后面要跟着什么”的条件判断。 后瞻断言也是类似的，只不过它是在相反的方向上进行条件判断。也就是说，它只允许匹配前面有特定字符串的模式。 后瞻肯定断言 语法为:后瞻肯定断言：(?&lt;=y)x, 意思是：匹配 x, 仅在前面是 y 的情况 举例123let str = \"1 turkey costs $30\";alert( str.match(/(?&lt;=\\$)\\d+/) ); // 30 （跳过了单个的数字 1）&gt;))) 后瞻否定断言 语法为：后瞻否定断言：(?&lt;!y)x, 意思是：匹配 x, 仅在前面不是 y 的情况 举例123let str = \"2 turkeys cost $60\";alert( str.match(/(?&lt;!\\$)\\d+/) ); // 2 (跳过了价格)","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://zjinc36.github.io/tags/正则表达式/"}]},{"title":"Yarn运行机制","date":"2019-12-13T15:45:45.000Z","path":"2019/12/13/Yarn运行机制流程图/","text":"Yarn运行机制Yarn运行机制流程图 具体步骤作业提交 Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业。 Client向RM申请一个作业id。 RM给Client返回该job资源的提交路径(hdfs://…/.staging/)和作业application_id。 Client在该路径提交jar包、切片信息和配置文件。 Client提交完资源后，向RM申请运行MrAppMaster。 作业初始化 当RM收到Client的请求后，将该job添加到资源调度器中，将job初始化成task。 某一个空闲的NM领取到该Job。 在该NM中创建Container，并产生MRAppmaster(一个job创建一个)，它管理该job。 下载之前Client提交的资源到本地。 任务分配 MRAppMaster向RM申请运行多个MapTask任务资源。 RM将运行MapTask任务分配给另外两个NodeManager，另外两个NodeManager分别领取任务并创建容器。 任务执行 MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。 MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。 ReduceTask向MapTask获取相应分区的数据。 程序运行完毕后，MR会向RM申请注销自己。 一些细节4大组件 ResourceManager：总的老大：处理客户端请求，监控NodeManager，启动或监控ApplicationMaster，资源的分配与调度 NodeManager：单个节点的老大：管理单个节点的资源，处理来自ResourceManager、ApplicationMaster的命令 ApplicationMaster：单个job的老大：负责数据切分，为应用程序申请资源并分配内部的任务，任务的监控与容错 Container：资源抽象：如内存、cpu、磁盘、网络等 3种资源调度器 FIFO：先进先出 Capacity Scheduler：多FIFO队列，会对同一用户提交资源进行限定，会把任务分配给更闲的队列。 Fair Scheduler：多队列，按缺额排序，缺额大者优先执行 任务推测执行机制 问题：系统中有99%的Map任务都完成了，只有少数几个Map老是进度很慢，完不成。 办法：为拖后腿任务启动一个备份任务，同时运行。谁先运行完，则采用谁的结果。 前提：每个Task只能有一个备份任务，当前Job已完成的Task必须不小于0.05（5%）。 不适用：任务间存在严重的负载倾斜；特殊任务，比如任务向数据库中写数据。 参考hadoop-Yarn流程解析","tags":[{"name":"BigData","slug":"BigData","permalink":"https://zjinc36.github.io/tags/BigData/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://zjinc36.github.io/tags/Hadoop/"}]},{"title":"Hadoop运行模式","date":"2019-12-12T23:06:48.000Z","path":"2019/12/13/Hadoop运行模式/","text":"本地运行模式官方grep案例 官方地址:Hadoop: Setting up a Single Node Cluster 在hadoop文件夹下创建一个input文件夹 1$ mkdir input 复制配置文件目录作为输入 1$ cp etc/hadoop/*.xml input 查找并显示给定正则表达式的每个匹配项,输出到给定的输出目录 1$ bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar grep input output &apos;dfs[a-z.]+&apos; 展示输出 1$ cat output/* 伪分布式运行模式启动HDFS并运行MapReduce程序分析 配置集群 启动并测试集群的增,删,查 执行WordCount案例 执行步骤 配置hadoop-env.sh 12345$ echo $&#123;JAVA_HOME&#125;$ vim etc/hadoop/hadoop-env.sh修改JAVA_HOME路径export JAVA_HOME=/your/java/path 配置etc/hadoop/core-site.xml 12345678910111213&lt;configuration&gt; &lt;!-- 指定HDFS中NameNode的地址 --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定HadHoop运行时产生文件的存储目录 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/opt/hadoop-2.9.2/data/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置etc/hadoop/hdfs-site.xml 12345678&lt;!-- 指定HDFS副本的数量 --&gt;&lt;!-- Hadoop虽然是多副本,但单一节点之多存储一份副本 --&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动 格式化NameNode(第一次启动时格式化,以后就不要总格式化) 1$ bin/hdfs namenode -format 启动NameNode 12$ sbin/hadoop-daemon.sh start namenode$ jps 启动DataNode 12$ sbin/hadoop-daemon.sh start datanode$ jps web端查看HDFS文件系统http://localhost:50070/dfshealth.html#tab-overview 查看产生的Log日志 1$ cd /opt/hadoop-2.9.2/logs 思考:为什么不能一直格式化NameNode,格式化NameNOde要注意什么 格式化只能在启动之前格式化 格式化NameNOde,会产生新的集群id,导致NameNode和DataNode的集群id不一致,集群找不到已往数据.所以,格式NameNode时,一定要删除data数据和log日志,然后再格式化NameNode 也就是如下两个clusterID会不一样(这里是一样的) Hadoop多次格式化出现 WARN hdfs.DataStreamer: DataStreamer Excep 启动YARN并运行MapReduce程序 配置etc/hadoop/yarn-env.sh12配置JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/java-8-oracle 配置etc/hadoop/yarn-site.xml 1234567891011121314&lt;configuration&gt; &lt;!-- Reducer获取数据的方式 --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定YARN的ResourceManager的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt; &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt; &lt;!-- &lt;value&gt;localhost&lt;/value&gt; --&gt; &lt;/property&gt;&lt;/configuration&gt; 配置mapred-env.sh 12配置JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/java-8-oracle 配置etc/hadoop/mapred-site.xml 如果没有这个文件,则拷贝mapred-site.xml.template并重命名为mapred-site.xml 1$ cp mapred-site.xml.template mapred-site.xml 配置mapred-site.xml文件 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;!-- &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt; --&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动集群 启动前必须保证NameNode和DataNode已经启动 启动ResourceManager123$ sbin/yarn-daemon.sh start resourcemanager$ jps 启动NodeManager123$ sbin/yarn-daemon.sh start nodemanager$ jps 集群操作 YARN的浏览器页面查看http://localhost:8088/cluster 举例123hadoop fs -put input /hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.9.2.jar grep /input /outputhadoop fs -cat /output/\\* &lt;- 这里*号转义是我自己终端的问题 错误: 找不到或无法加载主类 org.apache.hadoop.mapreduce.v2.app.MRAppMaster 完全分布式运行模式","tags":[{"name":"BigData","slug":"BigData","permalink":"https://zjinc36.github.io/tags/BigData/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://zjinc36.github.io/tags/Hadoop/"}]},{"title":"Hadoop核心问题","date":"2019-12-12T22:48:51.000Z","path":"2019/12/13/Hadoop核心问题/","text":"Hadoop核心问题海量数据 数据量进制 1bit = 1位 1byte = 8bit 1kb = 1024byte 1mb = 1024kb 1gb = 1024mb 1tb = 1024gb 1pb = 1024tb 1eb = 1024pb 1zb = 1024eb 1yb = 1024zb 海量数据的存储分割存放 由于海量数据，所以一台电脑肯定放不下，最简单的方式就是分开存放，这就涉及到分布式 分布式 -&gt; dfs:distributed file system 运算mapreduce map -&gt; 映射 reduce -&gt; 化简","tags":[{"name":"BigData","slug":"BigData","permalink":"https://zjinc36.github.io/tags/BigData/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://zjinc36.github.io/tags/Hadoop/"}]},{"title":"Hadoop安装","date":"2019-12-11T20:35:45.000Z","path":"2019/12/12/Hadoop安装/","text":"Hadoop三大发行版本Hadoop三大发行版本:Apache,Cloudera,Hortonworks Apache:版本最原始(最基础)版本,对于入门学习最好 Cloudera:在大型互联网企业中用的较多 Hortonworks:文档较好 Hadoop的优势 高可靠性:Hadoop底层维护多个数据副本,所以即使Hadoop某个计算元素或存储故障,也不会导致数据的丢失 高扩展性:在集群间分配任务数据,可方便的扩展以千计的节点 高效性:在MapReduce的思想下,Hadoop是并行工作的,以加快任务处理速度 高容错性:能够将失败的任务重新分配 Hadoop1.x和Hadoop2.x区别 Hadoop组成HDFS架构概述 NameNode(nn):存储文件的元数据,如文件名,文件目录结构,文件属性(生成时间,副本数,文件权限),以及每个文件的块列表和块所在的DataNode等 DataNode(dn):在本地文件系统存储文件块数据,以及数据的校验和 Secondary NameNode(2nn):用来监控HDFS状态的辅助后台程序,每隔一段时间获取HDFS元数据的快照 YARN架构概述YARN调度内存和CPU,即调度的是算力资源 MapReduceMapReduce将计算过程分为两个阶段:Map和Reduce Map阶段并行处理数据 Reduce阶段对Map结果进行汇总 Hadoop安装下载这是一个apache项目,自然在官网进行下载,下载方式很多,用命令wget也好,用curl也罢,这里主要说明要在哪里能找到Hadoop程序 http://apache.org/index.html 找到Hadoop 下载想要的版本的二进制文件 点击下载 安装安装很简单,解压就好,解压完后,目录下有如下文件 配置变量123456789101112131415161. cd /etc/profile.d/2. sudo vim jdk.sh3. 输入如下内容,并保存export J2SDKDIR=/usr/lib/jvm/java-8-oracleexport J2REDIR=/usr/lib/jvm/java-8-oracle/jreexport PATH=$PATH:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/binexport JAVA_HOME=/usr/lib/jvm/java-8-oracleexport DERBY_HOME=/usr/lib/jvm/java-8-oracle/db4. sudo vim hadoop.sh5. 输入如下内容并保存export HADOOP_HOME=/opt/hadoop-2.9.2export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin6. source /etc/export 测试安装hadoop version Hadoop的目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118hadoop-2.9.2├── bin│ ├── container-executor│ ├── hadoop│ ├── hadoop.cmd│ ├── hdfs│ ├── hdfs.cmd│ ├── mapred│ ├── mapred.cmd│ ├── rcc│ ├── test-container-executor│ ├── yarn│ └── yarn.cmd├── etc│ └── hadoop│ ├── capacity-scheduler.xml│ ├── configuration.xsl│ ├── container-executor.cfg│ ├── core-site.xml│ ├── hadoop-env.cmd│ ├── hadoop-env.sh│ ├── hadoop-metrics2.properties│ ├── hadoop-metrics.properties│ ├── hadoop-policy.xml│ ├── hdfs-site.xml│ ├── httpfs-env.sh│ ├── httpfs-log4j.properties│ ├── httpfs-signature.secret│ ├── httpfs-site.xml│ ├── kms-acls.xml│ ├── kms-env.sh│ ├── kms-log4j.properties│ ├── kms-site.xml│ ├── log4j.properties│ ├── mapred-env.cmd│ ├── mapred-env.sh│ ├── mapred-queues.xml.template│ ├── mapred-site.xml.template│ ├── slaves│ ├── ssl-client.xml.example│ ├── ssl-server.xml.example│ ├── yarn-env.cmd│ ├── yarn-env.sh│ └── yarn-site.xml├── include│ ├── hdfs.h│ ├── Pipes.hh│ ├── SerialUtils.hh│ ├── StringUtils.hh│ └── TemplateFactory.hh├── lib│ └── native│ ├── examples│ ├── libhadoop.a│ ├── libhadooppipes.a│ ├── libhadoop.so -&gt; libhadoop.so.1.0.0│ ├── libhadoop.so.1.0.0│ ├── libhadooputils.a│ ├── libhdfs.a│ ├── libhdfs.so -&gt; libhdfs.so.0.0.0│ └── libhdfs.so.0.0.0├── libexec│ ├── hadoop-config.cmd│ ├── hadoop-config.sh│ ├── hdfs-config.cmd│ ├── hdfs-config.sh│ ├── httpfs-config.sh│ ├── kms-config.sh│ ├── mapred-config.cmd│ ├── mapred-config.sh│ ├── yarn-config.cmd│ └── yarn-config.sh├── LICENSE.txt├── NOTICE.txt├── README.txt├── sbin│ ├── distribute-exclude.sh│ ├── FederationStateStore│ │ ├── MySQL│ │ └── SQLServer│ ├── hadoop-daemon.sh│ ├── hadoop-daemons.sh│ ├── hdfs-config.cmd│ ├── hdfs-config.sh│ ├── httpfs.sh│ ├── kms.sh│ ├── mr-jobhistory-daemon.sh│ ├── refresh-namenodes.sh│ ├── slaves.sh│ ├── start-all.cmd│ ├── start-all.sh│ ├── start-balancer.sh│ ├── start-dfs.cmd│ ├── start-dfs.sh│ ├── start-secure-dns.sh│ ├── start-yarn.cmd│ ├── start-yarn.sh│ ├── stop-all.cmd│ ├── stop-all.sh│ ├── stop-balancer.sh│ ├── stop-dfs.cmd│ ├── stop-dfs.sh│ ├── stop-secure-dns.sh│ ├── stop-yarn.cmd│ ├── stop-yarn.sh│ ├── yarn-daemon.sh│ └── yarn-daemons.sh└── share ├── doc │ └── hadoop └── hadoop ├── common ├── hdfs ├── httpfs ├── kms ├── mapreduce ├── tools └── yarn","tags":[{"name":"BigData","slug":"BigData","permalink":"https://zjinc36.github.io/tags/BigData/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://zjinc36.github.io/tags/Hadoop/"}]},{"title":"Docker简介","date":"2019-11-23T16:22:24.000Z","path":"2019/11/24/docker简介/","text":"Docker为什么会出现环境配置是异常麻烦的,换一台机器,就要重来一次,费事费力.很多人想到,能不能从根本上解决这个问题 -&gt; 即软件可以带环境安装吗?也就是说,安装的时候,把原始环境一模一样地复制过来.开发人员利用docker可以消除协作编码时”在我机器上可正常工作”的问题 Docker理念Docker的主要目标是”Build, Ship and Run Any App, Anywhere”,也就是通过对应用组件的封装,分发,部署,运行等生命周期的管理,使用户的App及其运行环境能过做到一次封装,到处运行 Docker是什么Docker是基于Go语言实现的云开源项目.解决了运行环境和配置问题软件容器,方便做持续集成并有助于整体发布的容器虚拟化技术 一次封装,到处运行一次封装,到处运行的方式传统的虚拟机方式虚拟机(virtual machine)就是带环境安装的一种解决方案 它可以在一种操作系统里面运行另一种操作系统,比如在windows系统里面运行linux系统.应用程序对此毫无感知,因为虚拟机看上去跟真实系统一模一样,而对于底层系统来说,虚拟机就是一个普通文件,不需要了就删掉,对其他部分毫无影响.这类虚拟机完美运行另一套系统,能够使应用程序,操作系统和硬件三者之间的逻辑不变. 虚拟机的缺点 资源占用多 冗余步骤多 启动慢 容器方式由于前面虚拟机存在这些缺点,Linux发展出另一种虚拟化技术:Linux容器(Linux Containers, 缩写为LXC) Linux容器不是模拟一个完整的操作系统,而是对进程进行隔离.有了容器,就可以将软件运行所需的所有资源打包到一个隔离的容器中.容器与虚拟机不同,不需要捆绑一整套操作系统,只需要软件工作所需的库资源和设置.系统因此而变得高效轻量并保证部署在任一环境中的软件都能始终如一的运行 比较了docker和传统虚拟化方式的不同之处: 传统虚拟技术是虚拟出一套硬件后,在其上运行一个完成操作系统,在该系统上在运行所需应用进程; 而容器内的应用进程直接运行于宿主的内核,容器内没有自己的内核,而且也没有进程硬件虚拟.因此容器要比传统虚拟机更为轻便; 每个容器之间相互隔离,每个容器有自己的文件系统,容器之间进程不会相互影响,能区分计算资源. 一次构建,到处运行的好处 更快速的应用交付和部署 更便捷的升级和扩容器 更简单的系统运维 更高效的计算资源利用","tags":[{"name":"docker","slug":"docker","permalink":"https://zjinc36.github.io/tags/docker/"}]},{"title":"Jquery可输入也可选择的下拉框","date":"2019-11-15T22:55:42.000Z","path":"2019/11/16/Jquery可输入也可选择的下拉框/","text":"来源可输入也可选择的下拉框(单选或输入) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;自定义下拉选择框&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123;margin:0; padding:0;&#125; ul,li&#123;list-style:none;&#125; :focus&#123;outline: none;&#125; input[type=text]&#123;border:1px solid #ccc;&#125; input[type=text]:hover,input[type=text]:focus&#123;border-color: #57bc80; box-shadow: none;&#125; /* 上面的css是初始化css,底下的css才是效果代码 */ body&#123;padding:50px; font-size: 12px;&#125; .my-select-box&#123;position: relative;&#125; .my-select-box .my-select-input&#123; height: 24px; line-height: 24px; padding:0 5px; background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAICAYAAADJEc7MAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAG2YAABzjgAA4DIAAIM2AAB5CAAAxgwAADT6AAAgbL5TJ5gAAABGSURBVHjaYvz//z8DOYCJgUzA0tnZidPK8vJyRpw24pLEpwnuVHRFhDQxMDAwMPz//x+OOzo6/iPz8WFGuocqAAAA//8DAD/sORHYg7kaAAAAAElFTkSuQmCC) right center no-repeat; padding-right:20px !important; width:100%; box-sizing: border-box; &#125; .my-select-box .my-select-list&#123;position:absolute; left:0; z-index: 101; border:1px solid #ccc; border-top:none; max-height: 120px; overflow-y: auto; display: none; background: #fff; width:100%; box-sizing: border-box;&#125; .my-select-box .my-select-list li&#123;height: 22px; line-height: 22px; padding:0 3px; cursor:pointer; margin-bottom: 1px&#125; .my-select-box .my-select-list li.choosed&#123;background: #ccc; color:#fff;&#125; .my-select-box .my-select-list li:hover&#123;background: #ccc; color:#fff;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"my-select-box\" style=\"width:300px;\"&gt; &lt;input type=\"text\" class=\"my-select-input\" placeholder=\"可输入也可选择\" maxlength=\"20\" /&gt; &lt;ul class=\"my-select-list\"&gt; &lt;li data-value=\"1\"&gt;第一项&lt;/li&gt; &lt;li data-value=\"2\"&gt;第二项&lt;/li&gt; &lt;li data-value=\"3\"&gt;第三项&lt;/li&gt; &lt;li data-value=\"4\"&gt;第四项&lt;/li&gt; &lt;li data-value=\"5\"&gt;第5项&lt;/li&gt; &lt;li data-value=\"6\"&gt;第6项&lt;/li&gt; &lt;li data-value=\"7\"&gt;第7项&lt;/li&gt; &lt;li data-value=\"8\"&gt;第8项&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div style=\"height: 30px\"&gt;&lt;/div&gt; &lt;div class=\"my-select-box\"&gt; &lt;input type=\"text\" class=\"my-select-input\" placeholder=\"可输入也可选择\" maxlength=\"20\" /&gt; &lt;ul class=\"my-select-list\"&gt; &lt;li data-value=\"1\"&gt;第一项&lt;/li&gt; &lt;li data-value=\"2\"&gt;第二项&lt;/li&gt; &lt;li data-value=\"3\"&gt;第三项&lt;/li&gt; &lt;li data-value=\"4\"&gt;第四项&lt;/li&gt; &lt;li data-value=\"5\"&gt;第5项&lt;/li&gt; &lt;li data-value=\"6\"&gt;第6项&lt;/li&gt; &lt;li data-value=\"7\"&gt;第7项&lt;/li&gt; &lt;li data-value=\"8\"&gt;第8项&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"jquery-3.2.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; ;(function($)&#123; $.fn.MySelect=function()&#123; this.each(function()&#123; var $box=$(this); var $input=$box.find(\"input.my-select-input\"); //输入框 var $list=$input.next(); //ul装扮成下拉框 var inputHeight=$input.outerHeight(); //计算input输入框的高度和宽度，方便定位ul和设置ul及包裹元素的宽度 $list.css(&#123;\"top\":(inputHeight)&#125;); $input.focus(function()&#123; //输入框获得焦点后，显示下拉选择ul var $nextUl=$(this).next(); if($nextUl.children().length&gt;0)&#123; $(this).next().show(); &#125; &#125;).bind('input propertychange',function()&#123; //绑定监测输入框的输入值更改 var $this=$(this); $this.attr(\"data-id\",\"\"); var curText=$this.val(); var $nextUl=$(this).next(); if($nextUl.children().length&gt;0)&#123; $nextUl.find(\"li\").removeClass(\"choosed\"); $nextUl.find(\"li\").each(function(i,item)&#123; var txt=$(item).text(); if(txt===curText)&#123; var v=$(item).attr(\"data-value\"); $this.attr(\"data-id\",v); $(item).addClass(\"choosed\"); &#125; &#125;); &#125; &#125;); //修改成如下事件绑定，为了给动态添加的li也可以产生点击效果 $list.off('click', 'li').on('click', 'li', function (e) &#123; var $this = $(this); var value = $this.attr(\"data-value\") || ''; $input.val($this.text()).attr(\"data-id\", value); $this.addClass(\"choosed\").siblings().removeClass(\"choosed\"); $this.parent().hide(); &#125;); &#125;); $(document).click(function (e) &#123; //点击.my-select-box范围外时隐藏ul下拉框 var target=e.target; var $target=$(target); var $parent=$target.closest('.my-select-box'); if($parent.length&lt;1)&#123; //说明不是.my-select-box范围内点击，将ul隐藏 $(\".my-select-list\").hide(); &#125;else if($parent.length==1)&#123; //如果存在多个my-select-box的情况，将其余的非这项以外的都隐藏 var $ul=$parent.find(\".my-select-list\"); var flag=$ul.is(\":hidden\"); $(\".my-select-list\").hide(); if(!flag) $ul.show(); &#125; &#125;); return this; &#125; &#125;)(jQuery); $(\".my-select-box\").MySelect(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果","tags":[{"name":"Jquery","slug":"Jquery","permalink":"https://zjinc36.github.io/tags/Jquery/"}]},{"title":"java用jackson包实现json、对象、Map之间的转换","date":"2019-11-12T10:25:25.000Z","path":"2019/11/12/java用jackson包实现json、对象、Map之间的转换/","text":"将对象转换成json12ObjectMapper mapper = new ObjectMapper(); //转换器 String jsonStr = mapper.writeValueAsString(user); json转换成map1Map m = mapper.readValue(json, Map.class); map转json1String jsonStr = mapper.writeValueAsString(m); json转java对象1User user = mapper.readValue(json, User.class);","tags":[{"name":"Jackson","slug":"Jackson","permalink":"https://zjinc36.github.io/tags/Jackson/"}]},{"title":"SpringSecurity的CSRF问题Invalid CSRF Token Null Was Found on...","date":"2019-11-12T09:48:48.000Z","path":"2019/11/12/SpringSecurity的CSRF问题Invalid-CSRF-Token-null-was-found-on/","text":"参考与引用Spring Security笔记：解决CsrfFilter与Rest服务Post方式的矛盾security禁用csrfspring security CSRF 问题 Invalid CSRF Token ‘null’ was found on …… 问题pring security在集成spring boot的微服务框架后，实现了cas认证和权限控制。只要使用post进行请求都会有如下问题 1HTTP Status 403－Invalid CSRF Token &apos;null&apos; was found on the request parameter &apos;_csrf&apos; or header &apos;X-CSRF-TOKEN&apos;. 原因Spring Security 4.0之后，引入了CSRF，默认是开启。 重点不得不说，CSRF和RESTful技术有冲突。CSRF默认支持的方法： GET HEAD TRACE OPTIONS 不支持POST 源码如下,POST方法被排除在外了,也就是说只有GET|HEAD|TRACE|OPTIONS这4类方法会被放行，其它Method的http请求，都要验证_csrf的token是否正确，而通常post方式调用rest服务时，又没有_csrf的token，所以校验失败。 12345678910private static final class DefaultRequiresCsrfMatcher implements RequestMatcher &#123; private Pattern allowedMethods = Pattern.compile(\"^(GET|HEAD|TRACE|OPTIONS)$\"); /* (non-Javadoc) * @see org.springframework.security.web.util.matcher.RequestMatcher#matches(javax.servlet.http.HttpServletRequest) */ public boolean matches(HttpServletRequest request) &#123; return !allowedMethods.matcher(request.getMethod()).matches(); &#125;&#125; 什么是csrf科普一下，什么是csrf,这是一个web应用安全的问题，CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack” 或者Session Riding，攻击方通过伪造用户请求访问受信任站点。 我们知道，客户端与服务端在基于http协议在交互的数据的时候，由于http协议本身是无状态协议，后来引进了cookie的 方式进行记录服务端和客户端的之间交互的状态和标记。cookie里面一般会放置服务端生成的session id（会话ID）用来识别客户端访问服务端过 程中的客户端的身份标记。 在跨域 (科普一下：同一个ip、同一个网络协议、同一个端口，三者都满足就是同一个域，否则就有跨域问题) 的情况下， session id可能会被恶意第三方劫持，此时劫持这个session id的第三方会根据这个session id向服务器发起请求，此时服务器收到这个请求会认为这是合法的请求，并返回根据请求完成相应的服务端更新。 为什么允许get而不允许post如果这个http请求是get方式发起的请求，意味着它只是访问服务器 的资源，仅仅只是查询，没有更新服务器的资源，所以对于这类请求，spring security的防御策略是允许的， 如果这个请求是通过post请求发起的， 那么spring security是默认拦截这类请求的，因为这类请求是带有更新服务器资源的危险操作，如果恶意第三方可以通过劫持session id来更新 服务器资源，那会造成服务器数据被非法的篡改，所以这类请求是会被Spring security拦截的，在默认的情况下，spring security是启用csrf 拦截功能的，这会造成，在跨域的情况下，post方式提交的请求都会被拦截无法被处理（包括合理的post请求），前端发起的post请求后端无法正常 处理，虽然保证了跨域的安全性，但影响了正常的使用，如果关闭csrf防护功能，虽然可以正常处理post请求，但是无法防范通过劫持session id的非法的post请求 解决原因找到了：spring Security 3默认关闭csrf，Spring Security 4默认启动了csrf 如果不采用csrf，可禁用security的csrfJava注解方式配置： 加上 .csrf().disable()即可。 修改前WebSecurityConfig.java 1234567891011121314@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .antMatchers(\"/\", \"/home\").permitAll() .and() .formLogin() .loginPage(\"/login\").permitAll() .and() .logout().logoutUrl(\"/logout\") .logoutSuccessUrl(\"/hello\") .permitAll(); http.addFilterBefore(customizeFilterSecurityInterceptor, FilterSecurityInterceptor.class) .csrf().disable();&#125; 不关闭csrf防护功能的前提下spring security要如何才能使用post方案一自己弄一个Matcher,既然源码中不允许POST,我们就自定义一个,放行就好 123456789101112131415161718192021222324252627282930313233343536373839package com.cnblogs.yjmyzz.utils;import java.util.List;import java.util.regex.Pattern;import javax.servlet.http.HttpServletRequest;import org.springframework.security.web.util.matcher.RequestMatcher;public class CsrfSecurityRequestMatcher implements RequestMatcher &#123; private Pattern allowedMethods = Pattern .compile(\"^(GET|HEAD|TRACE|OPTIONS)$\"); public boolean matches(HttpServletRequest request) &#123; if (execludeUrls != null &amp;&amp; execludeUrls.size() &gt; 0) &#123; String servletPath = request.getServletPath(); for (String url : execludeUrls) &#123; if (servletPath.contains(url)) &#123; return false; &#125; &#125; &#125; return !allowedMethods.matcher(request.getMethod()).matches(); &#125; /** * 需要排除的url列表 */ private List&lt;String&gt; execludeUrls; public List&lt;String&gt; getExecludeUrls() &#123; return execludeUrls; &#125; public void setExecludeUrls(List&lt;String&gt; execludeUrls) &#123; this.execludeUrls = execludeUrls; &#125;&#125; 这里添加了一个属性execludeUrls，允许人为排除哪些url。 然后在配置文件里，这样修改： 1234567891011121314&lt;http entry-point-ref=\"loginEntryPoint\" use-expressions=\"true\"&gt; ... &lt;intercept-url pattern=\"/rest/**\" access=\"permitAll\" /&gt; ... &lt;csrf request-matcher-ref=\"csrfSecurityRequestMatcher\"/&gt; &lt;/http&gt; &lt;beans:bean id=\"csrfSecurityRequestMatcher\" class=\"com.cnblogs.yjmyzz.utils.CsrfSecurityRequestMatcher\"&gt; &lt;beans:property name=\"execludeUrls\"&gt; &lt;beans:list&gt; &lt;beans:value&gt;/rest/&lt;/beans:value&gt; &lt;/beans:list&gt; &lt;/beans:property&gt; &lt;/beans:bean&gt; 方案二spring security为了正确的区别合法的post请求，采用了token的机制。 在跨域的场景下，客户端访问服务端会首先发起get请求，这个get请求在到达服务端的时候，服务端的Spring security会有一个过滤 器 CsrfFilter去检查这个请求，如果这个request请求的http header里面的X-CSRF-COOKIE的token值为空的时候，服务端就好自动生成一个 token值放进这个X-CSRF-COOKIE值里面，客户端在get请求的header里面获取到这个值，如果客户端有表单提交的post请求，则要求客户端要 携带这个token值给服务端，在post请求的header里面设置_csrf属性的token值，提交的方式可以是ajax也可以是放在form里面设置hidden 属性的标签里面提交给服务端，服务端就会根据post请求里面携带的token值进行校验，如果跟服务端发送给合法客户端的token值是一样的，那么 这个post请求就可以受理和处理，如果不一样或者为空，就会被拦截。由于恶意第三方可以劫持session id，而很难获取token值，所以起到了安全的防护作用。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://zjinc36.github.io/tags/SpringSecurity/"}]},{"title":"大数据学习大纲","date":"2019-10-12T16:53:34.000Z","path":"2019/10/13/大数据学习大纲/","text":"大数据概念大数据(Big Data):指无法在一定时间范围内用常规软件工具进行捕捉,管理和处理的数据集合,是需要新处理模式才能具有更强的决策力,洞察发现力和流程优化能力的海量,高增长率和多样化的信息资产 主要解决海量数据的存储和海量数据的分析计算问题 大数据特点 Volume(大量)截至目前,人类生产的所有印刷材料的数据量是200PB,而历史上全人类总共说过的话是5EB,当前,典型个人计算机硬盘容量为TB量级,而一些大企业的数据量已经接近EB量级 Velocity(高速)这是大数据区分于传统数据挖掘的显著特征.根据IDC的”数字宇宙”的报告,预计到2020年,全球数据使用量将达到35.2ZB.在如此海量的数据面前,处理数据的效率就是企业的生命 Variety(多样)这种类型的多样性也让数据分为结构化数据和非结构化数据.相对于以往便与存储的以数据库/文本为主的结构化数据,非结构化数据越来越多,包括网络日志,音频,视频,图片,地理位置信息等,这些多类型的数据对数据的处理能力提出了更高的要求 Value(价值低密度)价值密度的高低与数据总量大小成反比.比如,在一天监控视频中,我们只关系其中的一分钟.如何快速对有价值数据”提纯”称为目前大数据背景下待解决的难题 大数据应用场景 物流仓储:大数据分析系统助力商家精细化运营,提升销量,节约成本 零售:分析用户消费习惯,为用户购买商品提供方便,从而提高商品销量 旅游:深度结合大数据能力与旅游行业需求,共建旅游产业智慧管理,智慧服务和智慧营销的未来 商品广告推荐:给用户推荐可能喜欢的商品 保险:海量数据挖掘及风险预测,助力保险行业精准营销,提升精细化定价能力 金融:多维度体现用户特征,帮助金融机构推荐优质客户,防范欺诈风险 房产:大数据全面助力房地产行业,打造精准投策与营销,选出更何时的地,建造更合适的楼,卖给更合适的人 人工智能 大数据部门组织结构 大数据生态体系总体生态体系 细化 操作系统Linux Java基础篇 java语法基础 java数据类型 java分支循环 oop io collection","tags":[{"name":"BigData","slug":"BigData","permalink":"https://zjinc36.github.io/tags/BigData/"}]},{"title":"SpringBoot的验证功能","date":"2019-10-03T14:34:30.000Z","path":"2019/10/03/SpringBoot的验证功能/","text":"来源背景说明我们都知道,任何发送到服务器的数据都必须有验证,而对于验证,我们常会看见类似如下的代码 其实,这样的代码并没有什么不好的.而且有时候由于没有利用到框架的特性,这样的代码更利于实现业务. 但是,我碰到一件很闹心的事情,就是客户看代码了,且由于一知半解,指出没有利用SpringBoot的特性,直接打回来了. 被打回来的项目里面,表单里有近两百个输入选项,各种逻辑,并且页面转换的时候是不允许使用任何存储(数据库,session,cookie) 同时,这些输入项有很多业务前后相关 具体来说 需要A,B,C存在才验证B 验证需要快速失败,即参数A有验证甲乙丙三种,按顺序,甲失败了,乙就不继续验证了 当然,好事来说,我经过这么折腾一次,整个验证都弄清楚了 SpringBoot的验证ValidationHibernate Validator文档地址:https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#preface Spring Validator文档地址:https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/core.html#validation","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zjinc36.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot的快速入门","date":"2019-10-02T22:52:32.000Z","path":"2019/10/03/SpringBoot的快速入门/","text":"Controller编写和测试 入门解析 工程的热部署 起步依赖 自动配置原理分析 配置文件的类型和作用 配置文件-yml文件的普通属性和对象属性 配置文件-yml文件的集合配置 通过@Value映射数据 通过@ConfigurationProperties映射数据 configuration-processor作用 集成Mybatis 集成Junit 集成SpringDataJPA 集成Redis","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zjinc36.github.io/tags/SpringBoot/"}]},{"title":"Flink运行架构总结","date":"2019-09-14T07:59:10.000Z","path":"2019/09/14/Flink运行架构总结/","text":"任务提交流程 TaskManager 与 Slotstask slot是什么 task slot表示内存资源且这个内存资源是TaskManager 拥有的内存资源的子集 TaskManager划分出task slot的目的 不需要跟来自其他 job 的 subtask 竞争被管理的内存(防止线程竞争内存资源,这里不会涉及到 CPU 的隔离) 一个 TaskManager 多个 slot 意味着 一个TaskManager 能接收多少个task &lt;=&gt; task slot的数量 &lt;=&gt; TaskManager 将内存资源平均分成几份 subtask 可以共享同一个 JVM ==&gt; 将共享 TCP 连接（基于多路复用）和心跳消息 ==&gt; 共享数据集和数据结构 ==&gt; 减少了每个task 的负载 防止线程竞争内存资源(这里不会涉及到 CPU 的隔离) 最大并行度(并发执行能力)( ==&gt; 注意和并行度进行区分) 最大并行度:即Task Slot的数量,是静态概念,指 TaskManager 具有的并发执行能力,用taskmanager.numberOfTaskSlots参数设置 并行度(parallelism): 是动态概念，即 TaskManager 运行程序时实际使用的并发能力,用parallelism.default参数设置 举例:假设一共有 3 个 TaskManager，每一个 TaskManager 中的分配 3 个TaskSlot，也就是每个 TaskManager 可以接收 3 个 task，一共 9 个 TaskSlot，如果我们设置 parallelism.default=1，即运行程序默认的并行度为 1，9 个 TaskSlot 只用了 1个，有 8 个空闲，因此，设置合适的并行度才能提高效率 Dataflow核心组件 由 Source、Transformation、Sink 这三个核心组件组成 &lt;=&gt; 输入(source operator) –stream–&gt; 转换(transformations operators) –stream–&gt; 输出(sink operator) 一个 stream 包含一个或多个 stream partition 一个 operator 包含一个或多个 operator subtask (operator subtasks 在不同的线程、不同的物理机或不同的容器中彼此互不依赖得执行) 并行度 一个特定 operator 的 subtask 的个数被称之为其 parallelism(并行度) 注意与最大并行度进行区分 如何执行 one-to-one的operator形成链条(operator chains),即形成subTask链,一条链相当于一个完整的task,只在一个线程中运行 类似Spark中的窄依赖 目的是减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量 Redistributing的operator运行一个线程 类似Spark中的宽依赖 一个操作链(设并行度是2) ==&gt; 将一个操作链划分成两部分 ==&gt; 对于每一个部分使用一个独立的task去运行(即一个独立的线程) ==&gt; 一个task处理的数据就是一个分区的数据 任务调度流程","tags":[{"name":"BigData","slug":"BigData","permalink":"https://zjinc36.github.io/tags/BigData/"}]},{"title":"Ubuntu中wps2019可以插入公式","date":"2019-09-12T09:38:40.000Z","path":"2019/09/12/Ubuntu中wps2019可以插入公式/","text":"下载地址:https://linux.wps.cn/ 说明 伴随着这次新版本的发行，我们将在Linux平台首次引入新公式插入功能，便捷高效、灵活易用。针对文档中插入复杂公式的应用需求，该功能将帮助用户更加舒适地将复杂多变的公式内容精准地落实到文档当中。","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"SpringBoot的环境搭建","date":"2019-09-03T22:39:41.000Z","path":"2019/09/04/SpringBoot的环境搭建/","text":"创建maven项目 项目创建完成后的结构图 修改pom.xml文件12345678910111213141516171819202122232425&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;spring&lt;/groupId&gt; &lt;artifactId&gt;boot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- springboot 项目要继承起步依赖 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- web功能的起步依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建示例代码 图片中的代码如下 12345678910111213package com.zjinc36;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MySpringBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MySpringBootApplication.class); &#125;&#125; 需要注意两个东西(暂时不用了解为什么) @SpringBootApplication SpringApplication.run(); 运行run as -&gt; spring boot app可以看到如下结果 在浏览器访问可以看到已经访问成功(页面出现错误是现在什么页面都没有)","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://zjinc36.github.io/tags/SpringBoot/"}]},{"title":"Ubuntu中安装iptux","date":"2019-08-18T17:26:35.000Z","path":"2019/08/19/ubuntu中安装iptux/","text":"作用ubuntu版的飞鸽传书 安装ubuntu软件中直接搜索安装","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu中安装桌面维基zim","date":"2019-08-18T16:49:05.000Z","path":"2019/08/19/ubuntu中安装桌面维基zim/","text":"zim是什么Zim是一个图形文本编辑器，用于维护一组wiki页面。 zim的作用每个页面都可以包含指向其他页面的链接，简单的格式和图像。页面存储在文件夹结构中，就像在大纲中一样，并且可以具有附件。创建新页面就像链接到不存在的页面一样简单。所有数据都存储在具有wiki格式的纯文本文件中。各种插件提供附加功能，如任务列表管理器，公式编辑器，托盘图标和版本控制支持。 Zim可用于： 保留笔记存档 保留每日或每周日记 在会议或讲座期间做笔记 组织任务列表 撰写博客条目和电子邮件 做头脑风暴 官网https://zim-wiki.org/ 安装123sudo add-apt-repository ppa:jaap.karssenberg/zimsudo apt-get updatesudo apt-get install zim","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"ubuntu中安装Openshot Video Editor","date":"2019-08-18T16:01:15.000Z","path":"2019/08/19/ubuntu中安装openshot-video-editor/","text":"作用能够支持视频剪辑、实时预览、支持设置仅显示视频或音频、图片覆盖等 安装Ubuntu软件中直接搜索安装就行","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"线性回归","date":"2019-08-17T18:39:54.000Z","path":"2019/08/18/线性回归/","text":"引出线性回归是最基础的回归算法 思考：x与y符合什么关系呢？ 观察到x与y的关系（模型选择），y=ax+b，建立线性回归模型 通过优化方法设法拟合数据，得到最优的a 评估该模型是否准确，查看训练集上的准确率 评估该模型的泛化性能，在测试集上的准确率 基本概念 训练集 测试集(交叉验证法、自助法等) =&gt; k折测试集 =&gt; 就是在不同区间上选取数据进行测试 目标函数 损失函数 优化方法 拟合 过拟合 =&gt; 就是太准确了,和样本数据几乎一样,这很大程度上会导致样本数据中的噪音也被拟合进函数了 欠拟合 准确率、泛化性能 一元线性回归模型 多元线性回归模型 上述直接采用极值方法求解，有什么缺点？如何解决缺点 数据非常多的时候,根本没办法全部放到内存中 解决 可以使用梯度下降求解最小值 梯度下降算法 优化方法 随机梯度下降法(SGD):只根据眼前的路径梯度下降求解的方法，称为随机梯度下降法(SGD) ⼩批量随机梯度下降:实际上使用样本的过程中，出于效率和稳定性的考虑，我们使用MiniBatch-SGD方法，使用批处理平均来进行梯度更新，而不是对每一个数据都进行一次梯度更新 思考：目标函数一定有最小值吗？ 不一定,但我们只需要极小值 准确度评估对于连续数据(回归问题)一般使用方差评估 对于离散数据(分类问题)三个指标 accuracy =&gt; 准确率 =&gt; 预测对的/所有 precision =&gt; 精确率 =&gt; 将正类预测为正类数/(将正类预测为正类数 + 将负类预测为正类数) recall =&gt; 召回率 =&gt; 将正类预测为正类数/(将正类预测为正类数 + 将正类预测为负类数) 例：训练样本有100个，其中60个为正，40个为负。现分类器对100个样本进行标记正负，各标记了50个。在正样本中，分对40个，分错10个，负样本中，分对30个，分错20个，则： TP: 将正类预测为正类数 40 FN: 将正类预测为负类数 20 FP: 将负类预测为正类数 10 TN: 将负类预测为负类数 30 准确率(accuracy) = 预测对的/所有 = (TP+TN)/(TP+FN+FP+TN) = (100 - 10 - 20) / 100 = 70% 精确率(precision) = TP/(TP+FP) = 40 / 50 = 80% 召回率(recall) = TP/(TP+FN) = 40 / 60 = 2/3 = 66.6% 为什么这样起名? 召回率 (Recall)：正样本有多少被找出来了（召回了多少）。 精确率 (Precision)：你认为的正样本，有多少猜对了（猜的精确性如何）。 调和平均数 所有数字取倒数 计算这些倒数的算术平均数 对上一步的计算结果取倒数 注意 召回率为R, 准确率为P。使用他们对算法的评估，这两个值通常情况下相互制约。 宁可错杀，不可放过：低准确，高召回。 宁可放过一个坏人，也绝不冤枉一个好人：高准确，低召回。 为了更加方便的评价算法的好坏。于是引入了F1值。F1为准确率P和召回率R的调和平均数。为什么F1使用调和平均数，而不是数字平均数。 举个例子：当R 接近于1, P 接近于 0 时。采用调和平均数的F1值接近于0；而如果采用算数平均数F1的值为0.5；显然采用调和平均数能更好的评估算法的性能。等效于评价R和P的整体效果","tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://zjinc36.github.io/tags/人工智能/"}]},{"title":"人工智能数学基础之概率论","date":"2019-08-17T18:36:15.000Z","path":"2019/08/18/人工智能数学基础之概率论/","text":"大数定理大数定理的定义 一件事发生的次数足够多,它就可信 大数定律(law of large numbers)，是一种描述当试验次数很大时所呈现的概率性质的定律。 但是注意到，大数定律并不是经验规律，而是在一些附加条件上经严格证明了的定理，它是一种自然规律因而通常不叫定理而是大数“定律”。而我们说的大数定理通常是经数学家证明并以数学家名字命名的大数定理，如伯努利大数定理 抛硬币实验概率与直观 不断抛掷一枚硬币，得到正面与反面的频率比例是多少呢？ 经过无数次抛掷，频率的极限趋近于X? 抛掷趋于无穷次时，正反面频率一致，根据大数定理 概率计算的基本公式概率的计算 已知A、B独立时,求交和并概率 条件概率 全概率公式 贝叶斯公式强调：这是一个非常重要的公式，记住它，基本就掌握了机器学习一半的内容 期望与方差 变量的分布伯努利分布有一类试验，比如抛掷硬币得到正面还是反面，项目成功或失败，产品是否有缺陷，只有两个可能结果。记这两个可能的结果为0和1，该分布就称为伯努利分布。 二项分布伯努利分布重复N次，就构成了二项分布。 高斯分布(正态分布)服从中心极限定律，是非常重要的分布。 熵 不是化学中的熵,是信息论中的熵,指的是传递信息需要的最小信息量 问题:世界杯比赛有32支球队参加，最少用多少bit信息表示出最后获胜的队伍？出最后获胜的队伍？ 传递的信息一定发生,则lnp(x) = ln1 = 0,所以熵为0 传递的信息一定不发生,则p(x) = 0,所以熵为0","tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://zjinc36.github.io/tags/人工智能/"}]},{"title":"人工智能数学基础之线性代数 => 分离技术","date":"2019-08-17T18:30:11.000Z","path":"2019/08/18/人工智能数学基础之线性代数/","text":"为什么研究线性变换 对于多项式来说,我们处理的更多是系数,而系数永远是线性的,所以线性代数才那么重要 线性变换指旋转、推移，他们的组合是线性变换 行列式 行列式的本质：线性变换的缩放因子 公式 &lt;= (高代书55定义4) 2*2矩阵的公式 3*3矩阵的公式 矩阵和乘法 矩阵的本质：线性变换！ 对应的图像 矩阵的缩放与旋转向量旋转与缩放与矩阵的关系 什么情况下矩阵乘法是缩放矩阵呢？ 仅对角线有非零值的矩阵为缩放矩阵 但对角线以外有非零元素,则不一定不是缩放矩阵 对角线元素代表了每个维度的缩放强度 什么情况下矩阵乘法是旋转矩阵呢？ 列向量正交且为单位向量的矩阵，也即正交阵为旋转矩阵 分离技术数学基础 =&gt; 特征值分解 矩阵能转成对角矩阵的充分必要条件:设线性变换A是n维空间V的一个线性变换,A的矩阵可以在某一组基下为对角矩阵的充分必要条件是,A有n个线性无关的特征向量 &lt;= (高代书299页) 什么情况下有逆矩阵:行列式不等于0 相似矩阵:设A,B为数域P上的两个n级矩阵,如果可以找到数域P上的n级可逆矩阵X,使得B=(X^-1)AX,就说A相似与B,记作A~B &lt;= (高代书288页) 我们通过矩阵的相似变换,可以变成一个对角矩阵 变成对角矩后,对角线上部分数据会明显小于其它数据,单从数据上看,这样的数据权重很小,不重要,可以舍弃,就将对角矩阵的维度降低了,因为对角矩阵对应的线性变换的特征值个数和对角线上的非零元素个数相同,所以也相当于减少了特征值的个数 svd/NFM分解图像本质上是一张矩阵而我们减少了特征值的个数可以看出图像的变化 总结 矩阵 &lt;==&gt; 线性变换 特征值 &lt;==&gt; 缩放强度 行列式 &lt;==&gt; 缩放强度","tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://zjinc36.github.io/tags/人工智能/"}]},{"title":"人工智能数学基础之数学分析 => 梯度下降算法","date":"2019-08-17T18:27:05.000Z","path":"2019/08/18/人工智能数学基础之数学分析/","text":"映射与函数 极限 导数 导数是曲线的斜率，是曲线变化 快慢的反应； 可导一定连续，连续不一定可导 极值如何求解导数为0的位置 常用函数求导公式 求sigmoid函数导数导数为 说明 导数不会求着求着就没了 它是非线性的,非线性可以将数据映射到一个其他维度的空间上去 泰勒展开式 常用函数的泰勒展开 在某邻域内，存在一阶近似、二阶近似、…. 逼近非线性函数求解 梯度下降算法参考深入浅出–梯度下降法及其实现 原理用最通俗的语言来介绍下： 假设你站在华山之巅，你现在想以最快速度下山，那你肯定是找一条最陡峭的路走。你环顾四周，找到了一条路线，恩，这个方向是最陡的。于是你就出发了，走了一会发现，这个方向不是最陡的路了。你就停下来，换了个最陡的方向，继续往下走。重复这个步骤，你最终到达了山脚下。 那么，你从山顶到山脚的整个下山的过程，就是梯度下降。 困难点 可以假设这座山最陡峭的地方是无法通过肉眼立马观察出来的，而是需要一个复杂的工具来测量，同时，你此时正好拥有测量出最陡峭方向的能力。所以，你每走一段距离，都需要一段时间来测量所在位置最陡峭的方向，这是比较耗时的。那么为了在太阳下山之前到达山底，就要尽可能的减少测量方向的次数。 这是一个两难的选择，如果测量的频繁，可以保证下山的方向是绝对正确的，但又非常耗时，如果测量的过少，又有偏离轨道的风险。 所以需要找到一个合适的测量方向的频率，来确保下山的方向不错误，同时又不至于耗时太多！ 什么是梯度偏微分(偏导)看待微分的意义，可以有不同的角度，最常用的两种是： 函数图像中，某点的切线的斜率 函数的变化率 几个微分的例子： 上面的例子都是单变量的微分，当一个函数有多个变量的时候，就有了多变量的微分，即分别对每个变量进行求微分 梯度梯度实际上就是多变量微分的一般化。我们可以看到，梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。如果是一个二维向量(两个力的方向),显然线性相加和(合力)是最大的,称之为方向导数 梯度是微积分中一个很重要的概念，之前提到过梯度的意义 在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率 在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向 这也就说明了为什么我们需要千方百计的求取梯度！我们需要到达山底，就需要在每一步观测到此时最陡峭的地方，梯度就恰巧告诉了我们这个方向。梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，这正是我们所需要的。所以我们只要沿着梯度的方向一直走，就能走到局部的最低点！ 梯度下降算法的数学解释数学公式说明上面我们花了大量的篇幅介绍梯度下降算法的基本思想和场景假设，以及梯度的概念和思想。下面我们就开始从数学上解释梯度下降算法的计算过程和思想！此公式的意义是：J是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点，也就是山底。首先我们先确定前进的方向，也就是梯度的反向，然后走一段距离的步长，也就是α，走完这个段步长，就到达了Θ1这个点！ 几点说明 α是什么含义？α在梯度下降算法中被称作为学习率或者步长，意味着我们可以通过α来控制每一步走的距离，以保证不要步子跨的太大扯着蛋，哈哈，其实就是不要走太快，错过了最低点。同时也要保证不要走的太慢，导致太阳下山了，还没有走到山下。所以α的选择在梯度下降法中往往是很重要的！α不能太大也不能太小，太小的话，可能导致迟迟走不到最低点，太大的话，会导致错过最低点！ 为什么要梯度要乘以一个负号？梯度前加一个负号，就意味着朝着梯度相反的方向前进！我们在前文提到，梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号 梯度下降算法的实例我们已经基本了解了梯度下降算法的计算过程，那么我们就来看几个梯度下降算法的小实例，首先从单变量的函数开始 单变量函数的梯度下降我们假设有一个单变量的函数 函数的微分 初始化，起点为 学习率为 根据梯度下降的计算公式 我们开始进行梯度下降的迭代计算过程： 如图，经过四次的运算，也就是走了四步，基本就抵达了函数的最低点，也就是山底 多变量函数的梯度下降我们假设有一个目标函数 现在要通过梯度下降法计算这个函数的最小值。我们通过观察就能发现最小值其实就是 (0，0)点。但是接下来，我们会从梯度下降算法开始一步步计算到这个最小值！我们假设初始的起点为： 初始的学习率为 函数的梯度为 进行多次迭代 我们发现，已经基本靠近函数的最小值点 梯度下降算法的实现简单说明最小二乘法某次实验得到了四个数据点 (x ,y):(1,6)、(2,5)、(3,7)、(4,10)（下图红色的点）。我们希望找出一条和这四个点最匹配的直线 最小二乘法采用的方法是尽量使得等号两边的平方差最小，也就是找出这个函数的最小值：最小值可以通过对上述函数分别求偏导数,然后使他们等于零得到。如此就得到了一个只有两个未知数的方程组，很容易就可以解出：也就是说直线y = 3.5 + 1.4x是最佳的。 梯度下降算法的实现下面我们将用python实现一个简单的梯度下降算法。场景是一个简单的线性回归的例子：假设现在我们有一系列的点，如下图所示 我们将用梯度下降法来拟合出这条直线！首先，我们需要定义一个代价函数，在此我们选用均方误差代价函数(最小二乘法) 此公式中 m是数据集中点的个数 ½是一个常量，这样是为了在求梯度的时候，二次方乘下来就和这里的½抵消了，自然就没有多余的常数系数，方便后续的计算，同时对结果不会有影响 y 是数据集中每个点的真实y坐标的值 h 是我们的预测函数，根据每一个输入x，根据Θ 计算得到预测的y值，即我们可以根据代价函数看到，代价函数中的变量有两个，所以是一个多变量的梯度下降问题，求解出代价函数的梯度，也就是分别对两个变量进行微分 明确了代价函数和梯度，以及预测的函数形式。我们就可以开始编写代码了。但在这之前，需要说明一点，就是为了方便代码的编写，我们会将所有的公式都转换为矩阵的形式，python中计算矩阵是非常方便的，同时代码也会变得非常的简洁。 为了转换为矩阵的计算，我们观察到预测函数的形式 我们有两个变量，为了对这个公式进行矩阵化，我们可以给每一个点x增加一维，这一维的值固定为1，这一维将会乘到Θ0上。这样就方便我们统一矩阵化的计算 然后我们将代价函数和梯度转化为矩阵向量相乘的形式 代码实现首先，我们需要定义数据集和学习率 123456789101112131415161718import numpy as np# Size of the points dataset.m = 20# Points x-coordinate and dummy value (x0, x1).X0 = np.ones((m, 1))X1 = np.arange(1, m+1).reshape(m, 1)X = np.hstack((X0, X1))# Points y-coordinatey = np.array([ 3, 4, 5, 5, 2, 4, 7, 8, 11, 8, 12, 11, 13, 13, 16, 17, 18, 17, 19, 21]).reshape(m, 1)# The Learning Rate alpha.alpha = 0.01 接下来我们以矩阵向量的形式定义代价函数和代价函数的梯度 123456789def error_function(theta, X, y): '''Error function J definition.''' diff = np.dot(X, theta) - y return (1./2*m) * np.dot(np.transpose(diff), diff)def gradient_function(theta, X, y): '''Gradient of the function J definition.''' diff = np.dot(X, theta) - y return (1./m) * np.dot(np.transpose(X), diff) 最后就是算法的核心部分，梯度下降迭代计算 12345678def gradient_descent(X, y, alpha): '''Perform gradient descent.''' theta = np.array([1, 1]).reshape(2, 1) gradient = gradient_function(theta, X, y) while not np.all(np.absolute(gradient) &lt;= 1e-5): theta = theta - alpha * gradient gradient = gradient_function(theta, X, y) return theta 当梯度小于1e-5时，说明已经进入了比较平滑的状态，类似于山谷的状态，这时候再继续迭代效果也不大了，所以这个时候可以退出循环！ 完整的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041import numpy as np# Size of the points dataset.m = 20# Points x-coordinate and dummy value (x0, x1).X0 = np.ones((m, 1))X1 = np.arange(1, m+1).reshape(m, 1)X = np.hstack((X0, X1))# Points y-coordinatey = np.array([ 3, 4, 5, 5, 2, 4, 7, 8, 11, 8, 12, 11, 13, 13, 16, 17, 18, 17, 19, 21]).reshape(m, 1)# The Learning Rate alpha.alpha = 0.01def error_function(theta, X, y): '''Error function J definition.''' diff = np.dot(X, theta) - y return (1./2*m) * np.dot(np.transpose(diff), diff)def gradient_function(theta, X, y): '''Gradient of the function J definition.''' diff = np.dot(X, theta) - y return (1./m) * np.dot(np.transpose(X), diff)def gradient_descent(X, y, alpha): '''Perform gradient descent.''' theta = np.array([1, 1]).reshape(2, 1) gradient = gradient_function(theta, X, y) while not np.all(np.absolute(gradient) &lt;= 1e-5): theta = theta - alpha * gradient gradient = gradient_function(theta, X, y) return thetaoptimal = gradient_descent(X, y, alpha)print('optimal:', optimal)print('error function:', error_function(optimal, X, y)[0,0]) 运行代码，计算得到的结果如下所拟合出的直线如下 小结至此，我们就基本介绍完了梯度下降法的基本思想和算法流程，并且用python实现了一个简单的梯度下降算法拟合直线的案例！最后，我们回到文章开头所提出的场景假设:这个下山的人实际上就代表了反向传播算法，下山的路径其实就代表着算法中一直在寻找的参数Θ，山上当前点的最陡峭的方向实际上就是代价函数在这一点的梯度方向，场景中观测最陡峭方向所用的工具就是微分 。在下一次观测之前的时间就是有我们算法中的学习率α所定义的。可以看到场景假设和梯度下降算法很好的完成了对应 牛顿法梯度下降法中的”最快”过于盲目、有缺陷,所以进一步利用曲线二阶导的信息进行迭代求解，称为牛顿法 参考常见的几种最优化方法（梯度下降法、牛顿法、拟牛顿法、共轭梯度法等） 牛顿法作用牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数f (x)的泰勒级数的前面几项来寻找方程f (x) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。 牛顿法和梯度下降法的效率对比 从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。） 根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。注：红色的牛顿法的迭代路径，绿色的是梯度下降法的迭代路径。 牛顿法的优缺点总结： 优点：二阶收敛，收敛速度快； 缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。","tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://zjinc36.github.io/tags/人工智能/"}]},{"title":"人工智能的基本说明","date":"2019-08-17T08:56:39.000Z","path":"2019/08/17/人工智能基础说明/","text":"什么是人工智能？定义人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它试图了解智能的实质，并生产出一种新的能以人类智能相似的方式作出反应的智能机器 应用场景 机器人 语音识别 图像识别 自然语言处理 专家系统 知识工程 机器学习 人工智能是对人的意识、思维的信息过程的模拟。人工智能不是人的智能，但能像人那样的思考，甚至超过人的智能。 弱人工智能、强人工智能、超人工智能 弱人工智能Artificial Narrow Intelligence(ANI):弱人工智能是擅长于单个方面的人工智能。 强人工智能Artificial General Intelligence(AGI):人类级别的人工智能。强人工智能是指在各方面都能喝人类比肩的人工智能，人类能干的脑力活它都能干。 超人工智能Artificial Super Intelligence(ASI):知名人工智能思想家Nick Bostrom把超级智能定义为”在几乎所有领域都比最聪明的人类大脑都聪明很多，包括科学创新、通识和社交技能”。 图灵测试 人工智能的历史 1956年夏天：达特茅斯会议，提出“人工智能“ 20世纪60年代：感知机 20世纪70年代：专家系统、知识工程 20世纪80年代：日本第五代机 20世纪90年代：统计机器学习 2006年：深度学习 2012年：卷积神经网络 机器是否具有真正的智能 人眼中的图像 计算机眼中的图像 目前只能实现感知智能，尚无法实现推理智能还有很长的路要走 计算机无法真正理解符号、数字背后的语义 所有的行为都是在“猜” 图像、语音：原始信息，感知智能 语言、艺术：人工信息，推理智能 对抗生成网络对抗生成网络基本思想 1234567有1000张人脸G =&gt; 生成器 =&gt; 从1000张人脸学习生成假脸D =&gt; 判别器 =&gt; 从1000张人脸学习判断是否是假脸形成对抗D =&gt; 判别生成器生成的脸是否是假脸G =&gt; 生成让D判别不出真假的脸","tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://zjinc36.github.io/tags/人工智能/"}]},{"title":"Java8函数式接口和Consumer、Supplier、Predicate、Function说明","date":"2019-08-10T11:20:50.000Z","path":"2019/08/10/Java8函数式接口Consumer、Supplier、Predicate和Function说明/","text":"@FunctionalInterface注解与@Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：@FunctionalInterface 。该注解可用于一个接口的定义上,一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。但是这个注解不是必须的，只要符合函数式接口的定义，那么这个接口就是函数式接口。 自定义函数式接口按照下面的格式定义，你也能写出函数式接口： 12345@FunctionalInterface修饰符 interface 接口名称 &#123; 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容&#125; 虽然@FunctionalInterface注解不是必须的，但是自定义函数式接口最好还是都加上，一是养成良好的编程习惯，二是防止他人修改，一看到这个注解就知道是函数式接口，避免他人往接口内添加抽象方法造成不必要的麻烦。 1234@FunctionalInterfacepublic interface MyFunction &#123; void print(String s);&#125; 看上图是我自定义的一个函数式接口，那么这个接口的作用是什么呢？就是输出一串字符串，属于消费型接口，是模仿Consumer接口写的，只不过这个没有使用泛型，而是将参数具体类型化了，不知道Consumer没关系，下面会介绍到，其实java8中提供了很多常用的函数式接口，Consumer就是其中之一，一般情况下都不需要自己定义，直接使用就好了。那么怎么使用这个自定义的函数式接口呢？我们可以用函数式接口作为参数，调用时传递Lambda表达式。如果一个方法的参数是Lambda，那么这个参数的类型一定是函数式接口。例如： 12345678910public class MyFunctionTest &#123; public static void main(String[] args) &#123; String text = \"试试自定义函数好使不\"; printString(text, System.out::print); &#125; private static void printString(String text, MyFunction myFunction) &#123; myFunction.print(text); &#125;&#125; 执行以后就会输出“试试自定义函数好使不”这句话，如果某天需求变了，我不想输出这句话了，想输出别的，那么直接替换text就好了。函数式编程是没有副作用的，最大的好处就是函数的内部是无状态的，既输入确定输出就确定。函数式编程还有更多好玩的套路，这就需要靠大家自己探索了。 常用函数式接口这几个接口都在 java.util.function 1234567891011Consumer&lt;T&gt; 消费型接口 消费对象 void accept(T t);Supplier&lt;T&gt; 供给型接口 生成对象 T get();Predicate&lt;T&gt; 断言型接口 进行条件判断 boolean test(T t);Function&lt;R,T&gt; 函数型接口 指定特定功能 R apply(T t); 那么，下面，我们从具体的应用场景来讲讲这个接口的用法！ Consumer接口从字面意思上我们就可以看得出啦，consumer接口就是一个消费型的接口，通过传入参数，然后输出值，就是这么简单，Java8 的一些方法看起来很抽象，其实，只要你理解了就觉得很好用，并且非常的简单。我们下面就先看一个例子，然后再来分析这个接口。 Consumer实例123456789101112131415161718192021222324252627282930313233/** * consumer接口测试 */ @Test public void test_Consumer() &#123; //① 使用consumer接口实现方法 Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;; Stream&lt;String&gt; stream = Stream.of(\"aaa\", \"bbb\", \"ddd\", \"ccc\", \"fff\"); stream.forEach(consumer); System.out.println(\"********************\"); //② 使用lambda表达式，forEach方法需要的就是一个Consumer接口 stream = Stream.of(\"aaa\", \"bbb\", \"ddd\", \"ccc\", \"fff\"); Consumer&lt;String&gt; consumer1 = (s) -&gt; System.out.println(s);//lambda表达式返回的就是一个Consumer接口 stream.forEach(consumer1); //更直接的方式 //stream.forEach((s) -&gt; System.out.println(s)); System.out.println(\"********************\"); //③ 使用方法引用，方法引用也是一个consumer stream = Stream.of(\"aaa\", \"bbb\", \"ddd\", \"ccc\", \"fff\"); Consumer consumer2 = System.out::println; stream.forEach(consumer); //更直接的方式 //stream.forEach(System.out::println); &#125; 输出结果 实例分析① consumer接口分析在代码①中，我们直接创建 Consumer 接口，并且实现了一个名为 accept 的方法，这个方法就是这个接口的关键了。我们看一下 accept 方法；这个方法传入一个参数，不返回值。当我们发现 forEach 需要一个 Consumer 类型的参数的时候，传入之后，就可以输出对应的值了。② lambda 表达式作为 consumer 1Consumer&lt;String&gt; consumer1 = (s) -&gt; System.out.println(s);//lambda表达式返回的就是一个Consumer接口 在上面的代码中，我们使用下面的 lambda 表达式作为 Consumer。仔细的看一下你会发现，lambda 表达式返回值就是一个 Consumer；所以，你也就能够理解为什么 forEach 方法可以使用 lamdda 表达式作为参数了吧。③ 方法引用作为 consumer 1Consumer consumer2 = System.out::println; 在上面的代码中，我们用了一个方法引用的方式作为一个 Consumer ，同时也可以传给 forEach 方法。 其他 Consumer 接口除了上面使用的 Consumer 接口，还可以使用下面这些 Consumer 接口。IntConsumer、DoubleConsumer、LongConsumer、BiConsumer，使用方法和上面一样。 Consumer 总结看完上面的实例我们可以总结为几点。① Consumer是一个接口，并且只要实现一个 accept 方法，就可以作为一个“消费者”输出信息。② 其实，lambda 表达式、方法引用的返回值都是 Consumer 类型，所以，他们能够作为 forEach 方法的参数，并且输出一个值。 Supplier 接口Supplier 接口是一个供给型的接口，其实，说白了就是一个容器，可以用来存储数据，然后可以供其他方法使用的这么一个接口，是不是很明白了，如果还是不明白，看看下面的例子，一定彻底搞懂！ Supplier实例123456789101112131415161718192021222324252627** * Supplier接口测试，supplier相当一个容器或者变量，可以存储值 */ @Test public void test_Supplier() &#123; //① 使用Supplier接口实现方法,只有一个get方法，无参数，返回一个值 Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; //返回一个随机值 return new Random().nextInt(); &#125; &#125;; System.out.println(supplier.get()); System.out.println(\"********************\"); //② 使用lambda表达式， supplier = () -&gt; new Random().nextInt(); System.out.println(supplier.get()); System.out.println(\"********************\"); //③ 使用方法引用 Supplier&lt;Double&gt; supplier2 = Math::random; System.out.println(supplier2.get()); &#125; 输出结果 实例分析① Supplier接口分析 1234567Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; //返回一个随机值 return new Random().nextInt(); &#125; &#125;; 看一下这段代码，我们通过创建一个 Supplier 对象，实现了一个 get 方法，这个方法无参数，返回一个值；所以，每次使用这个接口的时候都会返回一个值，并且保存在这个接口中，所以说是一个容器。 ② lambda表达式作为 Supplier 1234//② 使用lambda表达式， supplier = () -&gt; new Random().nextInt(); System.out.println(supplier.get()); System.out.println(\"********************\"); 上面的这段代码，我们使用 lambda 表达式返回一个 Supplier类型的接口，然后，我们调用 get 方法就可以获取这个值了。 ③ 方法引用作为 Supplier 123//③ 使用方法引用 Supplier&lt;Double&gt; supplier2 = Math::random; System.out.println(supplier2.get()); Supplier 实例2我们看完第一个实例之后，我们应该有一个了解了，下面再看一个。 12345678910111213141516171819202122232425262728/** * Supplier接口测试2，使用需要Supplier的接口方法 */ @Test public void test_Supplier2() &#123; Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5); //返回一个optional对象 Optional&lt;Integer&gt; first = stream.filter(i -&gt; i &gt; 4) .findFirst(); //optional对象有需要Supplier接口的方法 //orElse，如果first中存在数，就返回这个数，如果不存在，就放回传入的数 System.out.println(first.orElse(1)); System.out.println(first.orElse(7)); System.out.println(\"********************\"); Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; //返回一个随机值 return new Random().nextInt(); &#125; &#125;; //orElseGet，如果first中存在数，就返回这个数，如果不存在，就返回supplier返回的值 System.out.println(first.orElseGet(supplier)); &#125; 输出结果 代码分析 1Optional&lt;Integer&gt; first = stream.filter(i -&gt; i &gt; 4).findFirst(); 使用这个方法获取到一个 Optional 对象，然后，在 Optional 对象中有 orElse 方法 和 orElseGet 是需要一个 Supplier 接口的。 1234567891011121314151617//optional对象有需要Supplier接口的方法 //orElse，如果first中存在数，就返回这个数，如果不存在，就放回传入的数 System.out.println(first.orElse(1)); System.out.println(first.orElse(7)); System.out.println(\"********************\"); Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; //返回一个随机值 return new Random().nextInt(); &#125; &#125;; //orElseGet，如果first中存在数，就返回这个数，如果不存在，就返回supplier返回的值 System.out.println(first.orElseGet(supplier)); orElse：如果first中存在数，就返回这个数，如果不存在，就放回传入的数 orElseGet：如果first中存在数，就返回这个数，如果不存在，就返回supplier返回的值 其他 Supplier 接口除了上面使用的 Supplier 接口，还可以使用下面这些 Supplier 接口。IntSupplier 、DoubleSupplier 、LongSupplier 、BooleanSupplier，使用方法和上面一样。 Supplier 总结① Supplier 接口可以理解为一个容器，用于装数据的。② Supplier 接口有一个 get 方法，可以返回值。 Predicate 接口Predicate 接口是一个断言型接口(谓词型接口)，其实，这个就是一个类似于 bool 类型的判断的接口，后面看看就明白了。 Predicate 实例1234567891011121314151617181920212223242526/** * Predicate谓词测试，谓词其实就是一个判断的作用类似bool的作用 */ @Test public void test_Predicate() &#123; //① 使用Predicate接口实现方法,只有一个test方法，传入一个参数，返回一个bool值 Predicate&lt;Integer&gt; predicate = new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) &#123; if(integer &gt; 5)&#123; return true; &#125; return false; &#125; &#125;; System.out.println(predicate.test(6)); System.out.println(\"********************\"); //② 使用lambda表达式， predicate = (t) -&gt; t &gt; 5; System.out.println(predicate.test(1)); System.out.println(\"********************\"); &#125; 输出结果 实例分析① Predicate 接口分析 12345678910//① 使用Predicate接口实现方法,只有一个test方法，传入一个参数，返回一个bool值 Predicate&lt;Integer&gt; predicate = new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) &#123; if(integer &gt; 5)&#123; return true; &#125; return false; &#125; &#125;; 这段代码中，创建了一个 Predicate 接口对象，其中，实现类 test 方法，需要传入一个参数，并且返回一个 bool 值，所以这个接口作用就是判断！ 1System.out.println(predicate.test(6)); 再看，调用 test 方法，传入一个值，就会返回一个 bool 值。 ② 使用lambda表达式作为 predicate 1234//② 使用lambda表达式， predicate = (t) -&gt; t &gt; 5; System.out.println(predicate.test(1)); System.out.println(\"********************\"); lambda 表达式返回一个 Predicate 接口，然后调用 test 方法！ Predicate 接口实例21234567891011121314151617181920212223/** * Predicate谓词测试，Predicate作为接口使用 */ @Test public void test_Predicate2() &#123; //① 将Predicate作为filter接口，Predicate起到一个判断的作用 Predicate&lt;Integer&gt; predicate = new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) &#123; if(integer &gt; 5)&#123; return true; &#125; return false; &#125; &#125;; Stream&lt;Integer&gt; stream = Stream.of(1, 23, 3, 4, 5, 56, 6, 6); List&lt;Integer&gt; list = stream.filter(predicate).collect(Collectors.toList()); list.forEach(System.out::println); System.out.println(\"********************\"); &#125; 输出结果这段代码，首先创建一个 Predicate 对象，然后实现 test 方法，在 test 方法中做一个判断：如果传入的参数大于 5 ，就返回 true，否则返回 false； 123Stream&lt;Integer&gt; stream = Stream.of(1, 23, 3, 4, 5, 56, 6, 6); List&lt;Integer&gt; list = stream.filter(predicate).collect(Collectors.toList()); list.forEach(System.out::println); 这段代码调用 Stream 的 filter 方法，filter 方法需要的参数就是 Predicate 接口，所以在这里只要大于 5 的数据就会输出。 Predicate 接口总结① Predicate 是一个谓词型接口，其实只是起到一个判断作用。② Predicate 通过实现一个 test 方法做判断。 Function 接口Function 接口是一个功能型接口，它的一个作用就是转换作用，将输入数据转换成另一种形式的输出数据。 Function 接口实例1234567891011121314151617181920/** * Function测试，function的作用是转换，将一个值转为另外一个值 */ @Test public void test_Function() &#123; //① 使用map方法，泛型的第一个参数是转换前的类型，第二个是转化后的类型 Function&lt;String, Integer&gt; function = new Function&lt;String, Integer&gt;() &#123; @Override public Integer apply(String s) &#123; return s.length();//获取每个字符串的长度，并且返回 &#125; &#125;; Stream&lt;String&gt; stream = Stream.of(\"aaa\", \"bbbbb\", \"ccccccv\"); Stream&lt;Integer&gt; stream1 = stream.map(function); stream1.forEach(System.out::println); System.out.println(\"********************\"); &#125; 输出结果 代码分析① Function 接口分析 1234567//① 使用map方法，泛型的第一个参数是转换前的类型，第二个是转化后的类型 Function&lt;String, Integer&gt; function = new Function&lt;String, Integer&gt;() &#123; @Override public Integer apply(String s) &#123; return s.length();//获取每个字符串的长度，并且返回 &#125; &#125;; 这段代码创建了一个 Function 接口对象，实现了一个 apply 方法，这个方法有一个输入参数和一个输出参数。其中，泛型的第一个参数是转换前的类型，第二个是转化后的类型。在上面的代码中，就是获取字符串的长度，然后将每个字符串的长度作为返回值返回。② 重要应用 map 方法 123Stream&lt;String&gt; stream = Stream.of(\"aaa\", \"bbbbb\", \"ccccccv\"); Stream&lt;Integer&gt; stream1 = stream.map(function); stream1.forEach(System.out::println); 在 Function 接口的重要应用不得不说 Stream 类的 map 方法了，map 方法传入一个 Function 接口，返回一个转换后的 Stream类。 其他 Function 接口除了上面使用的 Function 接口，还可以使用下面这些 Function 接口。IntFunction 、DoubleFunction 、LongFunction 、ToIntFunction 、ToDoubleFunction 、DoubleToIntFunction 等等，使用方法和上面一样。 Function 接口总结① Function 接口是一个功能型接口，是一个转换数据的作用。② Function 接口实现 apply 方法来做转换。 总结通过前面的介绍，已经对Consumer、Supplier、Predicate、Function这几个接口有详细的了解了，其实，这几个接口并不是很难，只是有点抽象，多加理解会发现很简单，并且特别好用！ 参考 Java8之Consumer、Supplier、Predicate和Function攻略 Java8-Lambda表达式-函数式接口 「Java8系列」神奇的函数式接口","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"MyBatis配置文件详解","date":"2019-07-31T22:49:09.000Z","path":"2019/08/01/MyBatis配置文件详解/","text":"参考:mybatis配置文件详解 挑几个比较重要的说 属性加载properties这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如： 12345&lt;!-- 先加载内部标签,后加载外部文件,名称一致时,外部会覆盖内部 --&gt;&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值。比如: 123456&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt;&lt;/dataSource&gt; 这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换 别名配置类型别名是为 Java 类型设置一个短的名字。 它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余 单个别名定义1234&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt; &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt;&lt;/typeAliases&gt; 当这样配置时，Blog 可以用在任何使用 domain.blog.Blog 的地方。具体在代码中的体现 指定包名定义也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 具体在代码中的体现 映射器Mapper配置的几种方法：第一种（常用） 1&lt;mapper resource=\" \" /&gt; resource指向的是相对于类路径下的目录如：&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt; 第二种 1&lt;mapper url=\" \" /&gt; 使用完全限定路径如：&lt;mapper url=&quot;file:///D:\\workspace\\mybatis1\\config\\sqlmap\\User.xml&quot; /&gt; 第三种 1&lt;mapper class=\" \" /&gt; 使用mapper接口类路径如：&lt;mapper class=&quot;cn.kang.mapper.UserMapper&quot;/&gt;注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 第四种（推荐） 1&lt;package name=\"\"/&gt; 注册指定包下的所有mapper接口如：&lt;package name=&quot;cn.kang.mapper&quot;/&gt;注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 使用示例： 1234&lt;mappers&gt; &lt;mapper resource=\"sqlmap/User.xml\"/&gt; &lt;package name=\"cn.kang.mapper\"/&gt;&lt;/mappers&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zjinc36.github.io/tags/MyBatis/"}]},{"title":"MyBatis中的DAO包装","date":"2019-07-31T21:48:53.000Z","path":"2019/08/01/MyBatis中的DAO包装/","text":"传统的DAO包装项目基本代码MyBatis工程搭建与增删改查 实现传统的DAO包装项目文件基本结构 UserDao.java 1234567891011121314package com.zjinc36.mybatis.dao;import java.util.List;import com.zjinc36.mybatis.pojo.User;public interface UserDao &#123; //根据用户id查询用户信息 public User getUserById(Integer id); //根据用户名称查找用户信息 public List&lt;User&gt; getUserByUsername(String username); //添加用户 public void insertUser(User user);&#125; UserDaoImpl.java 12345678910111213141516171819202122232425262728293031323334353637package com.zjinc36.mybatis.dao;import static org.hamcrest.CoreMatchers.nullValue;import java.util.List;import org.apache.ibatis.session.SqlSession;import com.zjinc36.mybatis.pojo.User;import com.zjinc36.mybatis.utils.MyBatisUtil;public class UserDaoImpl implements UserDao &#123; @Override public User getUserById(Integer id) &#123; SqlSession sqlSession = MyBatisUtil.getSession(); User user = sqlSession.selectOne(\"user.getUserById\", id); sqlSession.close(); return user; &#125; @Override public List&lt;User&gt; getUserByUsername(String username) &#123; SqlSession sqlSession = MyBatisUtil.getSession(); List&lt;User&gt; list = sqlSession.selectList(\"user.getUserByUsername\",username); sqlSession.close(); return list; &#125; @Override public void insertUser(User user) &#123; SqlSession sqlSession = MyBatisUtil.getSession(); sqlSession.insert(\"user.insertUser\", user); sqlSession.commit(); sqlSession.close(); &#125;&#125; UserDaoTest.java 12345678910111213141516171819202122232425262728293031323334353637package com.zjinc36.mybatis.test;import java.util.List;import org.junit.Test;import com.zjinc36.mybatis.dao.UserDao;import com.zjinc36.mybatis.dao.UserDaoImpl;import com.zjinc36.mybatis.pojo.User;public class UserDaoTest &#123; @Test public void testGetUserById() &#123; UserDao userDao = new UserDaoImpl(); User user = userDao.getUserById(1); System.out.println(user); &#125; @Test public void testGetUserByUsername() &#123; UserDao userDao = new UserDaoImpl(); List&lt;User&gt; list = userDao.getUserByUsername(\"张\"); for (User user : list) &#123; System.out.println(user); &#125; &#125; @Test public void testInsertUser() &#123; UserDao userDao = new UserDaoImpl(); User user = new User(); user.setUsername(\"白鸽\"); user.setSex(\"2\"); user.setAddress(\"天津\"); userDao.insertUser(user); &#125;&#125; 动态代理DAO包装项目基本代码MyBatis工程搭建与增删改查 实现动态代理DAO包装动态代理只需使用接口，不需使用实现接口的实体类 UserMapper.java 12345678910111213141516package com.zjinc36.mybatis.mapper;import java.util.List;import com.zjinc36.mybatis.pojo.User;public interface UserMapper &#123; // 根据用户id查询用户信息 public User getUserById(Integer id); // 根据用户名称查找用户信息 public List&lt;User&gt; getUserByUsername(String username); // 添加用户 public void insertUser(User user);&#125; UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace 命名空间，用于隔离sql语句，后继有重要作用 --&gt;&lt;!-- 在动态代理中： 1.命名空间的值必须是接口的全路径名 如：com.zjinc36.mybatis.mapper.UserMapper 2.接口的方法名必须与sql id 一致。如select标签下的id属性必须与UserMapper接口的对应方法名一致 3.接口的入参 必须与 sql parameterType的类型一致。 4.接口的返回值必须与sql resultType的类型一致--&gt;&lt;mapper namespace=\"com.zjinc36.mybatis.mapper.UserMapper\"&gt; &lt;!-- 在select标签中编写查询的SQL语句， 设置select标签的id属性为getUserById，id属性值必须是唯一的，不能够重复 使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型 resultType=\"com.wuhaitao.mybatis.demo1.User\"就表示将查询结果封装成一个User类的对象返回 User类就是cst_customer表所对应的实体类 --&gt; &lt;select id=\"getUserById\" parameterType=\"int\" resultType=\"com.zjinc36.mybatis.pojo.User\"&gt; &lt;!-- 查询语句这么写是因为，再查询时大量数据时可以节省很多时间 ，在参数上使用' #&#123;&#125;' 来表示 相当于JDBC的？号--&gt; SELECT `user`.id, `user`.username, `user`.birthday, `user`.sex, `user`.address FROM `user` WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;select id=\"getUserByUsername\" parameterType=\"string\" resultType=\"com.zjinc36.mybatis.pojo.User\"&gt; &lt;!-- 查询语句这么写是因为，再查询时大量数据时可以节省很多时间 ，在参数上使用' #&#123;&#125;' 来表示 相当于JDBC的？号--&gt; &lt;!-- $&#123;&#125; 当参数类型为普通类型时 ，其值只能为value --&gt; SELECT `user`.id, `user`.username, `user`.birthday, `user`.sex, `user`.address FROM `user` &lt;!-- WHERE username LIKE '%$&#123;value&#125;%' --&gt; WHERE username LIKE '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 插入用户 --&gt; &lt;insert id=\"insertUser\" parameterType=\"com.zjinc36.mybatis.pojo.User\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; &lt;!-- keyProperty指User中的主键属性 --&gt; &lt;!-- resultTYype 主键数据类型 --&gt; &lt;!-- order 何时执行 --&gt; &lt;!-- &lt;selectKey keyProperty=\"id\" resultType=\"int\" order=\"AFTER\"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; --&gt; INSERT INTO `user` (`username`,`birthday`, `sex`, `address`) VALUES (#&#123;username&#125;,#&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;) &lt;/insert&gt;&lt;/mapper&gt; SqlMapConfig.xml中将UserMapper.xml引入 1234&lt;!-- 加载映射文件 --&gt;&lt;mappers&gt; &lt;mapper resource=\"mybatis/UserMapper.xml\" /&gt;&lt;/mappers&gt; 测试UserMapperTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zjinc36.mybatis.test;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import com.zjinc36.mybatis.mapper.UserMapper;import com.zjinc36.mybatis.pojo.User;import com.zjinc36.mybatis.utils.MyBatisUtil;public class UserMapperTest &#123; @Test public void testGetUserById() &#123; SqlSession sqlSession = MyBatisUtil.getSession(); // 获取接口的代理实现类，由getMapper()实现 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.getUserById(1); System.out.println(user); sqlSession.close(); &#125; @Test public void testGetUserByUsername() &#123; SqlSession sqlSession = MyBatisUtil.getSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.getUserByUsername(\"白\"); for (User user : list) &#123; System.out.println(user); &#125; sqlSession.close(); &#125; @Test public void testInsertUser() &#123; SqlSession sqlSession = MyBatisUtil.getSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername(\"白灵涵\"); user.setSex(\"2\"); user.setAddress(\"河南\"); userMapper.insertUser(user); sqlSession.commit(); sqlSession.close(); &#125;&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zjinc36.github.io/tags/MyBatis/"}]},{"title":"MyBatis架构","date":"2019-07-31T21:46:30.000Z","path":"2019/08/01/MyBatis架构/","text":"","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://zjinc36.github.io/tags/MyBatis/"}]},{"title":"MyBatis工程搭建与增删改查","date":"2019-07-31T20:55:30.000Z","path":"2019/08/01/MyBatis工程搭建与增删改查/","text":"基于maven创建工程 使用maven创建web工程Eclipse创建maven工程 引入MyBatis需要的依赖pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zjinc36&lt;/groupId&gt; &lt;artifactId&gt;DemoMyBaits&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 属性配置 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加MyBatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 入门案例参考:Maven学习（八）- 构建MyBatis项目 项目基本结构 日志配置log4j.properties 123456789101112131415### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=/home/zjc/Loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###log4j.rootLogger=info, stdout 建表语句1234567891011121314151617create table `user` ( `id` int(11) not null AUTO_INCREMENT, `username` varchar(32) not null, `birthday` date default null, `sex` char(1) default null, `address` varchar(256) default null, primary key(`id`)) engine=innodb default charset=utf8create table `order` ( `id` int(11) not null AUTO_INCREMENT, `user_id` int(11) not null, `number` varchar(256) default null, `createtime` date default null, `note` char(1) default null, primary key(`id`)) engine=innodb default charset=utf8 表对应的类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//User.javapackage com.zjinc36.mybatis.pojo;/** * * @author zjc * `id` int(11) not null AUTO_INCREMENT, `username` varchar(32) not null, `birthday` date default null, `sex` char(1) default null, `address` varchar(256) default null, */public class User &#123; private Long id; private String username; private String birthday; private String sex; private String address; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getBirthday() &#123; return birthday; &#125; public void setBirthday(String birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", username=\" + username + \", birthday=\" + birthday + \", sex=\" + sex + \", address=\" + address + \"]\"; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//Order.javapackage com.zjinc36.mybatis.pojo;/** * * @author zjc * `id` int(11) not null AUTO_INCREMENT, `user_id` int(11) not null, `number` varchar(256) default null, `createtime` date default null, `note` char(1) default null, */public class Order &#123; private Long id; private Long user_id; private String number; private String createtime; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getUser_id() &#123; return user_id; &#125; public void setUser_id(Long user_id) &#123; this.user_id = user_id; &#125; public String getNumber() &#123; return number; &#125; public void setNumber(String number) &#123; this.number = number; &#125; public String getCreatetime() &#123; return createtime; &#125; public void setCreatetime(String createtime) &#123; this.createtime = createtime; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; @Override public String toString() &#123; return &quot;Order [id=&quot; + id + &quot;, user_id=&quot; + user_id + &quot;, number=&quot; + number + &quot;, createtime=&quot; + createtime + &quot;, note=&quot; + note + &quot;]&quot;; &#125;&#125; 将表和对应类连接起来SqlMapConfig.xml用以配置数据库连接池和加载映射文件 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后,environments将废除 --&gt; &lt;!-- 可以配置多个连接池,主要用于开发环境和测试环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mybatis/user.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 映射文件,用以写查表语句,也就是指定用哪个SQL语句查哪个类 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"user\"&gt; &lt;!-- 查询所有用户 --&gt; &lt;select id=\"getUserById\" resultType=\"com.zjinc36.mybatis.pojo.User\" parameterType=\"int\"&gt; select * from user where id=#&#123;id2&#125; &lt;/select&gt;&lt;/mapper&gt; 调用查表语句需要一个SqlSessionFactory对象,用来连接数据库,并用以使用xml形式的查表语句 123456789101112131415161718192021222324252627282930package com.zjinc36.mybatis.utils;import java.io.IOException;import java.io.InputStream;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class MyBatisUtil &#123; private static SqlSessionFactory factory = null; private static void initialFactory() &#123; String resource = \"SqlMapConfig.xml\"; try &#123; InputStream in = Resources.getResourceAsStream(resource); factory = new SqlSessionFactoryBuilder().build(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static SqlSession getSession() &#123; if(factory == null) &#123; initialFactory(); &#125; return factory.openSession(); &#125;&#125; 具体调用写在xml映射文件中的查表语句 123456789101112131415package com.zjinc36.server;import org.apache.ibatis.session.SqlSession;import com.zjinc36.mybatis.pojo.User;import com.zjinc36.mybatis.utils.MyBatisUtil;public class Demo1 &#123; public void getUserById () &#123; SqlSession session = MyBatisUtil.getSession(); User user = session.selectOne(\"user.getUserById\", 1); System.out.println(user); session.close(); &#125;&#125; 测试12345678910111213package com.zjinc36.mybatis.test;import org.junit.Test;import com.zjinc36.server.Demo1;public class TestDemo1 &#123; @Test public void testGetUserById() &#123; Demo1 demo1 = new Demo1(); demo1.getUserById(); &#125;&#125; 增删改查操作参考: mybatis系列一：mybatis实现增删改查","tags":[{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://zjinc36.github.io/tags/MyBatis/"}]},{"title":"Maven的工程拆分与聚合","date":"2019-07-31T14:21:16.000Z","path":"2019/07/31/maven的工程拆分与聚合/","text":"工程的拆分与聚合我们项目拆分成多个子模块之后,独立运行各个模块是无法完成软件项目的要求的,只有把它们整合起来,分工合作才能完成工作,因此需要父工程来管理各个自摸块,把它们聚合在一起 继承的理解类似java的类,都是为了消除重复,父类里有的方法和属性在子类中就不需要再定义和实现了,使用的时候直接调用父类就可以了我们把工程拆分之后,有一个父工程,子工程要用到的依赖都可以在父工程的pom.xml先定义好,将来子工程开发的时候,就不需要再引坐标了 具体拆分实例转载:通过maven对项目进行拆分、聚合 对现在已有maven ssh项目进行拆分，拆分思路：将dao层的代码已经配置文件全体提取出来到一个表现上独立的工程中。同样service、action拆分。 需要创建： ssh-parent: 父工程 ssh-dao:（子模块） ssh-service:（子模块） ssh-web:（子模块） 拆分完成对拆分后的项目进行聚合，提出概念父工程 创建父工程 创建父工程父项目用pom 创建好父工程目录结构只有pom.xml，可以推断父工程不进行编码 父工程要做的事情： 项目需要的依赖的信息，在父工程中定义，子模块继承过来 将各个子模块聚合到一起 将创建父工程发布到本地仓库如果不把父工程发布到本地仓库，那么，将来service、dao工程发布到本地仓库，会报错。因为它找不到依赖的父工程！！！ 创建子模块ssh-daossh-dao负责数据访问层：包含dao相关代码&amp;配置文件 子项目war(如果是web项目的话)和jar中选择 可以看到，Parent Project中GAV都有了信息，那是因为创建Maven Module时，是点在父工程上右键创建的。 将spring的配置文件拆分 applicationContext-basic.xml项目基础的信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\" xmlns:soap=\"http://cxf.apache.org/bindings/soap\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\"&gt; &lt;!-- 加载属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\" /&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"configLocations\" value=\"classpath:hibernate.cfg.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- xml方式管理事务 --&gt; &lt;!-- 配置通知：具体增强逻辑 --&gt; &lt;tx:advice id=\"txAdvice\"&gt; &lt;tx:attributes&gt; &lt;!-- 匹配业务类中方法名称 --&gt; &lt;tx:method name=\"save*\" /&gt; &lt;tx:method name=\"update*\" /&gt; &lt;tx:method name=\"delete*\" /&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置aop --&gt; &lt;aop:config&gt; &lt;!-- 配置切点：具体哪些方法要增强（真正被增强的方法）--&gt; &lt;aop:pointcut expression=\"execution(* cn.itcast.service.*.*(..))\" id=\"cut\"/&gt; &lt;!-- 配置切面：将增强逻辑作用到切点 （通知+切入点） --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"cut\"/&gt; &lt;/aop:config&gt; &lt;!-- xml方式管理事务 --&gt; &lt;!-- 注解方式管理事务 --&gt; &lt;!-- 1、开启注解驱动 2、在service类上或者方法上使用注解@Transactional--&gt;&lt;!-- &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; --&gt; &lt;!-- 注解方式管理事务 --&gt;&lt;/beans&gt; applicationContext-dao.xmldao层bean对象 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\" xmlns:soap=\"http://cxf.apache.org/bindings/soap\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\"&gt; &lt;!-- 配置dao对象 --&gt; &lt;bean id=\"customerDao\" class=\"cn.itcast.dao.impl.CustomerDaoImpl\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建子模块ssh-service子项目war(如果是web项目的话)和jar中选择 applicationContext-service.xml 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jaxws=\"http://cxf.apache.org/jaxws\" xmlns:soap=\"http://cxf.apache.org/bindings/soap\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://cxf.apache.org/bindings/soap http://cxf.apache.org/schemas/configuration/soap.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\"&gt; &lt;!-- 配置service对象 --&gt; &lt;bean id=\"customerService\" class=\"cn.itcast.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; service层的pom.xml 12345678910111213141516171819202122&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;01_maven_parent-ssh&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;ssh-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;ssh-dao&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 将ssh-dao工程打包到本地仓库(打包用install)；在service工程pom.xml文件添加ssh-dao的依赖 创建子模块ssh-web：war子项目war(如果是web项目的话)和jar中选择 在ssh-web项目中添加service工程依赖。pom.xml 1234567891011121314151617&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;01_maven_parent-ssh&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;ssh-web&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;cn.itcast&lt;/groupId&gt; &lt;artifactId&gt;ssh-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; web.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;display-name&gt;01_maven_ssh&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Struts核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置监听器：默认加载WEB-INF/applicationContext.xml --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 通过上下文参数指定spring配置文件路径 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 运行方式 Maven方式方式1：运行父工程(tomcat:run)。父工程会自动将各个子模块聚合到一起。将ssh-web打war包发布到tomcat方式2：直接运行web工程(tomcat:run) 其他方式部署到tomcat maven如何处理重复引用依赖转载:maven的依赖原则 当一个项目中出现重复引用依赖jar包时，maven一般有如下三种原则处理jar maven的依赖原则 最短路径原则12A -&gt; B -&gt; C -&gt; D(V1)F -&gt; G -&gt; D(V2) 这个时候项目中就出现了两个版本的D，这时maven会采用最短路径原则，选择V2版本的D，因为V1版本的D是由A包间接依赖的，整个依赖路径长度为3，而V2版本的D是由F包间接依赖的，整个依赖路径长度为2。 优先声明原则12A -&gt; B -&gt; D(V1)F -&gt; G -&gt; D(V2) 如果两个jar包版本路径深度相同，则使用优先声明的版本 多次直引不同版本的jar时，使用最后声明的版本1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.20.RELEASE&lt;/version&gt;&lt;/dependency&gt; 如果再pom文件中，同时引用了如上两个版本，则会使用4.3.20.RELEASE版本 依赖传递中的版本冲突问题转载:Eclipse maven 解决jar包版本冲突 在使用maven进行项目依赖管理的时候，有时候会出现一种情况，多个不同的开源组件都依赖了另外一个组件，但是这个组件的版本却不一样，在maven依赖中就会看到两个版本不同的jar,通常我们可以根据实际情况排除其中一个,当然前提是这个版本没有太大的差异，兼容 方法一手工添加配置：在dependency标签里使用子标签exclusions，比如A组件使用了zookeeper 3.3.3的依赖包，B组件使用了zookeeper 3.3.6的依赖包，这时候我们要排除3.3.3这个版本可以这样做： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.xxx&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 方法二通过eclipse的pom编辑工具： 另外也可以使用命令mvn project-info-reports:dependencies 查看项目依赖情况。 依赖的传递范围(了解) 版本锁定这样做的好处：统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，才能保证测试的和发布的是相同的成果因此，在顶层pom中定义共同的依赖关系。同时可以避免在每个使用的子项目中都声明一个版本号，这样想升级或者切换到另一个版本时，只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个版本号时，只需要在dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。 方式一:使用dependencyManagement版本锁定（指定项目中依赖的版本）:只是起到指定依赖版本的作用，并不会导入依赖 123456789&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-bean&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; dependencyManagement其实只是一个管理jar的作用,是管理jar的版本,其他他的什么作用都没有,只是定义找到该jar的三维坐标,并不是真正的去执行下载的jar的功能. 有depencyManagement的时候,maven按如下规则寻找jar包依赖 在dependencies中的依赖中如果没有声明jar的版本,就到dependenciesManage中去找,找到就使用,没有就报错 在dependencies中声明jar的版本,则使用该版本,不管在dependenciesManage中有没有声明jar的version,都以该jar的版本为主. 版本锁定之后,子项目引入对应的jar包时,是没有版本号的 因为,在我们项目顶层的POM文件中，我们会看到dependencyManagement元素。通过它元素来管理jar包的版本，让子项目中引用一个依赖而不用显示的列出版本号。Maven会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement元素中指定的版本号。 DepencyManagement应用场景 当我们的项目模块很多的时候，我们使用Maven管理项目非常方便，帮助我们管理构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。 由于我们的模块很多，所以我们又抽象了一层，抽出一个itoo-base-parent来管理子项目的公共的依赖。为了项目的正确运行，必须让所有的子项目使用依赖项的统一版本，必须确保应用的各个项目的依赖项和版本一致，才能保证测试的和发布的是相同的结果。 Dependencies相对于dependencyManagement，所有生命在dependencies里的依赖都会自动引入，并默认被所有的子项目继承 dependencies和dependencymanagement的区别 dependencies即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承） dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。 方式二:提取常量提取常量放入pom.xml的属性中 12345&lt;properties&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt; &lt;struts.version&gt;2.3.24&lt;/struts.verson&gt;&lt;/properties&gt; 引入属性通过ognl表达式带入到依赖的版本中：例如${spring.version}","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"},{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"}]},{"title":"Vim中删除句尾的空白字符","date":"2019-07-30T23:13:22.000Z","path":"2019/07/31/vim中删除句尾的空白字符/","text":"命令：%s/\\s\\+$//g可以删除行尾多余的空格和tab符号。 命令：%s/ *$//g/和*中间有空格，只能删除行尾空格，对于tab不能删除","tags":[{"name":"vim","slug":"vim","permalink":"https://zjinc36.github.io/tags/vim/"}]},{"title":"Eclipse创建maven工程","date":"2019-07-30T21:05:20.000Z","path":"2019/07/31/eclipse创建maven工程/","text":"创建一个maven工程 刚生成的工程就报错问题因为是web工程,webapp下缺少必要的目录和文件 缺少的文件如下 解决 方式一,使用eclipse的直接生成 方式二,手动创建缺少的目录和文件 调整jdk版本主要有两种方式 调整pom.xml文件 调整setting.xml文件 调整pom.xml文件调整pom.xml文件有两种方式 使用eclipse界面操作修改pom.xml文件 直接修改pom.xml文件 方式一使用eclipse界面操作修改pom.xml文件 右键项目 -&gt; Maven -&gt; Add Plugin 出现如下窗口后,进行图中所示配置 此时打开pom.xml文件会发现如下内容 在pom.xml文件中增加如下内容 12345&lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt;&lt;/configuration&gt; 此时,pom.xml如下所示 右键项目 -&gt; Maven -&gt; Update Project 方式二直接修改pom.xml文件在maven的pom.xml中添加以下代码指定jdk版本 1234567891011121314&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 不要忘记,右键项目 -&gt; Maven -&gt; Update Project 调整setting.xml文件在maven的安装目录找到settings.xml文件，在里面添加如下代码 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 设置完成后，右键项目-&gt;maven-&gt;update project,这样每次新建maven项目都默认为jdk1.7版本了 创建Servlet项目主要用以说明如何引入依赖 新增Servlet src/main/java -&gt; 右键 -&gt; new -&gt; servlet 键入如下内容,进行创建 增加示例代码 /helloworld/src/main/java/com/zjinc36/web/HelloServlet.java 12345678910111213141516171819202122232425262728293031323334353637package com.zjinc36.web;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class HelloServlet */public class HelloServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * Default constructor. */ public HelloServlet() &#123; // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"进入HelloServlet\"); request.getRequestDispatcher(\"/index.jsp\").forward(request, response); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; /helloworld/src/main/webapp/index.jsp 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello,world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 增加依赖上述示例用代码,现在没有引入jar包,肯定是一堆报错,接下去说明,如何修改maven的pom.xml文件来解决依赖问题servlet项目需要增加两种依赖 Servlet依赖 jsp依赖 增加Servlet依赖有两种方式 直接在pom.xml中增加dependencies 与eclipse紧密结合放方式 方式一直接在pom.xml中增加dependencies 123456789101112131415161718192021222324252627282930313233&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zjinc36&lt;/groupId&gt; &lt;artifactId&gt;helloworld&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;mavenFirst&lt;/name&gt; &lt;description&gt;第一次建maven工程&lt;/description&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 方式二与eclipse紧密结合放方式 增加jsp依赖123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 依赖的作用范围上述增加依赖时,需要指定scop来控制依赖的范围 依赖范围参数 参数说明 test 范围指的是测试范围有效，在编译和打包时都不会使用这个依赖 compile 默认值,范围指的是编译范围有效，在编译和打包时都会将依赖存储进去 provided 依赖：在编译和测试的过程有效，最后生成war包时不会加入 runtime 在运行的时候依赖，在编译的时候不依赖 为什么需要依赖作用范围例如上面配置的依赖,指定作用范围为provided,是因为servlet-api，tomcat等web服务器已经存在了，如果此时还是compile,那么就会出现重复打包,会引起冲突 配置tomcat方式一原先配置方式Eclipse配置Tomcat 方式二使用maven插件Maven - 两种Tomcat插件的配置 Maven Tomcat插件现在主要有两个版本，tomcat-maven-plugin和tomcat7-maven-plugin，使用方式基本相同。 tomcat-maven-plugin 插件官网：http://mojo.codehaus.org/tomcat-maven-plugin/plugin-info.html tomcat7-maven-plugin 插件官网：http://tomcat.apache.org/maven-plugin.html tomcat-maven-plugin 插件使用在pom.xml中加入下面代码： 123456789101112&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/wp&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;url&gt;http://localhost:8080/manager/html&lt;/url&gt; &lt;server&gt;tomcat6&lt;/server&gt; &lt;/configuration&gt;&lt;/plugin&gt; 简要说明一下： path 是访问应用的路径 port 是tomcat 的端口号 uriEncoding URL按UTF-8进行编码，这样就解决了中文参数乱码。 Server 指定tomcat名称。 如果Eclipse 安装了Maven插件，选择pom.xml文件 -&gt; 击右键 -&gt; 选择 Run As -&gt; Maven build 如果是第一次运行，会弹出对话框,在Goals框加加入以下命令: tomcat:run这样Tomcat 插件就可以运行。 下面介绍几个常用的Goal tomcat:deploy –部署一个web war包 tomcat:reload –重新加载web war包 tomcat:start –启动tomcat tomcat:stop –停止tomcat tomcat:undeploy–停止一个war包 tomcat:run 启动嵌入式tomcat ，并运行当前项目 tomcat7-maven-plugin 插件使用 在pom.xml中加入下面代码： 123456789101112131415161718&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在这里要注意一下，该插件命名方式有些不同，比如启动tomcat ，对应的目标命令是: tomcat7:run ,同样，其它命令也是这样，需要更改为：tomcat7：&lt;插件执行点&gt; tomcat7:deploy –部署一个web war包 tomcat7:reload –重新加载web war包 tomcat7:start –启动tomcat tomcat7:stop –停止tomcat tomcat7:undeploy–停止一个war包 tomcat7:run 启动嵌入式tomcat ，并运行当前项目 如果需要debug，就使用debug as 方式启动项目！","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"},{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"}]},{"title":"Eclipse配置maven","date":"2019-07-30T19:57:15.000Z","path":"2019/07/31/eclipse配置maven/","text":"设定编码在Windows -&gt; Preferences 更改maven版本将eclipse中的maven版本变为自己使用的版本 在Windows -&gt; Preferences 将我们自己的maven版本添加进eclipse 添加完之后勾选我们自己的maven版本 添加maven的配置文件在Windows -&gt; Preferences maven的视图面板 打开windows -&gt; Show View -&gt; other 点击确定后可以看到 如果想在本地同步一份,可以在Local Respository -&gt; 右键 -&gt; Rebuild Index","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"},{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"}]},{"title":"Maven的常用命令和生命周期","date":"2019-07-30T12:58:41.000Z","path":"2019/07/30/maven的常用命令和生命周期/","text":"maven的常用命令cleanclean是maven工程的清理命令,执行clean会删除target目录及其目录下所有内容 compilecompile是maven工程的编译命令,作用是将src/main/java下的java源文件编译为class文件并输出到target下的classes目录下 testtest是maven工程的测试命令,mvn test会执行src/test/java下的单元测试类 packagepackage是maven工程的打包命令,对于java工程执行package打包成jar包,对于web工程打包成war包 installinstall是maven工程的安装命令,执行install将maven打成jar包或war包发布到本地仓库 查看打包情况 maven的声明周期maven对项目的构建过程分为三套独立的生命周期,请注意,这里说的是”三套”,而且是”相互独立”,这三套声明周期分别是: Clean Lifecycle:在进行真正的构建之前,进行一些清理工作 Default Lifecycle:构建的核心部分,编译,测试,打包,部署等 Site Lifecycle:生成项目报告,站点,发布站点 每一个阶段都有一个对应的命令,且有响应的插件来支持命令的运行 从上面命令结果可以看出,当运行后面的命令时,前面的操作过程也都会执行,也就是说属于同一个指令周期里的指令,当后面的命令执行时,前面的命令也会执行","tags":[{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"}]},{"title":"Maven的目录结构规范","date":"2019-07-30T11:29:28.000Z","path":"2019/07/30/maven的目录结构规范/","text":"具有公共目录布局允许用户熟悉Maven项目从一个到另一个。 标准的目录结构maven定义了一个标准的目录结构 123456789- src - main - java - resources - webapp - test - java - resources- target src 目录是源代码和测试代码的根目录。 main 目录是与源代码相关的根目录到应用程序本身，而不是测试代码。 test 目录包含测试源代码。 main和test下的 java 目录包含Java代码的应用程序本身是在main和用于测试的Java代码。 resources 目录包含您项目所需的资源。 target 目录由Maven创建。它包含所有编译的类，JAR文件等。 当执行 mvn clean 命令时，Maven将清除目标目录。 webapp 目录包含Java Web应用程序，如果项目是Web应用程序。 webapp 目录是Web应用程序的根目录。webapp目录包含 WEB-INF 目录。 如果按照目录结构，你不需要指定你的源代码的目录，测试代码，资源文件等。 具体每个目录的作用 目录 商店 src/main/java 应用程序/库源 src/main/resources 应用程序/库资源 src/main/config 配置文件 src/main/scripts 应用程序/库脚本 src/main/webapp 应用程序/库脚本… src/test/java 测试源 src/test/resources 测试资源 src/assembly 汇编描述符 src/site Site target The target directory is used to store all output of the build. LICENSE.txt 项目许可证 NOTICE.txt 通知和归因 README.txt 项目的自述 在项目根目录的顶部有pom.xml文件和任何属性，maven.xml。另外，还有文本文件用户在接收时立即读取来源:README.txt，LICENSE.txt等。","tags":[{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"}]},{"title":"Maven配置本地仓库","date":"2019-07-30T11:11:24.000Z","path":"2019/07/30/maven配置本地仓库/","text":"下载jar包规则本地仓库是远程仓库的一个缓冲和子集，当你构建Maven项目的时候 首先会从本地仓库查找资源 如果没有，那么Maven会从远程仓库(可能是私服,没有私服就是中央仓库了)下载到你本地仓库,这样在你下次使用的时候就不需要从远程下载了 如果你所需要的jar包版本在本地仓库没有，而且也不存在于远程仓库，Maven在构建的时候会报错，这种情况可能是有些jar包的新版本没有在Maven仓库中及时更新。 配置本地仓库 默认仓库的存储位置Maven缺省的本地仓库路径为${user.home}/.m2/repository 自定义修改仓库的存储位置可改变默认的 .m2 目录下的默认本地存储库文件夹具体就是修改如下的Xml代码 1&lt;localRepository&gt;自己仓库的存放目录&lt;/localRepository&gt;","tags":[{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"}]},{"title":"Maven的安装","date":"2019-07-30T10:58:53.000Z","path":"2019/07/30/maven的安装/","text":"去官网下载https://maven.apache.org/download.cgi 移动到自己指定的位置 1sudo mv apache-maven-3.5.3-bin.tar.gz /usr/local/ 解压 1234sudo tar -zxvf apache-maven-3.5.3-bin.tar.gzsudo rm -rf apache-maven-3.5.3-bin.tar.gz解压之后的文件夹名字为：apache-maven-3.5.3 修改全局配置文件 12345sudo vim /etc/profile添加如下配置export M2_HOME=/usr/local/apache-maven-3.5.3export PATH=$&#123;M2_HOME&#125;/bin:$PATH 使修改的配置立刻生效 1source /etc/profile 检查是否安装成功 1mvn -v","tags":[{"name":"maven","slug":"maven","permalink":"https://zjinc36.github.io/tags/maven/"}]},{"title":"Ubuntu中安装fzf","date":"2019-07-29T15:54:00.000Z","path":"2019/07/29/ubuntu中安装fzf/","text":"安装fzf作用Fzf是一款小巧，超快，通用，跨平台的命令行模糊查找器 安装123$ git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf$ cd ~/.fzf/$ ./install 配置 核心命令 FZF_DEFAULT_COMMAND对于使用 fzf 来查找文件的情况，fzf 其实底层是调用的 Unix 系统 find 命令，如果你觉得 find 不好用也可以使用其它查找文件的命令行工具「我使用 fd」。注意：对原始命令添加一些参数应该在这个环境变量里面添加比如说我们一般都会查找文件 -type f，通常会忽略一些文件夹/目录 –exclude=…，下面是我的变量值： 1export FZF_DEFAULT_COMMAND=\"fd --exclude=&#123;.git,.idea,.vscode,.sass-cache,node_modules,build&#125; --type f\" 界面展示 FZF_DEFAULT_OPTS界面展示这些参数在 fzf –help 中都有，按需配置即可 1export FZF_DEFAULT_OPTS=\"--height 40% --layout=reverse --preview '(highlight -O ansi &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500'\" --preview表示在右侧显示文件的预览界面，语法高亮的设置使用了highlight,如果 highlight 失败则使用最常见的 cat 命令来查看文件内容 使用在Bash和Zsh中使用模糊完成要触发文件和目录的模糊完成，请将**字符添加为触发序列 12345$ cat **&lt;Tab&gt;$ unset **&lt;Tab&gt;$ unalias **&lt;Tab&gt;$ export **&lt;Tab&gt;$ kill -9 &lt;Tab&gt; 启用fzf作为Vim插件第一步:在.vimrc文件添加set rtp+=~/.fzf,这个指向的是fzf命令文件所在位置第二步:进入bundles中添加Bundle &#39;junegunn/fzf.vim&#39;,主要是为了获得更多的命令支持,不然上一步完成已经可以使用:FZF命令进行使用了第三步:使用fzf插件https://segmentfault.com/a/1190000016186540 vim中使用fzf插件,写几个比较重要的 命令 作用 备注 Files 路径 FZF一样的作用，它会列出所有文件，选中后vim会打开选中的文件 无 Buffers 用于在存在于buffer中的文件间切换 无 Lines 用于在存在于buffer里的文件中寻找含有某个关键词的行 无 BLines 在当前buffer里查找 无 Rg 会调用ripgrep来递归搜索当前目录 无 参考Fuzzy finder(fzf+vim) 使用全指南","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Vim中显示markdown结构大纲","date":"2019-07-29T12:50:30.000Z","path":"2019/07/29/vim中显示markdown结构大纲/","text":"简介可能许多人都知道利用 ctags 工具和 tagbar 插件可以在 vim 中显示侧边栏，列出代码文件的结构、类和函数等。实际上在写 markdown 文本时，如果也能在 tagbar 中显示文本大纲，那么显然可以帮助我们理清写作思路，也能快速定位到相关的段落进行修改。实际上，因为 markdown 文件是高度结构化的，所以很容易就能让 ctags 识别 markdown 的文本结构，从而为我们提取出大纲。在 github 上已经有人分享了这一工具：markdown2ctags 需要的工具Excuberant Ctags 作用该工具通过提取关键字等方式，为不同语言生成 index 目录文件。这些 index 文件可以被用来索引大纲并实现快速跳转。 安装1$ sudo apt-get install exuberant-ctags easytags 作用自动在保存时更新ctag索引文件,虽然本身能够生成索引文件，但是每次都要手动去生成、更新，比较麻烦。安装 easytags 插件之后可以自动在保存时更新 ctags 索引文件，非常方便。 安装使用vim的插件管理器,(我还是用旧版本的Bundle,新版本的改成Plugin就好),在vim的配置文件中加入如下语句123&quot; vim-misc插件是easytags的依赖,作者自己搞的Bundle &apos;xolox/vim-misc&apos;Bundle &apos;xolox/vim-easytags&apos; tagbar 作用tagbar 也是一款 vim 插件，安装之后能够利用 ctags 索引文件，在窗口的右侧生成一个侧边窗口，显示文本的结构，默认使用 来打开/关闭该窗口。 安装这个一般都有安装 markdown2ctags 作用该工具可以用来为 markdown 生成 ctags 可以识别的索引文件 安装 1Bundle &apos;jszakmeister/markdown2ctags&apos; 配置 123456789101112131415&quot; Add support for markdown files in tagbar.let g:tagbar_type_markdown = &#123; \\ &apos;ctagstype&apos;: &apos;markdown&apos;, \\ &apos;ctagsbin&apos; : &apos;/path/to/markdown2ctags.py&apos;, \\ &apos;ctagsargs&apos; : &apos;-f - --sort=yes --sro=»&apos;, \\ &apos;kinds&apos; : [ \\ &apos;s:sections&apos;, \\ &apos;i:images&apos; \\ ], \\ &apos;sro&apos; : &apos;»&apos;, \\ &apos;kind2scope&apos; : &#123; \\ &apos;s&apos; : &apos;section&apos;, \\ &#125;, \\ &apos;sort&apos;: 0,\\ &#125; 需要在 .vimrc 中加入上述所展示的一段代码需要特别注意的是 ‘ctagstype’: ‘markdown’, ‘ctagsbin’ : ‘/path/to/markdown2ctags.py’,这两个地方需要和你的 vim 所识别的 markdown 格式匹配,检测自己的 vim 所识别的 markdown 文本的格式的方式是在 vim 中输入 :set filetype? ，所显示的 filetype= 后面的内容如果不是markdown 效果图 参考 https://github.com/jszakmeister/markdown2ctags https://github.com/xolox/vim-misc https://github.com/xolox/vim-easytags 在 vim 中显示 markdown 结构大纲","tags":[{"name":"vim","slug":"vim","permalink":"https://zjinc36.github.io/tags/vim/"}]},{"title":"SSH整合方式","date":"2019-07-28T15:02:03.000Z","path":"2019/07/28/SSH整合方式/","text":"Spring整合web项目,有可能是Servlet作为web层.如果是servlet作为web层,必须使用工厂获得业务层类,但是如果使用Struts2,Struts2里面有一个插件,可以简化web层代码 引入jar包Struts2的jar包 struts-2.3.37\\apps\\struts2-blank\\WEB-INF\\lib\\*.jar – Struts2需要的所有jar包其他需要了解的包 struts2-spring-plugin-2.3.37.jar – Struts2整合Spring的插件包 struts2-convention-plugin-2.3.37.jar – Struts2注解开发包 struts2-json-plugin-2.3.37.jar – Struts2整合AJAX的开发包 Hibernate的jar包Hibernate的开发必须的包 hibernate-release-5.0.7.Final\\lib\\required\\*.jar – Hibernate框架需要的jar包日志记录 `log4j-1.2.16.jar`` slf4j-api-1.6.1.jar – 日志接口 slf4j-log4j12-1.7.2.jar – 日志实现 Mysql驱动 mysql-connector-java-5.1.7-bin.jar – MySQL的驱动包 使用c3p0 c3p0-0.9.5.3.jar 注意:Struts2和Hibernate都引入了javassist这个jar包,需要删除一个 Spring的jar包 IOC核心包 AOP核心包 JDBC模板和事务核心包 Spring整合web开发 Spring整合Hibernate核心包 Spring整合JUnit测试包 Spring整合Struts2核心包 引入映射文件Struts2的配置文件 在web.xml中配置spring与struts的相关代码 配置struts2核心过滤器这里定义为拦截所有 123456789 &lt;!-- 配置核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置spring的监听器当服务启动时，就会先加载spring的配置文件 1234&lt;!-- 配置Spring框架整合WEB的监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 配置默认加载路径 12345 &lt;!-- 监听器默认加载Web-INF文件下，需要配置参数来加载指定文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 总结：web.xml全部代码为 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;SSHDemo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置Spring框架整合WEB的监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 监听器默认加载Web-INF文件下，需要配置参数来加载指定文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; struts2.xml用以配置哪个url访问到哪个action12345CTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.1//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt;&lt;/struts&gt; Hibernate的配置文件 hibernate.cfg.xml 注意:要记得删除那个与线程绑定的session 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 必须配置 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://192.168.174.130:3306/SSH&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 配置C3P0的连接池 --&gt; &lt;property name=\"connection.provider_class\"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- 不能配置绑定当前的线程的操作 --&gt; &lt;!-- 映射配置文件 --&gt; &lt;mapping resource=\"com/zjinc36/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 映射文件 Spring的配置文件 web.xml在上面的web.xml中已经配置了 applicationContext.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;&lt;/beans&gt; 日志文件 123456789101112131415### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.errlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c\\:mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change 'info' to 'debug' ###log4j.rootLogger=info, stdout 相关说明用代码 表语句 12345678910create table `cst_customer` ( `cust_id` BIGINT(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` VARCHAR(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` VARCHAR(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` VARCHAR(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` VARCHAR(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` VARCHAR(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` VARCHAR(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY(`cust_id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 配置dao层 定义接口 123public interface CustomerDao &#123; public void save(Customer customer);&#125; 定义实现类 12345public class CustomerDaoImpl implements CustomerDao &#123; public void save(Customer customer) &#123; &#125;&#125; 定义业务层接口和实现类 定义接口 123456789101112package com.zjinc36.ssh.service;import com.zjinc36.ssh.domain.Customer;/** * 客户管理的业务接口 * @author zjc * */public interface CustomerService &#123; public void save(Customer customer);&#125; 定义实现类 12345678910111213141516package com.zjinc36.ssh.service.impl;import com.zjinc36.ssh.domain.Customer;import com.zjinc36.ssh.service.CustomerService;/** * 客户管理的业务实现类 * @author zjc * */public class CustomerServiceImpl implements CustomerService &#123; @Override public void save(Customer customer) &#123; &#125;&#125; 定义Customer对象 定义对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.zjinc36.ssh.domain;public class Customer &#123; private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public Long getCust_user_id() &#123; return cust_user_id; &#125; public void setCust_user_id(Long cust_user_id) &#123; this.cust_user_id = cust_user_id; &#125; public Long getCust_create_id() &#123; return cust_create_id; &#125; public void setCust_create_id(Long cust_create_id) &#123; this.cust_create_id = cust_create_id; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_linkman() &#123; return cust_linkman; &#125; public void setCust_linkman(String cust_linkman) &#123; this.cust_linkman = cust_linkman; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125; @Override public String toString() &#123; return \"Customer [cust_id=\" + cust_id + \", cust_name=\" + cust_name + \", cust_user_id=\" + cust_user_id + \", cust_create_id=\" + cust_create_id + \", cust_source=\" + cust_source + \", cust_industry=\" + cust_industry + \", cust_level=\" + cust_level + \", cust_linkman=\" + cust_linkman + \", cust_phone=\" + cust_phone + \", cust_mobile=\" + cust_mobile + \"]\"; &#125;&#125; 定义映射文件Customer.hbm.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.zjinc36.ssh.domain.Customer\" table=\"cst_customer\"&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\"/&gt; &lt;/id&gt; &lt;property name=\"cust_name\" column=\"cust_name\"/&gt; &lt;property name=\"cust_user_id\" column=\"cust_user_id\"/&gt; &lt;property name=\"cust_create_id\" column=\"cust_create_id\"/&gt; &lt;property name=\"cust_source\" column=\"cust_source\"/&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\"/&gt; &lt;property name=\"cust_level\" column=\"cust_level\"/&gt; &lt;property name=\"cust_linkman\" column=\"cust_linkman\"/&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\"/&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\"/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; spring整合struts2方式一:Action由Struts2框架创建这里先初略的定义持久层交给heibernate，业务层交个struts2，创建实例交给spring 基本思路 客户端访问url进行数据提交,所以需要一个html页面 配置web.xml,对url进行拦截 在struts2.xml配置映射关系,对拦截下来的url进行解析,映射到对应的action 5,6,8三层为了解偶,并不会在代码中显示调用依赖,这时候就需要配置applicationContext.xml,进行依赖注入 编写action的相关代码,将请求所带的数据交给Service层(业务层) 编写Service层(业务层)的相关代码,使得数据符合业务,然后将数据交给Dao层(持久层) 在写持久层之前,需要配置Hibernate.xml,告诉持久层与数据库建立关系 编写Dao层(持久层)的相关代码,将数据保存到数据库 具体操作 定义web界面定义一个保存客户的界面,利用form表单进行数据的提交,根据域名可知，这里利用的是struts2的通配符方式进行访问 12345&lt;FORM id=form1 name=form1 action=\"$&#123;pageContext.request.contextPath &#125;/customer_add.action\" method=post&gt; &lt;!--table部分省略--&gt;&lt;/FORM&gt; 配置struts.xml在struts.xml中配置接受请求，根据action名和方法跳转指定的action，执行指定的方法 因为导入的struts2-spring-plugin-2.3.24.jar 包自带一个配置文件 struts-plugin.xml ，该配置文件中有如下代码 &lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&gt;开启一个常量，如果该常量开启，那么下面的常量就可以使用 struts.objectFactory.spring.autoWire = name，该常量是可以让Action的类来自动装配Bean对象 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 该属性指定需要Struts 2处理的请求后缀，该属性的默认值是action，即所有匹配*.action的请求都由Struts 2处理。 如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（，）隔开。 --&gt; &lt;constant name=\"struts.action.extension\" value=\"action\" /&gt; &lt;!-- Struts2为了管理Action的配置,通过包进行管理 --&gt; &lt;!-- 配置Struts2的包 --&gt; &lt;!-- name:包名,可以随便写,但是要唯一 --&gt; &lt;package name=\"customer\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!-- 配置Action --&gt; &lt;!-- name和访问的路径要一致 --&gt; &lt;!-- class是包名 --&gt; &lt;action name=\"customer_*\" class=\"com.zjinc36.ssh.web.action.CustomerAction\" method=\"&#123;1&#125;\"&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 配置applicationContext.xml在spring的applicationContext.xml中配置相对应的bean以及事务,这里利用spring中IOC(控制反转)的特性，将创建实例的任务交给spring框架管理 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;bean id=\"customerService\" class=\"com.zjinc36.ssh.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"customerDao\" class=\"com.zjinc36.ssh.dao.Impl.CustomerDaoImpl\"&gt; &lt;property name=\"hibernateTemplate\" ref=\"hibernateTemplate\" /&gt; &lt;/bean&gt; &lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate5.HibernateTemplate\"&gt; &lt;!-- 注入sessionFactory --&gt; &lt;property name=\"sessionFactory\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写action编写action相关代码,这里通过struts2的模板类 123456789101112131415161718192021222324252627282930313233343536373839package com.zjinc36.ssh.web.action;import org.apache.struts2.ServletActionContext;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.WebApplicationContextUtils;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.zjinc36.ssh.domain.Customer;import com.zjinc36.ssh.service.CustomerService;public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt;&#123; //不要忘记手动new private Customer customer=new Customer(); public Customer getModel() &#123; return customer; &#125; //提供service成员属性，提供set方法 private CustomerService customerService; public void setCustomerService(CustomerService customerService) &#123; this.customerService = customerService; &#125; /** * 保存客户 * @return */ public String add()&#123; System.out.println(\"WEB层，保存客户\"); //方式一：创建web的工厂（action由struts2创建） WebApplicationContext context=WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext()); CustomerService cs=(CustomerService) context.getBean(\"customerService\"); //调用方法 cs.save(customer); return NONE; &#125;&#125; 编写持久层编写持久层实现类相关代码,这里利用hibernate提供的模板类，内部封转了session，从而可以调用session中的方法 12345678910111213141516171819202122232425package com.zjinc36.ssh.dao.Impl;import org.springframework.orm.hibernate3.HibernateTemplate;import com.zjinc36.ssh.dao.CustomerDao;import com.zjinc36.ssh.domain.Customer;public class CustomerDaoImpl implements CustomerDao &#123; //将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session)) private HibernateTemplate hibernateTemplate; public void setHibernateTemplate(HibernateTemplate hibernateTemplate) &#123; this.hibernateTemplate = hibernateTemplate; &#125; @Override /** * 保存客户 */ public void save(Customer customer) &#123; System.out.println(\"持久层：保存客户\"); hibernateTemplate.save(customer); &#125;&#125; 编写业务层编写业务层实现类相关代码 12345678910111213141516171819202122232425package com.zjinc36.ssh.service.impl;import com.zjinc36.ssh.dao.CustomerDao;import com.zjinc36.ssh.domain.Customer;import com.zjinc36.ssh.service.CustomerService;/** * 客户管理的业务实现类 * @author zjc * */public class CustomerServiceImpl implements CustomerService &#123; private CustomerDao customerDao; public void setCustomerDao(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override //用来保存客户 public void save(Customer customer) &#123; System.out.println(\"业务层，保存客户\"); customerDao.save(customer); &#125;&#125; (推荐)方式二：action由spring框架管理需要引入插件包struts2-spring-plugin-2.3.37.jar – Struts2整合Spring的插件包 基本思路 客户端访问url进行数据提交,所以需要一个html页面 配置web.xml,对url进行拦截 (有变化)解析url -&gt; applicationContext.xml中的bean -&gt; Action 5,6,8三层为了解偶,并不会在代码中显示调用依赖,这时候就需要配置applicationContext.xml,进行依赖注入 编写action的相关代码,将请求所带的数据交给Service层(业务层) 编写Service层(业务层)的相关代码,使得数据符合业务,然后将数据交给Dao层(持久层) 在写持久层之前,需要配置Hibernate.xml,告诉持久层与数据库建立关系 编写Dao层(持久层)的相关代码,将数据保存到数据库 具体操作 配置struts2.xml和applicationContext.xml配置struts2.xml和applicationContext.xml,对拦截下来的url进行解析,映射到对应的Action原本在Struts2.xml写映射的时候,是直接映射到Action,但是现在不是 原本:解析url –&gt; Action 现在:解析url –&gt; applicationContext.xml中的bean –&gt; Action 注意 Spring框架默认生成CustomerAction是单例的，而Struts2框架是多例的。所以需要配置 scope=”prototype”,如果使用单例,所有保存的值会在同一个值栈,会出现问题的 此时没有struts2的自动装配，在action需要手动配置customerService属性，并在action类中生成set方法 applicationContext.xml中的bean -&gt; Action 12345678910&lt;!-- 配置客户模块 --&gt; &lt;!-- 强调：配置的Aciton,必须是多列的 --&gt; &lt;bean id=\"customerAction\" class=\"com.zjinc36.ssh.web.action.CustomerAction\" scope=\"prototype\"&gt; &lt;!--注意：struts管理action时，基于其中有个struts-plugin的jar包，其中更改了一个 常量struts.objectFactory.spring.autoWire = name将其打开了，可以自动装配，只需要提供set方法 但是此时action由spring管理，自动装配失效，所以需要手动进行配置注入 --&gt; &lt;!-- 也就是需要手动注入业务层(service) --&gt; &lt;property name=\"customerService\" ref=\"customerService\"&gt;&lt;/property&gt;&lt;/bean&gt; url-&gt;applicationContext.xmlstruts.xml需要做修改 123456789101112&lt;struts&gt; &lt;!-- 配置包结构 --&gt; &lt;package name=\"crm\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!-- 配置客户的Action --&gt; &lt;!-- 方式一：aciton由struts2框架管理,将url直接映射到Action --&gt; &lt;!-- &lt;action name=\"customer_*\" class=\"com.zjinc36.ssh.web.action.CustomerAction\" method=\"&#123;1&#125;\"/&gt; --&gt; &lt;!-- 方式二：action由spring管理，class标签上只需要编写srping配置bean的ID值既可以--&gt; &lt;!-- 将url映射到applicationContext.xml中的bean --&gt; &lt;action name=\"customer_*\" class=\"customerAction\" method=\"&#123;1&#125;\"&gt;&lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; Spring整合Hibernate(配置事务)方式一:带有hibernate.cfg.xml的配置文件在原生的hibernate中，hibernate.cfg.xml都是由hibernate框架管理，其配置文件能生成sessionFactory,持久层加载此配置文件获取sessionFactory，从而创建工厂生成session，进行数据的增删改成，此时其配置文件应该交给spring管理，充分利用spring的IOC特性Spring框架提供了一个HibernateDaoSupport的工具类，以后DAO都可以继承该类! 在引入hibernate核心配置文件之前，得让dao层继承一个父类HibernateDaoSupport，此父类内部封装了事务模板 基本思路在Dao层整合持久化操作,Hibernate的持久化类=Java类+映射文件(详见:什么是持久化类),核心为数据库的连接配置和SessionFactory对象 spring管理hibernate.cfg.xml文件 spring将sessionFactory注入到Dao 修改持久层实现类,让其继承工具类Hibernatedaosupport,可以简化非常多的操作 使用注解配置事务,需要两步 配置平台事务管理器(详见:常见事务管理器),这里使用Hibernate的事务管理器 开启事务注解(详见:开启事务注解) 修改业务层,开启事务注解@Transactional(详见:注解事务),当然也可以使用xml配置(详见:xml配置事务) 具体实现 Spring管理Hibernate.cfg.xml文件 1234567&lt;!-- 编写bean,名称都是固定的，由spring提供，用来加载hibernate.cfg.xml的配置文件 --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象 --&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\" /&gt;&lt;/bean&gt; Spring将sessionFactory注入到Dao 123456&lt;!-- 以后，Dao都需要继承HibernateDaoSupport，注入sessionFactory --&gt;&lt;bean id=\"customerDao\" class=\"com.zjinc36.ssh.dao.Impl.CustomerDaoImpl\"&gt; &lt;!-- &lt;property name=\"hibernateTemplate\" ref=\"hibernateTemplate\" /&gt; --&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt; 修改持久层实现类,让其继承工具类HibernateDaoSupport 12345678910111213141516171819202122232425262728package com.zjinc36.ssh.dao.Impl;//import org.springframework.orm.hibernate3.HibernateTemplate;import org.springframework.orm.hibernate3.support.HibernateDaoSupport;import com.zjinc36.ssh.dao.CustomerDao;import com.zjinc36.ssh.domain.Customer;public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao &#123;// //将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session))// private HibernateTemplate hibernateTemplate;// public void setHibernateTemplate(HibernateTemplate hibernateTemplate) &#123;// this.hibernateTemplate = hibernateTemplate;// &#125; @Override /** * 保存客户 */ public void save(Customer customer) &#123; System.out.println(\"持久层：保存客户\");// hibernateTemplate.save(customer);// 本来应该是sessionFactory.save()操作的,但是sessionFactory被spring管理注入后,这样就可以了 this.getHibernateTemplate().save(customer); &#125;&#125; 配置平台事务管理器 123456&lt;!-- 先配置平台事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt;&lt;/bean&gt; 开启事务注解 12&lt;!-- 开启事务的注解 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; 修改业务层,开启事务注解@Transactional 12345678910111213141516171819202122232425262728package com.zjinc36.ssh.service.impl;import javax.transaction.Transactional;import com.zjinc36.ssh.dao.CustomerDao;import com.zjinc36.ssh.domain.Customer;import com.zjinc36.ssh.service.CustomerService;/** * 客户管理的业务实现类 * @author zjc * */@Transactionalpublic class CustomerServiceImpl implements CustomerService &#123; private CustomerDao customerDao; public void setCustomerDao(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override //用来保存客户 public void save(Customer customer) &#123; System.out.println(\"业务层，保存客户\"); customerDao.save(customer); &#125;&#125; applicationcontext.xml全部代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;bean id=\"customerService\" class=\"com.zjinc36.ssh.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 以后，Dao都需要继承HibernateDaoSupport，注入sessionFactory --&gt; &lt;bean id=\"customerDao\" class=\"com.zjinc36.ssh.dao.Impl.CustomerDaoImpl\"&gt; &lt;!-- &lt;property name=\"hibernateTemplate\" ref=\"hibernateTemplate\" /&gt; --&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- &lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate5.HibernateTemplate\"&gt; 注入sessionFactory &lt;property name=\"sessionFactory\" /&gt; &lt;/bean&gt; --&gt; &lt;!-- 编写bean,名称都是固定的，由spring提供，用来加载hibernate.cfg.xml的配置文件 --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象 --&gt; &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\" /&gt; &lt;/bean&gt; &lt;!-- 先配置平台事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 开启事务的注解 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt;&lt;/beans&gt; 方式二:不带有hibernate.cfg.xml的配置文件不带有hibernate.cfg.xml文件,不代表配置可以省,所以这些配置都是需要的,只是从hibernate.cfg.xml文件转移到了appllicatiionContext.xml文件中了 基本思路基本思路和方式一差不多在Dao层整合持久化操作,Hibernate的持久化类=Java类+映射文件(详见:什么是持久化类),核心为数据库的连接配置和SessionFactory对象 spring管理hibernate.cfg.xml文件 spring中配置hibernate.cfg.xml文件中配置的内容 这里准备删除hibernate的核心配置文件，在删除之前，需要将其配置文件中的相关内容配置到spring的applicatioinContext.xml文件中 hibernate.cfg.xml文件的内容如下 数据库连接基本参数（4大参数） Hibernate相关的属性 连接池 映射文件 spring将sessionFactory注入到Dao 修改持久层实现类,让其继承工具类Hibernatedaosupport,可以简化非常多的操作 使用注解配置事务,需要两步 配置平台事务管理器(详见:常见事务管理器),这里使用Hibernate的事务管理器 开启事务注解(详见:开启事务注解) 修改业务层,开启事务注解@Transactional(详见:注解事务),当然也可以使用xml配置(详见:xml配置事务) 具体实现修改spring中配置hibernate.cfg.xml文件中配置的内容引入连接池 1234567&lt;!-- 先配置C3p0的连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://192.168.174.130:3306/SSH\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; 在sessionFactory引入位置增加其他参数 修改对应的sessionFactory,因为已经没有了hibernate.cfg.xml的配置文件，所以需要修改该配置，注入连接池引入对象映射文件：因为已经没有了hibernate.cfg.xml的配置文件，不会扫描到该配置文件，需要注入 12345678910111213141516171819202122232425&lt;!-- 编写bean,名称都是固定的，由spring提供，用来加载hibernate.cfg.xml的配置文件 --&gt;&lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象 --&gt; &lt;!-- 这里原本需要引入hibernate.cfg.xml,但此时不引入就需要配置 --&gt; &lt;!-- &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\" /&gt; --&gt; &lt;!--先加载连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 加载方言，加载可选项 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 引入映射的配置文件 --&gt; &lt;property name=\"mappingResources\"&gt; &lt;list&gt; &lt;value&gt;/com/zjinc36/ssh/domain/Customer.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 现在applicationContxxt.xml文件全部内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 先配置C3p0的连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/hibernate\" /&gt; &lt;property name=\"user\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;bean id=\"customerService\" class=\"com.zjinc36.ssh.service.impl.CustomerServiceImpl\"&gt; &lt;property name=\"customerDao\" ref=\"customerDao\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 以后，Dao都需要继承HibernateDaoSupport，注入sessionFactory --&gt; &lt;bean id=\"customerDao\" class=\"com.zjinc36.ssh.dao.Impl.CustomerDaoImpl\"&gt; &lt;!-- &lt;property name=\"hibernateTemplate\" ref=\"hibernateTemplate\" /&gt; --&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- &lt;bean id=\"hibernateTemplate\" class=\"org.springframework.orm.hibernate5.HibernateTemplate\"&gt; 注入sessionFactory &lt;property name=\"sessionFactory\" /&gt; &lt;/bean&gt; --&gt; &lt;!-- 编写bean,名称都是固定的，由spring提供，用来加载hibernate.cfg.xml的配置文件 --&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象 --&gt; &lt;!-- 这里原本需要引入hibernate.cfg.xml,但此时不引入就需要配置 --&gt; &lt;!-- &lt;property name=\"configLocation\" value=\"classpath:hibernate.cfg.xml\" /&gt; --&gt; &lt;!--先加载连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 加载方言，加载可选项 --&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 引入映射的配置文件 --&gt; &lt;property name=\"mappingResources\"&gt; &lt;list&gt; &lt;value&gt;/com/zjinc36/ssh/domain/Customer.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 先配置平台事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate5.HibernateTransactionManager\"&gt; &lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 开启事务的注解 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt;&lt;/beans&gt; 此时可以安心的删除hibernate.cfg.xml文件了这样SSH整合完毕 Hibernate模板常用方法插入 持久层 12345678910111213141516171819202122package com.zjinc36.dao.impl;import java.util.List;import org.hibernate.criterion.DetachedCriteria;import org.springframework.orm.hibernate5.HibernateTemplate;import org.springframework.orm.hibernate5.support.HibernateDaoSupport;import com.zjinc36.domain.Customer;/** * 持久层 * 继承HibernateDaoSupport，内部封装了HibernateTemplat * @author Administrator * */public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao &#123; @Override public void update(Customer customer) &#123; // TODO Auto-generated method stub this.getHibernateTemplate().update(customer); &#125;&#125; 业务层 1234567891011121314151617181920212223242526package com.zinc36.service.impl;import java.util.List;import org.springframework.transaction.annotation.Transactional;import com.zjinc36.dao.CustomerDao;import com.zjinc36.domain.Customer;/** * 客户的业务层 * @author Administrator * */@Transactionalpublic class CustomerServiceImpl implements CustomerService&#123; private CustomerDao customerDao; public void setCustomerDao(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; @Override public void update(Customer customer) &#123; // TODO Auto-generated method stub customerDao.update(customer); &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435package com.zjinc36.test;import java.util.List;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.zjinc36.domain.Customer;import com.zjinc36.service.CustomerService;/** * 测试Hiberante模板类的简单方法 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo1 &#123; @Resource(name=\"customerService\") private CustomerService customerService; /** * 测试插入 */ @Test public void run1()&#123; Customer customer=new Customer(); customer.setCust_id(1L); customer.setCust_name(\"测试\"); customerService.update(customer); &#125;&#125; 指定查询、查询所有、离线查询代码 持久层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.zjinc36.dao;import java.util.List;import org.hibernate.criterion.DetachedCriteria;import org.springframework.orm.hibernate5.HibernateTemplate;import org.springframework.orm.hibernate5.support.HibernateDaoSupport;import com.zjinc36.domain.Customer;/** * 持久层 * 继承HibernateDaoSupport，内部封装了HibernateTemplate * @author Administrator * */public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao &#123; //将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session)) /*private HibernateTemplate hibernateTemplate; public void setHibernateTemplate(HibernateTemplate hibernateTemplate) &#123; this.hibernateTemplate = hibernateTemplate; &#125;*/ /** * 保存客户 */ public void save(Customer customer) &#123; System.out.println(\"持久层：保存客户\"); this.getHibernateTemplate().save(customer); &#125; @Override public void update(Customer customer) &#123; // TODO Auto-generated method stub this.getHibernateTemplate().update(customer); &#125; /** * 通过主键查询 */ public Customer getById(Long id) &#123; return this.getHibernateTemplate().get(Customer.class, id); &#125; /** * 查询所有 */ @Override public List&lt;Customer&gt; findAll() &#123; String sql=\"from Customer\"; List&lt;Customer&gt; list=(List&lt;Customer&gt;) this.getHibernateTemplate().find(sql); return list; &#125; /** * QBC离线查询 */ @Override public List&lt;Customer&gt; findAllByQBC() &#123; DetachedCriteria criteria=DetachedCriteria.forClass(Customer.class); List&lt;Customer&gt; list=(List&lt;Customer&gt;) this.getHibernateTemplate().findByCriteria(criteria); return list; &#125;&#125; 业务层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.zjinc36.service;import java.util.List;import org.springframework.transaction.annotation.Transactional;import com.zjinc36.dao.CustomerDao;import com.zjinc36.domain.Customer;/** * 客户的业务层 * @author Administrator * */@Transactionalpublic class CustomerServiceImpl implements CustomerService&#123; private CustomerDao customerDao; public void setCustomerDao(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; //用来保存客户 public void save(Customer customer) &#123; System.out.println(\"业务层，保存客户\"); customerDao.save(customer); &#125; @Override public void update(Customer customer) &#123; // TODO Auto-generated method stub customerDao.update(customer); &#125; @Override public Customer getById(Long id) &#123; // TODO Auto-generated method stub return customerDao.getById(id); &#125; @Override public List&lt;Customer&gt; findAll() &#123; return customerDao.findAll(); &#125; @Override public List&lt;Customer&gt; findAllByQBC() &#123; // TODO Auto-generated method stub return customerDao.findAllByQBC(); &#125;&#125; 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.zjinc36.test;import java.util.List;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.zjinc36.domain.Customer;import com.zjinc36.service.CustomerService;/** * 测试Hiberante模板类的简单方法 * @author Administrator * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class Demo1 &#123; @Resource(name=\"customerService\") private CustomerService customerService; /** * 测试插入 */ @Test public void run1()&#123; Customer customer=new Customer(); customer.setCust_id(1L); customer.setCust_name(\"测试\"); customerService.update(customer); &#125; /** * 测试查询指定的客户 */ @Test public void run2()&#123; Customer customer=customerService.getById(2L); System.out.println(customer); &#125; /** * 查询所有的客户 */ @Test public void run3()&#123; List&lt;Customer&gt; list=customerService.findAll(); System.out.println(list); &#125; /** * QBC(离线查询) */ @Test public void run4()&#123; List&lt;Customer&gt; list=customerService.findAllByQBC(); System.out.println(list); &#125;&#125; 关于SSH延迟加载问题问题使用延迟加载的时候，再WEB层查询对象的时候程序会抛出异常！ 原因是延迟加载还没有发生SQL语句，在业务层session对象就已经销毁了，所以查询到的JavaBean对象已经变成了托管态对象！ 注意：一定要先删除javassist-3.11.0.GA.jar包（jar包冲突了） 解决办法Spring框架提供了一个过滤器，让session对象在WEB层就创建，在WEB层销毁。只需要配置该过滤器即可 但是：要注意需要在struts2的核心过滤器之前进行，spring监听器之后配置 123456789&lt;!-- 解决延迟加载的问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 演示延迟加载 持久层：调用load方法，此方法时延迟加载的 12345678/** * 延迟加载 */ @Override public Customer loadById(long id) &#123; // TODO Auto-generated method stub return this.getHibernateTemplate().load(Customer.class, id); &#125; 业务层 12345@Override public Customer loadById(long id) &#123; // TODO Auto-generated method stub return customerDao.loadById(id); &#125; 测试类 12345@Test public void run5()&#123; Customer customer=customerService.loadById(2L); System.out.println(customer); &#125; 参考Spring+Hibernate+Struts(SSH)框架整合","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"Hibernate","slug":"Hibernate","permalink":"https://zjinc36.github.io/tags/Hibernate/"},{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"},{"name":"SSH","slug":"SSH","permalink":"https://zjinc36.github.io/tags/SSH/"}]},{"title":"Java中的闭包","date":"2019-07-28T11:13:49.000Z","path":"2019/07/28/Java中的闭包/","text":"参考 本文作者为: SylvanasSun.转载请务必将下面这段话置于文章开头处(保留超链接). 本文转发自SylvanasSun Blog,原文链接: https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/ C++11 中值得关注的几大变化（详解）评论区6# 闭包定义一个闭包的要点如下: 一个依赖于外部环境的自由变量的函数. 这个函数能够访问外部环境的自由变量. 也就是说,外部环境持有内部函数所依赖的自由变量,由此对内部函数形成了闭包. 自由变量那么什么是自由变量呢?自由变量就是在函数自身作用域之外的变量,一个函数f(x)=x+yf(x)=x+y,其中y就是自由变量,它并不是这个函数自身的自变量,而是通过外部环境提供的. 下面以JavaScript的一个闭包为例: 12345function Add(y) &#123; return function(x) &#123; return x + y; &#125;&#125; 对于内部函数function(x)来说,y就是自由变量.而y是函数Add(y)内的参数,所以Add(y)对内部函数function(x)形成了一个闭包. 这个闭包将自由变量y与内部函数绑定在了一起,也就是说,当Add(y)函数执行完毕后,它不会随着函数调用结束后被回收(不能在栈上分配空间). 12var add_function = Add(5); // 这时y=5,并且与返回的内部函数绑定在了一起var result = add_function(10); // x=10,返回最终的结果 10 + 5 = 15 Java中的闭包Java与JavaScript又或者其他支持闭包的语言不同,它是一个基于类的面向对象语言,也就是说一个方法所用到的自由变量永远都来自于其所在类的实例的. 123456class AddUtils &#123; private int y = 5; public int add(int x) &#123; retrun x + y; &#125;&#125; 这样一个方法add(x)拥有一个参数x与一个自由变量y,它的返回值也依赖于这个自由变量y.add(x)想要正常工作的话,就必须依赖于AddUtils类的一个实例,不然它无法知道自由变量y的值是多少,也就是自由变量未与add(x)进行绑定. 严格上来说,add(x)中的自由变量应该为this,这是因为y也是通过this关键字来访问的. 所以说,在Java中闭包其实无处不在,只不过我们难以发现而已.但面向对象的语言一般都不把类叫成闭包,这是一种习惯. Java中的内部类就是一种典型的闭包结构. 123456789public class Outer &#123; private int y = 5; private class Inner &#123; private int x = 10; public int add() &#123; return x + y; &#125; &#125;&#125; 内部类通过一个指向外部类的引用来访问外部环境中的自由变量,由此形成了一个闭包. 匿名内部类1234567891011121314public interface AnonInner() &#123; int add();&#125;public class Outer &#123; public AnonInner getAnonInner(final int x) &#123; final int y = 5; return new AnonInner() &#123; public int add() &#123; return x + y; &#125; &#125; &#125;&#125; getAnonInner(x)方法返回了一个匿名内部类AnonInner,匿名内部类不能显式地声明构造函数,也不能对构造函数传参,且返回的是一个AnonInner接口,但它的add()方法实现中用到了两个自由变量(x与y),也就是说外部方法getAnonInner(x)对这个匿名内部类构成了闭包. 但我们发现自由变量都被加上了final修饰符,这是因为Java对闭包支持的不完整导致的. 对于自由变量的捕获策略有以下两种: capture-by-value: 只需要在创建闭包的地方把捕获的值拷贝一份到对象里即可.Java的匿名内部类和Java 8新的lambda表达式都是这样实现的. capture-by-reference: 把被捕获的局部变量“提升”（hoist）到对象里.C#的匿名函数(匿名委托/lambda表达式)就是这样实现的. Java只实现了capture-by-value,但又没有对外说明这一点,为了以后能进一步扩展成支持capture-by-reference留后路,所以干脆就不允许向被捕获的变量赋值,所以这些自由变量需要强制加上final修饰符(在Jdk8中似乎已经没有这种强制限制了). 那么究竟什么是闭包闭包不是私有,闭的意思不是”封闭内部状态”,而是”封闭外部状态”一个函数如何能封闭状态呢?当外部状态的scope失效的时候,还有一份留在内部状态里面 C++11 中值得关注的几大变化（详解）评论区6#","tags":[{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"}]},{"title":"Java匿名内部类访问外部变量，为何需被标志为final","date":"2019-07-28T10:39:27.000Z","path":"2019/07/28/Java匿名内部类访问外部变量，为何需被标志为final/","text":"final关键字有什么用对于Java语言中的final使用，大家应该很熟悉: 可以修饰类，表示不可继承； 可以修饰方法，表示不可被子类重写； 可以修饰变量，表示不可以被二次赋值 Java匿名内部类访问外部变量，为何需被标志为final？这跟上述三个特性有关系吗？问题的提出例如有如下代码 123456789101112// 在方法中使用匿名内部类public void initListener(Button btn )&#123; //必须标记为final final int name = \"zhangsan\"; btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; btn.setText(name); //动态改变按钮的文字 &#125; &#125;);&#125; 为何name变量需被标志为final？这深层次的原因是什么？为什么有这样一个让人摸不着头脑的规定？ 解释Java中的闭包 匿名内部类在方法里面,也就是说,内部类和外部方法形成一个闭包,也就是说内部类能够访问外部方法的变量 由于匿名内部类的生命周期有可能比外部的方法要长,所以有可能出现外部变量访问不到的情况 解决这个问题很简单,就是将外部方法的变量复制一份给匿名内部类,这样即使外部方法”死了”,内部类还是能拿到变量 这样会产生新的问题,那就是当我们在内部类修改了外部变量的值时,由于内部类修改的是”复制品”,就会造成和外部变量不一致的情况 那怎么办?不让改就好了,所以外部变量要使用final关键字,告诉内部类这个变量是不允许改的","tags":[{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"}]},{"title":"Spring的事务管理","date":"2019-07-27T18:39:13.000Z","path":"2019/07/28/Spring的事务管理/","text":"事务什么是事务事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元,要么全部成功,要么全部失败 事务特性 原子性:代表事务不可分割 一致性:代表事务执行的前后,数据的完整性保持一致 隔离性:代表一个事务执行的过程中,不应该收到其他事务的干扰 持久性:代表事务执行完成后,数据就持久到数据库中如果不考虑隔离性,引发安全问题 读问题脏读:一个事务读到另一个事务未提交的数据不可重复读:一个事务读到另一个事务已经提交的update数据,导致在前一个事务多次查询结果不一致虚读:一个事务读到另一个事务已经提交的insert数据,导致在前一个事务多次查询结果不一致 写问题(了解)引发两类丢失更新 读问题的解决 Read uncommitted:以上读问题都会发生 Read committed:解决脏读,但是不可重复读和虚度有可能发生(Oracle用这种) Repeatable read:解决脏读和不可重复读,但是虚读有可能发生(MySQL用这种) Serializable:解决所有问题,但是效率低 Spring的事务管理的APISpring 框架中,最重要的事务管理的 API 有三个：TransactionDefinition、PlatformTransactionManager 和 TransactionStatus所谓事务管理,实质上就是按照给定的事务规则来执行提交或者回滚操作.其中 “给定的事务规则”是用 TransactionDefinition 表示的 “按照……来执行提交或者回滚操作”是用 PlatformTransactionManager 表示的 TransactionStatus 可以看作代表事务本身.PlatformTransactionManager:平台事物管理器平台事务管理器:接口,是Spring用于管理事务的真正对象 DataSourceTransactionManager:底层使用JDBC管理事务 HibernateTransactionManager:底层使用Hibernate管理事务 TransactionDefinition:事务定义信息事务定义:用于定义事务的相关信息,隔离级别,超时信息,传播行为,是否只读 TransactionStatus:事务的状态Spring进行事务管理的时候,首先平台事务管理器根据事务定义信息进行事务的管理,在事物管理过程中,产生各种状态,将这些状态的信息记录到事务状态中 搭建Spring的事务管理的环境主要有以下两个步骤 配置连接池和JDBC的模板 在DAO注入jdbc的模板 具体实现一次 创建Service的接口 123456789package com.zjinc36.transaction;/** * 转账接口 * @author zjc * */public interface AccountService &#123; public void transfer(String from, String to, Double money);&#125; 创建Service的实现类 123456789101112131415161718192021package com.zjinc36.transaction;public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override /** * from:转出帐号 * to:转入帐号 * money:金额 */ public void transfer(String from, String to, Double money) &#123; accountDao.outMoney(from, money); accountDao.inMoney(to, money); &#125;&#125; 创建DAO的接口 123456789101112package com.zjinc36.transaction;/** * 转账的Dao接口 * @author zjc * */public interface AccountDao &#123; public void outMoney(String from, Double money); public void inMoney(String to, Double money);&#125; 创建DAO的实现类 123456789101112131415161718192021222324252627282930313233package com.zjinc36.transaction;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.support.JdbcDaoSupport;/** * 转账的Dao的实现类 * @author zjc * */public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123;// 在不继承JdbcDaoSupport的前提下,是需要写如下代码用以注入Jdbc的// 但是继承之后就不需要了,因为在继承类中就已经有如下代码了// 还可以继续简化,继承这个类后,在appllicationContext.xml文件中,只需要配置一个连接池就行// 因为继承类中连注入的步骤都已经有了// private JdbcTemplate jdbcTemplate;// public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;// this.jdbcTemplate = jdbcTemplate;// &#125; // 在DAO中编写扣钱和加钱的方法 @Override public void outMoney(String from, Double money) &#123; this.getJdbcTemplate().update(\"update account set money = money - ? where name = ?\", money, from); &#125; @Override public void inMoney(String to, Double money) &#123; this.getJdbcTemplate().update(\"update account set money = money + ? where name = ?\", money, to); &#125;&#125; 配置Service和DAO:交给Spring管理 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 引入属性文件 --&gt; &lt;!-- 第一种方式通过一个Bean标签引入的(很少使用) --&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\" value=\"classpath:jdbc.properties\" /&gt; &lt;/bean&gt; &lt;!-- 配置Spring的内置连接池 --&gt; &lt;bean id=\"dataSourcePool\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 属性注入 --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driverClass&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/bean&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSourcePool\" /&gt; &lt;/bean&gt; &lt;!-- 配置Service --&gt; &lt;bean id=\"accountService\" class=\"com.zjinc36.transaction.AccountServiceImpl\"&gt; &lt;!-- 在AccountServiceImpl中注入accountDao --&gt; &lt;property name=\"accountDao\" ref=\"accountDao\" /&gt; &lt;/bean&gt; &lt;!-- 配置DAO --&gt; &lt;bean id=\"accountDao\" class=\"com.zjinc36.transaction.AccountDaoImpl\"&gt; &lt;!-- 向DAO中注入jdbc --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 测试整个环境是否打通 12345678910111213141516171819202122232425package com.zjinc36.transaction;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * 测试转账的环境 * @author zjc * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class TestTransf &#123; @Resource(name=\"accountService\") private AccountService accountService; @Test public void demo1() &#123; accountService.transfer(\"Lucy\", \"lisi\", 100d); &#125;&#125; Spring的事务管理上述搭建的环境中,转账过程没有进行事务管理,以下提供两种方式进行事务管理 常见的事务管理器Spring的事务管理(一) Spring事务管理的实现，事务的属性(隔离级别，传播行为，只读)Spring事务管理二：Spring事务管理器常见事务管理器有如下几种 Jdbc事务如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。 为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; DataSourceTransactionManager是通过调用Connection来管理事务，通过调用Connection的commit方法提交事务，rollback方法回滚事务 Hiberante事务 Hibernate持久化策略，利用HibernateTransactionManager进行事务管理。对于Hibernate3，需要在Spring上下文定义中添加如下的声明： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt;&lt;/bean&gt; sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职 责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。 当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。 JPA事务 Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。 如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\" /&gt; &lt;/bean&gt; JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。 JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。 Java原生API事务 如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就 需要使用JtaTransactionManager： 123&lt;bean id=\"transactionManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"&gt; &lt;property name=\"transactionManagerName\" value=\"java:/TransactionManager\" /&gt;&lt;/bean&gt; JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction 和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务 失败通过UserTransaction.rollback()方法回滚。 方式一:编程式事务(需要手动编写代码)Spring事务管理三：编程式事务 配置平台事务管理器常见的事务管理器 配置事务管理的模板类123&lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt;&lt;/bean&gt; 在业务层注入事务管理的模板1234567&lt;!-- 配置Service --&gt;&lt;bean id=\"accountService\" class=\"com.zjinc36.transaction.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\" /&gt; &lt;!-- 注入事务管理的模板 --&gt; &lt;property name=\"transactionTemplate\" ref=\"transactionTemplate\" /&gt;&lt;/bean&gt; 编写事务管理的代码在AccountServiceImpl.java文件,为transfer函数添加事务 1234567891011121314@Override/** * from:转出帐号 to:转入帐号 money:金额 */public void transfer(String from, String to, Double money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult( TransactionStatus transactionStatus) &#123; accountDao.outMoney(from, money); accountDao.inMoney(to, money); &#125; &#125;);&#125; 方式二:声明式事务Spring事务管理四：声明式事务 事务属性在定义事务之前，需要了解一些事务的参数，包括传播机制、隔离级别、是否只读、事务超时等，还包括回滚规则定义等参数。 事务的传播行为如果遇到了特别复杂的业务逻辑,有可能会出现业务之间的方法相互调用我们一般将事务建立在业务层,那么当业务复杂的时候,代码层面上会出现A代码创建了事务,B代码也创建了事务,同时B代码中调用A的代码,这样就会出现事务”嵌套”在一起,而不是一个业务逻辑就一个事务.事务的传播的行为主要用来解决业务层方法相互调用的问题 传播行为 解释 备注 PROPAGATION_REQUIRED 如果存在一个事务,则支持当前事务.如果没有事务则开启事务 Spring中默认的传播行为,前三个用以保证多个操作在同一个事务中 PROPAGATION_SUPPORTS 如果存在一个事务,则支持当前事务.如果没有事务,则非事务的执行 PROPAGATION_MANDATORY 如果已经存在一个事务,则支持当前事务.如果没有一个活动的事务,则抛出异常 PROPAGATION_REQUIREDS_NEW 总是开启一个新的事务.如果一个事务已经存在,则将这个存在的事务挂起,并创建一个新的事务,只包含自身操作.如果没有事物,创建一个只包含自身的事务 用以保证多个操作不在同一个事务中,在批处理,信用卡还款处理,给每一个卡创建一个独立的事务,不会因为一个处理失败,全部失败 PROPAGATION_NOT_SUPPORTED 总是非事务的执行,并挂起任何存在的事务 PROPAGATION_NEVER 总是非事务的执行,如果已经存在一个事务,则抛出异常 PROPAGATION_NESTED 如果一个活动的事务存在,则运行在一个嵌套的事务中；如果没有活动事务,则按照PROPAGATION_REQUIRED属性执行(开启一个新的事务) 嵌套事务,如果A中有事务,按照A的事务执行,执行完成后,设置一个保存点,然后执行B中的操作.如果没有异常,则执行通过,如果有异常,可以选择回滚到初始位置,也可以回滚到保存点 隔离级别隔离级别(isolation level)：定义了其他并发事务对当前事务的影响程度，或者说是当前事务对事务数据的自私程度。 在了解隔离级别定义之前，首先需要了解事务并发带来的问题，包括如下几个方面： 第一类丢失更新：两个事务更新相同数据，如果第一个事务提交，另一个事务回滚，第一个事务的更新会被回滚。 脏读(dirty reads)：第二个事务查询到第一个事务未提交的更新数据，第二个事务根据该数据执行，但第一个事务回滚，第二个事务操作脏数据。 幻读(phantom read)：一个事务查询到了另一个事务已经提交的新数据，导致多次查询数据不一致。 不可重复读(nonrepeatable read)：一个事务查询到另一个事务已经修改的数据，导致多次查询数据不一致。 第二类丢失更新：多个事务同时读取相同数据，并完成各自的事务提交，导致最后一个事务提交会覆盖前面所有事务对数据的改变。 理想情况下，事务是完全隔离的，从而防止上述问题产生，但是这样通常会涉及数据库锁定(锁表、行)数据，造成性能问题。通常，并不是所有应用都需要完全的隔离事务。事务隔离级别提供了事务隔离上的灵活性，从而让开发人员进行灵活的取舍。Spring提供了5中事务隔离级别： 隔离级别 含义 DEFAULT 使用后端数据库默认的隔离级别(spring中的的选择项) READ_UNCOMMITED 允许你读取还未提交的改变了的数据。可能导致脏、幻、不可重复读 READ_COMMITTED 允许在并发事务已经提交后读取。可防止脏读，但幻读和不可重复读仍可发生 REPEATABLE_READ 对相同字段的多次读取是一致的，除非数据被事务本身改变。可防止脏、不可重复读，但幻读仍可能发生。 SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。 这5中隔离级别中，READ_UNCOMMITED是最高效的但也是隔离程度最低的；而SERIALIZABLE则是效率最低但是隔离程度最高的。Spring的这5中隔离级别在枚举类Isolation中进行了定义，其中最终也是调用的TransactionDefinition接口中的常量定义。 是否只读如果事务只对后端数据进行读操作，那么如果将事务设置为只读事务，可以利用后端数据库优化措施进行适当优化。 只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。 因此，“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。 只读事务实在开启事务时有数据库实施的，所以只对具备启动新事务的传播机制有效，如REQUIRED、REQUIRES_NEW、NESTED。 超时时间超时时间定义了当事务执行时间超过一定时间后自动回滚。 超时机制会在事务开启时启动，所以只对具备启动新事务的传播机制有效，如REQUIRED、REQUIRES_NEW、NESTED。 回滚规则回滚规则定义了事务在遇到什么异常进行回滚、什么异常不进行回滚。默认情况下，事务在遇到运行时异常(RuntimeException)才会回滚，但是我们可以在Spring中进行定义来改变其默认行为。Spring在xml文件配置事务时提供了rollback-for和no-rollback-for参数，来指定回滚和不会滚的异常名称，该名称对应的类为Throwable的子类。 我们总体了解了事务的各个属性以及对事务的影响，接下来，我们看看在Spring中如何进行声明式事务配置。 XML配置事务基于基本代码环境进行修改 配置命名空间123456789&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; 创建事务的规则1234567891011121314151617181920212223242526&lt;!-- JDBC事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!-- 声明式事务配置 --&gt;&lt;!-- proxy-target-class属性值决定是基于接口的还是基于类的代理被创建。首先说明下proxy-target-class=\"true\"和proxy-target-class=\"false\"的区别，为true则是基于类的代理将起作用（需要cglib库），为false或者省略这个属性，则标准的JDK 基于接口的代理将起作用 --&gt;&lt;aop:config proxy-target-class=\"false\"&gt; &lt;aop:pointcut expression=\"execution(* com.zjinc36.transaction.AccountServiceImpl.*(..))\" id=\"pointcut1\" /&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\"/&gt;&lt;/aop:config&gt;&lt;!-- 通用事务通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"transfer*\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"query*\" read-only=\"true\"/&gt; &lt;tx:method name=\"list*\" read-only=\"true\"/&gt; &lt;tx:method name=\"do*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\" rollback-for=\"Exception\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 如上所示，在定义通知(tx:advice)时需要依赖事务管理器。 tx:method的name属性定义了受事务控制的方法名称，可以使用通配符“*”来进行模糊匹配；read-only标识了该方法的事务是否是只读事务；propagation定义事务的传播机制；rollback-for定义那些异常进行回滚；另外还有timeout、no-rollback-for、isolation等属性配置，分别对应事务的超时时间、不会滚异常、隔离级别等。 aop:config标签进行了aop相关的配置，aop:advisor引用了通知，并定义了事务作用的切点，其采用AspectJ的切入点表达式。关于AOP的配置这里不再赘述 使用注解配置事务除了XML进行声明式事务配置外，还可以采用@Transactional注解来进行事务配置，该注解定义如下： 1234567891011121314151617181920public @interface Transactional &#123; String value() default \"\"; // 事务传播机制 Propagation propagation() default Propagation.REQUIRED; // 事务的隔离级别 Isolation isolation() default Isolation.DEFAULT; // 事务超时时间 int timeout() default TransactionDefinition.TIMEOUT_DEFAULT; // 事务是否只读 boolean readOnly() default false; // 定义使事务回滚的异常类 Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;; // 定义使事务回滚的异常类名称 String[] rollbackForClassName() default &#123;&#125;; // 定义不使异常回滚的异常类 Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;; // 定义不使异常回滚的异常类名称 String[] noRollbackForClassName() default &#123;&#125;;&#125; 配置事务管理器1234&lt;!--JDBC事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 开启注解事务支持1&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 这个配置告诉Spring，检查所管理的配置了@Transactional注解的bean，并为它们添加事务通知 在代码中使用注解@Transactional注解可以用于类和方法上，用于类上表示事务定义应用于该类的所有方法，用于方法则表示单独定义该方法的事务控制属性 12345678910111213141516171819202122232425// 方法受事务控制，而且抛出RuntimeException，事务回滚，无法插入数据@Transactional(propagation = Propagation.REQUIRED)@Overridepublic void tryInsert(User user) throws Exception &#123; userMapper.insert(user); // 模拟抛出异常，事务回滚 throw new NullPointerException(\"hahaha\");&#125;// 方法不受事务控制，可以正常插入数据@Overridepublic void tryInsert(User user) throws Exception &#123; userMapper.insert(user); // 模拟抛出异常，事务回滚 throw new Exception(\"hahaha\");&#125;// 方法受事务控制，但是抛出的是Exception，默认不会滚，可以正常插入数据@Transactional(propagation = Propagation.REQUIRED)@Overridepublic void tryInsert(User user) throws Exception &#123; userMapper.insert(user); // 模拟抛出异常，事务回滚 throw new Exception(\"hahaha\");&#125; 用于类上： 12345@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)@Servicepublic class UserServiceImpl implements UserService &#123;&#125; 告诉Spring，UserServiceImpl这个bean下的所有方法都可以支持事务，传播机制为SUPPORTS，默认都是只读事务。当然，如果方法上定义了事务，会采用方法的事务设置，遵循就近原则 在查找事务相关问题时，将Spring日志级别设定为DEBUG，就可以清楚的看到事务相关的日志信息，便于调试问题 总结可以从传播机制、隔离级别、是否只读、事务超时、回滚规则等方面来描述事务。Spring提供了xml和注解两者事务声明方式： 采用xml：需要使用tx命名空间，好处是在xml中完成事务定义，代码中不需要做任何事务相关的编码；但是，事务控制的方法名称需要遵循一定的规则，一遍Spring能够匹配到并为其加入事务通知。 采用注解：xml仅需一行配置，其他的事务控制都可以通过编码加上注解实现，而且对方法名称没有要求；如果整个应用不需要事务控制，取消xml配置即可。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的JDBC的模板的使用","date":"2019-07-21T16:30:02.000Z","path":"2019/07/22/Spring的JDBC的模板的使用/","text":"创建项目引入jar包 引入基本开发包 数据库驱动 Spring的JDBC模板的jar包 入门程序此时连接池直接出现在代码中 123456789101112131415161718192021222324252627package com.zjinc36.jdbc.demo1;import org.junit.Test;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;/** * JDBC模板的使用 * @author zjc */public class JdbcDemo1 &#123; @Test /** * jdbc模板的使用类似与DButils */ public void demo1() &#123; // 创建连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql:///spring_jdbc\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"root\"); // 创建jdbc模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); jdbcTemplate.update(\"insert into account values(null, ?, ?)\", \"zhangsan\", 10000d); &#125;&#125; 将连接池和模板交给Spring管理本质上就是将配置信息提取到xml文件中 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置Spring的内置连接池 --&gt; &lt;bean id=\"dataSourcePool\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 属性注入 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring_jdbc\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSourcePool\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021package com.zjinc36.jdbc.demo1;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcDemo2 &#123; @Resource(name=\"jdbcTemplate\") private JdbcTemplate jdbcTemplate; @Test public void demo2() &#123; jdbcTemplate.update(\"insert into account value(null, ?, ?)\", \"lisi\", 1000d); &#125;&#125; 配置不同的连接池Spring内置的连接池上面的代码就是用这种方式 applicationContext.xmlorg.springframework.jdbc.datasource.DriverManagerDataSource12345678&lt;bean id=\"dataSourcePool\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 属性注入 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring_jdbc\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt;&lt;/bean&gt; DHCP连接池 jar包 applicationContext.xmlorg.apache.commons.dbcp.BasicDataSource12345678&lt;bean id=\"dataSourcePool\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;!-- 属性注入 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring_jdbc\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt;&lt;/bean&gt; c3p0连接池 jar包 applicationContext.xml12345678&lt;bean id=\"dataSourcePool\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 属性注入 --&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring_jdbc\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt;&lt;/bean&gt; 将详细配置从xml中提取到外部配置文件中Spring引入外部properties文件 定义一个属性文件jdbc.properties 1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///spring_jdbcjdbc.username=rootjdbc.password=root applicationContext.xml文件中引入属性文件 第一种方式,通过bean标签引入 123&lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\" value=\"classpath:jdbc.properties\"/&gt;&lt;/bean&gt; 第二种方式,使用context标签 1&lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; 此时applicationContext.xml应该怎么写12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 引入属性文件 --&gt; &lt;!-- 第一种方式通过一个Bean标签引入的(很少使用) --&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\" value=\"classpath:jdbc.properties\" /&gt; &lt;/bean&gt; &lt;!-- 配置Spring的内置连接池 --&gt; &lt;bean id=\"dataSourcePool\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;!-- 属性注入 --&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driverClass&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/bean&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSourcePool\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 模板的CURD操作spring的JdbcTemplate模板类的常用操作 增删改操作Spring入门之JdbcTemplate【一】增加、删除、修改数据库表数据 12345678910111213141516171819202122232425262728293031323334353637383940package com.zjinc36.jdbc.demo1;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcDemo2 &#123; @Resource(name = \"jdbcTemplate\") private JdbcTemplate jdbcTemplate; @Test // 保存操作 public void demo2() &#123; jdbcTemplate.update(\"insert into account value(null, ?, ?)\", \"lisi\", 1000d); &#125; // 删除操作 @Test public void delete() &#123; // 调用jdbcTemplate对象的方法实现删除操作 String sql = \"DELETE FROM account WHERE name=?\"; int rows = jdbcTemplate.update(sql, \"Lucy\"); System.out.println(rows); &#125; // 修改操作 @Test public void update() &#123; // 调用jdbcTemplate对象的方法实现修改操作 String sql = \"update account set name=? where id=?\"; int rows = jdbcTemplate.update(sql, \"Lucy\", 1); System.out.println(rows); &#125;&#125; 查操作Spring入门之JdbcTemplate【二】查询数据库表数据 将查询数据封装进对象 创建对象(将数据封装进对象) 123456789101112131415161718192021222324252627282930ckage com.zjinc36.jdbc.demo1;public class Account &#123; private Integer id; private String name; private Double money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return \"Account [id=\" + id + \", name=\" + name + \", money=\" + money + \"]\"; &#125;&#125; 自己写类实现接口,自己做数据封装 1234567891011121314151617package com.zjinc36.jdbc.demo1;import java.sql.ResultSet;import java.sql.SQLException;import org.springframework.jdbc.core.RowMapper;class MyRowMapper implements RowMapper&lt;Account&gt; &#123; @Override public Account mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Account account = new Account(); account.setId(rs.getInt(\"id\")); account.setName(rs.getString(\"name\")); account.setMoney(rs.getDouble(\"money\")); return account; &#125;&#125; 取出数据 1234567891011121314151617181920212223package com.zjinc36.jdbc.demo1;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcDemo2 &#123; @Resource(name = \"jdbcTemplate\") private JdbcTemplate jdbcTemplate; // 查询返回对象 @Test public void testObject() &#123; Account account = jdbcTemplate.queryForObject( \"select * from account where id=?\", new MyRowMapper(), 2); System.out.println(account); &#125;&#125; 查询表中有多少条记录123456789101112131415161718192021222324252627282930package com.zjinc36.jdbc.demo1;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcDemo2 &#123; @Resource(name = \"jdbcTemplate\") private JdbcTemplate jdbcTemplate; // 查询表中有多少条记录 @Test public void testCount() &#123; // 调用方法得到记录数 String sql = \"select count(*) from account\"; // 调用jdbcTemplate方法得到记录 /* * queryForObject(String sql,Class&lt;T&gt; requiredType) 第一个参数：sql语句 * 第二个参数：返回类型的class */ int count = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(count); &#125;&#125; 查询所有对象list集合123456789101112131415161718192021222324252627282930313233package com.zjinc36.jdbc.demo1;import java.util.List;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcDemo2 &#123; @Resource(name = \"jdbcTemplate\") private JdbcTemplate jdbcTemplate; // 查询所有对象list集合 @Test public void testList() &#123; // 写SQL语句，根据username查询 String sql = \"select * from account\"; /* * query(String sql,RowMapper&lt;T&gt; rowMapper,Object ... args) 第一个参数：SQL语句 * 第二个参数：RowMapper接口，自己写类实现数据封装 第三个参数：可变参数 */ // 调用jdbcTemplate的query()方法 List&lt;Account&gt; list = jdbcTemplate.query(sql, new MyRowMapper()); System.out.println(list); &#125;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的AOP根据参数名称获取参数的值","date":"2019-07-21T15:58:34.000Z","path":"2019/07/21/Spring的aop根据参数名称获取参数的值/","text":"来源Spring Aop根据参数名称获取参数的值（JoinPoint根据参数名获取参数的值） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import org.apache.commons.lang3.ArrayUtils;import org.apache.commons.lang3.StringUtils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Aspect@Componentpublic class AuthAspect &#123; /** * 1.controller包及子包下的所有类的所有方法使用aop * 2.RoomController下的list方法不使用aop */ @Pointcut(value = \"execution(* com.open.controller..*.*(..)) &amp;&amp; !execution(* com.open.controller.RoomController.list(..))\") public void sdkAuth() &#123; &#125; /** * 案例：通过aop控制公共参数的校验 * 1.针对下面的接口，使用@RequestParam注解，不管是get/post请求，都是有效的 * 2.HttpServletRequest#getParameter，调用接口时的参数为appId=xxx或者groupAppId=xxx，使用getParameter(\"appId\");都可以获取到，但getParameter(\"groupAppId\")只可以获取到groupAppId=xxx * 3.在通知中，是针对方法列表中的参数名，而非注解指定的参数名 * public Object list(String accessToken, @RequestParam(\"appId\") String groupAppId, String subGroupAppId) &#123;&#125; * * @param joinPoint * @return */ @Around(\"sdkAuth()\") public Object doAround(ProceedingJoinPoint joinPoint) &#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); String[] parameterNames = methodSignature.getParameterNames(); // 获取accessToken的下表 int accessTokenIndex = ArrayUtils.indexOf(parameterNames, \"accessToken\"); // 获取groupAppId的下标 int groupAppIdIndex = ArrayUtils.indexOf(parameterNames, \"groupAppId\"); // 获取subGroupAppId的下标 int subGroupAppIdIndex = ArrayUtils.indexOf(parameterNames, \"subGroupAppId\"); if (accessTokenIndex == -1 || groupAppIdIndex == -1 || subGroupAppIdIndex == -1) &#123; return \"error\"; &#125; /** * 方法参数的值，返回的数组按照方法定义的顺序，对于null值的，在debug时，不会显示null的数组下表，例如： * public Object list(String accessToken, @RequestParam(\"appId\") String groupAppId, String subGroupAppId) &#123;&#125; * 传参：accessToken=xxx&amp;subGroupAppId=xxx * Object[] args = joinPoint.getArgs();获取的值，在debug时 * args[0] = xxx * args[2] = xxx * 对于args[1]，虽然debug时没有显示这个变量，但实际上它是存在的，值为null */ Object[] args = joinPoint.getArgs(); String accessToken = String.valueOf(args[accessTokenIndex]); String groupAppId = String.valueOf(args[groupAppIdIndex]); String subGroupAppId = String.valueOf(args[subGroupAppIdIndex]); if (StringUtils.equals(accessToken, \"null\") || StringUtils.equals(groupAppId, \"null\") || StringUtils.equals(subGroupAppId, \"null\")) &#123; return \"error\"; &#125; try &#123; return joinPoint.proceed(); &#125; catch (Throwable e) &#123; return \"success\"; &#125; &#125;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring使用注解方式实现AOP","date":"2019-07-21T15:56:28.000Z","path":"2019/07/21/Spring使用注解方式实现AOP/","text":"参考:使用Spring的注解方式实现AOP入门参考:使用Spring的注解方式实现AOP的细节 需要引入的包首先在Eclipse中新建一个普通的Java Project，名称为springAOP。为了使用Spring的注解方式进行面向切面编程，需要在springAOP项目中加入与AOP相关的jar包，spring aop需要额外的jar包有： com.springsource.org.aopalliance-1.0.0.jar com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar spring-aop-4.2.5.RELEASE.jar spring-aspects-4.2.5.RELEASE.jar 这样，springAOP项目共须jar包如下：要进行AOP编程，我们接着要在Spring的配置文件——beans.xml中引入aop命名空间： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\"&gt;&lt;/beans&gt; Spring提供了两种切面声明方式，实际工作中我们可以选用其中一种： 基于XML配置方式声明切面。 基于注解方式声明切面。本文选用第二种方式进行面向切面编程，即基于Spring注解的方式声明切面 使用注解的方式实现AOP案例 我们在src目录下新建一个it.cast.service包，并在该包下创建PersonService接口，其代码为： 12345public interface PersonService &#123; public void save(String name); public void update(String name, Integer id); public String getPersonName(Integer id);&#125; 紧接着在src目录下新建一个it.cast.service.impl包，并在该包下创建PersonService接口的实现类——PersonServiceBean.java，其代码为： 12345678910111213141516171819public class PersonServiceImpl implements PersonService &#123; @Override public void save(String name) &#123; System.out.println(\"我是save()方法\"); &#125; @Override public void update(String name, Integer id) &#123; System.out.println(\"我是update()方法\"); &#125; @Override public String getPersonName(Integer id) &#123; System.out.println(\"我是getPersonName()方法\"); return \"xxx\"; &#125;&#125; 然后，我们就要在cn.itcast.service包下创建一个切面类——MyInterceptor.java，下面我们来按照以下步骤将其写出来。 首先用@Aspect注解声明整个类是一个切面 1234@Aspectpublic class MyInterceptor &#123; ...&#125; 其次用@Pointcut注解声明一个切入点 123456@Aspectpublic class MyInterceptor &#123; @Pointcut(&quot;execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))&quot;) private void anyMethod() &#123;&#125; // 声明一个切入点，anyMethod为切入点名称 ...&#125; 然后,我们可利用方法签名来编写切入点表达式最典型的切入点表达式是根据方法的签名来匹配各种方法 execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))：匹配PersonServiceImpl类中声明的所有方法。第一个*代表任意修饰符及任意返回值类型，第二个*代表任意方法，..匹配任意数量任意类型的参数，若目标类与该切面在同一个包中，可以省略包名。 execution public * cn.itcast.service.impl.PersonServiceImpl.*(..)：匹配PersonServiceImpl类中的所有公有方法。 execution public double cn.itcast.service.impl.PersonServiceImpl.*(..)：匹配PersonServiceImpl类中返回值类型为double类型的所有公有方法。 execution public double cn.itcast.service.impl.PersonServiceImpl.*(double, ..)：匹配PersonServiceImpl类中第一个参数为double类型，后面不管有无参数的所有公有方法，并且该方法的返回值类型为double类型。 execution public double cn.itcast.service.impl.PersonServiceImpl.*(double, double)：匹配PersonServiceImpl类中参数类型为double，double类型的，并且返回值类型也为double类型的所有公有方法。 接着声明前置通知方法前置通知方法在目标方法开始之前执行 1234567891011@Aspectpublic class MyInterceptor &#123; @Pointcut(\"execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))\") private void anyMethod() &#123;&#125; // 声明一个切入点，anyMethod为切入点名称 // 声明该方法是一个前置通知：在目标方法开始之前执行 @Before(\"anyMethod()\") public void doAccessCheck() &#123; System.out.println(\"前置通知\"); &#125;&#125; 注意：若是将一个类声明为一个切面，那么需要把该类放到IOC容器管理。 接下来，我们理应要修改Spring的配置文件——beans.xml了，将其改为： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd\"&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;bean id=\"myInterceptor\" class=\"cn.itcast.service.MyInterceptor\" /&gt; &lt;bean id=\"personService\" class=\" cn.itcast.service.impl.PersonServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 最后，在src目录下新建一个junit.test包，并在该包中新建一个单元测试类——SpringAOPTest.java，其代码为： 12345678910public class SpringAOPTest &#123; @Test public void interceptorTest() &#123; ApplicationContext cxt = new ClassPathXmlApplicationContext(\"beans.xml\"); PersonService personService = (PersonService) cxt.getBean(\"personService\"); personService.save(\"xxx\"); &#125;&#125; 如何使用各种通知前面我们已经入门使用Spring的注解方式实现AOP了，现在我们再来学习使用Spring的注解方式实现AOP的一些细节。本文是来讲解使用Spring的注解方式实现AOP的一些细节，其实说白了就是学习如何使用各种通知而已，例如前置通知、后置通知、异常通知、最终通知、环绕通知等，之前我们已经学习了前置通知，现在就来学习剩余的通知。 后置通知我们先来看后置通知，此时须将MyInterceptor类的代码修改为： 12345678910111213141516171819202122/** * 切面 * @author li ayun * */@Aspectpublic class MyInterceptor &#123; @Pointcut(\"execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))\") private void anyMethod() &#123;&#125; // 声明一个切入点，anyMethod为切入点名称 // 声明该方法是一个前置通知：在目标方法开始之前执行 @Before(\"anyMethod()\") public void doAccessCheck() &#123; System.out.println(\"前置通知\"); &#125; @AfterReturning(\"anyMethod()\") public void doAfterReturning() &#123; System.out.println(\"后置通知\"); &#125;&#125; 最终通知我们再来看最终通知，此时须将MyInterceptor类的代码修改为： 1234567891011121314151617181920212223242526/** * 切面 * @author li ayun * */@Aspectpublic class MyInterceptor &#123; @Pointcut(\"execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))\") private void anyMethod() &#123;&#125; // 声明一个切入点，anyMethod为切入点名称 // 声明该方法是一个前置通知：在目标方法开始之前执行 @Before(\"anyMethod()\") public void doAccessCheck() &#123; System.out.println(\"前置通知\"); &#125; @AfterReturning(\"anyMethod()\") public void doAfterReturning() &#123; System.out.println(\"后置通知\"); &#125; @After(\"anyMethod()\") public void doAfter() &#123; System.out.println(\"最终通知\"); &#125;&#125; 异常通知再接者，我们来看一下异常通知，异常通知是在目标方法抛异常时执行的，故我们应将PersonServiceImpl类的代码改为： 1234567891011121314151617181920public class PersonServiceImpl implements PersonService &#123; @Override public void save(String name) &#123; throw new RuntimeException(\"我是异常\"); // System.out.println(\"我是save()方法\"); &#125; @Override public void update(String name, Integer id) &#123; System.out.println(\"我是update()方法\"); &#125; @Override public String getPersonName(Integer id) &#123; System.out.println(\"我是getPersonName()方法\"); return \"xxx\"; &#125;&#125; 然后在MyInterceptor类中声明异常通知方法： 12345678910111213141516171819202122232425262728293031/** * 切面 * @author li ayun * */@Aspectpublic class MyInterceptor &#123; @Pointcut(\"execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))\") private void anyMethod() &#123;&#125; // 声明一个切入点，anyMethod为切入点名称 // 声明该方法是一个前置通知：在目标方法开始之前执行 @Before(\"anyMethod()\") public void doAccessCheck() &#123; System.out.println(\"前置通知\"); &#125; @AfterReturning(\"anyMethod()\") public void doAfterReturning() &#123; System.out.println(\"后置通知\"); &#125; @After(\"anyMethod()\") public void doAfter() &#123; System.out.println(\"最终通知\"); &#125; @AfterThrowing(\"anyMethod()\") public void doAfterThrowing() &#123; System.out.println(\"异常通知\"); &#125;&#125; 环绕通知最后，我们来看一下环绕通知，Struts2提供的拦截器就属于环绕通知，环绕通知在我们做权限系统时将大量使用。这时，我们还是将PersonServiceImpl类的代码恢复为： 123456789101112131415161718public class PersonServiceImpl implements PersonService &#123; @Override public void save(String name) &#123; // throw new RuntimeException(\"我是异常\"); System.out.println(\"我是save()方法\"); &#125; @Override public void update(String name, Integer id) &#123; System.out.println(\"我是update()方法\"); &#125; @Override public String getPersonName(Integer id) &#123; System.out.println(\"我是getPersonName()方法\"); return \"xxx\"; &#125; 然后在MyInterceptor类中声明环绕通知方法，环绕通知方法的写法是固定的，形如： 123public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; ...&#125; 这样，MyInterceptor类的代码应该是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 切面 * @author li ayun * */@Aspectpublic class MyInterceptor &#123; @Pointcut(\"execution (* cn.itcast.service.impl.PersonServiceImpl.*(..))\") private void anyMethod() &#123;&#125; // 声明一个切入点，anyMethod为切入点名称 // 声明该方法是一个前置通知：在目标方法开始之前执行 @Before(\"anyMethod()\") public void doAccessCheck() &#123; System.out.println(\"前置通知\"); &#125; @AfterReturning(\"anyMethod()\") public void doAfterReturning() &#123; System.out.println(\"后置通知\"); &#125; @After(\"anyMethod()\") public void doAfter() &#123; System.out.println(\"最终通知\"); &#125; @AfterThrowing(\"anyMethod()\") public void doAfterThrowing() &#123; System.out.println(\"异常通知\"); &#125; @Around(\"anyMethod()\") public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; /** * 环绕通知内部一定要确保执行该方法，如果不执行该方法，业务bean中被拦截的方法就不会被执行。 * 当执行该方法，如果后面还有切面的话，它的执行顺序应该是这样的：先执行后面的切面，如果后面没有切面了， * 再执行最终的目标对象的业务方法。若不执行该方法，则后面的切面，业务bean的方法都不会被执行。 */ // if () &#123; // 判断用户是否有权限， System.out.println(\"进入方法\"); Object result = pjp.proceed(); System.out.println(\"退出方法\"); // &#125; return result; &#125;&#125; 注意：环绕通知内部一定要确保执行proceed()该方法，如果不执行该方法，业务bean中被拦截的方法就不会被执行。当执行该方法，如果后面还有切面的话，它的执行顺序应该是这样的：先执行后面的切面，如果后面没有切面了，再执行最终的目标对象的业务方法。若不执行该方法，则后面的切面，业务bean的方法都不会被执行。其实我们仅使用环绕通知就可以实现前置通知、后置通知、异常通知、最终通知等的效果。 细节前面部分我们已经学会了如何使用各种通知，例如前置通知、后置通知、异常通知、最终通知、环绕通知等，现在我们再来看使用Spring的注解方式实现AOP的另一些细节。 细节一：需要得到输入参数如在前置通知里面，得到用户输入的数据。此时，须将前置通知方法修改为： 1234@Before(\"anyMethod() &amp;&amp; args(name)\")public void doAccessCheck(String name) &#123; System.out.println(\"前置通知：\" + name);&#125; @Before(“anyMethod() &amp;&amp; args(name)”)匹配的是PersonServiceImpl类中参数为String类型的方法，即save()方法。测试SpringAOPTest类的interceptorTest()方法，可以发现Eclipse控制台打印： 细节二：如我要获得PersonServiceImpl类中的getPersonName()方法的返回参数此时，须将后置通知方法修改为： 1234@AfterReturning(pointcut=\"anyMethod()\", returning=\"result\")public void doAfterReturning(String result) &#123; System.out.println(\"后置通知：\" + result);&#125; @AfterReturning(pointcut=”anyMethod()”, returning=”result”)匹配的是PersonServiceImpl类中返回值类型为String的方法，并且returning属性能将返回值传入进后置通知方法里面。我们还要修改SpringAOPTest类的代码为： 12345678910public class SpringAOPTest &#123; @Test public void interceptorTest() &#123; ApplicationContext cxt = new ClassPathXmlApplicationContext(\"beans.xml\"); PersonService personService = (PersonService) cxt.getBean(\"personService\"); personService.getPersonName(2); &#125;&#125; 细节三：在目标方法出现异常时，得到抛出的异常为了便于试验，我们须将PersonServiceImpl类的代码修改为： 1234567891011121314151617181920public class PersonServiceImpl implements PersonService &#123; @Override public void save(String name) &#123; throw new RuntimeException(\"我是异常\"); // System.out.println(\"我是save()方法\"); &#125; @Override public void update(String name, Integer id) &#123; System.out.println(\"我是update()方法\"); &#125; @Override public String getPersonName(Integer id) &#123; System.out.println(\"我是getPersonName()方法\"); return \"xxx\"; &#125;&#125; 然后将异常通知方法修改为： 1234@AfterThrowing(pointcut=\"anyMethod()\", throwing=\"e\")public void doAfterThrowing(Exception e) &#123; System.out.println(\"异常通知：\" + e);&#125; 最后，我们还要将SpringAOPTest类的代码改为： 12345678910public class SpringAOPTest &#123; @Test public void interceptorTest() &#123; ApplicationContext cxt = new ClassPathXmlApplicationContext(\"beans.xml\"); PersonService personService = (PersonService) cxt.getBean(\"personService\"); personService.save(\"xxx\"); &#125;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的切点表达式写法","date":"2019-07-21T14:13:35.000Z","path":"2019/07/21/Spring的切点表达式写法/","text":"Aspectj切入点语法定义在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut”切入点” 例如定义切入点表达式execution(* com.sample.service.impl..*.*(..)) execution()是最常用的切点函数，其语法如下所示： 整个表达式可以分为五个部分： 1、execution(): 表达式主体。 2、第一个*号：表示返回类型，*号表示所有的类型。 3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。 4、第二个*号：表示类名，*号表示所有的类。 5、*(..):最后这个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的通知类型","date":"2019-07-21T12:00:53.000Z","path":"2019/07/21/Spring的通知类型/","text":"前提项目基本代码 前置通知在目标方法执行之前进行操作 修改切面类,获得切入点信息123456789101112131415package com.zjinc36.spring.aop;import org.aspectj.lang.JoinPoint;/** * 切面类 * @author zjc * */public class MyAspectXML &#123; //前置通知 public void beforeMethod(JoinPoint joinPoint) &#123; System.out.println(\"前置通知\" + joinPoint); &#125;&#125; 后置通知在目标方法执行之后进行操作 ProductDaoImpl.java增加返回值 12345678910package com.zjinc36.spring.aop;public class ProductDaoImpl implements ProductDao &#123; @Override public String save() &#123; System.out.println(\"save\"); return \"saveReturn\"; &#125;&#125; 切面类增加后置通知和打印上述返回值 1234567891011121314151617package com.zjinc36.spring.aop;import org.aspectj.lang.JoinPoint;/** * 切面类 * @author zjc * */public class MyAspectXML &#123; //后置通知 //这里参数一定是Object对象 //参数命名要和applicationContext.xml中的命名一致 public void afterMethod(Object productDaoImplResult) &#123; System.out.println(\"后置方法\" + productDaoImplResult); &#125;&#125; 在applicationContext.xml文件中增加后置通知和获得返回值设置 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;bean id=\"productDao\" class=\"com.zjinc36.spring.aop.ProductDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 将切面类交给Spring管理 --&gt; &lt;bean id=\"myAspect\" class=\"com.zjinc36.spring.aop.MyAspectXML\" /&gt; &lt;!-- 通过AOP的配置完成对目标类产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 对哪些点进行拦截 * 表示任意返回值 .. 表示任意参数 --&gt; &lt;aop:pointcut expression=\"execution(* com.zjinc36.spring.aop.ProductDaoImpl.save(..) )\" id=\"product1\" /&gt; &lt;!-- 配置切面 --&gt; &lt;!-- ref:切面id returning:切点product1的返回值会赋值给productDaoImplResult,并传递给切面中的afterMethod方法 --&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after-returning method=\"afterMethod\" pointcut-ref=\"product1\" returning=\"productDaoImplResult\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 环绕通知在目标方法执行之前和之后进行操作 修改切面类 123456789101112131415161718package com.zjinc36.spring.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;/** * 切面类 * @author zjc * */public class MyAspectXML &#123; public Object aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(\"环绕前通知\"); Object obj = joinPoint.proceed(); System.out.println(\"环绕后通知\"); return obj; &#125;&#125; applicationContext.xml增加环绕通知 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;bean id=\"productDao\" class=\"com.zjinc36.spring.aop.ProductDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 将切面类交给Spring管理 --&gt; &lt;bean id=\"myAspect\" class=\"com.zjinc36.spring.aop.MyAspectXML\" /&gt; &lt;!-- 通过AOP的配置完成对目标类产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 对哪些点进行拦截 * 表示任意返回值 .. 表示任意参数 --&gt; &lt;aop:pointcut expression=\"execution(* com.zjinc36.spring.aop.ProductDaoImpl.save(..) )\" id=\"product1\" /&gt; &lt;!-- 配置切面 --&gt; &lt;!-- ref:切面id --&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!-- 环绕通知 --&gt; &lt;aop:around method=\"aroundMethod\" pointcut-ref=\"product1\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 异常抛出通知在程序出现异常的时候,进行操作 修改切面类 123456789101112131415161718package com.zjinc36.spring.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;/** * 切面类 * @author zjc * */public class MyAspectXML &#123; //异常抛出通知 //xml文件规定了用ex变量将错误信息传进来,即这边使用的变量要和xml文件中规定的变量相同 public void throwing(Throwable ex) &#123; System.out.println(\"异常抛出通知\"); System.out.println(\"异常内容\" + ex.getMessage()); &#125;&#125; applicationContext.xml中增加异常抛出通知 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;bean id=\"productDao\" class=\"com.zjinc36.spring.aop.ProductDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 将切面类交给Spring管理 --&gt; &lt;bean id=\"myAspect\" class=\"com.zjinc36.spring.aop.MyAspectXML\" /&gt; &lt;!-- 通过AOP的配置完成对目标类产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 对哪些点进行拦截 * 表示任意返回值 .. 表示任意参数 --&gt; &lt;aop:pointcut expression=\"execution(* com.zjinc36.spring.aop.ProductDaoImpl.save(..) )\" id=\"product1\" /&gt; &lt;!-- 配置切面 --&gt; &lt;!-- ref:切面id --&gt; &lt;!-- throwing:切点product1抛出的异常会被赋值到throwing规定变量ex中,并传递给切面所对应的方法throwing中 --&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;aop:after-throwing method=\"throwing\" pointcut-ref=\"product1\" throwing=\"ex\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 注意:测试的时候什么都不会,是因为程序中没有任何异常,只有有异常的时候才会处理到切面类 最终通知无论代码是否有异常,总是会执行 修改切面类 12345678910111213141516package com.zjinc36.spring.aop;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;/** * 切面类 * @author zjc * */public class MyAspectXML &#123; //最终通知 public void afterFinalMethod() &#123; System.out.println(\"最终通知\"); &#125;&#125; applicationContext.xml增加最终通知 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;bean id=\"productDao\" class=\"com.zjinc36.spring.aop.ProductDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 将切面类交给Spring管理 --&gt; &lt;bean id=\"myAspect\" class=\"com.zjinc36.spring.aop.MyAspectXML\" /&gt; &lt;!-- 通过AOP的配置完成对目标类产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 对哪些点进行拦截 * 表示任意返回值 .. 表示任意参数 --&gt; &lt;aop:pointcut expression=\"execution(* com.zjinc36.spring.aop.ProductDaoImpl.save(..) )\" id=\"product1\" /&gt; &lt;!-- 配置切面 --&gt; &lt;!-- ref:切面id --&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;aop:after method=\"afterFinalMethod\" pointcut-ref=\"product1\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 通知同时出现时,通知的顺序如下 引介通知(不用知道)","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的AOP的基本使用案例","date":"2019-07-20T22:31:18.000Z","path":"2019/07/21/Spring的AOP的基本使用案例/","text":"本质上就是将面向切面变成要写的一堆代码变成只需要配置xml文件就可以了 ProductDao.java123456package com.zjinc36.spring.aop;public interface ProductDao &#123; public void save(); public void update();&#125; ProductDaoImpl.java123456789101112131415package com.zjinc36.spring.aop;public class ProductDaoImpl implements ProductDao &#123; @Override public void save() &#123; System.out.println(\"save\"); &#125; @Override public void update() &#123; System.out.println(\"update\"); &#125;&#125; 写切面类123456789101112package com.zjinc36.spring.aop;/** * 切面类 * @author zjc * */public class MyAspectXML &#123; public void checkPri() &#123; System.out.println(\"权限校验\"); &#125;&#125; applicationContext.xml参考:切点表达式写法参考:Spring的通知类型 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;bean id=\"productDao\" class=\"com.zjinc36.spring.aop.ProductDaoImpl\"&gt;&lt;/bean&gt; &lt;!-- 将切面类交给Spring管理 --&gt; &lt;bean id=\"myAspect\" class=\"com.zjinc36.spring.aop.MyAspectXML\" /&gt; &lt;!-- 通过AOP的配置完成对目标类产生代理 --&gt; &lt;aop:config&gt; &lt;!-- 表达式配置哪些类的哪些方法需要进行增强 对哪些点进行拦截 * 表示任意返回值 .. 表示任意参数 --&gt; &lt;aop:pointcut expression=\"execution(* com.zjinc36.spring.aop.ProductDaoImpl.save(..) )\" id=\"product1\" /&gt; &lt;!-- 配置切面 --&gt; &lt;!-- ref:切面id --&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;aop:before method=\"checkPri\" pointcut-ref=\"product1\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试1234567891011121314151617181920212223package com.zjinc36.spring.test;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.zjinc36.spring.aop.ProductDao;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)public class TestProductAOP &#123; @Resource(name = \"productDao\") private ProductDao productDao; @Test public void demo1() &#123; productDao.save(); productDao.update(); &#125;&#125;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的代理模式","date":"2019-07-15T15:04:14.000Z","path":"2019/07/15/Spring的代理模式/","text":"来源:java设计模式之代理模式（动态代理和静态代理） 什么是代理代理的含义在于代替原对象做更多的事情，而不破坏原代码的代码结构 代理也分静态代理 和 动态代理，我们先以简单的静态代理为例子。 静态代理定义一个接口 12345package designmode.代理模式;public interface Sourceable &#123; public void method();&#125; 被代理的对象，它实现了 Sourceable 接口 12345678910111213/** * 被代理对象 * @author panqian * */public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125;&#125; 然后 假设method方法已经不能满足我们的要求，我们需要在这个方法里输出更多的语句，但是我不需要直接修改Source 这个类，我们可以设计一个代理类： 这个代理类Proxy同样实现了Sourceable 接口，但是多了一个Source 成员变量，我们可以通过构造器接收我们原来的对象，然后在代理类的method()方法中，增强我们原有代码的功能（拓展Source对象method的功能 ）。 12345678910111213141516171819202122/** * Proxy 是一个代理类 静态代理 * * @author panqian */public class Proxy implements Sourceable &#123; public Source source; public Proxy(Source source) &#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println(\"before proxy!\"); source.method(); System.out.println(\"after proxy!\"); &#125;&#125; 最后写一个测试用例并看输出的结果： 1234567public class ProxyTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Sourceable sourceable = new Proxy(source); sourceable.method(); &#125;&#125; 结果:可以看到，我们达到了我们的目的，不改变原有代码而增强了代码的功能 123before proxy!the original method!after proxy! 动态代理在写代理模式时，我们做的其实是面向接口编程，代理类和被代理类都实现了一个接口，这也是代理的规范写法。在静态代理中，我们自己要编写代理类，虽然没有破坏原有代码，但是也有几个问题 如果我们要做不同接口的代理，而且我们需要增强的功能没有区别的话，重复的编写代理类是 就造成了代码重复。 如果源对象的接口新增了方法，实现类不用多说，就连代理类也需要重新实现新的方法，代码维护难度上升了。 上面问题全出在代理类上，jdk给我们的解决方案便是 动态代理。在动态代理中，我们不需要自己编写代理类，上面的两个问题 动态代理 来帮我们解决~！ 为了展示动态代理的好处，我们在原有接口上新增一个方法： 1234public interface Sourceable &#123; public void method(); public void method1();&#125; Source 类也需要多实现method1（）方法： 12345678910111213public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125; @Override public void method1() &#123; System.out.println(\"the original method1!\"); &#125;&#125; 关键来了，我们请来了动态代理的核心接口 InvocationHandler,InvocationHandler 接口只需要实现invoke方法，三个参数依次为 代理对象(基本没什么用)，代理对象调用的方法，调用的方法中的参数。通过method.invoke方法，我们传入需要代理的对象（被代理对象作为DynamicProxy 的成员对象，通过构造器传入），和这个方法的参数，便可以调用被代理对象的原方法。然后其它跟静态代理没什么区别。还有一点，method.getName()可以知道被代理对象调用了什么方法，根据不同方法可以自由编写增强现有代码的功能。 1234567891011121314151617181920212223242526/** * 动态代理，不用自己实现 被代理类 */public class DynamicProxy implements InvocationHandler &#123; Object object; DynamicProxy(Object object) &#123; super(); this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (\"method1\".equals(method.getName())) &#123; System.out.println(\"before dynamicProxy!\"); method.invoke(object, args); System.out.println(\"before dynamicProxy!\"); &#125; else if (\"method\".equals(method.getName())) &#123; System.out.println(\"before dynamicProxy1!\"); method.invoke(object, args); System.out.println(\"before dynamicProxy1!\"); &#125; return null; &#125;&#125; 最后编写测试类 Proxy.newProxyInstance方法传入 被代理对象的classloader，接口和被代理对象本身。它会在代码运行时 自动创建代理对象（免去了自己写代理类的问题），然后通过返回的代理对象调用代理方法。 12345678910public static void main(String[] args) &#123; Sourceable source = new Source(); DynamicProxy dynamicProxy = new DynamicProxy(source); Sourceable sourceable = (Sourceable) Proxy.newProxyInstance(Source.class.getClassLoader(), Source.class.getInterfaces(), dynamicProxy); sourceable.method(); System.out.println(\"=========\"); sourceable.method1();&#125; 动态代理 相比较 静态代理 相同点在于都是面向接口编程，都不破坏原有代码而增强功能，不同点在于 动态代理不需要自己写代理类，也就免去了很多因为自己写代理类而带来的问题。 在spring大名鼎鼎的aop特性中(参见这里:Spring的AOP的XML开发)，Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，默认的策略是如果目标类是接口，则使用JDKProxy，JDKProxy便是我们所说的动态代理，否则使用Cglib来生成代理。所以说代理模式不是空中楼阁，对于减少代码重复量，减少代码冗余有很多实际的用处。","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://zjinc36.github.io/tags/设计模式/"}]},{"title":"Spring的AOP的XML开发","date":"2019-07-15T10:38:51.000Z","path":"2019/07/15/Spring的AOP的XML开发/","text":"AOP概述AOP，Aspect Oriented Programming，面向切面编程，是指在运行时，动态地将代码切入到类的指定方法、指定位置上的一种编程技术。AOP 是 OOP 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容。利用 AOP 可以对业务逻辑与横切关注点（cross-cutting concerns，例如日志记录，事务处理）进行隔离，从而使得业务逻辑与横切关注点的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP 目的是为了解耦，它可以使一组类共享相同的行为。面向对象编程（OOP）目的也是为了提高代码的可重用性，那么 AOP 和 OOP 有什么不同之处呢？对于 OOP 来说，只能通过继承类和实现接口这种方式来实现，但这会使代码的耦合程度增强，不利于代码的维护。AOP 正是为了弥补了 OOP 的不足而出现。 Spring 框架提供了 AOP 的丰富支持，允许开发人员通过分离应用程序的业务逻辑与横切关注点从而进行内聚性的开发。举例来说，日志记录，性能统计，安全控制，事务处理，异常处理，这些称之为横切关注点的功能，对于应用程序来说是必须的。AOP 允许将这些横切关注点从业务逻辑代码中划分出来，从而改变这些横切关注点的代码不影响业务逻辑的代码。 Spring底层的AOP实现原理动态代理 JDK动态代理:只能对实现了接口的类产生代理 Cglib动态代理:类似于Javassist第三方代理技术,对没有实现接口的类产生代理对象,生成子类对象JDK动态代理参见:设计模式之代理模式 UserDao 123456package com.zjinc36.spring.aop;public interface UserDao &#123; public void save(); public void update();&#125; 继承UserImpl 123456789101112131415package com.zjinc36.spring.aop;public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(\"save\"); &#125; @Override public void update() &#123; System.out.println(\"update\"); &#125;&#125; 动态代理,面向UserDao接口 12345678910111213141516171819202122232425262728293031323334353637package com.zjinc36.spring.aop;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 使用JDK动态代理对UserDao产生代理 * @author zjc */public class JdkProxy implements InvocationHandler &#123; // 将被增强的对象传递到代理中 private UserDao userDao; public JdkProxy(UserDao userDao) &#123; this.userDao = userDao; &#125; public UserDao createProxy() &#123; UserDao userDaoProxy = (UserDao) Proxy.newProxyInstance( userDao.getClass().getClassLoader(), userDao.getClass().getInterfaces(), this); return userDaoProxy; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 判断方法名是不是save if (\"save\".equals(method.getName())) &#123; System.out.println(\"save power up\"); return method.invoke(userDao, args); &#125; return method.invoke(userDao, args); &#125;&#125; 测试 123456789101112131415161718package com.zjinc36.spring.test;import org.junit.Test;import com.zjinc36.spring.aop.JdkProxy;import com.zjinc36.spring.aop.UserDao;import com.zjinc36.spring.aop.UserDaoImpl;public class TestAOP &#123; @Test public void demo1() &#123; UserDao userDao = new UserDaoImpl(); //创建代理 UserDao proxy = new JdkProxy(userDao).createProxy(); proxy.save(); proxy.update(); &#125;&#125; Cglib动态代理第三方开源代码生成类库,动态添加类的属性和方法 Spring已经核心包已经引入Cglib包了 创建CustomerDao对象 12345678910package com.zjinc36.spring.aop;public class CustomerDao &#123; public void save() &#123; System.out.println(\"save\"); &#125; public void update() &#123; System.out.println(\"update\"); &#125;&#125; 动态代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.zjinc36.spring.aop;import java.lang.reflect.Method;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;/** * Cglib动态代理 * @author zjc * */public class CglibProxy implements MethodInterceptor &#123; private CustomerDao customerDao; public CglibProxy(CustomerDao customerDao) &#123; this.customerDao = customerDao; &#125; /** * 使用Cglib产生代理的方法 */ public CustomerDao createProxy() &#123; // 1.创建cglib核心类对象 Enhancer enhancer = new Enhancer(); // 2.设置父类 enhancer.setSuperclass(customerDao.getClass()); // 3.设置回调(类似于InvocationHandler对象) enhancer.setCallback(this); // 4.创建代理对象 CustomerDao proxy = (CustomerDao) enhancer.create(); return proxy; &#125; @Override public Object intercept(Object proxy, Method method, Object[] arg, MethodProxy methodProxy) throws Throwable &#123; if (\"save\".equals(method.getName())) &#123; System.out.println(\"save power up\"); return methodProxy.invokeSuper(proxy, arg); &#125; return methodProxy.invokeSuper(proxy, arg); &#125;&#125; 测试 12345678@Testpublic void demo2() &#123; CustomerDao customerDao = new CustomerDao(); //创建代理 CustomerDao proxy = new CglibProxy(customerDao).createProxy(); proxy.save(); proxy.update();&#125; AspectJAspectJ简介 Spring的AOP有自己的实现方式(非常繁琐),AspectJ是一个AOP框架,Spring引入AspectJ作为自身AOP的开发 Spring两套AOP开发方式 Spring传统方式(已弃用) Spring基于AspectJ的AOP的开发(使用) AOP的相关术语 相关术语 通俗理解 作用 Joinpoint(连接点) 可以被拦截到的点 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点. Pointcut(切入点) 真正拦截到的点 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 Advice(通知/增强) 方法层面的增强 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Introduction(引介) 类层面的增强 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field. Target(目标对象) 被增强的对象 代理的目标对象 Weaving(织入) 将Advice应用到Target的过程 是指把增强应用到目标对象来创建新的代理对象的过程.spring采用动态代理织入，而AspectJ采用编译期织入和类装在期织入 Proxy（代理） 代理对象 一个类被AOP织入增强后，就产生一个结果代理类 Aspect(切面) 切面 是切入点和通知（引介）的结合 AspectJ的XML的方式开发","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的IOC注解开发","date":"2019-07-15T09:29:33.000Z","path":"2019/07/15/Spring的IOC注解开发/","text":"参考Spring IOC注解开发 入门案例引入jar包 引入配置文件 log4j.properties applicationContext.xml引入一个context的约束1234567&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 创建相关包和类 创建接口 12345678910package com.pc.service;/** * 用户服务类接口 */public interface UserService &#123; /** * 保存用户 */ public void save();&#125; 创建实现类 12345678910package com.pc.service.impl;/** * 用户服务实现类 */public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println(\"保存用户\"); &#125;&#125; 将类的控制权交给Spring容器在Spring中开启IOC的注解 1&lt;context:component-scan base-package=\"com.pc.service\"/&gt; 在类上添加注解 12345678910111213141516ackage com.pc.service.impl;import org.springframework.stereotype.Service;import com.pc.service.UserService;/** * 用户服务实现类 */@Service(\"userService\")public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println(\"保存用户\"); &#125;&#125; 编写测试1234567891011121314151617package com.pc.test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * SpringIOC注解测试 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringIOCAnnotationTest &#123; @Test public void test1() &#123; &#125;&#125; 依赖注入12345678910111213141516171819202122232425package com.pc.test;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.pc.service.UserService;/** * SpringIOC注解测试 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringIOCAnnotationTest &#123; @Resource(name = \"userService\") private UserService userService; @Test public void test1() &#123; userService.save(); &#125;&#125; 如果属性有set方法，注解需要加到set方法上，如果没有set方法直接在属性上添加注解 Spring的IOC注解的详解原来需要使用XML配置的方式将id和类绑定，现在不需要这样做了只需要在类上添加注解即可。 @Component ：组件 @Controller ：修饰web层类 @Service ：修饰业务层类 @Repository ：修饰持久层类 @Component是Spring提供的通用的组件注解，可以通过在类上使用该注解，将对应的类标记为Spring Bean，使用此功能需要在Spring配置文件中，开启组件扫描，&lt;context:component-scan base-package=&quot;包名&quot;/&gt; @Component和@Component(“name”)的区别在于，前者只能通过Spring的按类型注入依赖，后者还能使用按名注入依赖。 @Controller、@Service和@Repository这三个注解和@Component的功能在目前的4.x.x版本都是一样的，只是表明它是一个组件。 不过通过在不同层使用相对应的注解，可以使注解更具有意义。在以后的版本中，Spring可能提供对这三个注解不同的增强。 Bean依赖(属性)注入注解普通类型的属性如果属性有set方法，注解需要加到set方法上，如果没有set方法直接在属性上添加注解。 1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringIOCAnnotationTest &#123; // @Value(\"Switch\") private String name; @Value(\"Switch\") public void setName(String name) &#123; this.name = name; &#125; @Test public void test2() &#123; System.out.println(name); &#125;&#125; PS：如果同时在属性和set方法上添加了注解，那么set方法上的注解将会覆盖属性上的。 普通类型的属性 @Value ：注入普通类型属性 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringIOCAnnotationTest &#123; @Value(\"Switch\") private String name; @Test public void test2() &#123; System.out.println(name); &#125;&#125; 对象类型的属性 @Resource ：按名称注入对象 @Autowired ：按类型注入对象 @Qualifier:我们习惯是按照名称完成属性注入,必须让@Autowired注解和@Qualifier注解一起使用完成按名称属性注入1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringIOCAnnotationTest &#123; // 按bean类型注入 // @Resource // 按名注入，需要组件设置名称 // @Resource(name = \"userService\") // 和上面功能一样，按名注入 @Qualifier(\"userService\") @Autowired private UserService userService; @Test public void test1() &#123; userService.save(); &#125;&#125; Bean的生命周期注解 @PostConstruct ：相当于init-method @PreDestroy ：相当于destroy-method1234567891011121314151617@Service(\"userService\")public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println(\"保存用户\"); &#125; @PostConstruct public void init() &#123; System.out.println(\"用户初始化\"); &#125; @PreDestroy public void destory() &#123; System.out.println(\"注销用户\"); &#125;&#125; Bean的作用范围的注解Bean的范围的注解：默认是单例的@Scope ：在类上添加的，控制类生成的时候采用单例还是多例取值: singleton ：单例 prototype ：多例 request ：request域，需要在web环境 session ：session域，需要在web环境 application： context域，需要在web环境 globalsession 集群环境的session域，需要在web环境PS：可以到WebApplicationContext接口和ConfigurableBeanFactory类中找到@Scope的取值。 Spring的IOC的XML方式和注解方式比较适用场景 XML:可以适用任何场景,结构清晰,维护方便 注解:有些地方用不了,比如类不是自己提供的,但是开发方便 XML和注解整合开发XML管理Bean,注解完成属性注入 context:componet-scan和context:annotation-config的区别通过&lt;context:annotation-config&gt;的注释可以看出它的作用是激活@Required、@Autowired、@PostConstruct、@PreDestroy、@Resource等注解。 通过&lt;context:component-scan base-package=&quot;xx&quot;/&gt;的注释可以看出它除了激活了&lt;context:annotation-config&gt;中所有的注解，同时还激活了@Component、@Repository、@Service、@Controller、@RestController、@ControllerAdvice、@Configuration 这些注解","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的分模块开发的配置","date":"2019-07-14T16:35:30.000Z","path":"2019/07/15/Spring的分模块开发的配置/","text":"参考:Spring学习笔记—Spring的分模块开发的配置 在加载配置文件的时候,加载多个例如把applicationContext.xml配置文件中的关于集合配置的部分剪切到applicationContext2.xml中，在加载配置文件的时候，将两个配置文件全部加载。 12345678public class SpringDemo5 &#123; @Test public void demo1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\",\"applicationContext2.xml\"); CollectionBean collectionBean= (CollectionBean)applicationContext.getBean(\"collectionBean\"); System.out.println(collectionBean); &#125;&#125; 在一个配置文件中引入多个配置在applicationContext.xml中用import标签引入applicationContext2.xml： 1&lt;import resource=\"applicationContext2.xml\"/&gt; 因为两个配置文件在同一个根目录下，所以可以直接写名字。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的工厂类","date":"2019-07-14T16:32:47.000Z","path":"2019/07/15/Spring的工厂类/","text":"工厂类 新旧工厂类BeanFactory:老版本的工厂类BeanFactory:调用getBean的时候,才会生成类的实例 ApplicationContext:新版本的工厂类 ApplicationContext:加载配合字文件的时候,就会将Spring管理的类都实例化 ApplicationContext有实现两个类 ClassPathXmlApplicationContext:加载类路径下的配置文件 FileSystemXmlApplicationContext:加载文件系统下的配置文件 Bean标签的id和name的配置 id:使用了约束中的唯一约束,里面不能出现特殊字符的 name:没有使用约束中的唯一约束(理论上可以出现重复,但是实际开发不能出现的),里面可以出现特殊字符 Bean的声明周期的配置(了解) init-method:Bean被初始化的时候执行的方法 destroy-method:Bean被销毁的时候执行的方法(Bean是单例创建,工厂关闭) Bean的作用范围(重点) scope:Bean的作用范围 参数 作用 singleton 默认的,Spring会采用单例模式创建这个对象 prototype 多例模式 request 应用在web项目中,Spring创建这个类以后,将这个类存入到request范围中 session 应用在web项目中,Spring创建这个类以后,将这个类存入到session范围中 globalsession 应用在web项目中,必须在porlet环境下使用(在一个地方存入后,在子系统中就不用登录),如果没有这种环境,相当于session Spring的Bean的实例化方式(了解) 根源上的目的是解决我们如何获得其他类,而不会引入耦合 由于Bean已经都交给Spring管理,为了不引入耦合,Spring创建Bean的实例时,有如下几种方式 无参构造方式(默认)123456public class Bean1 &#123; public void Bean1() &#123; super(); system.out.println(\"Bean1的无参数的构造方法执行了...\"); &#125;&#125; 编写配置 1&lt;bean id=\"bean1\" class=\"com.zjinc36.spring.demo1.Bean1&gt;&lt;/bean&gt; 静态工厂实例化的方式参考:Spring 静态工厂方法及实例工厂方法配置bean静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取 调用静态工厂方法创建Bean是将对象创建的过程封装到静态方法中。当客户端需要对象时，只需要简单地调用静态方法，而不关心创建对象的细节。 要声明通过静态方法创建的Bean，需要在Bean的class属性里指定拥有该工厂的方法的类，同时在factory-method属性里指定工厂方法的名称。最后，使用&lt;constructor-arg&gt;元素为该方法传递方法参数。 下面代码给出一个例子，调用DateFormat中的getDateInstance静态方法来创建Bean。 123&lt;bean id=\"dataformat\" class=\"java.text.DateFormat\" factory-method=\"getDateInstance\"&gt; &lt;constructor-arg value=\"2\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 通过调用实例工厂方法创建Bean参考:Spring 静态工厂方法及实例工厂方法配置bean 实例工厂方法：将对象的创建过程封装到另外一个对象实例的方法里。当客户端需要请求对象时，只需要简单的调用该实例方法而不需要关心对象的创建细节。要声明通过实例工厂方法创建的Bean 在Bean的factory-bean属性里指定拥有该工厂方法的Bean 在factory-method属性指定该工厂方法的名称 使用constructor-arg元素为工厂方法传递方法参数 下面代码给出一个例子，首先声明拥有工厂方法的bean-simpledataformat，接着创建新的对象factory-bean指定为上面的simpledateformat，并设置factory-method为parse方法，并在constructor-arg中传递参数， 123456&lt;bean id=\"simpledataformat\" class=\"java.text.SimpleDateFormat\"&gt; &lt;constructor-arg value=\"yyyy-MM-dd hh-mm-ss\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"date\" factory-bean=\"simpledataformat\" factory-method=\"parse\"&gt; &lt;constructor-arg value=\"2018-05-28 20-47-00\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的属性注入","date":"2019-07-14T16:29:54.000Z","path":"2019/07/15/Spring的属性注入/","text":"Spring的属性注入参考:Spring中属性注入的几种方式以及复杂属性的注入 简单的属性注入构造方法的方式的属性注入构造方法注入和p名称空间注入这两种方式我们在开发中用的并不算多，但是我们还是有必要先来看看构造方法如何注入 1234567891011121314public class User4 &#123; private String username; public User4(String username) &#123; this.username = username; &#125; @Override public String toString() &#123; return \"User4&#123;\" + \"username='\" + username + '\\'' + '&#125;'; &#125;&#125; User4中有一个变量叫做username，我希望通过构造方法给它注入值，那我在User4中提供相应的构造方法即可，然后在Spring的配置文件中做如下配置即可： 123&lt;bean id=\"user4\" class=\"org.sang.User4\"&gt; &lt;constructor-arg name=\"username\" value=\"张三\"/&gt;&lt;/bean&gt; 如此我便成功给username赋上值了我们来看看测试方法 123456@Testpublic void test4() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User4 user = (User4) context.getBean(\"user4\"); System.out.println(user);&#125; Set方法的方式的属性注入set方法注入是我们用的比较多的一种注入方式，这种注入方式也很简单，假设我有一个User5，如下： 1234567891011121314public class User5 &#123; private String username; public void setUsername(String username) &#123; this.username = username; &#125; @Override public String toString() &#123; return \"User5&#123;\" + \"username='\" + username + '\\'' + '&#125;'; &#125;&#125; User5中也有username属性，但是我不想通过构造方法注入，想通过set方法注入，那么在User5中我们首先要提供set方法，然后在Spring配置文件中做如下配置即可：注入特定的值 123&lt;bean id=\"user5\" class=\"org.sang.User5\"&gt; &lt;property name=\"username\" value=\"lisi\"/&gt;&lt;/bean&gt; 另:若是注入指定类应如下 123456&lt;bean id=\"accountDao\" class=\"com.zjinc36.transaction.AccountDaoImpl\"&gt; &lt;!-- 向DAO中注入jdbc --&gt; &lt;!-- name指的是类中的属性 --&gt; &lt;!-- ref指的是需要注入的类 --&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt;&lt;/bean&gt; 测试代码如下 123456@Testpublic void test5() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); User5 user = (User5) context.getBean(\"user5\"); System.out.println(user);&#125; p名称空间注入(Spring2.5以后的版本)p名称空间注入也是一种注入方式，虽然用的不多，我们来看看p名称空间要怎么注入首先，我们需要在Spring配置的bean节点中添加p名称空间，如下： 1234&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 现在假设我有一个User6，如下： 12345678910public class User6 &#123; private String username; public void setUsername(String username) &#123; this.username = username; &#125; public void test() &#123; System.out.println(username); &#125;&#125; User6中有一个username属性，我为该属性提供了set方法，我们来看看如何在配置文件中通过p名称空间进行注入： 1&lt;bean id=\"user6\" class=\"org.sang.User6\" p:username=\"张三\"&gt; 直接在bean节点中通过p:username执行相应的值即可。这也是一种注入方式，不过这种方式我们在开发中用的并不多。 SpEL方式注入入门:参考:表达式SpEL方式的属性注入 稍微复杂一点,重点关注applicationContext.xml文件的配置,如下 写一个普通类 12345678910111213141516171819202122232425262728package com.zjinc36.spring.bean;public class Book &#123; private String bookName; private int bookPrice; public void setBookName(String bookName) &#123; this.bookName = bookName; &#125; public String getBookName() &#123; return bookName; &#125; public void setBookPrice(int bookPrice) &#123; this.bookPrice = bookPrice; &#125; public int getBookPrice() &#123; return bookPrice; &#125; @Override public String toString() &#123; return \"Book [bookName=\" + bookName + \", bookPrice=\" + bookPrice + \"]\"; &#125;&#125; 另一个类,有返回数据 1234567891011121314151617package com.zjinc36.spring.bean;public class BookInfo &#123; private String name; public Double calculatorPrice() &#123; return Math.random() * 100; &#125; public String getName() &#123; return \"简爱\"; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 修改applicationContext.xml 123456&lt;!--表达式 SpEL方式的属性注入 --&gt;&lt;bean id=\"bookInfo\" class=\"com.zjinc36.spring.bean.BookInfo\"&gt;&lt;/bean&gt;&lt;bean id=\"book\" class=\"com.zjinc36.spring.bean.Book\"&gt; &lt;property name=\"bookName\" value=\"#&#123; bookInfo.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"bookPrice\" value=\"#&#123; bookInfo.calculatorPrice() &#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 进行测试 123456@Testpublic void testSpEL() &#123; ClassPathXmlApplicationContext beanFactory = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Book book = (Book) beanFactory.getBean(\"book\", Book.class); System.out.println(book);&#125; 复杂的属性注入对象的注入这算是开发中最最常用的注入了 举一个常见的使用场景，我们在DAO层进行数据库的操作，在Service层进行业务逻辑操作，那我在Service中需要有一个DAO实例，如下，我有一个UserDao： 12345public class UserDao &#123; public void getData() &#123; System.out.println(\"获取到数据啦!\"); &#125;&#125; 我还有一个UserService: 12345678910111213141516public class UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125;// 这个和上面setUserDao是两中类型,这个使用的是构造方法方式// public UserService(UserDao userDao) &#123;// this.userDao = userDao;// &#125; public void getData() &#123; userDao.getData(); &#125;&#125; UserService 中有一个UserDao的实例，我为之提供了set方法，一会通过set方法进行注入，我们来看看Spring配置文件中要如何写 123456&lt;bean id=\"userDao\" class=\"org.sang.UserDao\"/&gt;&lt;bean id=\"userService\" class=\"org.sang.UserService\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt; &lt;!-- 这里是配合上面构造方法的方式进行注入的 --&gt; &lt;!--&lt;constructor-arg name=\"userDao\" ref=\"userDao\"/&gt;--&gt;&lt;/bean&gt; 我们要配置两个bean，第一个bean用来配置一个UserDao 的实例，第二个bean用来配置一个UserService实例，在获取UserService实例的时候顺便将第一个bean获取的userDao作为参数传入当然我们也可以通过构造方法进行对象的注入，方式就是我注释掉的代码，我这里不再赘述。同样,p名称空间注入和SpEL方式注入都可以配置复杂对象,主要在applicationContext.xml文件中修改,配置方式类似,就是要遵循各自对应的语法就行 数组注入&amp;List集合注入&amp;Map注入&amp;Properties注入这几个复杂属性的注入我放到一起来说，假设我有一个User7，如下： 1234567891011121314151617181920212223242526public class User7 &#123; private String[] names; private List&lt;String&gt; list; private Set&lt;String&gt; set; private Map&lt;String, String&gt; map; private Properties properties; public void setNames(String[] names) &#123; this.names = names; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setSet(Set&lt;String&gt; set) &#123; this.set = set; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; User7中已经囊括了这几种复杂属性，我们看一下在Spring的配置文件中如何给它们注入值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;bean id=\"user7\" class=\"org.sang.User7\"&gt; &lt;property name=\"names\"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;/list&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"username\" value=\"张三\"/&gt; &lt;entry key=\"password\" value=\"123456\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"username\" value=\"张三\"/&gt; &lt;entry key=\"password\" value=\"123456\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;赵六&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 数组和List集合的注入方式是一样的。map由于是以键值对的形式存储的，所以注入稍微有一点区别","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring的IOC和DI","date":"2019-07-13T12:52:17.000Z","path":"2019/07/13/Spring的IOC和DI/","text":"IOC控制反转将对象的创建权反转给了Spring Spring的IOC的底层实现实现解偶的思维方式 传统模式 面向接口编程 工厂模式 工厂+反射+配置文件 IOC依赖反转代码实现 文件导航 java代码 123456789101112131415161718192021222324252627//UserDaoImpl01package com.zjinc36.spring.demo1;public class UserDaoImpl01 implements UserDao&#123; @Override public void save() &#123; System.out.println(\"UserDaoImpl01执行了\"); &#125;&#125;//主要看这个package com.zjinc36.spring.demo1;import org.junit.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringDemo1 &#123; @Test public void demo1() &#123; //创建Spring的工厂 ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao user = (UserDao) ac.getBean(\"userDao\"); user.save(); &#125;&#125; applicationContext.xml文件 12345678910&lt;!-- applicationContext.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.zjinc36.spring.demo1.UserDaoImpl01\"&gt;&lt;/bean&gt;&lt;/beans&gt; DI(依赖注入)依赖注入,前提必须有IOC的环境,Spring管理这个类的时候将类的依赖属性注入(设置)进来 依赖/继承/聚合的区别 依赖 123456789class A &#123;&#125;class B &#123; public void test(A a) &#123; return a; &#125;&#125; 继承: is a (是一个) 1234567class A &#123;&#125;class B extends A &#123;&#125; 聚合: has a (有一个)有松散和紧密之分 Spring如何实现依赖注入 java代码 12345678910111213package com.zjinc36.spring.demo1;public class UserDaoImpl01 implements UserDao&#123; private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void save() &#123; System.out.println(\"UserDaoImpl01执行了\" + name); &#125;&#125; applicationContext.xml代码 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.zjinc36.spring.demo1.UserDaoImpl01\"&gt; &lt;property name=\"name\" value=\"zhangsan\" /&gt; &lt;/bean&gt;&lt;/beans&gt;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Spring如何下载包","date":"2019-07-13T11:52:17.000Z","path":"2019/07/13/Spring如何下载包/","text":"参考:Spring如何下载源码和jar包 下载下载地址 目录说明","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"}]},{"title":"Struts2的标签库","date":"2019-07-13T11:16:56.000Z","path":"2019/07/13/Struts2的标签库/","text":"标签分类 自定义标签自定义标签 OGNL标签详解参考:OGNL标签详解 非用户界面标签库控制标签if...elseif...标签由于if…elseif…标签后都可以指定一个boolean表达式，所以if…elseif…标签可接受一个test属性，该属性确定执行判断的boolean表达式。具体用法如下： 123456&lt;s:if test=\"100 in &#123;100,200,300&#125;\"&gt; 包含&lt;/s:if&gt;&lt;s:else&gt; 不包含&lt;/s:else&gt; 迭代iterator标签iterator标签主要用于对集合（List、Set、数组和Map）进行迭代。使用iterator标签对集合进行迭代输出时，可以指定以下三个属性： 属性名 描述 是否可选 value 用于指定被迭代的集合；如果没有指定value属性，则使用ValueStack栈顶的集合 可选 id 用于指定集合里元素的ID 可选 status 用于指定迭代时的IteratorStatus实例，通过该实例即可判断当前迭代元素的属性，例如是否为最后一个，以及当前迭代元素的索引等 可选 12345678910111213&lt;!--List--&gt;&lt;s:set name=\"varList\" value=\"&#123;'www.jellythink.com', 'www.google.com', 'www.facebook.com'&#125;\"/&gt;&lt;s:iterator value=\"#varList\" id=\"website\" status=\"st\"&gt; 当前已经输出了&lt;s:property value=\"#st.getCount()\"/&gt;个&lt;br/&gt; &lt;s:property value=\"website\"/&gt;&lt;br/&gt;&lt;/s:iterator&gt;&lt;!--Map--&gt;&lt;s:set name=\"varMap\" value=\"#&#123;'谷歌':'www.jellythink.com', '脸书':'www.facebook.com'\" /&gt;&lt;s:iterator value=\"#varMap\" id=\"website\" status=\"st\"&gt; 第&lt;s:property value=\"#st.getCount()\"/&gt;组 &lt;s:property value=\"key\"/&gt;=&lt;s:property value=\"value\"/&gt;&lt;br/&gt;&lt;/s:iterator&gt; 为&lt;s:iterator.../&gt;标签指定status属性，即每次迭代时都会有一个IteratorStatus实例，该实例包含以下几个方法： int getCount()：返回当前迭代了几个元素 int getIndex()：返回当前迭代元素的索引 boolean isEven()：返回当前迭代元素的索引是否是偶数 boolean isOdd()：返回当前迭代元素的索引是否是奇数 boolean isFirst()：返回当前迭代元素是否是第一个元素 boolean isLast()：返回当前迭代元素是否是最后一个元素 合并集合对象append标签append标签用于将多个集合对象拼接起来，组成一个新的集合。通过这种拼接，从而允许通过一个&lt;s:iterator…/&gt;标签就可以完成对多个集合的迭代。使用append标签时需要指定一个var属性，该属性确定拼接生成的新集合的名字，该新集合被放入Stack Context中。 123456&lt;s:set name=\"varList\" value=\"&#123;'www.google.com', 'www.facebook.com'&#125;\"/&gt;&lt;s:set name=\"varList2\" value=\"&#123;'www.xiaomi.com', 'www.qq.com'&#125;\"/&gt;&lt;s:append var=\"newCollection\"&gt; &lt;s:param value=\"#varList\" /&gt; &lt;s:param value=\"#varList2\"/&gt;&lt;/s:append&gt; 合并集合对象merge标签merge标签和append标签看起来非常类似，也是用于将多个集合拼接成一个集合，但它采用的拼接方式与append的拼接方式有所不同，比如现在有三个集合，每个集合有三个元素，分别使用append和merge方式进行拼接，产生的新集合将有所区别。使用append方式拼接，则新集合的元素顺序为：第一个集合中的第一个元素第一个集合中的第二个元素第一个集合中的第三个元素第二个集合中的第一个元素第二个集合中的第二个元素第二个集合中的第三个元素第三个集合中的第一个元素第三个集合中的第二个元素第三个集合中的第三个元素使用merge方式拼接，则新集合的元素顺序为： 第一个集合中的第一个元素第二个集合中的第一个元素第三个集合中的第一个元素第一个集合中的第二个元素第二个集合中的第二个元素第三个集合中的第二个元素第一个集合中的第三个元素第二个集合中的第三个元素第三个集合中的第三个元素从上面可以看出来，采用append和merge方式合并集合时，新集合中集合元素完全相同，只是新集合中集合元素的顺序有所不同。 分割字符串generator标签generator标签可以将指定字符串按指定分隔符分隔成多个子串，临时生成的多个子串可以使用iterator标签来迭代输出。在该标签的标签体内，整个临时生成的集合将位于ValueStack的顶端，但一旦该标签结束，该集合将被移出ValueStack。使用generator标签时可以指定如下几个属性： 属性名 描述 是否可选 count 指定生成集合中元素的总数 可选 separator 指定用于解析字符串的分隔符 必填 val 指定被解析的字符串 必填 converter 该属性指定一个转换器，该转换器负责将集合中的每个字符串转换成对象，通过该转换器可以将一个字符串解析成对象的集合。该属性值必须是一个org.apache.Struts2.util.IteratorGenerator.Converter对象 可选 var 如果指定了该属性，则将生成的Iterator对象放入Stack Context中 可选 12345&lt;s:generator val=\"'www.google.com,www.baidu.com'\" separator=\",\"&gt; &lt;s:iterator id=\"website\"&gt; &lt;s:property value=\"website\" /&gt;&lt;br/&gt; &lt;/s:iterator&gt;&lt;/s:generator&gt; 取得集合子集subset标签用于取得集合的子集，具体使用请参见相关文档。 对集合进行排序sort标签sort标签用于对指定的集合元素进行排序，进行排序时，必须提供自定义的排序规则，即实现自己的Comparator，自定义的Comparator需要实现java.util.Comparator接口使用sort标签时可指定如下几个属性： 属性名 描述 是否可选 comparator 指定进行排序的Comparator 必填 source 指定被排序的集合；如果不指定该属性，则对ValueStack栈顶的集合进行排序 可选 var 如果指定了该属性，则将生成的Iterator对象设置成page范围的属性，不放入Stack Context中 可选 数据标签数据标签主要结合OGNL表达式进行数据访问，比如显示一个Action里的属性值，或者生成国际化输出等。数据标签主要包含如下几个： 在页面中调用action标签使用action标签可以允许在JSP页面中直接调用Action。在使用action标签时，可以指定如下几个属性：|属性名 |描述 |是否可选||—-|—-|—-||var |一旦定义了该属性，该Action将被放入ValueStack中 |可选||name |该属性指定该标签调用哪个Action| 必填||namespace |该属性指定标签调用的Action所在的namespace |可选||executeResult |该属性指定是否要将Action的处理结果页面包含到本页面，默认为false |可选||ignoreContextParams |指定该页面中的请求参数是否需要传入调用的Action，默认为false，即将本页面的请求参数传入被调用的Action| 可选| 创建一个JavaBean实例bean标签bean标签用于创建一个JavaBean实例。创建JavaBean实例时，可以在该标签体内使用param标签为该JavaBean实例传入属性。使用bean标签时可以指定以下属性： 属性名 描述 是否可选 name 指定要实例化的JavaBean的实现类 必填 var 如果指定了该属性，则该JavaBean实例会被放入Stack Context中，并放入requestScope中 可选 具体的代码示例请参见push标签中的代码。 时间date标签date标签用于格式化输出一个日期，除此之外，date标签还可以计算指定日期和当前时刻之间的时差。使用date标签时，可以指定以下几个属性： |属性名 描述 是否可选||—-|—-|—-||format |根据该属性指定的格式来格式化日期 |可选||nice |用于指定是否输出指定日期和当前时刻之间的时差，默认为false，即不输出时差| 可选||name |指定要格式化的日期值| 必填||var |格式化后的字符串将被放入Stack Context中| 可选| 用于调试debug标签debug标签主要用于调试，它在页面上生成一个超链接，通过该链接可以查看到ValueStack和Stack Context中所有的值信息 包含其他页面include标签include标签用于将一个JSP页面，或者一个Servlet包含到本页面中，使用时需要指定以下属性： 属性名 描述 是否可选 value 该属性指定需要被包含的JSP页面，或者Servlet 必填 例如下面这段代码包含regist.jsp: 1234&lt;s:include value=\"regist.jsp\"&gt; &lt;s:param name=\"name\" value=\"'jelly'\" /&gt; &lt;s:param name=\"password\" value=\"1234567\" /&gt;&lt;/s:include&gt; regist.jsp的代码如下： 12&lt;%=request.getParameter(\"name\") %&gt;&lt;%=request.getParameter(\"password\") %&gt; 为其它标签提供参数param标签param标签主要用于为其它标签提供参数，具体请参见下面的push标签的示例代码。 将某个值放到ValueStack的栈顶push标签push标签用于将某个值放到ValueStack的栈顶。就一个属性值： 属性名 描述 是否可选 value 该属性指定需要放到ValueStack栈顶的值 必填 1234&lt;s:bean name=\"com.jellythink.practise.LoginAction\" var=\"p\"&gt; &lt;s:param name=\"userName\" value=\"jelly\" /&gt; &lt;s:param name=\"password\" value=\"123456\" /&gt;&lt;/s:bean&gt; 1234&lt;s:push value=\"#p\"&gt; ValueStack栈顶对象的username属性：&lt;s:property value=\"name\" /&gt; ValueStack栈顶对象的password属性：&lt;s:property value=\"password\" /&gt;&lt;/s:push&gt; 只有在push标签内时，被push标签放入ValueStack中的对象才存在；一旦离开了push标签，则刚刚放入的对象将立刻被移出ValueStack。 将某个值放入指定范围内set标签set标签用于将某个值放入指定范围内 生成一个URL地址url标签url标签用于生成一个URL地址，可以通过url标签指定param子元素，从而向指定URL发送请求参数。 输出value属性指定的值property标签property标签输出value属性指定的值，如果没有指定value属性，则默认输出ValueStack栈顶的值。该标签有以下几个属性： 属性名 描述 是否可选 default 如果需要输出的属性值为null，则显示default属性指定的值 可选 escape 指定是否escape HTML代码，默认为true 可选 value 指定需要输出的属性值，如果没有指定该属性，则默认输出ValueStack栈顶的值 可选","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"}]},{"title":"Struts2的拦截器","date":"2019-07-13T00:48:00.000Z","path":"2019/07/13/Struts2的拦截器/","text":"拦截器概述什么是拦截器 Interceptor:拦截器,起到拦截Action的作用 Filter:过滤器,过滤从客户端向服务器发送的请求 Interceptor:拦截器,拦截客户端多Action的访问,更细粒度的拦截(拦截Action中的具体方法) Struts2框架核心的功能都是依赖拦截器实现 拦截器在Struts2中处于什么位置以下是Struts2的执行流程 代码中的执行流程 客户端向服务器发送一个Action的请求,执行核心过滤器doFilter()方法 在doFilter()方法中,调用executeAction()方法 在executeAction()方法内部调用dispatcher.serviceAction() 在dispatcher.serviceAction()中创建一个Action代理 最终执行的是Action代理中的execute() 在代理中执行的execute方法中调用ActionInvocation的invoke()方法 在invoke()方法内部递归执行一组拦截器(完成部分功能) 如果没有下一个拦截器,就会执行目标Action 根据Action的返回结果进行页面跳转 官方提供的运行流程参考:Struts2 架构与运行流程 Servlet Filters(橙色)：过滤链，所有的请求都要经过Filter处理。 Struts Core(浅蓝色)：Struts2的核心部分，Struts2已经做好的功能，开发中不需要动它们。 Interceptors(浅绿色)：Struts2的拦截器。Struts2提供了很多默认的拦截器，帮助开发者完成绝大部分工作。开发者也可以自定义拦截器，来实现具体的功能。 User Created(浅黄色)：这一部分需要由开发人员完成，包括struts.xml、Action、Template等。 FilterDispatcherFilterDispatcher是任何一个Struts2应用都需要配置的，一般出现在过滤器的最后；如果在FilterDispatcher前出现了如SiteMesh这种特殊的过滤器，还必须在SiteMess前应用Struts2的ActionContextCleanUp过滤器。FilterDispatcher将请求转发给ActionMapper。 ActionMapperActionMapper负责识别当前的请求是否需要Struts2做出处理。当ActionMapper告诉FilterDispatcher需要处理这个请求时，FilterDispatcher会停止过滤链之后的部分，所以通常FilterDispatcher应该出现在过滤链的最后。然后建立一个ActionProxy对象，这个对象作为Action于XWork之间的中间层，会代理Action的运行过程。 ActionProxyActionProxy对象被创建出来时，并不知道要运行哪个Action，它手里只有从FilterDispatcher中拿到的请求URL。这时，它去ConfigurationManager询问到底要运行哪个Action。 ConfigurationManager在服务器启动的时候，ConfigurationManager负责将struts.xml文件从配置文件映射到内存中，并缓存起来，以保证ActionProxy拿着来访问的URL向它询问要运行哪一个Action的时候，就可以直接匹配，查找并回答出来。ActionProxy知道了要运行的那个Action，相关的拦截器以及所有可能使用的Result信息，就可以着手建立ActionInvocation对象了，ActionInvocation对象描述了Action运行的整个过程。 ActionInvocationActionInvocation对象执行的时候会做很多事情： 首先按照拦截器的应用顺序依次执行各个拦截器的前置部分； 然后执行Action的execute()方法； 根据execute()返回的结果，在struts.xml中匹配选择下一个页面 ActionInvocation对象再按照拦截器的引用顺序倒序依次执行各个拦截器的后置部分。ActionInvocation对象执行完毕之后，实际上已经得到了响应对象，也就是HttpServletResponse对象，最终向用户显示响应的结果 使用拦截器参考:Struts2拦截器 自定义拦截器编写拦截器类123456789101112131415161718192021package com.zjinc36.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;/** * 自定义拦截器 * @author zjc * */public class InterceptorDemo1 extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(\"InterceptorDemo1执行了...\"); String obj = invocation.invoke(); System.out.println(\"InterceptorDemo1执行结束了...\"); return obj; &#125;&#125; 引入拦截器 方式一:定义拦截器进行配置 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"interceptor\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name=\"interceptorDemo1\" class=\"com.zjinc36.interceptor.InterceptorDemo1\" /&gt; &lt;interceptor name=\"interceptorDemo2\" class=\"com.zjinc36.interceptor.InterceptorDemo2\" /&gt; &lt;/interceptors&gt; &lt;action name=\"actionDemo1\" class=\"com.zjinc36.interceptor.ActionDemo\"&gt; &lt;result&gt;success.jsp&lt;/result&gt; &lt;!-- 引入拦截器 --&gt; &lt;!-- 一旦引入自定义拦截器,默认拦截器栈的拦截器就不执行了,所以必须手动引入默认栈拦截器 --&gt; &lt;interceptor-ref name=\"defaultStack\" /&gt; &lt;interceptor-ref name=\"interceptorDemo1\" /&gt; &lt;interceptor-ref name=\"interceptorDemo2\" /&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 方式二:定义一个拦截器栈 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"interceptor\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!-- 定义拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name=\"interceptorDemo1\" class=\"com.zjinc36.interceptor.InterceptorDemo1\" /&gt; &lt;interceptor name=\"interceptorDemo2\" class=\"com.zjinc36.interceptor.InterceptorDemo2\" /&gt; &lt;!-- 定义一个拦截器栈 --&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"defaultStack\" /&gt; &lt;interceptor-ref name=\"interceptorDemo1\" /&gt; &lt;interceptor-ref name=\"interceptorDemo2\" /&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name=\"actionDemo1\" class=\"com.zjinc36.interceptor.ActionDemo\"&gt; &lt;result&gt;success.jsp&lt;/result&gt; &lt;!-- 引入拦截器栈 --&gt; &lt;interceptor-ref name=\"myStack\" /&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt;","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"}]},{"title":"Struts2的值栈(ValueStack)","date":"2019-07-12T16:48:14.000Z","path":"2019/07/13/Struts2的值栈ValueStack/","text":"值栈什么是值栈 参考:什么是值栈 在 Servlet 中把数据放到域对象(域对象的主要作用:在一定范围内,存值和取值),再在页面中使用EL 表达式获取数据 Struts2 本身也提供了一种存储机制,称之为 值栈（ValueStack）,值栈类似于域对象,可以存值和取值,在 Action 中把数据放到值栈,再在页面中获取值栈数据 ValueStack其实类似一个数据中转站(Struts2的框架当中的数据就都保存到ValueStack中) Valuestack接口,实现类OgnlValueStack对象 ValueStack贯穿整个Action的声明周期(Action一旦创建了,框架就会创建一个ValueStack对象) 值栈的存储位置 参考:什么是值栈 每次访问 Action 时,都会创建 Action 对象 在每个 Action 对象中都会有一个值栈对象（且只有一个） 分析值栈的内部结构从结论说起值栈中有两个主要区域 root区域其实就是一个ArrayList,里面一般放置对象,获取root不需要加# context区域其实就是一个Map,里面放置web开发的常用的对象的数据引用,包含如下 request session application parameters attr 如何得到上述结论方法一:源码分析查看源码ognl的源代码没有在Struts2的源码包里面 值栈结构图 方法二:打印debug页面1.Action代码1234567891011121314151617181920package com.zjinc36.ognl;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.util.ValueStack;/** * ValueStack的内部结构 * @author zjc * */public class ValueStackDemo1 extends ActionSupport&#123; @Override public String execute() throws Exception &#123; //获得值栈 @SuppressWarnings(\"unused\") ValueStack valueStack = ActionContext.getContext().getValueStack(); return SUCCESS; &#125;&#125; 2.jsp页面(出口)12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 3.在浏览器打开 ActionContext什么是ActionContext 回顾:ServletContext ActionContext是一个类,表示的是Action的上下文环境，它封装了一个Action运行所需要的环境，比如session、parameters、locale等,OGNL的操作都是基于ActionContext而进行的 对于这个ActionContext来说，每一个请求对应一个Action，这也是为什么说每个 Action 对象中都会有一个值栈对象（且只有一个）,所以说你不用担心什么线程安全的问题了 对于ActionContext中的SESSION、APPLICATION、PARAMETERS和LOCALE就不用多说了，前面我们重点总结的还是VALUE_STACK就是为此值栈和ActionContext的关系 创建ActionContext对象:通过源码查看到,当请求过来的时候,执行过滤器中doFilter()方法,在这个方法中创建ActionContext 创建ValueStack对象:创建ActionContext过程中,创建ValueStack对象,将ValueStack对象传递给ActionContext对象 所以可以通过ActionContext获取值栈对象 ActionContext对象之所以能够访问Servlet的API(访问是域对象的数据),因为在其内部有值栈的引用 获取值栈 通过ActionContext获得值栈 -&gt; 操作的是root区域 通过request对象获得 -&gt; 操作的是context区域1234567891011121314151617181920212223242526package com.zjinc36.ognl;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.util.ValueStack;/** * 获取ValueStack * @author zjc * */public class ValueStackDemo2 extends ActionSupport&#123; @Override public String execute() throws Exception &#123; // 1.通过ActionContext获得 ValueStack valueStack1 = ActionContext.getContext().getValueStack(); // 2.通过request对象获得 // 以下两种写法相同 // ServletActionContext.STRUTS_VALUESTACK_KEY的值就是\"struts.valueStack\" // ValueStack valueStack2 = (ValueStack) ServletActionContext.getRequest().getAttribute(\"struts.valueStack\"); ValueStack valueStack3 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); return NONE; &#125;&#125; 注意:一个Action的实例,只会创建一个ValueStack的对象 操作值栈这里重点放在将不同类型的数据存入值栈时,值栈的root区域和context区域发生怎么样的变化,虽然也有OGNL如何从值栈取出数据,但不是值栈这边的重点 操作值栈中的root区域利用Action在值栈中的特性 Action 12345678910111213141516171819202122232425262728293031//Actionpackage com.zjinc36.ognl;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.util.ValueStack;/** * 获取ValueStack * @author zjc * */public class ValueStackDemo3 extends ActionSupport&#123; private User user; @Override public String execute() throws Exception &#123; user = new User(\"zhangsan\", \"222\"); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; jsp文件 12345678910111213141516&lt;!-- jsp文件 --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; username:&lt;s:property value=\"user.username\"&gt;&lt;/s:property&gt; password:&lt;s:property value=\"user.password\"&gt;&lt;/s:property&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 结果页面 使用值栈的push方法 Action 1234567891011121314151617package com.zjinc36.ognl;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.util.ValueStack;public class ValueStackDemo4 extends ActionSupport&#123; private User user; @Override public String execute() throws Exception &#123; ValueStack vs = ActionContext.getContext().getValueStack(); user = new User(\"zhangsan\", \"222\"); vs.push(user); return SUCCESS; &#125;&#125; jsp页面 12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt; username:&lt;s:property value=\"username\"&gt;&lt;/s:property&gt; password:&lt;s:property value=\"password\"&gt;&lt;/s:property&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 结果页面 使用值栈的set方法 Action 1234567891011121314151617package com.zjinc36.ognl;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.util.ValueStack;public class ValueStackDemo4 extends ActionSupport&#123; private User user; @Override public String execute() throws Exception &#123; ValueStack vs = ActionContext.getContext().getValueStack(); // 创建一个Map集合,将Map压入栈中 vs.set(\"name\", \"lisi\"); return SUCCESS; &#125;&#125; jsp页面 123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt; name:&lt;s:property value=\"name\"&gt;&lt;/s:property&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 结果页面 使用值栈的set方法(设置ArrayList) Action 12345678910111213141516171819202122package com.zjinc36.ognl;import java.util.ArrayList;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.util.ValueStack;public class ValueStackDemo4 extends ActionSupport&#123; private User user; @Override public String execute() throws Exception &#123; ValueStack vs = ActionContext.getContext().getValueStack(); ArrayList&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(\"aaa\", \"111\")); list.add(new User(\"bbb\", \"222\")); list.add(new User(\"aaa\", \"333\")); ActionContext.getContext().getValueStack().set(\"list\", list); return SUCCESS; &#125;&#125; jsp页面 1234567891011121314151617181920212223242526272829&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt; username:&lt;s:property value=\"list[0].username\"&gt;&lt;/s:property&gt; password:&lt;s:property value=\"list[0].password\"&gt;&lt;/s:property&gt; username:&lt;s:property value=\"list[1].username\"&gt;&lt;/s:property&gt; password:&lt;s:property value=\"list[1].password\"&gt;&lt;/s:property&gt; username:&lt;s:property value=\"list[2].username\"&gt;&lt;/s:property&gt; password:&lt;s:property value=\"list[2].password\"&gt;&lt;/s:property&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 操作值栈中的context区域 写入数据 1234567891011121314package com.zjinc36.ognl;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;public class ValueStackDemo4 extends ActionSupport&#123; @Override public String execute() throws Exception &#123; ServletActionContext.getRequest().setAttribute(\"name\", \"wangwu\"); ServletActionContext.getRequest().getSession().setAttribute(\"name\", \"liubei\"); ServletActionContext.getServletContext().setAttribute(\"name\", \"guanyu\"); return SUCCESS; &#125;&#125; 获取数据 12345678910111213141516171819202122232425262728&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt; request:&lt;s:property value=\"#request.name\"&gt;&lt;/s:property&gt; session:&lt;s:property value=\"#session.name\"&gt;&lt;/s:property&gt; application:&lt;s:property value=\"#application.name\"&gt;&lt;/s:property&gt; attr:&lt;s:property value=\"#attr.name\"&gt;&lt;/s:property&gt; parameters.id:&lt;s:property value=\"#parameters.id\"&gt;&lt;/s:property&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 结果页面 注意:如果request没有设置数据,而我们又有取request的数据,则能拿到的是session的数据,同理,其他也有类似规则(不需要特意记忆,在页面开debug找就行) OGNL表达式获取值栈数据参考:OGNL表达式获取值栈数据 EL表达式获取值栈数据参考:EL表达式获取值栈数据","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"},{"name":"OGNL","slug":"OGNL","permalink":"https://zjinc36.github.io/tags/OGNL/"}]},{"title":"对象图导航语言OGNL","date":"2019-07-11T11:27:22.000Z","path":"2019/07/11/对象图导航语言OGNL/","text":"什么是OGNL 参考(维基百科):对象导航图语言 对象导航图语言（Object Graph Navigation Language），简称OGNL，是应用于Java中的一个开源的表达式语言（Expression Language），它被集成在Struts2等框架中，作用是对数据进行访问，它拥有类型转换、访问对象方法、操作集合对象等功能 OGNL,对象导航图语言,比EL表达式强大很多倍的语言 EL:从域对象中获取数据,从EL的11个对象中获取(EL表达式) OGNL:调用对象的方法,获取Struts2的值栈的数据.OGNL其实是第三方的表达式语言 OGNL的Java环境入门(了解)访问对象的方法12345678910111213/** * OGNL调用对象方法 * @throws OgnlException */public void demo1() throws OgnlException &#123; // 获取context OgnlContext context = new OgnlContext(); // 获得根对象 Object root = context.getRoot(); // 执行表达式 Object obj = Ognl.getValue(\"'helloword'.length()\", context, root); System.out.println(obj);&#125; 访问静态的方法1234567891011121314/** * 访问静态的方法 * @throws OgnlException */public void demo2() throws OgnlException &#123; // 获取context OgnlContext context = new OgnlContext(); // 获得根对象 Object root = context.getRoot(); // 执行表达式 // 静态的固定写法:@类名@方法名 Object obj = Ognl.getValue(\"@java.lang.Math@random()\", context, root); System.out.println(obj);&#125; 访问Root中的数据一般会在root中存放java对象 设置一个java对象(User类) 12345678910111213141516171819202122232425262728293031323334353637package com.zjinc36.ognl;public class User &#123; private String username; private String password; public User() &#123; super(); &#125; public User(String username, String password) &#123; super(); this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User [username=\" + username + \", password=\" + password + \"]\"; &#125;&#125; 访问Root中的数据 1234567891011121314151617@Test/** * 访问Root中的数据 * @throws OgnlException */public void demo3() throws OgnlException &#123; // 获取context OgnlContext context = new OgnlContext(); // 设置根对象 context.setRoot(new User(\"aaa\", \"123\")); // 获得根对象 Object root = context.getRoot(); // 执行表达式 Object username = Ognl.getValue(\"username\", context, root); Object password = Ognl.getValue(\"password\", context, root); System.out.println(username + \"--\" + password);&#125; 获取OgnlContext中的数据1234567891011121314151617@Test/** * 获取context中的数据 * @throws OgnlException */public void demo4() throws OgnlException &#123; // 获取context OgnlContext context = new OgnlContext(); // 获得根对象 Object root = context.getRoot(); // 向context中存入数据 context.put(\"name\", \"zhangsan\"); // 执行表达式 // 访问context中的数据时,需要加# Object obj = Ognl.getValue(\"#name\", context, root); System.out.println(obj);&#125; OGNL在Struts2环境中的使用参考:Struts2学习之OGNL表达式 访问ValueStack查看:什么是值栈ValueStack由于ValueStack是Struts2中OGNL的根对象，如果用户需要访问值栈中的对象，在JSP页面可以直接通过下面的OGNL表达式访问ValueStack(值栈)中对象的属性： 1&lt;s:property value=\"userName\" /&gt; 在ValueStack中处于第一位的对象叫栈顶对象。通常我们在OGNL表达式里直接写上属性的名称即可访问ValueStack变量里对象的属性，搜索顺序是从栈顶对象开始寻找，如果栈顶对象不存在该属性，就会从第二个对象寻找，如果没有找到就从第三个对象寻找，依次往下访问，直到找到为止。 访问application对象访问ValueStack以外其它对象时，由于他们不是根对象，所以在访问时，需要添加#前缀。application对象用于访问ServletContext的属性，例如： 12&lt;s:property value=\"#application.userName\" /&gt;&lt;s:property value=\"#application['userName']\" /&gt; 上述代码同调用ServletContext的getAttribute(“userName”)方法的效果是一样的。 访问session对象session对象用于访问HttpSession的属性，例如： 12&lt;s:property value=\"#session.userName\" /&gt;&lt;s:property value=\"#session['userName']\" /&gt; 上述代码同调用HttpSession的getAttribute(“userName”)方法的效果是一样的。 访问request对象request对象用于访问HttpServletRequest的属性，例如： 12&lt;s:property value=\"#request.userName\" /&gt;&lt;s:property value=\"#request['userName']\" /&gt; 上述代码同调用HttpServletRequest的getAttribute(“userName”)方法的效果是一样的。 访问parameters对象parameters对象用于访问HTTP请求参数，例如： 12&lt;s:property value=\"#parameters.userName\" /&gt;&lt;s:property value=\"#parameters['userName']\" /&gt; 上述代码同调用HttpServletRequest的getParameter(“userName”)方法的效果是一样的。 访问attr对象attr对象依次搜索以下对象中的属性，找到便返回： PageContext HttpServletRequest HttpSession ServletContext 调用对象方法1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!-- 引入struts2的标签库,struts2就这一个标签 --&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;OGNL在Struts2环境中的入门&lt;/h1&gt; &lt;h3&gt;调用对象方法&lt;/h3&gt; &lt;!-- 直接调用字符串的方法 --&gt; &lt;s:property value=\"'struts'.length()\" /&gt;&lt;/body&gt;&lt;/html&gt; 调用对象的静态方法Struts2默认是不能访问静态方法的,需要开启一个常量 如何开启常量Struts2的常量要如何配置在映射文件中配置 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 配置Struts2的常量 --&gt; &lt;constant name=\"struts.action.extension\" value=\"action\" /&gt; &lt;constant name=\"struts.ognl.allowStaticMethodAccess\" value=\"true\" /&gt;&lt;/struts&gt; 调用 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!-- 引入struts2的标签库,struts2就这一个标签 --&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;OGNL在Struts2环境中的入门&lt;/h1&gt; &lt;h3&gt;调用对象的静态方法&lt;/h3&gt; &lt;!-- Struts2默认是不能访问静态方法的 --&gt; &lt;!-- 需要开启一个常量 --&gt; &lt;s:property value=\"@java.lang.Math@random()\" /&gt;&lt;/body&gt;&lt;/html&gt; OGNL中的特殊字符#号的用法两种用法 #可以用于获得域对象的值 可以用于定义一个map1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!-- 引入struts2的标签库,struts2就这一个标签 --&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;#号的用法&lt;/h1&gt; &lt;h3&gt;存值&lt;/h3&gt; &lt;% request.setAttribute(\"name\", \"123\"); %&gt; &lt;s:property value=\"#request.name\" /&gt; &lt;h3&gt;构建List集合&lt;/h3&gt; &lt;s:iterator var=\"i\" value=\"&#123;'aa', 'bb', 'cc'&#125;\"&gt; &lt;s:property value=\"i\"&gt;&lt;/s:property&gt; ---- &lt;s:property value=\"#i\"&gt;&lt;/s:property&gt; &lt;br&gt; &lt;/s:iterator&gt; &lt;h3&gt;构建Map集合&lt;/h3&gt; &lt;h4&gt;方式一&lt;/h4&gt; &lt;s:iterator value=\"#&#123; 'aa':'11', 'bb':'22'&#125;\"&gt; &lt;s:property value=\"key\"&gt;&lt;/s:property&gt; ---- &lt;s:property value=\"value\"&gt;&lt;/s:property&gt; &lt;br&gt; &lt;/s:iterator&gt; &lt;h4&gt;方式二&lt;/h4&gt; &lt;s:iterator var=\"entry\" value=\"#&#123; 'aa':'11', 'bb':'22'&#125;\"&gt; &lt;s:property value=\"#entry.key\"&gt;&lt;/s:property&gt; ---- &lt;s:property value=\"#entry.value\"&gt;&lt;/s:property&gt; &lt;br&gt; &lt;/s:iterator&gt; &lt;h1&gt;利用List或Map集合创建单选框&lt;/h1&gt; &lt;h3&gt;值相同&lt;/h3&gt; &lt;s:radio list=\"&#123;'男', '女'&#125;\" name=\"sex\" label=\"性别\"&gt;&lt;/s:radio&gt; &lt;h3&gt;值不同&lt;/h3&gt; &lt;s:radio list=\"#&#123;'1':'男', '2':'女'&#125;\" name=\"sex2\" label=\"性别\"&gt;&lt;/s:radio&gt; &lt;h1&gt;利用List或Map集合创建复选框&lt;/h1&gt; &lt;s:checkboxlist name=\"checkbox1\" list=\"&#123;'上网','看书','爬山','游泳','唱歌'&#125;\" value=\"&#123;'上网','看书'&#125;\" &gt;&lt;/s:checkboxlist&gt;&lt;/body&gt;&lt;/html&gt; %的用法两种用法(只能在OGNL标签中使用) 强制解析为OGNL表达式 强制不解析为OGNL表达式123456789101112131415161718192021222324&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!-- 引入struts2的标签库,struts2就这一个标签 --&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;%号的用法&lt;/h1&gt; &lt;h3&gt;存值&lt;/h3&gt; &lt;% request.setAttribute(\"name\", \"123\"); %&gt; &lt;h3&gt;强制解析成OGNL表达式&lt;/h3&gt; &lt;s:textfield name=\"name\" value=\"%&#123;#request.name&#125;\"&gt;&lt;/s:textfield&gt; &lt;h3&gt;强制不解系成OGNL表达式(每什么用)&lt;/h3&gt; &lt;s:textfield name=\"name\" value=\"%&#123;'#request.name'&#125;\"&gt;&lt;/s:textfield&gt;&lt;/body&gt;&lt;/html&gt; $ 符号的用法在配置文件中可以使用OGNL表达式(EL表达式也是使用$) 属性文件(国际化地方) xml文件123456&lt;action name=\"download1\" class=\"cn.itcast.demo2.DownloadAction\"&gt; &lt;result name=\"success\" type=\"stream\"&gt; &lt;param name=\"contentType\"&gt;$&#123;contentType&#125;&lt;/param&gt; &lt;param name=\"contentDisposition\"&gt;attachment;filename=$&#123;downFilename&#125;&lt;/param&gt; &lt;/result&gt;&lt;/action&gt;","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"},{"name":"OGNL","slug":"OGNL","permalink":"https://zjinc36.github.io/tags/OGNL/"}]},{"title":"Struts2的数据封装","date":"2019-07-10T20:36:51.000Z","path":"2019/07/11/Struts2的数据封装/","text":"Struts2提供了数据封装的功能,将提交的数据封装到一个类中 封装到对象中属性驱动:提供属性set方法的方式1.入口1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;属性驱动:提供属性set方法的方式&lt;/h3&gt; &lt;form action=\"$&#123; pageContext.request.contextPath &#125;/userAction.action\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"age\" /&gt;&lt;br/&gt; 生日:&lt;input type=\"text\" name=\"birthday\" /&gt;&lt;br/&gt; 工资:&lt;input type=\"text\" name=\"salary\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" name=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.用户类123456789101112131415161718192021222324252627282930313233343536373839404142package com.zjinc36.demo4;import java.sql.Date;public class User &#123; private String username; private String password; private Integer age; private Date birthday; private Double salary; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Double getSalary() &#123; return salary; &#125; public void setSalary(Double salary) &#123; this.salary = salary; &#125;&#125; 3.Action(同时将数据封装到用户类)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.zjinc36.demo4;import java.sql.Date;import com.opensymphony.xwork2.ActionSupport;/** * 数据封装方式一:提供属性的set方法的方式 * @author zjc * */public class UserAction extends ActionSupport&#123; private String username; private String password; private Integer age; private Date birthday; private Double salary; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; System.out.println(birthday); this.birthday = birthday; &#125; public void setSalary(Double salary) &#123; this.salary = salary; &#125; @Override public String execute() throws Exception &#123; System.out.println(username); System.out.println(password); System.out.println(age); System.out.println(birthday); System.out.println(salary); //封装数据 User user = new User(); user.setUsername(username); user.setPassword(password); user.setAge(age); user.setBirthday(birthday); user.setSalary(salary); return NONE; &#125;&#125; 3.Action映射1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo4\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"userAction\" class=\"com.zjinc36.demo4.UserAction\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 属性驱动:页面中提供表达式方式1.入口(重要)1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;属性驱动:提供属性set方法的方式&lt;/h3&gt; &lt;form action=\"$&#123; pageContext.request.contextPath &#125;/user2Action.action\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"user.username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"user.password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"user.age\" /&gt;&lt;br/&gt; 生日:&lt;input type=\"text\" name=\"user.birthday\" /&gt;&lt;br/&gt; 工资:&lt;input type=\"text\" name=\"user.salary\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" name=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.用户类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zjinc36.demo4;import java.sql.Date;public class User &#123; private String username; private String password; private Integer age; private Date birthday; private Double salary; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Double getSalary() &#123; return salary; &#125; public void setSalary(Double salary) &#123; this.salary = salary; &#125; @Override public String toString() &#123; return \"User [username=\" + username + \", password=\" + password + \", age=\" + age + \", birthday=\" + birthday + \", salary=\" + salary + \"]\"; &#125;&#125; 3.Action(同时将数据封装到用户类)1234567891011121314151617181920package com.zjinc36.demo4;import com.opensymphony.xwork2.ActionSupport;public class User2Action extends ActionSupport &#123; // 提供一个User对象 private User user; // 提供user的set和get方法,一定要提供get方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; 4.Action映射1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo4\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"user2Action\" class=\"com.zjinc36.demo4.User2Action\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 模型驱动:采用模型驱动方式1.入口1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;属性驱动:提供属性set方法的方式&lt;/h3&gt; &lt;form action=\"$&#123; pageContext.request.contextPath &#125;/user3Action.action\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"age\" /&gt;&lt;br/&gt; 生日:&lt;input type=\"text\" name=\"birthday\" /&gt;&lt;br/&gt; 工资:&lt;input type=\"text\" name=\"salary\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" name=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.用户类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zjinc36.demo4;import java.sql.Date;public class User &#123; private String username; private String password; private Integer age; private Date birthday; private Double salary; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Double getSalary() &#123; return salary; &#125; public void setSalary(Double salary) &#123; this.salary = salary; &#125; @Override public String toString() &#123; return \"User [username=\" + username + \", password=\" + password + \", age=\" + age + \", birthday=\" + birthday + \", salary=\" + salary + \"]\"; &#125;&#125; 3.Action(同时封装数据)注意:如果有非常多的set要写,可以实现ModelDriven接口具体可以看ModelDriven接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.zjinc36.demo4;import java.sql.Date;import com.opensymphony.xwork2.ActionSupport;/** * 数据封装方式一:提供属性的set方法的方式 * @author zjc * */public class UserAction extends ActionSupport&#123; private String username; private String password; private Integer age; private Date birthday; private Double salary; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; System.out.println(birthday); this.birthday = birthday; &#125; public void setSalary(Double salary) &#123; this.salary = salary; &#125; @Override public String execute() throws Exception &#123; System.out.println(username); System.out.println(password); System.out.println(age); System.out.println(birthday); System.out.println(salary); //封装数据 User user = new User(); user.setUsername(username); user.setPassword(password); user.setAge(age); user.setBirthday(birthday); user.setSalary(salary); return NONE; &#125;&#125; 4.Action的映射1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo4\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"userAction\" class=\"com.zjinc36.demo4.UserAction\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"user2Action\" class=\"com.zjinc36.demo4.User2Action\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"user3Action\" class=\"com.zjinc36.demo4.User3Action\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 模型驱动方式和属性驱动的辨析 模型驱动方式是最常用的方式,但缺点是只能同时向一个对象中封装数据 使用属性驱动(页面提供表达式方式)也是较常用的方式,可以向多个对象中封装数据,就是比较麻烦 INPUT逻辑视图配置出现的问题传入的参数类型和Action中定义的类型不一致时,会出现404错误 问题根源说明 默认栈下的拦截器会依次执行 任何一个栈出错都会向Struts2的错误信息存储区域发送数据 如果没有任何错误,会直接转到Action 如果有错误(本问题中是有params拦截器会发送错误),会交由workflow拦截器进行处理 workflow对应类的doIntercep方法中可以看到,当错误出现的时候,返回的是INPUT这个页面 当我们如下配置xml映射文件 12345&lt;package name=\"demo4\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"userAction\" class=\"com.zjinc36.demo4.UserAction\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 里面只配置了success而没有配置INPUT,就会找不到页面,也就返回404错误了 解决在映射文件中配置input 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo4\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;global-results&gt; &lt;result name=\"input\"&gt;input.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name=\"userAction\" class=\"com.zjinc36.demo4.UserAction\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 稍微扩展一下如果在input.jsp文件做如下配置,可以打印出错误信息 taglib指令的使用 JSLT的写法 -&gt; &lt;s:fielderror/&gt;1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"/struts-tags\" prefix=\"s\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;input&lt;/h1&gt; &lt;s:fielderror/&gt;&lt;/body&gt;&lt;/html&gt; 封装到容器中封装到List中1.入口123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;封装到List集合中:批量插入商品&lt;/h3&gt; &lt;form action=\"$&#123; pageContext.request.contextPath &#125;/productAction.action\" method=\"post\"&gt; 商品名称:&lt;input type=\"text\" name=\"products[0].name\"&gt;&lt;br/&gt; 商品价格:&lt;input type=\"text\" name=\"products[0].price\"&gt;&lt;br/&gt; 商品名称:&lt;input type=\"text\" name=\"products[1].name\"&gt;&lt;br/&gt; 商品价格:&lt;input type=\"text\" name=\"products[1].price\"&gt;&lt;br/&gt; 商品名称:&lt;input type=\"text\" name=\"products[2].name\"&gt;&lt;br/&gt; 商品价格:&lt;input type=\"text\" name=\"products[2].price\"&gt;&lt;br/&gt; &lt;input type=\"submit\" name=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.Action12345678910111213141516171819202122232425package com.zjinc36.demo5;import java.util.List;import com.opensymphony.xwork2.ActionSupport;public class ProductAction extends ActionSupport &#123; private List&lt;Product&gt; products; @Override public String execute() throws Exception &#123; System.out.println(1); for (Product product : products) &#123; System.out.println(product); &#125; return NONE; &#125; public void setProducts(List&lt;Product&gt; products) &#123; this.products = products; &#125; public List&lt;Product&gt; getProducts() &#123; return products; &#125;&#125; 3.Product类12345678910111213141516171819202122package com.zjinc36.demo5;public class Product &#123; private String name; private Double price; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return \"Product [name=\" + name + \", price=\" + price + \"]\"; &#125;&#125; 4.映射文件123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo5\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"productAction\" class=\"com.zjinc36.demo5.ProductAction\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;input.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 封装到Map中1.入口12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;封装到Map集合中&lt;/h3&gt; &lt;form action=\"$&#123; pageContext.request.contextPath &#125;/productAction2.action\" method=\"post\"&gt; 商品名称:&lt;input type=\"text\" name=\"map['one'].name\"&gt;&lt;br/&gt; 商品价格:&lt;input type=\"text\" name=\"map['one'].price\"&gt;&lt;br/&gt; 商品名称:&lt;input type=\"text\" name=\"map['two'].name\"&gt;&lt;br/&gt; 商品价格:&lt;input type=\"text\" name=\"map['two'].price\"&gt;&lt;br/&gt; &lt;input type=\"submit\" name=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.Action123456789101112131415161718192021222324252627282930package com.zjinc36.demo5;import java.util.Iterator;import java.util.Map;import java.util.Set;import com.opensymphony.xwork2.ActionSupport;public class ProductAction2 extends ActionSupport &#123; private Map&lt;String, Product&gt; map; public Map&lt;String, Product&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Product&gt; map) &#123; this.map = map; &#125; @Override public String execute() throws Exception &#123; Set&lt;String&gt; keys = map.keySet(); for (Iterator iterator = keys.iterator(); iterator.hasNext();) &#123; String key = (String) iterator.next(); Product value = map.get(key); System.out.println(key + \"----\" + value); &#125; return NONE; &#125;&#125; 3.Product类12345678910111213141516171819202122package com.zjinc36.demo5;public class Product &#123; private String name; private Double price; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return \"Product [name=\" + name + \", price=\" + price + \"]\"; &#125;&#125; 4.映射123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo5\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"productAction2\" class=\"com.zjinc36.demo5.ProductAction2\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;input.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt;","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"}]},{"title":"Struts2访问Servlet的API","date":"2019-07-10T16:27:56.000Z","path":"2019/07/11/Struts2访问Servlet的API/","text":"Servlet 和 Action 的区别 参考:https://blog.csdn.net/siwuxie095/article/details/77075528 Servlet：默认在第一次访问时创建，且只创建一次，是单实例对象 Action：访问时创建，且每次访问都会创建，创建多次，是多实例对象 Struts2访问Servlet的API的方式完全解耦合的方式1.入口123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Struts访问Servlet的API&lt;/h1&gt; &lt;h3&gt;方式一:完全解耦合的方式&lt;/h3&gt; &lt;form action=\"$&#123; pageContext.request.contextPath &#125;/requestDemo1.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"name\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.Action12345678910111213141516171819202122232425262728293031323334package com.zjinc36.demo3;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class requestDemo1 extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 接受参数 // 利用Struts2中的对象 ActionContext context = ActionContext.getContext(); // 调用ActionContext中的方法 // 类似于request.getParameterMap() Map&lt;String, Object&gt; map = context.getParameters(); Set&lt;String&gt; keySet = map.keySet(); for (Iterator iterator = keySet.iterator(); iterator.hasNext();) &#123; String key = (String) iterator.next(); String[] value = (String[]) map.get(key); System.out.println(key + \"----\" + Arrays.toString(value)); &#125; //向域对象中存入数据 context.put(\"reqName\", \"reqValue\"); //相当于request.setAttribute() context.getSession().put(\"sessName\", \"sessValue\"); //相当于session.setAttribute() context.getApplication().put(\"appName\", \"appValue\"); //相当于application.setAttribute() return SUCCESS; &#125;&#125; 3.映射1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo3\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;action name=\"requestDemo1\" class=\"com.zjinc36.demo3.requestDemo1\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 4.出口123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Struts访问Servlet的API&lt;/h1&gt; &lt;h3&gt;方式一:完全解耦合的方式&lt;/h3&gt; &lt;form action=\"$&#123; pageContext.request.contextPath &#125;/requestDemo1.action\" method=\"post\"&gt; 姓名:&lt;input type=\"text\" name=\"name\" /&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 需要注意注:这种方式只能获得代表request,session,application的数据的Map集合,不能操作这些对象本身的方法 使用servlet原生的api方式Action123456789101112131415161718192021222324252627282930313233package com.zjinc36.demo3;import java.util.Arrays;import java.util.Iterator;import java.util.Map;import java.util.Set;import javax.servlet.http.HttpServletRequest;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;public class requestDemo2 extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 1.接受数据 // 直接获得request对象,通过ServletActionContext HttpServletRequest request = ServletActionContext.getRequest(); Map&lt;String, String[]&gt; map = request.getParameterMap(); Set&lt;String&gt; keys = map.keySet(); for (Iterator iterator = keys.iterator(); iterator.hasNext();) &#123; String key = (String) iterator.next(); String[] value = map.get(key); System.out.println(key + \"----\" + Arrays.toString(value)); &#125; // 2.向域对象中保存数据 request.setAttribute(\"reqName\", \"reqValue\"); request.getSession().setAttribute(\"sessName\", \"sessValue\"); ServletActionContext.getServletContext().setAttribute(\"appName\", \"appValue\"); return SUCCESS; &#125;&#125; 需要注意这种方式既可以操作域对象的数据,也可以获得对象的方法 接口注入方式Action123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zjinc36.demo3;import java.util.Arrays;import java.util.Iterator;import java.util.Map;import java.util.Set;import javax.servlet.ServletContext;import javax.servlet.ServletContextAttributeListener;import javax.servlet.http.HttpServletRequest;import org.apache.struts2.interceptor.ServletRequestAware;import org.apache.struts2.util.ServletContextAware;import com.opensymphony.xwork2.ActionSupport;public class requestDemo3 extends ActionSupport implements ServletRequestAware, ServletContextAware&#123; private HttpServletRequest request; private ServletContext context; @Override public String execute() throws Exception &#123; // 1.接受参数 // 通过接口注入的方式获得request Map&lt;String, String[]&gt; map = request.getParameterMap(); Set&lt;String&gt; keys = map.keySet(); for (Iterator iterator = keys.iterator(); iterator.hasNext();) &#123; String key = (String) iterator.next(); String[] value = map.get(key); System.out.println(key + \"----\" + Arrays.toString(value)); &#125; //2.向域对象中保存数据 request.setAttribute(\"reqName\", \"reqValue\"); request.getSession().setAttribute(\"sessName\", \"sessValue\"); context.setAttribute(\"appName\", \"appValue\"); return super.execute(); &#125; @Override public void setServletContext(ServletContext context) &#123; this.context = context; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125;&#125; 注意Servlet是单例的,多个程序访问一个Servlet只会创建一个Servlet实例.而这里的Action是多例的,一次请求,创建一个Action的实例,不会出现线程安全的问题","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"}]},{"title":"Struts2入门和配置","date":"2019-07-09T19:03:50.000Z","path":"2019/07/10/Struts2入门和配置/","text":"Struts2是什么 参考:官网:https://struts.apache.org/ Apache Struts is a free, open-source, MVC framework for creating elegant, modern Java web applications. It favors convention over configuration, is extensible using a plugin architecture, and ships with plugins to support REST, AJAX and JSON.(翻译:apache Struts是一个免费的，开源的MVC框架，用于创建优雅，现代的Java Web应用程序。 它支持约定优于配置，可使用插件体系结构进行扩展，并附带插件以支持REST，AJAX和JSON) 参考:维基百科:Struts Struts是Apache软件基金会（ASF）赞助的一个开源项目。它最初是Jakarta项目中的一个子项目，并在2004年3月成为ASF的顶级项目。它通过采用Java Servlet／JSP技术，实现了基于Java EE Web应用的Model-View-Controller（MVC）设计模式的应用框架，是MVC经典设计模式中的一个经典产品 参考:维基百科:Struts2 Struts2缘起于Apache Struts的WebWork框架，旨在提供相对于Struts框架的增强和改进，同时保留与Struts框架类似的结构 参考:百度百科 Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互 常见的Web层框架 Struts2 Webwork SpringMVC Struts2的开发环境 下载 包说明 创建Web项目(引入jar包) 如何知道要引入什么jar包 引入如下jar包 Struts2的示例项目 项目文件导航 创建入口文件entrance.jsp在项目下的创建入口文件WebContent/demo/entrance.jsp 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Struts2的入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Struts2的入门&lt;/h1&gt; &lt;h3&gt;&lt;a href=\"$&#123; pageContext.request.contextPath &#125;/hello.action\"&gt;Struts2的入门&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 配置核心过滤器web.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;Struts2Demo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 创建Action文件HelloAction.java 12345678910111213141516171819package com.zjinc36.struts;/** * Struts2的入门的Action类 * @author zjc * */public class HelloAction &#123; /** * 提供一个方法 * 方法的写法是固定的 * 返回值是String类型 * 方法名是execute * 这个方法中不能传递参数 */ public String execute() &#123; System.out.println(\"HelloAction...执行了\"); return \"success\"; &#125;&#125; 创建Action的映射struts.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- Struts2为了管理Action的配置,通过包进行管理 --&gt; &lt;!-- 配置Struts2的包 --&gt; &lt;!-- name:包名,可以随便写,但是要唯一 --&gt; &lt;package name=\"demo\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!-- 配置Action --&gt; &lt;!-- name和访问的路径要一致 --&gt; &lt;!-- class是包名 --&gt; &lt;action name=\"hello\" class=\"com.zjinc36.struts.HelloAction\"&gt; &lt;!-- 配置页面的跳转 --&gt; &lt;result name=\"success\"&gt;/demo/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 创建出口文件success.jsp 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;跳转成功页面&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 执行流程 当用户访问某一个Action的时候,先经过核心过滤器 在核心过滤器中执行一组拦截器(这组拦截器实现部分功能),执行目标Action 根据Action的返回值,执行跳转 加载顺序 default.properties struts-default.xml struts-plugin.xml struts.xml struts.properties web.xml 注意:后配置的常量的值会覆盖先配置的常量的值 Structs的常见配置package的配置 package写在哪 对于上述项目,package标签写在struts.xml文件中. package是什么标签 package标签称为包,这个包与java中的包的概念不一致,包为了更好管理action. package标签的属性 name:包的名称,在一个项目中不可重复 extends:继承哪个包,通常值为struts-default abstract:抽象的,允许其他包继承 namespace:名称空间,与标签中的name属性共同决定访问路径名称空间有三种写法 带名称的空间 -&gt; /aaa /aaa/bbb 根名称空间 -&gt; namespace=”/“ 默认名称空间 -&gt; namespace=””区别在于访问顺序不同,先找带名称的空间,然后去根名称空间,然后才是默认名称空间 action映射的配置 action映射写在哪 对于上述项目,action映射标签写在struts.xml文件中. action映射是什么标签 action映射标签配置Action类 action映射标签的属性 name:与namespace共同决定访问路径 class:Action类的全路径 method:执行Action中的哪个方法的方法名,默认值execute,可以显式写成其他方法 converter:用于设置类型转换器 结果页面的配置 全局结果页面配置 global-results 在包中配置一次,其他的在这个包中的所有的action只要返回了这个值,都可以跳转到这个页面,即这对这个包下的所有的action的配置都有效 局部结果页面配置 参考:result标签的配置 resutl标签 针对当前的action有效 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"demo3\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;global-results&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name=\"requestDemo1\" class=\"com.zjinc36.demo3.requestDemo1\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"requestDemo2\" class=\"com.zjinc36.demo3.requestDemo2\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=\"requestDemo3\" class=\"com.zjinc36.demo3.requestDemo3\"&gt; &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; result标签的配置参考:结果页面的配置 result标签的属性 name:逻辑视图名称,默认值为success type:有很多值 dispatcher:默认值,请求转发 redirect:重定向(Action重定向jsp) chain:转发(Action转发Action) redirectAction:重定向(Action重定向Action) stream:文件下载的功能 type的属性去哪里找 Struts常量配置 去哪里找常见的常量在Struts2框架中,提供了非常多的常量,去Libraries下的/org/apache/struts2/default.properties找 struts.i18n.encoding=UTF-8:Struts2中所有post请求的中文乱码不用处理了 struts.action.extension=action,,:请求的默认扩展名,默认扩展名是.action或什么都不写 … 要修改常量怎么改修改常量的值,可以有三个位置进行修正 struts.xml -&gt; constant标签 12345678910111213141516171819202122&lt;!-- 注意constant标签 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!-- 配置structs2的常量 --&gt; &lt;constant name=\"struts.action.extension\" value=\"abc\" /&gt; &lt;!-- Struts2为了管理Action的配置,通过包进行管理 --&gt; &lt;!-- 配置Struts2的包 --&gt; &lt;!-- name:包名,可以随便写,但是要唯一 --&gt; &lt;package name=\"demo\" extends=\"struts-default\" namespace=\"/\"&gt; &lt;!-- 配置Action --&gt; &lt;!-- name和访问的路径要一致 --&gt; &lt;!-- class是包名 --&gt; &lt;action name=\"hello\" class=\"com.zjinc36.struts.HelloAction\"&gt; &lt;!-- 配置页面的跳转 --&gt; &lt;result name=\"success\"&gt;/demo/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; struts.properties -&gt; 用户自定义的 web.xml -&gt; init-param标签 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;Struts2Demo&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置Struts2的核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;!-- 修改常量 --&gt; &lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;xyz&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 分模块开发配置主要用于团队开发 文件位置 文件内容 struts_personal.xml,个人自定义配置 struts.xml团队配置 12345678&lt;!-- struts.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;include file=\"com/zjinc36/struts/struts_personal.xml\" /&gt;&lt;/struts&gt; Action的编写方式 Action编写方式一纯粹写个Action文件 1234567891011121314package com.zjinc36.struts;public class HelloAction &#123; /** * 提供一个方法 * 方法的写法是固定的 * 返回值是String类型 * 方法名是execute * 这个方法中不能传递参数 */ public String execute() &#123; System.out.println(\"HelloAction...执行了\"); return \"success\"; &#125;&#125; Action编写方式二实现Action接口 1234567891011121314151617181920212223package com.zjinc36.struts;import com.opensymphony.xwork2.Action;/** * Action编写方式二:实现Action接口 * 这种方式,提供了五个常量(五个逻辑视图名称) * + SUCCESS:成功 * + ERROR:失败 * + LOGIN:登录出错的信息页面 * + INPUT:表单校验的时候出错 * + NONE:不调转 * @author zjc * */public class Struts2Demo01Action implements Action&#123; @Override public String execute() throws Exception &#123; System.out.println(\"ok\"); return null; &#125;&#125; Action编写方式三(推荐)Action类继承ActionSupport类 123456789101112131415161718package com.zjinc36.struts;import com.opensymphony.xwork2.ActionSupport;/** * Action编写方式三:Action类继承ActionSupport类 * 推荐使用继承ActionSupport方式 * + ActionSupport中提供了数据校验,国际化等一系列操作的方法 * @author zjc * */public class Struts2Demo02Action extends ActionSupport&#123; @Override public String execute() throws Exception &#123; System.out.println(\"ok\"); return null; &#125;&#125; Action的访问 通过method设置123456&lt;body&gt; &lt;h3&gt;&lt;a href=\"$&#123; pageContext.request.contextPath &#125;/userFind.action\"&gt;查询用户&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href=\"$&#123; pageContext.request.contextPath &#125;/userUpdate.action\"&gt;修改用户&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href=\"$&#123; pageContext.request.contextPath &#125;/userDelete.action\"&gt;删除用户&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href=\"$&#123; pageContext.request.contextPath &#125;/userSave.action\"&gt;保存用户&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt; 123456&lt;package name=\"demo2\" extends=\"struts-default\" namespace=\"/demo2\"&gt; &lt;action name=\"userFind\" class=\"com.zjinc36.Demo2.UserAction\" method=\"find\"&gt;&lt;/action&gt; &lt;action name=\"userUpdate\" class=\"com.zjinc36.Demo2.UserAction\" method=\"update\"&gt;&lt;/action&gt; &lt;action name=\"userDelete\" class=\"com.zjinc36.Demo2.UserAction\" method=\"delete\"&gt;&lt;/action&gt; &lt;action name=\"userSave\" class=\"com.zjinc36.Demo2.UserAction\" method=\"save\"&gt;&lt;/action&gt;&lt;/package&gt; 12345678910package com.zjinc36.Demo2;public class UserAction&#123; public String find() &#123; System.out.println(\"find\"); return null; &#125; //code...&#125; 通过通配符的方式进行配置其他和上述method一致,就xml文件要使用通配符1&lt;action name=\"user*\" class=\"com.zjinc36.Demo2.UserAction\" method=\"&#123;1&#125;\"&gt;&lt;/action&gt; 更加抽象 12&lt;!-- 和前文无关 --&gt;&lt;action name=\"**\" class=\"xxx.&#123;1&#125;\" method=\"&#123;2&#125;\"&gt;&lt;/action&gt; 动态方法访问配置123&lt;body&gt; &lt;h3&gt;&lt;a href=\"$&#123; pageContext.request.contextPath &#125;/user!find.action\"&gt;查询用户&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt; 123456&lt;!-- 开启动态访问 --&gt;&lt;!-- 默认是没有开启动态访问的 --&gt;&lt;constant name=\"struts.enable.DynamicMehtodInvocation\" value=\"true\"&gt;&lt;/constant&gt;&lt;package name=\"demo2\" extends=\"struts-default\" namespace=\"/demo2\"&gt; &lt;action name=\"userFind\" class=\"com.zjinc36.Demo2.UserAction\"&gt;&lt;/action&gt;&lt;/package&gt;","tags":[{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"}]},{"title":"问题:Xxx Is a Raw Type. References to Generic Type Xxx<y> Should Be Parameterized","date":"2019-07-09T10:55:11.000Z","path":"2019/07/09/xxx-is-a-raw-type-References-to-generic-type-xxx-y-should-be-parameterized/","text":"Eclipse出现如下报错 Query is a raw type. References to generic type Query should be parameterized或者 List is a raw type. References to generic type List should be parameterized 解决需要知道 这不是error而是warning 该问题和泛型有关(要理解泛型,可以查看https://docs.oracle.com/javase/tutorial/java/generics/index.html) 三种解决方式知道泛型包含的是什么类型1List&lt;YourType&gt; synchronizedpubliesdList = Collections.synchronizedList(publiesdList); 如果有多种对象则使用?通配符1List&lt;?&gt; synchronizedpubliesdList = Collections.synchronizedList(publiesdList); 只是想摆脱警告12@SuppressWarnings(\"rawtypes\")List synchronizedpubliesdList = Collections.synchronizedList(publiesdList);","tags":[{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"}]},{"title":"Hibernate的查询方式","date":"2019-07-09T01:44:54.000Z","path":"2019/07/09/Hibernate的查询方式/","text":"OID查询Hibernate根据对象的OID(主键)进行检索 使用get方法1Customer customer = session.get(Customer.class, 1L); 使用load方法1Customer customer = session.load(Customer.class, 6L); 对象导航检索Hibernate根据一个已经查询到的对象,获得其关联的对象的一种查询方式 12LinkMan linkMan = session.get(LinkMan.class, 2L);Custoner customer = LinkMan.getCustomer(); HQL检索Hibernate Query Language,Hibernate查询语言,这种语言和SQL极其类似,面向对象的查询语句不支持select *这种写法 简单查询12345678910111213141516171819@Test/** * 简单的查询 */public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要了 Query query = session.createQuery(\"from Customer\"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; 别名查询1234567891011121314151617181920 @Test /** * 别名查询 */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要// Query query = session.createQuery(\"from Customer c\"); Query query = session.createQuery(\"select c from Customer c\"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit(); &#125; 排序查询1234567891011121314151617181920 @Test /** * 排序查询 */ public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 // 升序查询// Query query = session.createQuery(\"from Customer order by cust_id\"); // 降序查询 Query query = session.createQuery(\"from Customer order by cust_id desc\"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit(); &#125; 条件查询按位置绑定12345678910111213141516171819@Test/** * 条件查询 * 按位置绑定 */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 Query query = session.createQuery(\"from Customer where cust_name like ?0\"); query.setParameter(0, \"sun%\"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; 按名称绑定12345678910111213141516171819@Test/** * 条件查询 * 按名称绑定 */public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 Query query = session.createQuery(\"from Customer where cust_name like :name\"); query.setParameter(\"name\", \"sun%\"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; 投影查询查询单个属性12345678910111213141516171819@Test/** * 投影查询 * 查询单个属性 */public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 // 查询单个属性 Query query = session.createQuery(\"select c.cust_name from Customer c\"); List&lt;Object&gt; list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; tx.commit();&#125; 查询多个属性返回的是数组12345678910111213141516171819202122@Test/** * 投影查询 * 查询多个属性 */public void demo8() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 // 查询多个属性 Query query = session.createQuery(\"select c.cust_id,c.cust_name from Customer c\"); // 注意这里和单个属性的区别 // 返回的是数组 List&lt;Object[]&gt; list = query.list(); for (Object[] object : list) &#123; System.out.println(Arrays.toString(object)); &#125; tx.commit();&#125; 返回的是对象 修改要查询的类 12345678910111213141516171819202122232425public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; //通过ORM方式表示:一个客户对应多个联系人 //放置的是多的一方的集合,Hibernate默认使用的是Set集合 private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;LinkMan&gt;(); public Customer() &#123; super(); &#125; public Customer(Long cust_id, String cust_name) &#123; super(); this.cust_id = cust_id; this.cust_name = cust_name; &#125; //code...&#125; 进行查询 123456789101112131415161718192021@Test/** * 投影查询 * 查询多个属性,但是我想封装到对象中 */public void demo9() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 // 查询多个属性 Query query = session.createQuery(\"select new Customer(cust_id, cust_name) from Customer\"); // 返回的是数组 List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; 分页查询12345678910111213141516171819202122@Test/** * 分页查询 */public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 通过session获得Query接口 // 注意这里的Customer指的是类 // 查询语句 String hql = \"from Customer\"; Query query = session.createQuery(hql); // 设置分页 query.setFirstResult(0); query.setMaxResults(3); List&lt;Customer&gt; list = query.getResultList(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; 聚合查询1234567891011121314151617@Test/** * 聚合查询 */public void demo10() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 // count(), max(), min(), avg(), sum() Query query = session.createQuery(\"select count(*) from Customer\"); Object count = query.uniqueResult(); System.out.println(count); tx.commit();&#125; 分组查询12345678910111213141516171819@Test/** * 分组统计查询 */public void demo11() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // from Customer -&gt; Customer是类名字 // 理论上要写全称createQuery(\"from com.zjinc36.hibernate.Customer\") // 但是我们配置了映射,就不需要 // 分组统计 Query query = session.createQuery(\"select cust_source, count(*) from Customer group by cust_source\"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit();&#125; HQL的多表查询参考:SQL多表查询 连接查询交叉链接(笛卡尔积)内连接显式内连接/隐式内连接12345678910111213141516171819@Test/** * HQL的多表查询 * HQL:普通内连接 */public void demo12() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); //普通内连接 //SQL : select * from cst_customer c inner join cst_linkman l on c.cust_id = l.lkm_cust_id //HQL内连接 List&lt;Object[]&gt; list = session.createQuery(\"from Customer c inner join c.linkMans\").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit();&#125; 迫切内连接12345678910111213141516171819@Test/** * HQL的多表查询 * HOL:迫切内连接 */public void demo13() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); //普通内连接 //SQL : select * from cst_customer c inner join cst_linkman l on c.cust_id = l.lkm_cust_id //HQL内连接 //与普通内连接相比,增加了一个关键字fetch List&lt;Customer&gt; list = session.createQuery(\"select distinct c from Customer c inner join fetch c.linkMans\").list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; 普通内连接和迫切内连接的区别普通内连接 -&gt; 返回的是数组 迫切内连接 -&gt; 返回的是对象 外连接 左外连接 右外连接 迫切左外连接 QBC检索简单查询12345678910111213141516171819202122232425262728293031323334 @Test /** * Criteria */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 写具体逻辑crud(增删改查)操作 // 1创建Criteria对象 createCriteria()在hibernate5.2之后过时了// Criteria criteria = session.createCriteria(Customer.class);// List&lt;Customer&gt; list = criteria.list();// for (Student customer : list) &#123;// System.out.println(customer);// &#125; // 新的查询方式 // 1.创建CriteriaBuilder对象 // 注意导入的包是import javax.persistence.criteria.CriteriaQuery; CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); // 2.获取CriteriaQuery对象 CriteriaQuery&lt;Customer&gt; createQuery = criteriaBuilder.createQuery(Customer.class); // 3.指定根条件 createQuery.from(Customer.class); // 4执行查询 List&lt;Customer&gt; List = session.createQuery(createQuery).getResultList(); for (Customer customer : List) &#123; System.err.println(customer); &#125; tx.commit(); &#125; 模糊查询12345678910111213141516171819202122232425262728293031323334353637383940 /** * 模糊查询 */ @Test public void demo4() &#123; //获取session对象 Session session = HibernateUtils.getCurrentSession(); //开启事务 Transaction tx = session.beginTransaction(); //写具体逻辑crud(增删改查)操作// //创建Criteria对象 createCriteria()在hibernate5.2之后过时了// Criteria criteria = session.createCriteria(Customer.class);// criteria.add(Restrictions.like(\"cust_name\", \"zhang%\"));// List&lt;Customer&gt; list = criteria.list();// for (Student customer : list) &#123;// System.out.println(customer);// &#125; //新的查询方式 //1.创建CriteriaBuilder对象 //注意导入的包是import javax.persistence.criteria.CriteriaQuery; CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); //2.获取CriteriaQuery对象 CriteriaQuery&lt;Customer&gt; createQuery = criteriaBuilder.createQuery(Customer.class); //3.指定根条件 Root&lt;Customer&gt; root = createQuery.from(Customer.class); //root.get(\"name\") \"name\"是实体类的属性名称 createQuery.where(criteriaBuilder.like(root.get(\"cust_name\"), \"%zhang%\")); //4.执行查询 List&lt;Customer&gt; List = session.createQuery(createQuery).getResultList(); for (Customer customer : List) &#123; System.err.println(customer); &#125; //提交事务 tx.commit(); &#125; 离线条件查询什么是离线条件查询参考:https://zhidao.baidu.com/question/542663097.html离线查询其实就是动态查询DetachedCriteria 为什么需要离线条件查询参考:https://zhidao.baidu.com/question/542663097.html 场景:一般我们进行web开发都会碰到多条件查询.例如根据条件搜索.条件的多少 逻辑关系 是or 还是and等等 我们要根据这些条件来拼写查询语句,这样就需要频繁改动查询语句 有了离线查询可以解决这个痛点,我们可以使用DetachedCriteria来构造查询条件,然后将这个DetachedCriteria作为方法调用参数传递给Service层对象.而业务层对象获得DetachedCriteria之后,可以在session范围内直接构造Criteria,进行查询.就此,查询语句的构造完全被搬离到web层实现,而service层则只负责完成持久化和查询的封装即可. 换句话说,service层代码是不变化的.我们不必为了查询条件的变化而去频繁改动查询语句了 代码怎么写参考:https://elf8848.iteye.com/blog/342688 12345678910111213141516171819202122232425262728@Test/** * web层 */public void webDemo() &#123; DetachedCriteria dc = DetachedCriteria.forClass(Customer.class); // String name = request.getParameter(\"name\"); String cust_name = \"liu%\"; // 拼查询条件 if (cust_name != null) &#123; dc.add(Restrictions.like(\"cust_name\", cust_name)); &#125; List customers = query(dc); for (Object object : customers) &#123; System.out.println(object); &#125;&#125;/** * service层 */public static List query(DetachedCriteria detachedCriteria) &#123; Session session = HibernateUtils.getCurrentSession(); Transaction transaction = session.beginTransaction(); Criteria criteria = detachedCriteria.getExecutableCriteria(session); List&lt;Customer&gt; list = criteria.list(); return list;&#125; 有可能遇到failed to lazily initialize a collection of role问题参考http://www.itzhai.com/hibernate-load-data-failed-failed-to-lazily-initialize-a-collection-of-role.html里面有一段话如下 该映射并没有设置lazy,所以这里是使用了默认的lazy=”true”,所以导致在页面获取时,因为session已经关闭,所以获取不到questionAnswer的数据. 所以为了解决这个问题,可以在set的lazy设置为false： 为set设置lazy=”false” 问题本质其实问题的本质就是代码中session已经被关闭了,但是代码中还有使用到,就是要确保使用session时候,session没有被关闭就行 SQL检索简单的查询1234567891011@Testpublic void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); NativeQuery sqlQuery = session.createSQLQuery(\"select * from cst_customer\"); List&lt;Object[]&gt; list = sqlQuery.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125;&#125; 查询结果指定列参考:SQL查询 addScalar()或addEntity() 12345678910111213@Testpublic void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); NativeQuery sqlQuery = session.createSQLQuery(\"select * from cst_customer\"); sqlQuery.addScalar(\"cust_id\", StandardBasicTypes.BIG_INTEGER); sqlQuery.addScalar(\"cust_name\", StandardBasicTypes.STRING); List&lt;Object[]&gt; list = sqlQuery.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125;&#125; 查询结果封装到对象参考:SQL查询 addScalar()或addEntity() 123456789101112@Testpublic void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); NativeQuery sqlQuery = session.createSQLQuery(\"select * from cst_customer\"); sqlQuery.addEntity(Customer.class); List&lt;Customer&gt; list = sqlQuery.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125;&#125; SQL的多表查询 交叉链接(笛卡尔积) select * from A,B; 内连接(inner join -&gt; inner可以省略) 显式内连接:select * from A,B where A.id=B.id; 隐式内连接:select * from A inner join B on A.id=B.id; 外连接(outer可以省略) 左外连接:select * from A left outer join B on A.id=B.aid; 右外连接:select * from A right outer join B on A.id=B.aid;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://zjinc36.github.io/tags/Hibernate/"}]},{"title":"Hibernate的关系映射","date":"2019-07-08T11:43:06.000Z","path":"2019/07/08/Hibernate的关系映射/","text":"一对多关系什么样关系属于一对多 一个部门对应多个员工,一个员工只能属于某一个部门 一个客户对应多个联系人,一个联系人只能属于某一个客户 一对多建表原则在多的一方创建外键指向一的一方的主键 一对多具体创建过程SQL语句一的一方1234567891011-- 一的一方create table `cst_customer` ( `cust_id` BIGINT(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` VARCHAR(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` VARCHAR(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` VARCHAR(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` VARCHAR(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` VARCHAR(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` VARCHAR(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY(`cust_id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 多的一方1234567891011121314151617181920-- 多的一方create table cst_linkman ( lkm_id bigint(32) not null auto_increment comment '联系人编号(主键)', lkm_name varchar(16) default null comment '联系人姓名', lkm_cust_id bigint(32) default null comment '客户id', lkm_gender char(1) default null comment '联系人性别', lkm_phone varchar(16) default null comment '联系人办公电话', lkm_mobile varchar(16) default null comment '联系人手机', lkm_email varchar(16) default null comment '联系人邮箱', lkm_qq varchar(64) default null comment '联系人qq', lkm_position varchar(16) default null comment '联系人职位', lkm_memo varchar(512) default null comment '联系人备注', primary key (lkm_id),-- 在lkm_cust_id上建立普通索引FK_cst_linkman_lkm_cust_id key FK_cst_linkman_lkm_cust_id(lkm_cust_id),-- 这里的FK_cst_linkman_lkm_cust_id和上面的没有任何关系-- 只是用相同名字表示这里的外键和上面的内键是同一个字段,只是一个命名-- 多的一方创建外键指向一的一方的主键 CONSTRAINT FK_cst_linkman_lkm_cust_id FOREIGN key (lkm_cust_id) REFERENCES cst_customer(cust_id) ON DELETE NO ACTION ON UPDATE NO ACTION) engine=InnoDB auto_increment=1 default charset=utf8; 对应的ER图 java对象一的一方1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.zjinc36.hibernate;import java.util.HashSet;import java.util.Set;public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; //通过ORM方式表示:一个客户对应多个联系人 //放置的是多的一方的集合,Hibernate默认使用的是Set集合 private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;LinkMan&gt;(); public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125; public Set&lt;LinkMan&gt; getLinkMans() &#123; return linkMans; &#125; public void setLinkMans(Set&lt;LinkMan&gt; linkMans) &#123; this.linkMans = linkMans; &#125;&#125; 多的一方12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.zjinc36.hibernate;public class LinkMan &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; //通过ORM方式表示:一个联系人只能属于某一个客户 //放置的是一的一方 //把外键改成一的一方的对象 private Customer customer; public Long getLkm_id() &#123; return lkm_id; &#125; public void setLkm_id(Long lkm_id) &#123; this.lkm_id = lkm_id; &#125; public String getLkm_name() &#123; return lkm_name; &#125; public void setLkm_name(String lkm_name) &#123; this.lkm_name = lkm_name; &#125; public String getLkm_gender() &#123; return lkm_gender; &#125; public void setLkm_gender(String lkm_gender) &#123; this.lkm_gender = lkm_gender; &#125; public String getLkm_phone() &#123; return lkm_phone; &#125; public void setLkm_phone(String lkm_phone) &#123; this.lkm_phone = lkm_phone; &#125; public String getLkm_mobile() &#123; return lkm_mobile; &#125; public void setLkm_mobile(String lkm_mobile) &#123; this.lkm_mobile = lkm_mobile; &#125; public String getLkm_email() &#123; return lkm_email; &#125; public void setLkm_email(String lkm_email) &#123; this.lkm_email = lkm_email; &#125; public String getLkm_qq() &#123; return lkm_qq; &#125; public void setLkm_qq(String lkm_qq) &#123; this.lkm_qq = lkm_qq; &#125; public String getLkm_position() &#123; return lkm_position; &#125; public void setLkm_position(String lkm_position) &#123; this.lkm_position = lkm_position; &#125; public String getLkm_memo() &#123; return lkm_memo; &#125; public void setLkm_memo(String lkm_memo) &#123; this.lkm_memo = lkm_memo; &#125; public Customer getCustomer() &#123; return customer; &#125; public void setCustomer(Customer customer) &#123; this.customer = customer; &#125;&#125; 映射创建多的一方123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.zjinc36.hibernate.LinkMan\" table=\"cst_linkman\"&gt; &lt;!-- 建立类中的属性和表中的主键对应 --&gt; &lt;!-- name对应类中的属性,column对应表中的字段 --&gt; &lt;id name=\"lkm_id\" column=\"lkm_id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"lkm_name\" column=\"lkm_name\" /&gt; &lt;property name=\"lkm_gender\" column=\"lkm_gender\" /&gt; &lt;property name=\"lkm_phone\" column=\"lkm_phone\" /&gt; &lt;property name=\"lkm_mobile\" column=\"lkm_mobile\" /&gt; &lt;property name=\"lkm_email\" column=\"lkm_email\" /&gt; &lt;property name=\"lkm_qq\" column=\"lkm_qq\" /&gt; &lt;property name=\"lkm_position\" column=\"lkm_position\" /&gt; &lt;property name=\"lkm_memo\" column=\"lkm_memo\" /&gt; &lt;!-- 配置一对多的关系 --&gt; &lt;!-- 自己是多的一方,则这里要放一的一方 --&gt; &lt;!-- many-to-one标签 + name:name表示自己类中用哪个变量表示对方 + class表示对方类的全路径 + column表示自己用哪个字段来与对方联系(参与构成外键的字段) --&gt; &lt;many-to-one name=\"customer\" class=\"com.zjinc36.hibernate.Customer\" column=\"lkm_cust_id\"&gt;&lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 一的一方123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 根标签 --&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;!-- name对应类名,table对应表名 --&gt; &lt;class name=\"com.zjinc36.hibernate.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立类中的属性和表中的主键对应 --&gt; &lt;!-- name对应类中的属性,column对应表中的字段 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\" /&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\" /&gt; &lt;property name=\"cust_level\" column=\"cust_level\" /&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\" /&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\" /&gt; &lt;!-- 配置一对多的映射 --&gt; &lt;!-- set标签:name表示自己类中用哪个变量表示对方 --&gt; &lt;set name=\"linkMans\"&gt; &lt;!-- key标签:column表示自己用哪个字段来与对方联系(参与构成外键的字段) --&gt; &lt;key column=\"lkm_cust_id\" /&gt; &lt;!-- one-to-many标签:class表示对方类的全路径 --&gt; &lt;one-to-many class=\"com.zjinc36.hibernate.LinkMan\" /&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 配置核心文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate?useSSL=false&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- 是否显示sql --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否格式化sql --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否使用注释 --&gt; &lt;property name=\"hibernate.use_sql_comments\"&gt;true&lt;/property&gt; &lt;!-- 设置事务隔离级别 --&gt; &lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt; &lt;!-- 配置当前线程绑定Session --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;!-- 映射规则文件 --&gt; &lt;!-- 这里有进行修改 --&gt; &lt;mapping resource=\"com/zjinc36/hibernate/Customer.hbm.xml\" /&gt; &lt;mapping resource=\"com/zjinc36/hibernate/LinkMan.hbm.xml\" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 一对多的级联操作什么叫做级联操作一个对象的时候,是否会同时操作其关联的对象 级联是有方向性 操作一的一方的时候,是否操作多的一方 操作多的一方的时候,是否操作一的一方 级联保存或更新操作一的一方12345678910111213141516171819202122232425262728293031323334&lt;!-- 要配置set --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 根标签 --&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;!-- name对应类名,table对应表名 --&gt; &lt;class name=\"com.zjinc36.hibernate.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立类中的属性和表中的主键对应 --&gt; &lt;!-- name对应类中的属性,column对应表中的字段 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\" /&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\" /&gt; &lt;property name=\"cust_level\" column=\"cust_level\" /&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\" /&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\" /&gt; &lt;!-- 配置一对多的映射 --&gt; &lt;!-- set标签:name表示自己类中用哪个变量表示对方 --&gt; &lt;set name=\"linkMans\" cascade=\"save-update\"&gt; &lt;!-- key标签:column表示自己用哪个字段来与对方联系(参与构成外键的字段) --&gt; &lt;key column=\"lkm_cust_id\" /&gt; &lt;!-- one-to-many标签:class表示对方类的全路径 --&gt; &lt;one-to-many class=\"com.zjinc36.hibernate.LinkMan\" /&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 123456789101112131415161718192021222324252627@Test/** * 级联保存或更新操作 * 保存客户级联联系人,操作的主题是客户对象,需要在Customer.hbm.xml中进行配置 * &lt;set name=\"linkMans\" cascade=\"save-update\"&gt; */public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); //1.创建客户 Customer customer = new Customer(); customer.setCust_name(\"liubei\"); //2.创建联系人 LinkMan linkMan = new LinkMan(); linkMan.setLkm_name(\"zhaoyun\"); //3.设置关系 customer.getLinkMans().add(linkMan); linkMan.setCustomer(customer); //4.保存数据 //前三步没有区别,就最后一步有区别 //由于对一的一方进行设置(&lt;set name=\"linkMans\" cascade=\"save-update\"&gt;) //所以保存的时候只需要保存一的一方 session.save(customer); tx.commit();&#125; 操作多的一方123&lt;!-- 需要配置LinkMan.hbm.xml文件 --&gt;&lt;!-- 其他省略 --&gt;&lt;many-to-one name=\"customer\" cascade=\"save-update\" class=\"com.zjinc36.hibernate.Customer\" column=\"lkm_cust_id\"&gt;&lt;/many-to-one&gt; 测试对象导航123456789101112131415161718192021222324252627282930 @Test /** * 测试对象导航 * 一对多双方都设置cascade=\"save-update\" */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); //1.创建客户 Customer customer = new Customer(); customer.setCust_name(\"liubei\"); //2.创建联系人 LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name(\"zhaoyun\"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name(\"huangzhong\"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name(\"machao\"); //3.设置关系 linkMan1.setCustomer(customer); customer.getLinkMans().add(linkMan2); customer.getLinkMans().add(linkMan3); //4.保存数据// session.save(linkMan1); //发送4条insert语句// session.save(customer); //发送3条insert语句 session.save(linkMan2); //发送1条insert语句 tx.commit(); &#125; 级联删除未设置级联删除 //实际会产生如下动作 将外键设置为空 在删除对应的值 设置级联删除删除客户级联删除联系人 12&lt;!-- 需要配置 --&gt;&lt;set name=\"linkMans\" cascade=\"save-update, delete\"&gt; 12345678910111213@Test/** * 级联删除 */public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = session.get(Customer.class, 1L); session.delete(customer); tx.commit();&#125; 注:删除联系人级联删除客户(基本不用) 一对多设置了双向关联产生多余的SQL语句原因 解决 单向维护 使一的一方放弃维护权 -&gt; 在set上配置 inverse=”true” 在一对多关联查询的修改的时候,必须设置 区分cascade和inverse的区别12345678910111213141516@Test/** * 区分cascade和inverse的区别 */public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name(\"liubei\"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name(\"zhugeliang\"); customer.getLinkMans().add(linkMan); // 条件Customer.hbm.xml上的set中配置了cascade=\"save-update\" inverse=\"true\" session.save(customer); //客户会插入到数据,联系人也会插入到数据,但是外键为null tx.commit();&#125; 多对多关系什么样关系属于多对多 一个学生可以选择多门课程,一门课程也可以被多个学生选择 一个用户可以选择多个角色,一个角色也可以被多个用户选择 多对多建表原则创建一个中间表,中间表至少有两个字段,分别作为外键指向多对多双方的主键 配置SQL语句123456789101112131415161718192021222324252627-- 用户表create table sys_user ( user_id bigint(32) not null auto_increment comment '用户id', user_code varchar(32) not null comment '用户帐号', user_name varchar(64) not null comment '用户名称', user_password varchar(32) not null comment '用户密码', user_state char(1) not null comment '1:正常,0:暂停', primary key(user_id)) engine=innodb auto_increment=1 default charset=utf8-- 角色表create table sys_role ( role_id bigint(32) not null auto_increment comment '角色id', role_name varchar(32) not null comment '角色名', role_memo varchar(64) not null comment '', primary key(role_id)) engine=innodb auto_increment=1 default charset=utf8-- 中间表CREATE TABLE sys_user_role ( role_id bigint(32) NOT NULL comment '角色id', user_id bigint(32) NOT NULL comment '用户id', PRIMARY KEY (role_id, user_id), KEY FK_user_role_user_id(user_id), CONSTRAINT FK_user_role_role_id FOREIGN KEY (role_id) REFERENCES sys_role(role_id) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT FK_user_role_user_id FOREIGN KEY (user_id) REFERENCES sys_user(user_id) ON DELETE NO ACTION ON UPDATE NO ACTION)engine=innodb default charset=utf8 ER图 java代码123456789101112131415161718192021public class Role &#123; private Long role_id; private String role_name; private String role_memo; //一个角色被多个用户选择 //放置的是用户的集合 private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); // getters and setters...&#125;public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; //一个用户有多个角色 //放置的是角色的集合 private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); // getters and setters...&#125; xml文件配置123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 根标签 --&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;!-- name对应类名,table对应表名 --&gt; &lt;class name=\"com.zjinc36.hibernate.Role\" table=\"sys_role\"&gt; &lt;!-- 建立类中的属性和表中的主键对应 --&gt; &lt;!-- name对应类中的属性,column对应表中的字段 --&gt; &lt;id name=\"role_id\" column=\"role_id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"role_name\" column=\"role_name\" /&gt; &lt;property name=\"role_memo\" column=\"role_memo\" /&gt; &lt;!-- 配置多对多的映射 --&gt; &lt;!-- 自己对对方的映射 --&gt; &lt;!-- set标签: name表示自己类中的private中是用哪个变量名作为对方对象集合的属性 table:多对多关系需要使用中间表,放的是中间表的名称 --&gt; &lt;set name=\"users\" table=\"sys_user_role\"&gt; &lt;!-- key标签:column表示自己哪个字段名用来参与与对方联系(外键字段) --&gt; &lt;key column=\"role_id\" /&gt; &lt;!-- many-to-many标签: class表示对方的类的全路径 column表示对方哪个字段名用来参与与对方联系((外键字段)) --&gt; &lt;many-to-many class=\"com.zjinc36.hibernate.User\" column=\"user_id\" /&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 根标签 --&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;!-- name对应类名,table对应表名 --&gt; &lt;class name=\"com.zjinc36.hibernate.User\" table=\"sys_user\"&gt; &lt;!-- 建立类中的属性和表中的主键对应 --&gt; &lt;!-- name对应类中的属性,column对应表中的字段 --&gt; &lt;id name=\"user_id\" column=\"user_id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"user_code\" column=\"user_code\" /&gt; &lt;property name=\"user_name\" column=\"user_name\" /&gt; &lt;property name=\"user_password\" column=\"user_password\" /&gt; &lt;property name=\"user_state\" column=\"user_state\" /&gt; &lt;!-- 配置多对多的映射 --&gt; &lt;!-- 自己对对方的映射 --&gt; &lt;!-- set标签: name表示自己类中的private中是用哪个变量名作为对方对象集合的属性 table:多对多关系需要使用中间表,放的是中间表的名称 --&gt; &lt;set name=\"roles\" table=\"sys_user_role\"&gt; &lt;!-- key标签:column表示自己哪个字段名用来参与与对方联系(外键字段) --&gt; &lt;key column=\"role_id\" /&gt; &lt;!-- many-to-many标签: class表示对方的类的全路径 column表示对方哪个字段名用来参与与对方联系(外键字段) --&gt; &lt;many-to-many class=\"com.zjinc36.hibernate.Role\" column=\"role_id\" /&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 配置核心文件12&lt;mapping resource=\"com/zjinc36/hibernate/Role.hbm.xml\" /&gt;&lt;mapping resource=\"com/zjinc36/hibernate/User.hbm.xml\" /&gt; Hibernate的多对多操作级联操作 级联保存和更新 级联删除(了解) 其他的操作 给用户选择角色 给用户该选角色 给用户删除角色 一对一关系什么样的关系属于一对一 一个公司只能有一个注册地址,一个地址只能被一个公司注册 一对一建表原则 方式一:主键对应 方式二:唯一外键对应(就是在其中一张表加一个字段,该字段的内容和另一张表的主键一致)","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://zjinc36.github.io/tags/Hibernate/"}]},{"title":"Hibernate事务管理","date":"2019-07-07T23:11:59.000Z","path":"2019/07/08/Hibernate事务管理/","text":"事务什么是事务事务指的是逻辑上的一组操作,组成这组操作的各个逻辑单元,要么全部成功,要么全部失败 事务特性 原子性:代表事务不可分割 一致性:代表事务执行的前后,数据的完整性保持一致 隔离性:代表一个事务执行的过程中,不应该收到其他事务的干扰 持久性:代表事务执行完成后,数据就持久到数据库中 如果不考虑隔离性,引发安全问题读问题 脏读:一个事务读到另一个事务未提交的数据 不可重复读:一个事务读到另一个事务已经提交的update数据,导致在前一个事务多次查询结果不一致 虚读:一个事务读到另一个事务已经提交的insert数据,导致在前一个事务多次查询结果不一致 写问题(了解)引发两类丢失更新 读问题的解决 Read uncommitted:以上读问题都会发生 Read committed:解决脏读,但是不可重复读和虚度有可能发生(Oracle用这种) Repeatable read:解决脏读和不可重复读,但是虚读有可能发生(MySQL用这种) Serializable:解决所有问题,但是效率低 Hibernate设置隔离级别四种隔离级别对应的数字 Read uncommitted —- 1 Read committed —- 2 Repeatable read —- 4 Serializable —- 8 设置隔离级别12345678910111213141516171819202122232425262728293031323334&lt;!-- 如下,设置事务隔离级别 --&gt;&lt;!-- 设置事务隔离级别 --&gt;&lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt;&lt;!-- hibernate.cfg.xml文件的全部内容 --&gt;&lt;!-- 用以确定 事务隔离级别 在该文件中要写在哪里 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 是否显示sql --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否格式化sql --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否使用注释 --&gt; &lt;property name=\"hibernate.use_sql_comments\"&gt;true&lt;/property&gt; &lt;!-- 设置事务隔离级别 --&gt; &lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt; &lt;!-- 映射规则文件 --&gt; &lt;mapping resource=\"com/zjinc36/hibernate/Customer.hbm.xml\" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 将事务加在Service层为什么需要把事务加在业务层 Dao中封装的是对数据源的单个操作(进行一次CURD) Service中封装业务逻辑操作,一个业务逻辑往往需要对数据源操作多次 由于一个Service 会调用多个Dao，为了保证这些调用的原子性，事务都是放到Service层的； 若是放到Dao层的话，那么Service里调用的其他的Dao无法保证与前面已经调用的Dao在同一个事务中 保证在同一个事务是什么意思 在jdbc要保证connection是同一个 在hibernate中要保证session是同一个 在Service层中如何保证在同一个事物参考:https://blog.csdn.net/tanghui270270/article/details/88427076 方法一:将connection向下传递(DBUtils就是这样做的) 方法二:使用ThreadLocal对象(Hibernate有封装) ThreadLocal说明:https://juejin.im/post/5ac2eb52518825555e5e06ee 简而言之:往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的,实现了线程的数据隔离 由此可以知道我们只需要做如下两件事 将这个连接绑定到当前线程中 在DAO的方法中,通过当前的线程获得到连接对象 Hibernate框架如何使用封装好的ThreadLocal 在SessionFactory中提供一个方法getCurrentSeesion() 要开启这个方法,需要通过一个配置完成 改写工具类12345678910111213141516171819202122232425262728package com.zjinc36.utils;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;/** * Hiberante的工具类 * @author zjc * */public class HibernateUtils &#123; public static final Configuration cfg; public static final SessionFactory sf; static &#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; public static Session openSession() &#123; return sf.openSession(); &#125; public static Session getCurrentSession() &#123; return sf.getCurrentSession(); &#125;&#125; 配置12345678910111213141516171819202122232425262728293031323334&lt;!-- 配置当前线程绑定Session --&gt;&lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt;&lt;!-- 具体在hibernate.cfg.xml文件中的位置 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 是否显示sql --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否格式化sql --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否使用注释 --&gt; &lt;property name=\"hibernate.use_sql_comments\"&gt;true&lt;/property&gt; &lt;!-- 设置事务隔离级别 --&gt; &lt;property name=\"hibernate.connection.isolation\"&gt;4&lt;/property&gt; &lt;!-- 配置当前线程绑定Session --&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;!-- 映射规则文件 --&gt; &lt;mapping resource=\"com/zjinc36/hibernate/Customer.hbm.xml\" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 使用12345678910111213@Testpublic void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name(\"张飞\"); session.save(customer); tx.commit(); // session不用关闭 // 因为使用getCurrentSession()时,线程结束会自动关闭&#125;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://zjinc36.github.io/tags/Hibernate/"}]},{"title":"Ubuntu安装截屏工具Shutter","date":"2019-07-07T21:24:30.000Z","path":"2019/07/08/Ubuntu安装截屏工具Shutter/","text":"安装截图工具Shutter安装Ubuntu18.04123456# 添加安装包软件源sudo add-apt-repository ppa:shutter/ppa# 更新源并安装 shuttersudo apt-get updatesudo apt-get install shutter Ubuntu20.04 参考Ubuntu 20.04 截图软件的使用 (gnome-screenshot、flameshot、shutter 截图编辑三叉戟) 虽然软件中心提供了，但是不要使用软件中心安装shutter安装：Ubuntu 20.04 官方源提供的 snap 版本可以安装，但运行时存在缺陷，发现如下问题： 1234Error while opening directory /home/username/PicturesThere was an error determining the filename ...截取窗口时程序崩溃却未退出，因此再次启动程序导致部分功能依然不能使用，需先杀死进程解决办法：不要使用官方snap包（软件中心）进行安装，添加下面的PPA源安装（定制修正版）即可（此版本暂不能截取网页，但其他功能稳定） 安装 123456789# 删除已安装有缺陷的版本sudo snap remove shutter# 添加安装包软件源sudo add-apt-repository ppa:linuxuprising/shutter# 更新源并安装 shuttersudo apt-get update -ysudo apt-get install shutter -y 问题:shutter编辑按钮灰色Ubuntu18.04 参考:https://itsfoss.com/shutter-edit-button-disabled/ 总结起来就是如下操作1234567891011121314# 下载必要的依赖wget https://launchpad.net/ubuntu/+archive/primary/+files/libgoocanvas-common_1.0.0-1_all.debwget https://launchpad.net/ubuntu/+archive/primary/+files/libgoocanvas3_1.0.0-1_amd64.debwget https://launchpad.net/ubuntu/+archive/primary/+files/libgoo-canvas-perl_0.06-2ubuntu3_amd64.deb# 安装依赖sudo dpkg -i libgoocanvas-common_1.0.0-1_all.debsudo dpkg -i libgoocanvas3_1.0.0-1_amd64.debsudo dpkg -i libgoo-canvas-perl_0.06-2ubuntu3_amd64.debsudo apt -f install# 重启shutter(或者重新安装shutter)sudo killall shutter重新启动shutter Ubuntu20.04 截至20200802为止,暂时没有找到好的解决方法 按照18.04的解决方法操作,libgoo-canvas-perl_0.06-2ubuntu3_amd64.deb需要依赖perlapi-5.26.0,但无法安装 设置快捷键参考:ubuntu 安装截图工具 Shutter，并设置快捷键 Ctrl+Alt+A","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Hibernate持久化类的编写规则","date":"2019-07-07T11:57:44.000Z","path":"2019/07/07/Hibernate持久化类的编写规则/","text":"什么是持久化类 持久化:将内存中的一个对象持久化到数据库中的过程,Hibernate就是用来进行持久化的框架 持久化类:一个java对象与数据库的表建立了映射关系,那么这个类在Hibernate中称为持久化类,即持久化类=Java类+映射文件 持久化类的编写规则 对持久化类提供一个无参数的构造方法:Hibernate底层需要使用反射生成实例 属性需要私有,对私有属性提供public的get和set方法:Hibernta中获取,设置对象的值 对持久化类提供一个唯一标识OID与数据库主键对应:java通过对象的地址区分是否是同一个对象,数据库中通过主键确定是否是同一个记录,在Hibernate中通过持久化类的OID的属性区分是否是同一个对象 持久化类中属性尽量使用包装类类型:因为基本数据类型默认是0,那么插入0的时候就会出现歧义.而包装类类型默认值是null 持久化类不要使用final修饰:延迟加载本身是hibernate一个优化的手段,返回的是一个代理对象(javassist可以对没有实现接口的类产生代理 —- 使用了非常底层字节码增强技术,继承这个类进行代理),如果不能被继承,就不能产生代理对象,延迟加载也就失效,load方法就和get方法一致 主键生成策略主键的分类 自然主键主键的本身就是表中的一个字段(实体中一个具体的属性) 代理主键主键本身不是表中必须的一个字段(不是实体中的某个具体属性) 在实际开发中,尽量使用代理主键 因为一旦自然主键参与到业务逻辑中,后期有可能需要修改源代码 设计原则:好的程序设计满足OCP原则,对程序的扩展是open,对修改源码是close的 Hibernate的主键生成策略在实际开发中一般不允许用户手动设置主键,一般将主键交给数据库,手动编写程序进行设置.在Hibernate中为了减少程序编写,提供了很多的主键生成策略 increment:hibernate中提供的自动增长机制,适用short,int,long类型的主键 在单线程程序中使用,不准用在多线程程序 运行机制:首先发送一条语句: select max(id) from 表, 然后让 id+1 作为下一条记录的主键 identity:适用short,int,long类型的主键,使用的是数据库底层的自动增长机制 没有自动增长机制的数据库不能用 适用于自动增长机制数据库(MySQL,MSSQL),Oracle没有自动增长机制 sequence:适用short,int,long类型的主键,采用的是序列的方式 Oracle支持序列,MySQL不能使用sequence uuid:使用hibernate中的随机方式生成字符串主键 适用于字符串类型的主键 native:本地策略,可以在identity和sequence之间进行自动切换 也就是说,如果底层使用MySQL,则使用identity机制,而如果使用oracle则使用sequence机制 asigned:hibernat放弃外键的管理 也就是说:需要通过手动编写程序或者用户自己设置 foreign:外部的(了解居多) 在一对一的一种关联映射的情况下使用 主键生成策略写在xml中1234567891011121314151617181920212223&lt;!-- Customer.hbm.xml文件 --&gt;&lt;!-- 在项目中的位置可以看\"Hibernate入门与配置\"一文中,下述代码对应位置 --&gt;&lt;!-- 关注generator节点 --&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;!-- name对应类名,table对应表名 --&gt; &lt;class name=\"com.zjinc36.hibernate.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立类中的属性和表中的主键对应 --&gt; &lt;!-- name对应类中的属性,column对应表中的字段 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\" /&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\" /&gt; &lt;property name=\"cust_level\" column=\"cust_level\" /&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\" /&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 持久化类的三种状态Hibernate是持久层框架,通过持久化类完成ORM操作,Hibernate为了更好的管理持久化类,将持久化类分成三种状态 瞬时态这种对象没有唯一的标识OID,被session管理,称之为瞬时态对象 在Session的缓存中，与Session实例相关联 在数据库中没有与之相对应的记录持久态这种对象有唯一标识OID,被session管理,称为持久态对象 在Session的缓存中，与Session实例相关联 在数据库中存在与之相对应的记录脱管态(游离态)这种对象有唯一标识OID,没有被session管理,称为脱管态对象 不在Session的缓存中，不与任何的Session实例相关联 在数据库中存在与之相对应的记录(前提条件是没有其他Session实例删除该条记录) 区分三种状态对象12345678910111213141516171819public class HibernateDemo3 &#123; public void demo1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); //这种对象没有唯一的标识OID,被session管理,称之为瞬时态对象 Customer customer = new Customer(); customer.setCust_name(\"wangwu\"); //这种对象有唯一标识OID,被session管理,称为持久态对象 Serializable id = session.save(customer); transaction.commit(); session.close(); //这种对象有唯一标识OID,没有被session管理,称为脱管态对象 System.out.println(\"客户名称:\" + customer.getCust_name()); &#125;&#125; 三种状态的转换参考这篇文章https://blog.csdn.net/a772304419/article/details/79319988 瞬时态对象获得Customer customer = new Customer(); 状态转换 瞬时-&gt;持久:save(); 瞬时-&gt;脱管:customer.setCust_id(1); 持久态对象获得 get() -&gt; Customer customer = session.get(Customer.class, 1L); load() find() iterate()状态转换 持久-&gt;瞬时:delete() 持久-&gt;脱管:close(),clear(),evict()脱管态对象获得 先变成瞬时:Customer customer = new Customer() 然后变成脱管:customer.setCust_id(1L)状态转化 脱管-&gt;持久:update(),saveOrUpdate() 脱管-&gt;瞬时:customer.setCust_id(null) 什么是缓存缓存:是一种优化的方式,将数据存入到内存中,使用的时候直接从缓存中获取,不通过存储源 Hibernate的缓存Hibernate框架中提供了优化手段:缓存,抓取策略.Hibernate中提供了两种缓存机制:一级缓存和二级缓存 Hibernate的一级缓存Hibernate的一级缓存:称为是Session级别的缓存,一级缓存生命周期与Session一致(一级缓存是由Session中的一系列的Java集合构成)一级缓存是自带的不可卸载的 证明一级缓存存在12345678910111213141516171819202122232425@Test/** * 证明一级缓存的存在 */public void demo4() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // customer1和customer2是否执行了两次SQL语句 Customer customer1 = session.get(Customer.class, 6L);//发送SQL语句 System.out.println(customer1); Customer customer2 = session.get(Customer.class, 6L);//不发送SQL语句 System.out.println(customer2); // 两次是否是同一个对象 System.out.println(customer1 == customer2);//是指向同一个地址 Customer customer3 = new Customer(); customer3.setCust_name(\"关羽\"); Serializable id = session.save(customer3); session.get(Customer.class, id);//不发送SQL语句,因为是直接从缓存中获取 tx.commit(); session.close();&#125; 什么快照区Hibernate一级缓存中的特殊区域 快照区和缓冲区的作用比较缓冲区和快照区的数据,一致则不更新数据库,不一致则更新数据库 代码运行过程 eclipse观察缓存区和快照区的变化 取出数据后,快照区和缓冲区的变化 修改数据后,快照区和缓冲区的变化过程说明再来解剖一下123456789101112@Test//一级缓存的快照区public void demo5() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer = session.get(Customer.class, 6L); customer.setCust_name(\"关羽\"); tx.commit(); session.close();&#125; 1）将数据从DB中取出来2）将数据转变成对象，并存入堆内存中3）将对象的id放入session缓存map的key中，将对象的引用放入session缓存map的 value中，这就纳入session管理了4）将对象的详情放入到“快照”中5) 当执行了tx.commit();时，Hibernate为了保证数据的一致性，Hibernate会清理session的一级缓存（flush），此时会将堆内存中的数据（已经纳入session管理的数据）与快照中的数据进行对比6) 如果不一致，则会执行同步（update）操作，若相同，则不执行update Hibernate的二级缓存Hibernate的二级缓存是SessionFactory级别的缓存,需要配置的,但是企业级中一般不开启,更多的是通过redis来替代二级缓存","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://zjinc36.github.io/tags/Hibernate/"}]},{"title":"Hibernate的API","date":"2019-07-04T14:19:31.000Z","path":"2019/07/04/Hibernate的API/","text":"Configuration作用用以加载核心配置文件 加载方式方式一:文件名是hibernate.properties(了解居多)1Configuration cfg = new Configuration(); 方式二:文件名是hibernate.cfg.xml1234Configuration cfg = new Configuration().configure();//如果不是默认的文件名,还需要如下语句//cfg.addResource(\"com/zjinc36/hibernate/Customer.hbm.xml\") SessionFactory简介SessionFactory内部维护了Hibernate的连接池和Hibernate的二级缓存(不讲)是线程安全的对象一个项目创建一个对象即可参考:https://blog.csdn.net/fan71900/article/details/45890915 配置 引入jar包,将hibernate-release-5.4.3.Final/lib/optional/c3p0下的所有jar包导入项目中 在核心配置文件中添加如下选项参考https://www.cnblogs.com/caoyc/p/5607051.html1234567891011&lt;!-- 数据库连接池的使用 --&gt;&lt;!-- 选择使用C3P0连接池 --&gt;&lt;property name=\"hibernate.connection.provider_class\"&gt;org.hibernate.c3p0.internal.C3P0ConnectionProvider&lt;/property&gt;&lt;!-- 连接池中最小连接数 --&gt;&lt;property name=\"hibernate.c3p0.min_size\"&gt;5&lt;/property&gt;&lt;!-- 连接池中最大连接数 --&gt;&lt;property name=\"hibernate.c3p0.max_size\"&gt;20&lt;/property&gt;&lt;!-- 设定数据库连接超时时间，以秒为单位。如果连接池中某个数据库连接处于空闲状态且超过timeout秒时，就会从连接池中移除--&gt;&lt;property name=\"hibernate.c3p0.timeout\"&gt;120&lt;/property&gt;&lt;!-- 设置数据库 --&gt;&lt;property name=\"hibernate.c3p0.idle_test_period\"&gt;3000&lt;/property&gt; 抽取工具类目的是为了保证一个项目只创建一个SessionFactory对象 123456789101112131415161718192021222324package com.zjinc36.utils;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;/** * Hiberante的工具类 * @author zjc * */public class HibernateUtils &#123; public static final Configuration cfg; public static final SessionFactory sf; static &#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; public static Session openSession() &#123; return sf.openSession(); &#125;&#125; Session简介Session代表的是Hibernate与数据库的连接对象,即与数据库交互桥梁不是线程安全 Session中的API保存操作 Serializable save(Object obj)`123456789101112131415@Test//测试save保存//返回idpublic void saveDemo() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name(\"lisi\"); Serializable id = session.save(customer); System.out.println(id); tx.commit(); session.close();&#125; 查询操作注意get和load方法的区别(代码中的注释) T get(Class c,Serializable id);123456789101112131415@Test// 测试get查询方法// 采用的是立即加载,执行到get的时候,就会马上发送SQL语句去查询// 查询后返回的是真实对象// 查询一个找不到的对象的时候,返回nullpublic void getDemo() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer = session.get(Customer.class, 1L); System.out.println(customer); tx.commit(); session.close();&#125; T load(Class, c,Serializable id);123456789101112131415@Test// 测试load查询方法// 采用的是延迟加载(lazy懒加载),执行到这行代码的时候,不会发送SQL语句,当真正使用这个对象的时候才会发送SQL语句// 查询后返回的是代理对象,利用`javassist-3.24.0-GA.jar`技术来产生代理// 查询一个找不到的对象的时候,返回ObjectNotFoundExceptionpublic void loadDemo() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer = session.load(Customer.class, 6L); System.out.println(customer); tx.commit(); session.close();&#125; 更新操作 void update(Object obj);123456789101112131415161718192021222324 @Test /** * 更新操作 */ public void updateDemo() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 不推荐 // 直接创建对象,进行修改// Customer customer = new Customer();// customer.setCust_id(1L);// customer.setCust_name(\"wangwu\");// session.update(customer); // 推荐 // 先查询,再修改 Customer customer = session.get(Customer.class, 6L); customer.setCust_name(\"wangwu\"); session.update(customer); tx.commit(); session.close(); &#125; 删除操作 void delete(Object obj);1234567891011121314151617181920212223 @Test /** * 删除操作 */ public void deleteDemo() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 不推荐 // 直接创建对象,进行删除// Customer customer = new Customer();// customer.setCust_id(1L);// session.delete(customer); // 推荐 // 先查询,再修改 // 级联删除 Customer customer = session.get(Customer.class, 6L); session.delete(customer); tx.commit(); session.close(); &#125; 保存或更新操作 void saveOrUpdate(Object obj);12345678910111213141516@Test/** * 保存或更新 */public void saveOrUpdateDemo() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_id(10L); customer.setCust_name(\"abc\"); session.saveOrUpdate(customer); tx.commit(); session.close();&#125; 查询所有操作12345678910111213141516171819202122232425 @Test /** * 查询所有 */ public void findAllDemo() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 接收HQL:Hibernate Query Language 面向对象的查询语句// Query&lt;Customer&gt; query = session.createQuery(\"from Customer\");// List&lt;Customer&gt; list = query.list();// for (Customer customer : list) &#123;// System.out.println(customer);// &#125; // 接受SQL SQLQuery&lt;Object[]&gt; query = session.createSQLQuery(\"select * from cst_customer\"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit(); session.close(); &#125; Transaction事务对象,详见本博客的其他文章Hibernate事务管理 commit() roallback() Query具体查看本博客的:Hibernate的查询方式 HQLHibernate Query Language,Hibernate查询语言,这种语言和SQL极其类似,面向对象的查询语句 简单的查询123456789101112131415161718192021@Test/** * 简单的查询 */public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 通过session获得Query接口 // 注意这里的Customer指的是类 // 查询语句 String hql = \"from Customer where cust_name like ?0\"; Query query = session.createQuery(hql); // 设置条件(如果查询语句不需要条件,该句可省略) query.setParameter(0, \"zhang%\"); List&lt;Customer&gt; list = query.getResultList(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; 分页查询12345678910111213141516171819202122@Test/** * 分页查询 */public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 通过session获得Query接口 // 注意这里的Customer指的是类 // 查询语句 String hql = \"from Customer\"; Query query = session.createQuery(hql); // 设置分页 query.setFirstResult(0); query.setMaxResults(3); List&lt;Customer&gt; list = query.getResultList(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; QBCQBC -&gt; Query by Criteria,更加面向对象的一种查询方式 简单查询12345678910111213141516171819202122232425262728293031323334 @Test /** * Criteria */ public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 写具体逻辑crud(增删改查)操作 // 1创建Criteria对象 createCriteria()在hibernate5.2之后过时了// Criteria criteria = session.createCriteria(Customer.class);// List&lt;Customer&gt; list = criteria.list();// for (Student customer : list) &#123;// System.out.println(customer);// &#125; // 新的查询方式 // 1.创建CriteriaBuilder对象 // 注意导入的包是import javax.persistence.criteria.CriteriaQuery; CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); // 2.获取CriteriaQuery对象 CriteriaQuery&lt;Customer&gt; createQuery = criteriaBuilder.createQuery(Customer.class); // 3.指定根条件 createQuery.from(Customer.class); // 4执行查询 List&lt;Customer&gt; List = session.createQuery(createQuery).getResultList(); for (Customer customer : List) &#123; System.err.println(customer); &#125; tx.commit(); &#125; 模糊查询12345678910111213141516171819202122232425262728293031323334353637383940 /** * 模糊查询 */ @Test public void demo4() &#123; //获取session对象 Session session = HibernateUtils.getCurrentSession(); //开启事务 Transaction tx = session.beginTransaction(); //写具体逻辑crud(增删改查)操作// //创建Criteria对象 createCriteria()在hibernate5.2之后过时了// Criteria criteria = session.createCriteria(Customer.class);// criteria.add(Restrictions.like(\"cust_name\", \"zhang%\"));// List&lt;Customer&gt; list = criteria.list();// for (Student customer : list) &#123;// System.out.println(customer);// &#125; //新的查询方式 //1.创建CriteriaBuilder对象 //注意导入的包是import javax.persistence.criteria.CriteriaQuery; CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder(); //2.获取CriteriaQuery对象 CriteriaQuery&lt;Customer&gt; createQuery = criteriaBuilder.createQuery(Customer.class); //3.指定根条件 Root&lt;Customer&gt; root = createQuery.from(Customer.class); //root.get(\"name\") \"name\"是实体类的属性名称 createQuery.where(criteriaBuilder.like(root.get(\"cust_name\"), \"%zhang%\")); //4.执行查询 List&lt;Customer&gt; List = session.createQuery(createQuery).getResultList(); for (Customer customer : List) &#123; System.err.println(customer); &#125; //提交事务 tx.commit(); &#125; SQLQuery用于接收SQL,特别复杂情况下使用SQL","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://zjinc36.github.io/tags/Hibernate/"}]},{"title":"Ubuntu安装文本工具notepadqq","date":"2019-07-04T09:59:33.000Z","path":"2019/07/04/Ubuntu安装文本工具notepadqq/","text":"安装notepadqq作用Windows 上的 Notepad++，开发者们已经将它移植到 Linux，名为 Notepadqq它是一个简单而强大的文本编辑器，你可以在日常使用它，或用于各种语言进行编程 安装123$ sudo add-apt-repository ppa:notpadqq-team/notepadqq$ sudo apt-get update$ sudo apt-get install notepadqq","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Ubuntu安装剪切板管理工具copyq","date":"2019-07-04T09:52:52.000Z","path":"2019/07/04/Ubuntu安装剪切板管理工具copyq/","text":"作用CopyQ 是一个简单但是非常有用的剪贴板管理器，它保存你的系统剪贴板内容，无论你做了什么改变，你都可以在你需要的时候搜索和恢复它。它是一个很棒的工具，支持文本、图像、HTML 和其它格式。CopyQ 自身有很多功能像拖放、复制/拷贝、编辑、移除、排序、创建等。它同样支持集成文本编辑器，如 Vim，所以如果你是程序员，这非常有用。 安装123$ sudo add-apt-repository ppa:hluk/copyq$ sudo apt-get update$ sudo apt-get install copyq 个人习惯配置1234+ 打开首选项+ 常规 -&gt; 将`用鼠标选择存储文本`打勾+ 常规 -&gt; 将`run automatic commands on selection`去除+ 快捷键 -&gt; 显示/隐藏主窗口 -&gt; 增加快捷键`ctrl+shift+v`","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Eclipse中导入dtd和xsd使得xml文件能自动提示","date":"2019-07-03T15:54:31.000Z","path":"2019/07/03/eclipse中导入dtd和xsd使得xml文件能自动提示/","text":"DTD 类型约束文件 Window-&gt;Preferences-&gt;XML-&gt;XML Catalog-&gt;User Specified Entries窗口中,选择Add 按纽 在Add XML Catalog Entry 对话框中选择或输入以下内容123Location: /home/zjc/文档/Jar/hibernate-release-5.4.3.Final/project/hibernate-core/src/main/resources/org/hibernate/hibernate-mapping-3.0.dtdKey Type: URIKEY: http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd XSD 类型约束文件 Window-&gt;Preferences-&gt;XML-&gt;XML Catalog-&gt;User Specified Entries窗口中,选择Add 按纽 在Add XML Catalog Entry 对话框中选择或输入以下内容123Location: you/address/spring-beans-2.5.xsdKey Type: Schema LocationKEY: http://www.springframework.org/schema/beans/spring-beans-2.5.xsd","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"}]},{"title":"Ubuntu安装数据库可视化工具dbeaver","date":"2019-07-03T10:09:35.000Z","path":"2019/07/03/Ubuntu安装数据库可视化工具dbeaver/","text":"dbeaver是什么dbeaver,一款基于java的数据库可视化工具 平台支持全平台支持 安装前提需要java环境 安装过程 去官网下载对应平台的包https://dbeaver.io/download/,这里使用的是Ubuntu环境,所以下载的是deb包 sudo dpkg -i dbeaver-ce_6.1.1_amd64.deb","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Hibernate入门与配置","date":"2019-07-02T00:25:13.000Z","path":"2019/07/02/Hibernate入门与配置/","text":"Hibernate在项目中的位置EE的三层结构 12345678910111213客户端层 -&gt; JavaApplet/Html/CSS/JS | | Web层 -&gt; Servlet/JSP -&gt; Structs2/Springmvc | |业务逻辑层 -&gt; JavaBean -&gt; Spring | | 持久层 -&gt; JDBC -&gt; Hibernate/Mybatis | | 数据库 Servlet+JSP+JavaBean+JDBC使用这套架构可以开发市面上所有应用,但是企业中不会使用(过于底层)企业开发一般使用SSH(Struts+Spring+Hibernate),SSM(SpringMVC+Spring+Mybatis) Hibernate的入门案例下载Hibernate和log4jhibernate:https://hibernate.org/orm/log4j:https://logging.apache.org/log4j/1.2/download.html 创建一个项目导入jar包核心包将hibernate-release-5.4.3.Final/lib/required中的所有文件复制到eclipse 日志包将log4j-1.2-api-2.12.0.jar和log4j-to-slf4j-2.12.0.jar复制到eclipse,用来打印日志 具体参考https://elfasd.iteye.com/blog/1770847 创建表12345678910create table `cst_customer` ( `cust_id` BIGINT(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` VARCHAR(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` VARCHAR(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` VARCHAR(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` VARCHAR(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` VARCHAR(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` VARCHAR(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY(`cust_id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 创建实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zjinc36.hibernate;/** * 客户管理的实体类 * @author zjc */public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125;&#125; 创建映射映射需要通过xml的配置文件完成,这个配置文件可以任意命名,但要尽量做到统一的命名规范,比如类名.hbm.xml这样,文件和对应类放在同一层级目录 12345678910111213141516171819202122232425&lt;!-- 创建Customer.hbm.xml文件,在和类相同的目录下 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 根标签 --&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;!-- name对应类名,table对应表名 --&gt; &lt;class name=\"com.zjinc36.hibernate.Customer\" table=\"cst_customer\"&gt; &lt;!-- 建立类中的属性和表中的主键对应 --&gt; &lt;!-- name对应类中的属性,column对应表中的字段 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;generator class=\"native\" /&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=\"cust_name\" column=\"cust_name\" /&gt; &lt;property name=\"cust_source\" column=\"cust_source\" /&gt; &lt;property name=\"cust_industry\" column=\"cust_industry\" /&gt; &lt;property name=\"cust_level\" column=\"cust_level\" /&gt; &lt;property name=\"cust_phone\" column=\"cust_phone\" /&gt; &lt;property name=\"cust_mobile\" column=\"cust_mobile\" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 创建一个Hibernate的核心文件Hibernate的核心文件hibernate.cfg.xml,用以设置数据库,设置映射文件等,放在src根目录下 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 连接数据库的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;root&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 是否显示sql --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否格式化sql --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 是否使用注释 --&gt; &lt;property name=\"hibernate.use_sql_comments\"&gt;true&lt;/property&gt; &lt;!-- 映射规则文件 --&gt; &lt;mapping resource=\"com/zjinc36/hibernate/Customer.hbm.xml\" /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 使用Hiberante向表中插入数据1234567891011121314151617181920212223242526272829303132333435363738package com.zjinc36.hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;/** * Hibernate入门案例 * @author zjc * */public class HibernateDemo1 &#123; @Test // 保存客户的案例 public void demo1() &#123; // 1. 加载Hibernate的核心配置文件 // 其实就是加载一个常量DEFAULT_CFG_RESOURCE_NAME=hibernate.cfg.xml // 这也就是为什么Hibernate的核心配置文件命名为hibernate.cfg.xml的原因 // 同时也是为什么我们说这个配置文件的名字可以改,但我们一般不改的原因 Configuration configuration = new Configuration().configure(); // 2. 创建一个SessionFactory对象,类似于JDBC连接池 SessionFactory sessionFactory = configuration.buildSessionFactory(); // 3. 通过SessionFactory获取到Session对象Connection Session session = sessionFactory.openSession(); // 4. 手动开启事务 Transaction transaction = session.beginTransaction(); // 5. 编写代码 Customer customer = new Customer(); customer.setCust_name(\"zhangsan\"); session.save(customer); // 6. 提交事务 transaction.commit(); // 7. 释放资源 session.close(); &#125;&#125; 在Eclipse中导入dtd和xsd文件，使XML自动提示DTD 类型约束文件 Window-&gt;Preferences-&gt;XML-&gt;XML Catalog-&gt;User Specified Entries窗口中,选择Add 按纽 在Add XML Catalog Entry 对话框中选择或输入以下内容123Location: /home/zjc/文档/Jar/hibernate-release-5.4.3.Final/project/hibernate-core/src/main/resources/org/hibernate/hibernate-mapping-3.0.dtdKey Type: URIKEY: http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd XSD 类型约束文件 Window-&gt;Preferences-&gt;XML-&gt;XML Catalog-&gt;User Specified Entries窗口中,选择Add 按纽 在Add XML Catalog Entry 对话框中选择或输入以下内容123Location: you/address/spring-beans-2.5.xsdKey Type: Schema LocationKEY: http://www.springframework.org/schema/beans/spring-beans-2.5.xsd Hibernate的映射的配置class标签用来建立类与表的映射关系 name:类的全路径 table:表名(类名与表名一致,那么table可以省略) catalog:数据库名id标签用来建立类中的属性与表中的主键的对应关系 name:类中的属性名 column:表中的字段名(类中的属性名和表中的字段名一致,那么column可以省略) length:长度 type:类型(有三种方式,分别是java写法,hibernate写法,sql写法)property标签的配置 name:类中的属性名 column:表中的字段名 length:长度 type:类型 not-null:设置非空 unique:设置唯一 Hibernate的核心配置有两种配置方式 属性文件的方式(了解,可以跳过) hibernate.properties文件 hibernate.connection.driver_class=com.mysql.jdbc.Driver hibernate.show_sql=true属性文件的方式不能引入映射文件(需要手动编写代码加载映射文件,所以这种方法不常用) XML文件的方式 hibernate.cfg.xml xml配置方式详解连接数据库的基本参数 驱动类 url路径 用户名 密码方言 可选的配置显示SQL 显示SQL:hibernate.show_sql 格式化SQL 格式化SQL:hibernate.format_sql 自动建表自动建表 自动建表:&lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; none:不使用hibernate的自动建表 create:如果数据库中已经有表,删除原有表,重新创建,如果没有表,新建表(测试常用) create-drop:如果数据库中已经有表,删除原有表,执行奥做,删除这个表.如果没有表,新建一个,使用完了删除该表(测试常用) update:如果数据库中有表,使用原有表.如果没有表,创建新表(更新表结构) validate:如果没有表,不会创建表,只会使用数据库中原有的表(校验映射和表结构) 问题:表可以删除,却无法自动创建 参考:https://blog.csdn.net/weixin_40327259/article/details/80803754 原因hibernate里的dialect和Mysql的版本不匹配,SQL语句,在MySQL5.0之前是设置表类型type=”…”，5.0之后是使用engine=”…”设置表类型 解决 12345&lt;!-- MySql5.0之前的配置 --&gt;&lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;&lt;!-- MySql5.0之后的配置 --&gt;&lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; 映射文件引入 引入映射文件的位置&lt;mapping resource=&quot;com/zjinc36/hibernate/Customer.hbm.xml&quot; /&gt;","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://zjinc36.github.io/tags/Hibernate/"}]},{"title":"JSP和EL和JSTL","date":"2019-06-29T09:49:11.000Z","path":"2019/06/29/JSP和EL和JSTL/","text":"JSP什么是JSPJava Server Page的缩写从用户角度看待,就是一个网页从程序员角度看待,其实是一个java类,它继承了Servlet,所以可以直接说jsp就是一个Servlet 为什么会有JSPhtml多数情况下用来显示静态内容,一成不变的.但是有时候我们需要在网页上显示一些动态数据比如:查询所有的学生信息,根据姓名去查询某个学生.这些动作都需要去查询数据库,然后在网页上显示html不支持写java代码,jsp里面可以写java代码 怎么用JSP指令的写法1&lt;%@ 指令名字 %&gt; 指令详解page指令1&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; language:表明jsp页面中可以写java代码 contentType:告诉浏览器我是什么内容类型,以及使用什么编码 pageEncoding:jsp内容编码 extends:用于指定jsp翻译成java文件后,继承的父类是谁,一般不用改 import:导包使用,一般不用手写 session:值可选的有true或false,用于控制在这个jsp页面里面,能够直接使用session对象,具体的区别请看翻译后的java文件,如果该值是true,那么在代码里面会有getSession()的调用,如果是false,那么就不会有该方法调用,也就是没有session对象了,在页面也就自然不能使用了 errorPage:指的是错误的页面,当当前页面有错误的java代码时,自动跳转到错误页面 isErrorPage:上面的errorPage用于指定错误的时候跑到哪一个页面去,而这个isErrorPage,就是声明某一个页面到底是不是错误的页面 include指令1&lt;%@ include file=&quot;other2.jsp&quot; %&gt; 本质上就是把另外一个页面的所有内容拿过来一起输出,所有的标签元素都包含进来 taglib指令1&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt; uri:标签库路径 prefix:标签库的别名 JSP动作标签123&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;&lt;jsp:param value=&quot;&quot; name=&quot;&quot; /&gt;&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; jsp:include 包含指定页面,这里是动态包含,也就是不把包含的页面所有元素标签全部拿过来输出,而是把它运行结果拿过来 jsp:forward 前往哪一个页面 相当于&lt;% request.getRequestDispatcher(&quot;other02.jsp&quot;).forward(request, response); %&gt; jsp:param 在包含某个页面的时候,或者在跳转某个页面的时候,带个参数 12345678other01.jsp页面:&lt;jsp:forward page=\"other02.jsp\"&gt; &lt;jsp:param value=\"beijing\" name=\"address\" /&gt;&lt;/jsp:forward&gt;&gt;ohter02.jsp页面&lt;%= request.getParameter(\"address\") %&gt; JSP内置对象所谓内置对象,就是我们可以直接在jsp页面中使用这些对象,不用创建内置对象如下 第一类:作用域对象 pageContext request session application 第二类:不常用对象 exception page config 第三类:常用 response out 第一类:作用域对象作用域定义 表示这个对象可以存值,它们的取值范围有限定 作用范围 pageContext[PageContext]:作用于仅限于当前页面,能够存值的同时,还能获取到其他8个对象 request[HttpServletRequest]:作用于仅限于一次请求,只要服务器对该请求作出了响应,这个域中的值就没有了 session[HttpSession]:作用于仅限于一次会话(多次请求与响应)当中 application[ServletContext]:整个工程都可以访问,服务器关闭后就不能访问了 操作12345678910//写数据&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;) %&gt;&lt;% request.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;) %&gt;&lt;% session.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;) %&gt;&lt;% application.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;) %&gt;//读数据&lt;%= pageContext.getAttribute(&quot;name&quot;) %&gt;&lt;%= request.getAttribute(&quot;name&quot;) %&gt;&lt;%= session.getAttribute(&quot;name&quot;) %&gt;&lt;%= application.getAttribute(&quot;name&quot;) %&gt; 第二类:不常用 exception =&gt; Throwable page =&gt; Object =&gt; 就是jsp翻译成java类的实例对象,就是在类中的this关键字 config =&gt; ServletConfig 第三类:常用 response =&gt; HttpServletResponse out =&gt; JspWriter 两者区别1234567891011&lt;% out.write(&quot;这是使用out对象输出的内容&quot;) %&gt;&lt;% response.getWriter().write(&quot;这是使用response对象输出的内容&quot;) %&gt;//得到的结果这是使用response对象输出的内容这是使用out对象输出的内容//背后逻辑1. 碰到out对象输出,会先将out的内容刷新到response的缓冲中2. 而response.getWriter会直接输出内容3. 这样,即使out代码写在前面,response代码写在后面,也会先输出response要输出的内容 EL表达式 为了简化jsp代码,具体一点就是为了简化在jsp里面写的那些java代码 主要用于取值工作 写法格式1$( 表达式 ) 具体使用取值方式如果是有下标的,使用[]的方式 123456&lt;% String[] a = &#123;&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;&#125;; pageContext.setAttribute(&quot;arr&quot;, a);%&gt;&lt;h3&gt;使用EL表达式取出作用域中数组的值&lt;/h3&gt;$&#123;arr[0]&#125;,$&#123;arr[1]&#125;,$&#123;arr[2]&#125;,$&#123;arr[3]&#125; 如果没有下标,使用.的方式 12345&lt;% pageContext.getAttribute(&quot;name&quot;);%&gt;&lt;h3&gt;使用EL表达式取出作用域中的值&lt;/h3&gt;$&#123;pageScope.name&#125; 取出4个作用域中存放的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt;&lt;% pageContext.setAttribute(\"name\", \"page1\"); request.setAttribute(\"name\", \"page2\"); session.setAttribute(\"name\", \"page3\"); application.setAttribute(\"name\", \"page4\");%&gt;&lt;h3&gt;按普通手段取值&lt;/h3&gt;&lt;% pageContext.getAttribute(\"name\"); request.getAttribute(\"name\"); session.getAttribute(\"name\"); application.getAttribute(\"name\");%&gt;&lt;h3&gt;使用EL表达式取出作用域中的值&lt;/h3&gt;$&#123;pageScope.name&#125;$&#123;requestScope.name&#125;$&#123;sessionScope.name&#125;$&#123;applicationScope.name&#125;&lt;% String[] a = &#123;\"aa\", \"bb\", \"cc\", \"dd\"&#125;; pageContext.setAttribute(\"arr\", a);%&gt;&lt;h3&gt;使用EL表达式取出作用域中数组的值&lt;/h3&gt;$&#123;arr[0]&#125;,$&#123;arr[1]&#125;,$&#123;arr[2]&#125;,$&#123;arr[3]&#125;&lt;% ArrayList list = new ArrayList(); list.add(\"11\"); list.add(\"22\"); list.add(\"33\"); list.add(\"44\"); pageContext.setAttribute(\"li\", list);%&gt;&lt;h3&gt;使用EL表达式取出作用域中集合的值&lt;/h3&gt;$&#123;li[0]&#125;,$&#123;li[2]&#125;,$&#123;li[3]&#125;,$&#123;li[4]&#125;&lt;% HashMap map = new HashMap(); map.put(\"name\", \"zhangsan\"); map.put(\"page\", 18); map.put(\"address\", \"beijing\"); pageContext.setAttribute(\"map\", map);%&gt;&lt;h3&gt;使用EL表达式取出作用域中集合的值&lt;/h3&gt;$&#123;map.name&#125;,$&#123;map.age&#125;,$&#123;map.address&#125;&lt;/body&gt; 没有指定作用域,此时取值顺序1234567891011121314151617&lt;body&gt;&lt;% pageContext.setAttribute(\"name\", \"page1\"); request.setAttribute(\"name\", \"page2\"); session.setAttribute(\"name\", \"page3\"); application.setAttribute(\"name\", \"page4\");%&gt;&lt;h3&gt;有指定作用域,就到对应作用域里找&lt;/h3&gt;$&#123;pageScope.name&#125;$&#123;requestScope.name&#125;$&#123;sessionScope.name&#125;$&#123;applicationScope.name&lt;h3&gt;没有指定作用域&lt;/h3&gt;&lt;h4&gt;先从pageContext里面找,不会在request里找,然后去session里面找,最后去application里面找&lt;/h4&gt;$&#123; name &#125;&lt;/body&gt; EL表达式的11个内置对象 JSP pageContext 作用域 pageScope requestScope sessionScope applicationScope 请求头 header headerValues 请求参数 param paramValues Cookie cookie 初始化参数 initParam JSTL定义和作用 JSP标准标签库,全称:JSP Standard Tag Library 简化jsp的代码编写,替换&lt;% %&gt;的写法,配合EL使用 项目中引入JSTL 复制jstl.jar和standard.jar文件到工程的WebContent/WEB-INF/lib目录下 在jsp页面上,使用taglib指令来引入标签库 注意:如果想支持EL表达式,那么引入的标签库必须选择1.1的版本,1.0的版本不支持EL表达式123&lt;!-- 在头中引入 --&gt;&lt;!-- 其中,prefix=\"c\"中的c可以任意值,但是有一定的习惯 --&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; 常用标签常用的标签 &lt;c:set&gt;&gt; &lt;c:if&gt; &lt;c:forEach&gt;&gt; 举例1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt;&lt;h1&gt;--------------------赋值操作-----------------------------&lt;/h1&gt;&lt;!-- 声明一个对象name,对象的值为zhangsan,存储到session 如果没有执行scop则默认是page作用域 --&gt;&lt;c:set var=\"name\" value=\"zhangsan\" scope=\"session\"&gt;&lt;/c:set&gt;$&#123;sessionScope.name &#125;&lt;h1&gt;--------------------条件语句-----------------------------&lt;/h1&gt;&lt;c:if test=\"\"&gt;&lt;/c:if&gt;&lt;c:set var=\"age\" value=\"18\" scope=\"session\"&gt;&lt;/c:set&gt;&lt;!-- test用以写判断条件,var用以存判断结果,scope用以设定作用域 --&gt;&lt;!-- 没有else --&gt;&lt;c:if test=\"$&#123; age &gt;= 6 &#125;\" var=\"flag\" scope=\"page\"&gt; 年龄大于5岁&lt;/c:if&gt;&lt;h1&gt;--------------------循环语句-----------------------------&lt;/h1&gt;&lt;!-- 从1开始遍历到10,步长为2,得到的结果复制给i,并且会存储到page域中 --&gt;&lt;c:forEach begin=\"1\" end=\"10\" var=\"i\" setp=\"2\"&gt; $&#123;i &#125;&lt;/c:forEach&gt;&lt;h1&gt;--------------------循环语句,遍历list--------------------&lt;/h1&gt;&lt;!-- items:表示遍历哪一个对象,注意这里必须写EL表达式 --&gt;&lt;!-- var:遍历出来的每一个元素用user去接受 --&gt;&lt;% ArrayList list = new ArrayList(); list.add(new User(\"zhangsan\", 18)); list.add(new User(\"lisi\", 28)); list.add(new User(\"wangwu\", 38)); list.add(new User(\"maliu\", 48)); list.add(new User(\"qianqi\", 58));%&gt;&lt;!-- items:表示遍历哪一个对象,注意这里必须写EL表达式 --&gt;&lt;!-- var:遍历出来的每一个元素用user去接受 --&gt;&lt;c:forEach var=\"user\" items=\"$&#123;list &#125;\"&gt; $&#123;user.name &#125; ---- $&#123;user.age &#125;&lt;/c:forEach&gt;&lt;/body&gt;","tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://zjinc36.github.io/tags/Servlet/"},{"name":"JSP/EL/JSTL","slug":"JSP-EL-JSTL","permalink":"https://zjinc36.github.io/tags/JSP-EL-JSTL/"},{"name":"Struts2","slug":"Struts2","permalink":"https://zjinc36.github.io/tags/Struts2/"}]},{"title":"Servlet中关于Cookie和Session的使用","date":"2019-06-27T23:43:11.000Z","path":"2019/06/28/Servlet中关于Cookie和Session的使用/","text":"Cookie什么是Cookie 饼干,其实就是一小份数据,是服务器给客户端,并且存储在客户端上的一份小数据 应用场景 自动登录,浏览记录,购物车等 为什么要使用Cookie http的请求是无状态的.客户端与服务端在通讯的时候,是无状态的,也就是说客户端第二次访问服务端的时候,服务端根本就不知道这个客户端以前是否有来过 从用户来讲:为了更好的用户体验,更好的交互[自动登录] 从公司来讲:可以更好的收集用户习惯[大数据] Cookie的使用123456789101112131415161718192021222324252627282930private void test02(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; //获取cookie Cookie[] cookies = req.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; System.out.println(cookie.getName() + \"=\" + cookie.getValue()); &#125; &#125; //新建cookie Cookie cookie = new Cookie(\"name\", \"zhangsan\"); //将cookie传给客户端 resp.addCookie(cookie); //给cookie添加有效期 //设置expiry的值 //正值 -&gt; 表示在这个数字之后,cookie将会失败 //负值 -&gt; 表示关闭浏览器,那么cookie就失效,默认值是-1 //没有设置有效期 -&gt; 关闭浏览器后,cookie就没有了 cookie.setMaxAge(60 * 60 * 24 * 7); //给cookie赋新的值 cookie.setValue(\"lisi\"); //用于指定只有请求了指定的域名,才会带上该cookie cookie.setDomain(\".address.com\"); //只有访问该域名下的cookieDemo的这个路径才会带cookie cookie.setPath(\"/CookieDemo\"); resp.getWriter().write(\"...\");&#125; Cookie的安全问题 由于Cookie会保存在客户端上,所以有安全隐患 cookie的大小与个数有限制 Session 会话,Session是基于Cookie的一种会话机制 Cookie是服务器返回一小份数据给客户端,并且存放在客户端 Session是将数据存放在服务端 Session的生命周期创建 如果在Servlet里面调用了request.getSession() 销毁 Session是存放在服务器的内存中的一份数据,当然可以持久话,即使关了浏览器session也不会销毁 关闭服务器 session会话过期时间默认30分钟,有效期过了,也就销毁了 Session常用API1234567891011121314protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); //得到会话id String id = session.getId(); //存值 session.setAttribute(\"name\", \"value\"); //取值 session.getAttribute(\"name\"); //移除值 session.removeAttribute(\"name\"); //销毁会话 session.invalidate();&#125; 简单的购物车例子1234567891011顺序: 商品列表 product_list.jsp | | 购物车逻辑 CarServlet.java | | 购物车展示页 cart.jsp | | 清空购物车逻辑 ClearCartServlet.java 1234567891011121314151617&lt;!-- product_list.jsp --&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"CartServlet?id=0\"&gt;&lt;h3&gt;Iphone7&lt;/h3&gt;&lt;/a&gt; &lt;a href=\"CartServlet?id=1\"&gt;&lt;h3&gt;小米&lt;/h3&gt;&lt;/a&gt; &lt;a href=\"CartServlet?id=2\"&gt;&lt;h3&gt;三星Note8&lt;/h3&gt;&lt;/a&gt; &lt;a href=\"CartServlet?id=3\"&gt;&lt;h3&gt;魅族7&lt;/h3&gt;&lt;/a&gt; &lt;a href=\"CartServlet?id=4\"&gt;&lt;h3&gt;华为9&lt;/h3&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*** CarServlet.java*/package com.zjinc36.servlet;import java.io.IOException;import java.util.HashMap;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class CarServlet */public class CartServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public CartServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=UTF-8\"); //1. 获取要添加到购物车的商品id int id = Integer.parseInt(request.getParameter(\"id\")); String[] names = &#123;\"Iphone7\", \"小米6\", \"三星Note8\", \"魅族7\", \"华为9\"&#125;; //2. 取到id对应的商品名称 String name = names[id]; //2. 获取购物车存放东西的session Map&lt;String, Integer&gt; HashMap&lt;String, Integer&gt; map = (HashMap&lt;String, Integer&gt;) request.getSession().getAttribute(\"cart\"); //session里面没有存放任何东西 if (map == null) &#123; map = new HashMap&lt;String, Integer&gt;(); request.getSession().setAttribute(\"cart\", map); &#125; //3. 判断购物车里面有没有该商品 if (map.containsKey(name)) &#123; // 在原来的值基础上 + 1 map.put(name, map.get(name) + 1); &#125; else &#123; map.put(name, 1); &#125; //4. 输出界面 response.getWriter().write(\"&lt;a href='product_list.jsp'&gt;&lt;h3&gt;继续购物&lt;/h3&gt;&lt;/a&gt;\"); response.getWriter().write(\"&lt;a href='cart.jsp'&gt;&lt;h3&gt;去购物车结算&lt;/h3&gt;&lt;/a&gt;\"); &#125;&#125; 123456789101112131415161718192021222324252627282930&lt;!-- cart.jsp --&gt;&lt;%@page import=\"java.util.HashMap\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;您的购物车&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;您的购物车的商品如下:&lt;/h2&gt; &lt;% //1. 先获取到map HashMap&lt;String, Integer&gt; map = (HashMap&lt;String, Integer&gt;)session.getAttribute(\"cart\"); //2. 遍历map if (map != null) &#123; for(String key : map.keySet()) &#123; int value = map.get(key); %&gt; &lt;h3&gt;名称:&lt;%=key %&gt;----数量&lt;%=value %&gt;&lt;/h3&gt;&lt;br&gt; &lt;% &#125; &#125; %&gt; &lt;a href=\"ClearCartServlet\"&gt;&lt;h4&gt;清空购物车&lt;/h4&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738package com.zjinc36.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** * Servlet implementation class ClearCartServlet */public class ClearCartServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public ClearCartServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); // 方法一 // 会话还在,数据清除了 session.removeAttribute(\"cart\"); // 方法二 // 会话直接就没了 //session.invalidate(); response.sendRedirect(\"cart.jsp\"); &#125;&#125;","tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://zjinc36.github.io/tags/Servlet/"}]},{"title":"Servlet中关于HttpServletRequest和HttpServletResponse的使用","date":"2019-06-27T23:15:01.000Z","path":"2019/06/28/Servlet中关于HttpServletRequest和HttpServletResponse的使用/","text":"HttpServletRequest作用这个对象封装了客户端提交过来的一切数据,包括 取得头信息 取得客户端提交上来的数据 使用 取得头信息 1234567891011protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 取出请求里面的头信息 Enumeration&lt;String&gt; headerNames = req.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String name = (String) headerNames.nextElement(); String value = req.getHeader(name); System.out.println(name + \"=\" + value); &#125;&#125; 取得客户端提交上来的数据 12345678910111213141516171819202122232425protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1. 获取客户端提交上来的数据 String name = req.getParameter(\"name\"); System.out.println(\"name=\" + name); String address = req.getParameter(\"address\"); System.out.println(\"address=\" + address); //2. 获取所有参数,得到枚举集合 //Enumeration&lt;String&gt; parameterNames = req.getParameterNames(); //3. 获取所有参数,得到一个Map集合 //这里Map&lt;String, String[]&gt;中,后一个是String[],表明是一个数组 //产生的原因是因为我们访问的时候是有如下可能的,只是我们一般不会这样写 //name=1&amp;name=2&amp;name=3 Map&lt;String, String[]&gt; map = req.getParameterMap(); Set&lt;String&gt; keySet = map.keySet(); //创建一个迭代器 Iterator&lt;String&gt; iterator = keySet.iterator(); while (iterator.hasNext()) &#123; String key = (String) iterator.next(); String value = map.get(key)[0]; System.out.println(key + \"=\" + value); &#125; &#125; 需要解决的问题处理中文乱码 方法一,在代码中进行转码 12345678910111213@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //get请求过来的数据,在url地址栏上就已经经过编码了,所以我们取到的就是乱码 //tomcat收到这批数据,getParameter默认使用ISO-8859-1去解码 //先让文字回到ISO-8859-1对应的字节数组,然后在按UTF-8组拼字符串 //getBytes(String charsetName): 使用指定的字符集将字符串编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 username = new String(username.getBytes(\"ISO-8859-1\"), \"UTF-8\"); password = new String(password.getBytes(\"ISO-8859-1\"), \"UTF-8\");&#125; 方法二,直接在tomcat中修改打开server.xml文件,在如下指定位置加上URIEncoding=&quot;UTF-8&quot; 1&lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 方法二：对请求头进行编码转换该方法只对POST方式提交的数据有效，对GET方式提交的数据无效! 1request.setCharacterEncoding(\"UTF-8\"); HttpServletResponse作用 负责返回数据给客户端 使用输出数据12345678910111213private void test01(HttpServletResponse resp) throws IOException &#123; // 以字符流的方式写数据 resp.getWriter().write(\"&lt;h1&gt;hello response...&lt;/h1&gt;\"); // 以字节流的方式写数据 resp.getOutputStream().write(\"hello\".getBytes());; // 设置当前这个请求的处理状态码 //resp.setStatus(\"\"); // 设置一个头 //resp.setHeader(name, value); // 设置响应的内容类型,以及编码 //resp.setContentType(type);&#125; 下载文件1234567891011121314151617181920212223242526272829303132private void test04(HttpServletRequest req, HttpServletResponse resp) throws FileNotFoundException, IOException &#123; // 1.获取要下载文件名称 String fileName = req.getParameter(\"filename\"); // 1.5 名字中带有中文 // 下载框中文件名是乱码或不显示的时候，往往是由于我们没有对中文文件名进行编码处理 // 针对浏览器类型，对文件名字做编码处理 Firefox (Base64) , IE、Chrome（UTF-8） String clientType = req.getHeader(\"User-Agent\"); if (clientType.contains(\"Firefox\")) &#123; fileName = DownLoadUtil.base64EncodeFileName(fileName); &#125; else &#123; fileName = URLEncoder.encode(fileName, \"UTF-8\"); &#125; // 2.获取这个文件在tomcat里面的绝对路径地址 String path = getServletContext().getRealPath(\"download/\" + fileName); // 3.转化成输入流 FileInputStream is = new FileInputStream(path); // 准备输出 // 4.准备输出流 ServletOutputStream os = resp.getOutputStream(); // 5.准备浏览器头,用以弹出下载框 resp.setHeader(\"Content-Disposition\", \"attachment; filename=\" + fileName); // 6.将输入流写到输出流 int len = 0; byte[] buffer = new byte[1024]; while ((len = is.read(buffer)) != -1) &#123; os.write(buffer, 0, len); &#125; os.close(); is.close();&#125; 123456789101112131415161718// 上述代码使用的工具类import java.io.UnsupportedEncodingException;import sun.misc.BASE64Encoder;public class DownLoadUtil &#123; public static String base64EncodeFileName(String fileName) &#123; BASE64Encoder base64Encoder = new BASE64Encoder(); try &#123; return \"=?UTF-8?B?\" + new String(base64Encoder.encode(fileName.getBytes(\"UTF-8\"))) + \"?=\"; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; 如果是中文文件下载,需要针对浏览器,对文件名字做编码处理 Firefox (Base64), IE和chrome使用URLEncoder 会出现的问题处理响应中文乱码问题 以字符流输出 -&gt; resp.getWriter() 123456789101112131415161718private void test02(HttpServletResponse resp) throws IOException &#123; //响应的中文乱码问题 //1. 指定输出到客户端的时候,这些文字使用UTF-8编码 //这里写出去的文字,默认使用的是ISO-8859-1,我们可以指定写出去的时候,使用什么编码写 resp.setCharacterEncoding(\"UTF-8\"); //2. 直接规定浏览器看这份数据的时候,使用什么编码来看 resp.setHeader(\"Content-Type\", \"text/html; charset=UTF-8\"); resp.getWriter().write(\"中文输出\");&#125;// resp.setCharacterEncoding(\"UTF-8\")和resp.setHeader(\"Content-Type\", \"text/html; charset=UTF-8\")可以合并成一句话// 即,可以用一句话来设置响应的数据类型private void test02(HttpServletResponse resp) throws IOException &#123; resp.setContentType(\"text/html;charset=UTF-8\"); resp.getWriter().write(\"中文输出\");&#125; 以字节流输出 -&gt; getOutputStream() 1234567891011121314151617private void test03(HttpServletResponse resp) throws IOException, UnsupportedEncodingException &#123; // 如果想让服务端出去的中文,在客户端能够正常显示,只要确保 // 出去的时候使用的编码和浏览器看这份数据使用的编码是一样的 // 1. 指定浏览器看这份数据使用的编码 resp.setHeader(\"Content-Type\", \"text/html; charset=UTF-8\"); // 2. 指定输出中文时使用的编码 // 默认情况下getOutputStream输出使用的是UTF-8码表 // 但为了确保万无一失,指定一下编码比较好 resp.getOutputStream().write(\"中文测试\".getBytes(\"UTF-8\"));// 可以使用一句话来设置响应的数据类型private void test03(HttpServletResponse resp) throws IOException, UnsupportedEncodingException &#123; resp.setContentType(\"text/html;charset=UTF-8\"); resp.getOutputStream().write(\"中文测试\".getBytes(\"UTF-8\"));&#125; 请求转发和重定向重定向什么是重定向 地址上显示的是最后的哪个资源的路径地址 请求次数最少有两次,服务器在第一次请求后,会返回302以及一个地址,浏览器再根据这个地址,执行第二次访问 可以跳转到任意路径,不是自己的工程也可以跳 效率稍微低一点,指向两次请求 后续的请求,没法使用上一次request对象,因为这是两次不同的请求 代码123456789101112131415161718192021 private void test02(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123; //1.获取数据 String userName = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //2.校验数据,并返回给客户端 PrintWriter pw = resp.getWriter(); if (\"admin\".equals(userName) &amp;&amp; \"123\".equals(password) ) &#123;// //之前的写法// //4.设置状态码// resp.setStatus(302);// //5.定位跳转的位置是哪一个页面// resp.setHeader(\"Location\", \"login_success.html\"); //重定向写法 resp.sendRedirect(\"login_success.html\"); &#125; else &#123; //失败,打印失败数据到网页 pw.write(\"login failed...\"); &#125; &#125; 请求转发什么是请求转发 地址栏上显示的是请求servlet的地址 请求次数只有一次,因为是服务器内部帮助客户端执行了后续的工作 只能跳转自己项目的资源路径 效率上稍微高一点,因为只执行一次请求 后续的请求,可以使用上一次request对象,因为只有一次请求 代码1234567891011121314private void test03(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException &#123; //1.获取数据 String userName = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //2.校验数据,并返回给客户端 PrintWriter pw = resp.getWriter(); if (\"admin\".equals(userName) &amp;&amp; \"123\".equals(password) ) &#123; req.getRequestDispatcher(\"login_success.html\").forward(req, resp); &#125; else &#123; //失败,打印失败数据到网页 pw.write(\"login failed...\"); &#125;&#125;","tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://zjinc36.github.io/tags/Servlet/"}]},{"title":"String直接赋值与使用new String的区别","date":"2019-06-27T16:18:36.000Z","path":"2019/06/28/String直接赋值与使用new-String的区别/","text":"原文标题:String直接赋值与使用new String的区别 原文链接:https://blog.csdn.net/weixin_41098980/article/details/80060200 在研究String直接赋值与new String的区别之前我们需要先了解java中的字符串常量池的概念 字符串常量池String类是我们平常项目中使用频率非常高的一种对象类型，jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符创常量池中。 使用String直接赋值String str = “abc”;可能创建一个或者不创建对象，如果”abc”在字符串池中不存在，会在java字符串池中创建一个String对象（”abc”），然后str指向这个内存地址，无论以后用这种方式创建多少个值为”abc”的字符串对象，始终只有一个内存地址被分配。==判断的是对象的内存地址，而equals判断的是对象内容。通过以下代码测试： 12345String str = \"abc\";String str1 = \"abc\";String str2 = \"abc\";System.out.println(str==str1);//trueSystem.out.println(str==str2);//true 也就是str、str1、str2都是指向同一个内存地址。 使用new String 创建字符串String str = new String(“abc”);至少会创建一个对象，也有可能创建两个。因为用到new关键字，肯定会在堆中创建一个String对象，如果字符池中已经存在”abc”,则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象。 12345String str = new String(\"abc\");String str1 = new String(\"abc\");String str2 = new String(\"abc\");System.out.println(str==str1);//falseSystem.out.println(str==str2);//false 可以看出来，str、str1、str2指向的是不同的内存地址 使用String拼接字符串项目中除了直接使用=赋值，也会用到字符串拼接，字符串拼接又分为变量拼接和已知字符串拼接 123456String str = \"abc\";//在常量池中创建abcString str1 = \"abcd\";//在常量池中创建abcdString str2 = str+\"d\";//拼接字符串，此时会在堆中新建一个abcd的对象，因为str2编译之前是未知的String str3 = \"abc\"+\"d\";//拼接之后str3还是abcd，所以还是会指向字符串常量池的内存地址System.out.println(str1==str2);//falseSystem.out.println(str1==str3);//true 所以在项目中还是不要使用new String去创建字符串，最好使用String直接赋值。","tags":[{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"}]},{"title":"HTTP Method GET Is Not Supported by This URL错误","date":"2019-06-27T10:18:25.000Z","path":"2019/06/27/HTTP-method-GET-is-not-supported-by-this-URL/","text":"错误详情123456789HTTP Status 405 ? Method Not AllowedType Status ReportMessage HTTP method GET is not supported by this URLDescription The method received in the request-line is known by the origin server but not supported by the target resource.Apache Tomcat/8.5.39 (Ubuntu) 解决方案没有有效的doGet()方法,doGet()方法应该像下述方法一样核心在于,要将super.doGet(req, resp)注释掉 1234protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //注意,这里的super.doGet(req, resp)要进行注释 //super.doGet(req, resp);&#125;","tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://zjinc36.github.io/tags/Servlet/"}]},{"title":"Servlet与ServletConfig与ServletContext的使用","date":"2019-06-26T09:16:47.000Z","path":"2019/06/26/Servlet与ServletConfig与ServletContext的使用/","text":"Servlet是什么? 其实就是一个java程序,运行在我们的web服务器上,用于接收和响应客户端的http请求 更多的是配合动态资源来做,当然静态资源也需要使用到Servlet,只不过是Tomcat里面已经定义好了一个 DefaultServlet Hello Servlet 写一个web工程,要有一个服务器 -&gt; 参见Eclipse配置Tomcat 测试运行web工程 在Java Resource/src下新建一个类,实现Servlet接口 12345678910111213141516171819202122232425262728293031323334package com.itheima.servlet;import java.io.IOException;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class HelloServlet implements Servlet &#123; @Override public void destroy() &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void init(ServletConfig config) throws ServletException &#123; &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(\"Hello\"); &#125;&#125; 配置Servlet,用于告诉服务器,我们的应用有这么个Servlet 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;HelloWeb&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 向tomcat报告,我这个应用里面有这个servlet,名字和具体路径 --&gt; &lt;servlet&gt; &lt;!-- 名字 --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- 具体路径 --&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册servlet映射 servletName:找到上面注册的具体servlet url-pattern:在地址栏上的path --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Servlet执行过程 找到Tomcat应用 找到项目 找web.xml,然后在web.xml里面找到url-pattern,有没有哪一个pattern的内容是/a 找到servlet-mapping中的那个servlet-name -&gt; [HelloServlet] 根据servlet-name找到servlet元素中的servlet-name中的[HelloServlet] 找到对应的class,然后开始创建该类的请求实例 执行对应class中的service方法 Servlet的通用写法1234567Servlet(接口) | |GenericServlet | |HttpServlet(用于处理http的请求) Servlet生命周期什么是生命周期 从创建到销毁的一段时间 生命周期方法 从创建到销毁,所调用的那些方法 init方法12345678910/** * 在创建该Servlet的实例时,就执行该方法 * 一个servlet只会初始化一次,init方法只会执行一次 * 默认情况下是:初次访问该servlet,才会创建实例 */@Overridepublic void init(ServletConfig config) throws ServletException &#123; // TODO Auto-generated method stub&#125; service方法12345678910/** * 只要客户端来了一个请求,那么就执行这个方法 * 该方法可以被执行很多次,一次请求,对应一次service方法的调用 */@Overridepublic void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; // TODO Auto-generated method stub&#125; destroy方法12345678910/** * servlet销毁的时候,就会执行该方法 * 1. 该项目从tomcat * 2. 正常关闭tomcat就会执行(shutdown.bat) */@Overridepublic void destroy() &#123; // TODO Auto-generated method stub&#125; 让Servlet创建实例的时机提前问题提出默认情况下,只有在初次访问servlet的时候,才会执行init方法.有的时候,我们可能需要在这个方法里面执行一些初始化工作,甚至做一些耗时的逻辑,那么这个时候,初次访问,可能会在init方法中逗留太久的时间.那么有没有方法可以让这个初始化的时机提前一点 解决方法在web.xml中配置的时候,使用&lt;load-on-startup&gt;元素,给定的数字越小,启动的时机就越早,一般不写负数,从2开始 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet03&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet03&lt;/servlet-class&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt; 使用ServletConfig作用 servlet的配置,通过这个对象,可以获取servlet在配置的时候一些信息 怎么写1234567891011121314151617&lt;!-- web.xml文件中的servlet的配置信息 --&gt;&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;HelloServletConfig&lt;/display-name&gt; &lt;servlet-name&gt;HelloServletConfig&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServletConfig&lt;/servlet-class&gt; &lt;!-- 可以添加初始化参数 --&gt; &lt;!-- 用config.getInitParameter(\"address\");函数获取 --&gt; &lt;init-param&gt; &lt;param-name&gt;address&lt;/param-name&gt; &lt;param-value&gt;beijing...&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServletConfig&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServletConfig&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 12345678910111213141516171819202122232425262728/*** 代码片段* ServletConfig,用以获取上述web.xml文件中对应的servlet配置信息*/protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); //ServletConfig,用以获取上述web.xml文件中对应的servlet配置信息 //1. 得到servlet配置对象,专门用于在配置中的servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name的文本内容 String servletName = config.getServletName(); System.out.println(servletName); //2. 可以获取具体的某一参数 String address = config.getInitParameter(\"address\"); System.out.println(address); System.out.println(\"-----------------------------\"); //3. 获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) &#123; String name = (String) names.nextElement(); System.out.println(\"name ===\" + name); &#125;&#125; 为什么需要有这个ServletConfig 未来我们自己开发的一些应用,使用到了一些技术,或者一些代码,我们不会,但是有人写出来了,它的代码放置在了自己的servlet类里面 刚好这个servlet里面需要一个数组或者叫做变量值,但是这个值不是固定的,所以要求使用到这个servlet的工资,在注册servlet的时候,必须要在web.xml里面,声明init-params Servlet配置方式看代码中的注释 全路径匹配1234567891011121314&lt;!-- web.xml文件 --&gt;&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;Demo&lt;/display-name&gt; &lt;servlet-name&gt;Demo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.zjinc36.servlet.Demo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo&lt;/servlet-name&gt; &lt;!-- 以 / 开始,要写的一模一样 --&gt; &lt;!-- 即浏览器要输入: http://localhost:8080/项目名称/aa/bb --&gt; &lt;url-pattern&gt;/aa/bb&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 路径匹配,前半段匹配123456789101112131415&lt;!-- web.xml文件 --&gt;&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;Demo&lt;/display-name&gt; &lt;servlet-name&gt;Demo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.zjinc36.servlet.Demo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo&lt;/servlet-name&gt; &lt;!-- 以 / 开始,但是以 * 结束 --&gt; &lt;!-- `*`其实是一个通配符,匹配任意文字 --&gt; &lt;!-- localhost:8080/项目名称/aa/bb &lt;- 这里不限定/aa/bb,可以随意写 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 以扩展名匹配123456789101112131415&lt;!-- web.xml文件 --&gt;&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;Demo&lt;/display-name&gt; &lt;servlet-name&gt;Demo&lt;/servlet-name&gt; &lt;servlet-class&gt;com.zjinc36.servlet.Demo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo&lt;/servlet-name&gt; &lt;!-- 没有/,以*开始,\"*.扩展名\" --&gt; &lt;!-- `*`其实是一个通配符,匹配任意文字 --&gt; &lt;!-- localhost:8080/项目名称/aa/bb/cc.aa &lt;- 这里不限定/aa/bb,可以随意写,只要结尾以.aa为扩展名就行 --&gt; &lt;url-pattern&gt;*.aa&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ServletContext Servlet上下文 每个web工程只有一个servletContext对象.也就是说,不管在哪个servlet里面,获取到的这个类的对象都是同一个. 有什么作用可以获取全局配置参数 web.xml文件,注意全局参数的位置 123456789101112131415161718192021222324252627282930&lt;!-- web.xml文件 --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;Demo3&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置全局参数 --&gt; &lt;!-- 全局参数:哪个Servlet都可以拿 --&gt; &lt;context-param&gt; &lt;param-name&gt;address&lt;/param-name&gt; &lt;param-value&gt;具体地址&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;Demo3&lt;/display-name&gt; &lt;servlet-name&gt;Demo3&lt;/servlet-name&gt; &lt;servlet-class&gt;com.zjinc36.servlet.Demo3&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Demo3&lt;/servlet-name&gt; &lt;url-pattern&gt;/Demo3&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; java的代码实现 1234567891011protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); // 1.获取对象 ServletContext context = getServletContext(); // 2.获取对应的参数 String address = context.getInitParameter(\"address\"); System.err.println(\"address=\" + address);&#125; 可以获取web应用中的资源 方式一:只取文件,自己手动转流 123456789101112131415161718192021/*** 先获取文件,在转换成流对象*/private void test01() throws FileNotFoundException, IOException &#123; //1.ServletContext对象 ServletContext context = getServletContext(); //2.获取给定的文件在服务器上面的绝对路径 //可以不给参数打印path,就能知道对应的根目录是哪个目录,从而能更清楚的写相对目录 String path = context.getRealPath(\"file/config.properties\"); //3.指定载入的数据源 //此处,如果想要获取web工程下的资源,用普通的FileInputStream写法不是OK的 //因为路径不对了,这里相对的路径,其实是根据jre来确定的. //由于我们这是一个web工程,jre后面会由tomcat管理,所以这里真正相对路径是tomcat里面的bin目录 //所以我们会用ServletContext对象来获取 InputStream is = new FileInputStream(path); //4.创建属性对象 Properties properties = new Properties(); properties.load(is); String name = properties.getProperty(\"name\"); System.out.println(\"name=\" + name);&#125; 方式二:直接将指定文件转化成流对象 123456789101112131415161718192021/*** 根据相对路径,直接获取流对象*/private void test02() &#123; try &#123; //1.ServletContext对象 ServletContext context = getServletContext(); //2.获取web工程下的资源,转化成流对象,前面隐藏当前工程的根目录 InputStream is = context.getResourceAsStream(\"file/config.properties\"); //3.创建属性对象 Properties properties = new Properties(); properties.load(is); String name = properties.getProperty(\"name\"); System.out.println(\"name=\" + name); is.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 方式三:直接将指定文件转化成流对象,但是不用到ServletContext对象 1234567891011121314151617181920/*** 根据相对路径,直接获取流对象* 不使用ServletContext对象*/private void test03() &#123; try &#123; //1.获取资源 //获取java文件的class, 然后获取到加载这个class到虚拟机中的那个类加载器对象 //此时的根路径在: wtpwebapps/项目名称/WEB-INF/classes InputStream is = this.getClass().getClassLoader().getResourceAsStream(\"../../file/config.properties\"); //2.创建属性对象 Properties properties = new Properties(); properties.load(is); String name = properties.getProperty(\"name\"); System.out.println(\"name=\" + name); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 存取数据,Servlet间共享数据(域对象)12345678910111213141516171819202122232425262728293031/*** 使用ServletContext存取数据*/protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取数据 String userName = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //2.校验数据,并返回给客户端 PrintWriter pw = resp.getWriter(); if (\"admin\".equals(userName) &amp;&amp; \"123\".equals(password) ) &#123; //成功 //3.保存数据,在多个Servlet之间共享 //获取ServletContext保存的count的数据 Object obj = getServletContext().getAttribute(\"count\"); int totalCount = 0; if (obj != null) &#123; totalCount = (int)obj; &#125; System.out.println(\"已知登录成功的次数是:\" + totalCount); //向ServletContext的CountServlet写入数据 getServletContext().setAttribute(\"count\", totalCount + 1); //4.设置状态码 resp.setStatus(302); //5.定位跳转的位置是哪一个页面 resp.setHeader(\"Location\", \"login_success.html\"); &#125; else &#123; //失败,打印失败数据到网页 pw.write(\"login failed...\"); &#125;&#125; ServletContext的生命周期何时创建 服务器启动的时候,会为托管的每一个web应用程序,创建一个ServletContext对象 何时销毁 从服务器移除托管,或者是关闭服务器 ServletContext的作用范围 只要在相同项目里面,都可以取.","tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://zjinc36.github.io/tags/Servlet/"}]},{"title":"Http协议","date":"2019-06-25T23:20:21.000Z","path":"2019/06/26/Http协议/","text":"什么是协议 双方在交互,通讯的时候,遵守的一种规范和规则 什么是Http协议 针对网络上的客户端与服务器,在执行http请求的时候,遵守的一种规范 其实就是规定了客户端在访问服务器的时候,要带上哪些东西.同时也规定了服务器返回数据的时候,要带上什么东西 Http的版本 1.0 -&gt; 请求数据,服务端返回后,将会断开链接 1.1 -&gt; 请求数据,服务器返回后,链接还会保持着,除非服务器或客户端有一端关掉.当然,也有一定的时间限制,如果都空着这个连接,那么后面会自己断掉 请求请求的数据里面包好三个部分:请求行,请求头,请求体以下述请求为例子 1234567891011121314151617181920//例子//对`http://localhost:8080/examples/servlets/servlet/RequestParamExample`进行抓包POST /examples/servlets/servlet/RequestParamExample HTTP/1.1Host: localhost:8080Connection: keep-aliveContent-Length: 37Cache-Control: max-age=0Origin: http://localhost:8080Upgrade-Insecure-Requests: 1DNT: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExampleAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,ja;q=0.6firstname=firstName&amp;lastname=lastName 请求行1234567//请求POST /examples/servlets/servlet/RequestParamExample HTTP/1.1//解释POST -&gt; 请求方式,以post去提交数据/examples/servlets/servlet/RequestParamExample -&gt; 请求的地址路径,就是要访问哪个地方HTTP/1.1 -&gt; 协议版本 请求头12345678910Accept:客户端向服务器表示,我能支持什么类型的数据Referer:真正请求的地址路径,全路径Accept-Language:支持语言格式User-Agent:用户代理,向服务器表明,当前来访客户信息Content-Type:提交的数据类型(application/x-www-form-urlencoded -&gt; 经过urlencoding编码的form表单数据)Accept-Encoding:压缩算法Host:主机地址Content-Length:数据长度Connection:keep-Alive 保存链接Cache-Control:对缓存的操作 请求体浏览器真正发送给服务器的数据发送的数据呈现的是key=value,如果存在多个数据,那么使用&amp; 1firstname=firstName&amp;lastname=lastName 响应响应的数据里面包含三个部分:响应行,响应头,响应体以如下响应数据为例 1234HTTP/1.1 200Content-Type: text/html;charset=UTF-8Content-Length: 692Date: Tue, 25 Jun 2019 15:39:28 GMT 响应行123456HTTP/1.1 200协议版本 HTTP/1.1状态码 -&gt; 表明一次交互到底是什么样结果的一个code 响应头1234Server:服务器是那一种类型Content-Type:服务器返回给客户端的内容类型Content-Length:返回的数据长度Date:通讯的日期,响应的时间 GET和POST请求POST 数据是以流的方式写过去,不会在地址栏上面显示 以流的方式写数据,所以数据大小没有限制 GET 会在地址栏后面拼接数据,所以有安全隐患.一般从服务器获取数据,并且客户端也不用提交上面数据的时候,可以使用GET 能够带的数据大小有限,1kb大小 GET和POST的区别 请求路径不同.POST请求,在url后面不跟上任何的数据,GET请求,在地址后面跟上数据 带上的数据不同.POST请求会使用流的方式写数据,GET请求是在地址栏上跟数据 由于POST请求使用流的方式写数据,所以一定需要一个Content-Length的头来说明数据的长度有多少 Web资源在http协议中,与web相关的资源,分为两类 静态资源 -&gt; html/js/css 动态资源 -&gt; servlet/jsp","tags":[{"name":"Http","slug":"Http","permalink":"https://zjinc36.github.io/tags/Http/"}]},{"title":"Ubuntu中添加用户到指定组","date":"2019-06-25T10:02:38.000Z","path":"2019/06/25/Ubuntu中添加用户到指定组/","text":"假定用户名为user1,组名为groupA 查看用户具体所在的组1groups user1 添加用户到指定用户组12345usermod -a -G groupA user1注意:一定要使用-a参数(代表append)如果没有使用该参数,会使你离开其他用户组，仅仅做为用户组groupA的成员","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"Eclipse配置Tomcat","date":"2019-06-24T23:40:15.000Z","path":"2019/06/25/Eclipse配置Tomcat/","text":"配置ServerUbuntu环境配置过程 在Servers里面(一般在正下方面板),右键-&gt;new-&gt;server-&gt;选择到apache分类-&gt;找到对应的tomcat版本,接着一步一步配置即可 配置完毕后,在server里面,右键刚才的服务器,然后open找到上面的Server Location,选择中间的Use Tomcat installation... 出现的问题tomcat文件分散在不同目录问题重现 1.在ubuntu中使用sudo apt get安装了apache tomcat9 2.使用Windows&gt; Preferences&gt; Server&gt; Runtime Environment将apache tomcat 9添加到eclipse中 3.从服务器视图启动服务器时出现Could not load the Tomcat server configuration at /Servers/Tomcat v9.0 Server at localhost-config. The configuration may be corrupt or incomplete.(无法在localhost-config的/ Servers / Tomcat v9.0服务器上加载Tomcat服务器配置。配置可能已损坏或不完整) 原因 用apt-get安装的tomcat9,文件并不在同一个位置,而Eclipse期望tomcat配置文件等都在同一个位置 文件需要具有必要的权限 解决12345cd /usr/share/tomcat9sudo ln -s /var/lib/tomcat9/conf confsudo ln -s /var/log/tomcat9 logssudo ln -s /etc/tomcat9/policy.d/03catalina.policy conf/catalina.policysudo chmod -R a + rwx /usr/share/tomcat9/conf 参考Could not load the Tomcat server configurationTOMCAT9 SERVER IN ECLIPSE WITH UBUNTU tomcat缺少backup目录启动Server时,报如下错误 Publishing the configuration… Error copying file to /usr/share/tomcat9/backup/catalina.policy: /usr/share/tomcat7/backup/catalina.policy (No such file or directory) /usr/share/tomcat7/backup/catalina.policy (No such file or directory) Error copying file to /usr/share/tomcat7/backup/catalina.properties: /usr/share/tomcat7/backup/catalina.properties (No such file or directory) /usr/share/tomcat7/backup/catalina.properties (No such file or directory) Error copying file to /usr/share/tomcat7/backup/context.xml: /usr/share/tomcat7/backup/context.xml (No such file or directory) /usr/share/tomcat7/backup/context.xml (No such file or directory) Error copying file to /usr/share/tomcat7/backup/server.xml: /usr/share/tomcat7/backup/server.xml (No such file or directory) /usr/share/tomcat7/backup/server.xml (No such file or directory) Error copying file to /usr/share/tomcat7/backup/tomcat-users.xml: /usr/share/tomcat7/backup/tomcat-users.xml (No such file or directory) /usr/share/tomcat7/backup/tomcat-users.xml (No such file or directory) Error copying file to /usr/share/tomcat7/backup/web.xml: /usr/share/tomcat7/backup/web.xml (No such file or directory) /usr/share/tomcat7/backup/web.xml (No such file or directory) 原因 这个错误通常在linux下或者osx下 而且tomcat目录不再当前user所属文件目录下 这时eclipse并没有权限到系统中tomcat安装目录下创建这样一个backup目录 解决我们可以自己手动建一个这样目录,然后赋予读写权限即可 12345678cd /usr/share/tomcat9/sudo mkdir backupsudo chmod 777 backup注意: 权限并非一定需要给到777 由于用apt-get安装的tomcat9大致分散在root组和tomcat组 所以,若能设置用户属于tomcat组,权限可以降低 tomcat缺少其他目录 如果在tomcat分散的目录有对应的目录就软链到/usr/share/tomcat9/目录 如果没有对应的目录,处理方式和上述tomcat缺少backup目录处理的方式相同","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://zjinc36.github.io/tags/Tomcat/"}]},{"title":"Tomcat发布项目","date":"2019-06-24T16:31:05.000Z","path":"2019/06/25/Tomcat发布项目/","text":"如何把一个项目发布到tomcat中目的如何能让其他的电脑访问我这台电脑上的资源 方法一:拷贝文件到webapps/ROOT底下 拷贝这个文件到webapps/ROOT底下,在浏览器里面访问 http://localhost:8080 -&gt; 其实对应的是webapps/ROOT目录 在webapps下面建一个文件夹,然后拷贝文件放置到这个文件夹中 http://localhost:8080/xml/ -&gt; 对应的是webapps/xml目录 http://localhost:8080/xml/example.xml访问xml目录的example.xml文件 方法二:配置虚拟路径 在conf/server.xml找到host元素节点 加入以下内容 123&lt;!-- docBase:项目的路径地址 --&gt;&lt;!-- path:对应的虚拟路径,一定要以`/`打头 --&gt;&lt;Context docBase='项目地址' path='/虚拟地址'&gt;&lt;/Context&gt;&gt; 在浏览器地址栏上输入:http://localhost:8080/a/person.xml会访问项目地址下的person.xml文件,而访问地址要加上a是由path决定的 方法三:配置虚拟路径 在tomcat/conf/catalina/localhost/目录下新建一个xml文件,名字可以自己定义,比如person.xml 在这个文件里面写入以下内容 12&lt;?xml versio='1.0' encoding='utf-8' ?&gt;&lt;Context docBase=\"D:\\abc\"&gt;&lt;/Context&gt;&gt; 在浏览器上面访问http://localhost:8080/person/xml的名字即可","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://zjinc36.github.io/tags/Tomcat/"}]},{"title":"Tomcat安装","date":"2019-06-24T15:56:03.000Z","path":"2019/06/24/Tomcat安装/","text":"Tomcat安装Windows中安装 直接解压,然后找到bin/startup.bat 可以安装 启动之后,如果能够正常看到黑窗口,表明已经成功安装,为了确保万无一失,最后在浏览器的地址栏上输入http://localhost:8080,如果有看到内容,就表明成功了 如果双击了startup.bat,看到一闪而过,一般都是JDK的环境变量没有配置 Ubuntu中安装 搜索tomcat apt-cache search tomcat 选择需要的版本,我安装的是tomcat9 sudo apt-get install tomcat9 后续 用apt-get安装,目录会比较分散 使用find / -name &quot;tomcat9&quot;能够显示出tomcat9安装在哪些目录 Tomcat目录介绍1234567bin -&gt; 包含了一些jar,bat文件.startup.batconf -&gt; tomcat的配置 server.xml web.xmllib -&gt; tomcat运行所需的jar文件logs -&gt; 运行的日志文件temp -&gt; 临时文件webapps -&gt; 发布到tomcat服务器上的项目,就存放在这个目录work -&gt; jsp翻译成java文件存放地","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://zjinc36.github.io/tags/Tomcat/"}]},{"title":"进程的描述和控制1","date":"2018-09-16T12:12:14.000Z","path":"2018/09/16/进程的描述和控制1/","text":"本章内容 前趋图和程序执行 进程的描述 进程控制 进程同步 经典进程的同步问题 进程通信 线程(Threads)的基本概念 线程的实现 2.1 前趋图和程序执行2.1.1 前趋图 作用:描述进程之间执行的前后关系 图中各种符号 结点:用于描述一个程序段或进程,乃至一条语句有向线段:用于描述两个结点之间存在的偏序或前趋关系 需要掌握的名词 前趋关系直接前趋直接后继初始结点终止结点重量 注意:前趋图不允许有循环,否则必然会产生不可能实现的前趋关系 2.1.2 程序执行程序的顺序执行 含义:仅当前一个程序段执行完后,才运行后一程序段 程序顺序执行时的特征 顺序性封闭性可再现性 程序的并发执行 含义 程序并发执行时的特征 间断性 失去封闭性 不可再现性:程序在并发执行时,由于失去了封闭性,其计算结果必将与并发程序的执行速度有关,从而使程序的执行失去了可再现性 2.2 进程的描述2.2.1 进程的定义和特征进程的定义 几种比较经典的定义 (1)进程是程序的一次执行 (2)进程是一个程序及其数据在处理机上顺序执行时所发生的活动 (3)进程是程序在一个数据集合上运行的过程,它是系统进行资源分配调度的一个独立单位 对传统OS中的进程定义为:进程是进程实体的运行过程,是系统进行资源分配和调度的一个独立单位 进程的特征 动态性 并发性 独立性 异步性","tags":[]},{"title":"Ubuntu中使用imwheel设置鼠标滚轮的速度","date":"2018-09-16T01:33:55.000Z","path":"2018/09/16/Ubuntu中控制鼠标滚动速度/","text":"问题换了个鼠标,想设置滚轮的速度,才发现Ubuntu是没有这个选项的 解决安装imwheel 安装流程安装1sudo apt-get install imwheel 配置 进入主目录 1cd 打开或创建.imwheelrc文件 1vim ~/.imwheelrc 粘贴如下内容 1234567&quot;.*&quot;None, Up, Button4, 3None, Down, Button5, 3Control_L, Up, Control_L|Button4Control_L, Down, Control_L|Button5Shift_L, Up, Shift_L|Button4Shift_L, Down, Shift_L|Button5 解释一下: 1234567+ 第一行:`.*`, 用来指定在哪些应用中生效+ 第二行,第三行: None, Up, Button4, 3 None, Down, Button5, 3 用来指定滚动的行数,其中 3 就代表默认滚动三行,且 3 是默认值+ 剩下的几行: 可以让鼠标支持Ctrl/Shift来决定上下滚动 启动1imwheel 后续很明显,这个必须加入到系统启动项去,才能开机就生效 1234567891. 打开profile文件 vim ~/.profile // 如果是要给全局用户使用 // vim /etc/profile2. 增加如下语句(自己写的, 仅供参考) ps aux | grep imwheel | grep -v grep | awk &apos;&#123;print $2&#125;&apos; if [ $? &lt;= 0 ]; then imwheel fi","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"操作系统引论2","date":"2018-09-16T01:12:03.000Z","path":"2018/09/16/操作系统引论2/","text":"1.4.1处理及管理功能进程控制主要功能 为作业创建进程 撤销已结束的进程 控制进程在运行过程中的状态转换 为一个进程创建若干线程的功能和撤销(终止)已完成任务的线程 进程同步目的 使多个进程能有条不紊地运行,系统中必须设置进程同步机制,用于协调多个进程的运行 进程同步的方式 进程互斥方式:对临界资源(独占资源)进行访问,应该采用互斥方式 进程同步方式:在相互合作去完成共同任务的诸进程(线程)间,由同步机构对它们的执行顺序加以协调 如何实现进程同步 设置锁(一般写为W),锁打开的时候能对临界资源进行访问 进程通信目的 为在计算机中,为了加速应用程序的运行,常在系统中建立多个进程,并为一个进程建立多个线程,那么这些相互配合的进程之间,线程之间需要进行相互交换 通信方式 同一计算机系统,通常采用直接通信方式,即由源进程利用发送命令直接将消息(message)挂在目标进程的消息队列上,以后由目标进程利用接收命令从消息队列中取出 调度目的 由于资源是有限的,所以每个作业需要调度才能执行 调度方式 作业调度:从后备队列中按照一定的算法,选出若干个作业,为它们分配其必需的资源(首先是分配内存),在将它们调入内存后,便分别为它们建立进程,使它们都成为可能获得处理机的就绪进程,并按照一定的算法将它们插入就绪队列 进程调度:就是从进程就绪队列中选出一新进程,把处理机分配给它,并为它设置运行线程,使进程投入执行 1.4.2存储器管理功能内存分配内存分配的方式 静态分配方式:内存空间是在内存装入时确定的,在作业装入后的整个运行期间不允许作业在申请新的内存空间,也不允许作业在内存中”移动” 动态分配方式:内存空间同样是在内存装入时确定的,但是允许作业在运行过程中继续申请新的附加内存空间,同时也允许作业在内存中”移动” 内存分配的主要任务 内存分配数据结构:该结构记录内存空间的使用情况 内存分配功能:系统按照一定的算法为用户分配内存空间 内存回收功能:系统对用户不再需要的内存,通过用户释放内存请求,去完成系统的回收功能 内存保护内存保护的主要任务 确保每道用户程序都仅在自己的内存空间内运行,彼此互不干扰 绝不允许用户程序访问操作系统的程序和数据,也不允许用户程序转移到非共享的其他用户程序中去执行 简单的内存保护机制 –&gt; 越界检查 简单来讲:就是给你一块地盘,给你划好界限,越界就就打你 越界检查一般由硬件实现:若是由软件检查,每增加一条指令就必须增加多条指令去处理,会显著降低程序的运行速度地址映射 有三方面来讲 逻辑地址(相对地址)和地址空间 物理地址和内存空间 逻辑地址如何转换成物理地址 逻辑地址(相对地址)和地址空间 在多道程序环境下,每道程序经编译后,通常会形成若干个目标程序,这些目标程序在经过链接便形成了可装入程序,而每次形成可装入程序时,地址都从”0”开始标记,有这些地址所形成的地址范围称之为”地址空间”,其中的地址称为”逻辑地址”或”相对地址” 物理地址和内存空间 由内存能中一系列的单元所限定的地址范围称为”内存空间”,其中的地址称为”物理地址” 逻辑地址转换成物理地址 由上述表明,若程序A的逻辑地址0映射到物理地址0,那么程序B的逻辑地址0就不能映射到物理地址0,这样造成的逻辑地址与其内存地址并不相一致,所以需要”地址映射”将逻辑地址转成物理地址 内存扩充定义 内存扩充并非是从物理上去扩大内存的容量,而是借助于虚拟存储技术,从逻辑上扩充内存容量 实现的功能 请求调入功能 置换功能 请求调入功能 系统允许用户在仅装入部分用户程序和数据的情况下,便能启动该程序运行,在程序运行过程中,若发现要继续运行时所需的程序和数据尚未装入内存,可向OS发送请求,由OS从磁盘中将所需部分调入内存,以便继续运行 置换功能 内存不够用的时候,系统需要将内存中的一部分暂时不用的程序和数据调至硬盘上,腾出空间,给其他需要的用","tags":[]},{"title":"操作系统引论1","date":"2018-09-16T01:11:53.000Z","path":"2018/09/16/操作系统引论1/","text":"","tags":[]},{"title":"Ubuntu批量修改目录与文件权限","date":"2018-09-16T01:11:28.000Z","path":"2018/09/16/Ubuntu批量修改目录与文件权限/","text":"问题 家目录下,所有目录的”可运行”权限全部消失,但文件的权限还是正常的 现在要给目录重新赋予”可运行”权限,但又不能给文件”可运行”权限修改一个目录下所有文件权限1chmod -R 0755 &lt;要修改的目录&gt; 批量修改一个目录下所有文件的权限1find /usr/local -type d -exec chmod 0755 &#123;&#125; \\;","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"JVM从入门到精通_08_堆","date":"2018-08-25T16:32:33.000Z","path":"2018/08/26/JVM从入门到精通-08-堆/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 堆的核心概念堆针对一个JVM进程来说是唯一的，也就是一个进程只有一个JVM，但是进程包含多个线程，他们是共享同一堆空间的。一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。 Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。 堆内存的大小是可以调节的。 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。 -Xms10m：最小堆内存 -Xmx10m：最大堆内存 下图就是使用：Java VisualVM查看堆空间的内容，通过 jdk bin提供的插件《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated） 我要说的是：“几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。 因为还有一些对象是在栈上分配的 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。 也就是触发了GC的时候，才会进行回收 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。 堆内存细分Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Permanent Space永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区养老区+元空间 Young Generation Space新生区 Young/New 又被划分为Eden区和Survivor区 Tenure generation space 养老区 Old/Tenure Meta Space 元空间 Meta 约定：新生区 -&gt; 新生代 -&gt; 年轻代 、 养老区 -&gt; 老年区 -&gt; 老年代、 永久区 -&gt; 永久代 JDK1.8后堆空间内部从永久代替换成了元空间 证明 键入代码 12345678910111213141516171819public class SimpleHeap &#123; private int id;//属性、成员变量 public SimpleHeap(int id) &#123; this.id = id; &#125; public void show() &#123; System.out.println(\"My ID is \" + id); &#125; public static void main(String[] args) &#123; SimpleHeap sl = new SimpleHeap(1); SimpleHeap s2 = new SimpleHeap(2); int[] arr = new int[10]; Object[] arr1 = new Object[10]; &#125;&#125; JDK1.7 =&gt; 永久代 JDK1.8 =&gt; 元空间 证明堆空间指的是新生区+养老区的大小 “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize “-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize事实上设置的是新生区+养老区的大小,如下证明 键入如下代码 123456789101112131415/** * -Xms10m -Xmx10m */public class HeapDemo &#123; public static void main(String[] args) &#123; System.out.println(\"start...\"); try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"end...\"); &#125;&#125; 设置运行参数 使用Java VisualVM在终端输入jvisualvm打开Java VisualVM,切换到 设置堆内存大小与OOMJava堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。 “-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize “-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区中的内存大小超过“-xmx”所指定的最大内存时，将会抛出outofMemoryError异常。 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在ava垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。 默认情况下 初始内存大小：物理电脑内存大小/64 最大内存大小：物理电脑内存大小/4 设置堆空间大小的参数 手动设置堆空间大小 手动设置：-Xms600m -Xmx600m 开发中建议将初始堆内存和最大的堆内存设置成相同的值 1234567891011121314151617181920/** * 1. 设置堆空间大小的参数 * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小 * -X 是jvm的运行参数 * ms 是memory start * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小 */public class HeapSpaceInitial &#123; public static void main(String[] args) &#123; //返回Java虚拟机中的堆内存总量 long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024; //返回Java虚拟机试图使用的最大堆内存量 long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024; // 1. 打印Xms和Xmx参数的值 System.out.println(\"-Xms : \" + initialMemory + \"M\"); System.out.println(\"-Xmx : \" + maxMemory + \"M\"); &#125;&#125; 输出结果 为什么不是600M而是575M?因为伊甸园区+幸存者0区+幸存者1区中,实际上存对象的区是伊甸园区 + 幸存者0区或者幸存者1区,这和垃圾回收有关,涉及到复制算法,所以幸存者0区与幸存者1区始终有一个是空的 证明方式一运行上述代码的时候加入参数-XX:+PrintGCDetails,运行结果如下 证明方式二代码如下修改,并运行 12345678910111213141516public class HeapSpaceInitial &#123; public static void main(String[] args) &#123; //返回Java虚拟机中的堆内存总量 long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024; //返回Java虚拟机试图使用的最大堆内存量 long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024; // 使用jps / jstat -gc 进程id 查看时,不要那么快退出 try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 查看堆内存的内存分配情况 1jps -&gt; staat -gc 进程id 计算结果如下,得证 查看默认堆空间的大小 初始内存大小：物理电脑内存大小 / 64 最大内存大小：物理电脑内存大小 / 4 什么都没有设置 12345678910111213141516171819202122package com.atguigu.java;/** * 2. 默认堆空间的大小 * 初始内存大小：物理电脑内存大小 / 64 * 最大内存大小：物理电脑内存大小 / 4 */public class HeapSpaceInitial &#123; public static void main(String[] args) &#123; //返回Java虚拟机中的堆内存总量 long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024; //返回Java虚拟机试图使用的最大堆内存量 long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024; // 2. 证明默认情况下 // ==&gt; 初始内存大小：物理电脑内存大小/64 // ==&gt; 最大内存大小：物理电脑内存大小/4 System.out.println(\"系统内存大小为：\" + initialMemory * 64.0 / 1024 + \"G\"); System.out.println(\"系统内存大小为：\" + maxMemory * 4.0 / 1024 + \"G\"); &#125;&#125; OutOfMemory举例我们简单的写一个OOM例子 1234567891011/** * OOM测试 */public class OOMTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(true) &#123; list.add(999999999); &#125; &#125;&#125; 然后设置启动参数 1-Xms10m -Xmx:10m 运行后，就出现OOM了，那么我们可以通过VisualVM这个工具查看具体是什么参数造成的OOM 年轻代与老年代年轻代与老年代的基本说明存储在JVM中的Java对象可以被划分为两类： 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速 生命周期短的，及时回收即可 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致 Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen） 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）下面这参数开发中一般不会调整： Eden ：From ：to -&gt; 8 : 1 : 1 新生代：老年代 - &gt; 1 : 2 配置新生代与老年代在堆结构的占比。 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 当发现在整个项目中，生命周期长的对象偏多，那么就可以通过调整 老年代的大小，来进行调优 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8：1：1当然开发人员可以通过选项“-xx:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8 几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。（有些大的对象在Eden区无法存储时候，将直接进入老年代） 绝大部分的Java对象的销毁都在新生代进行了 IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。 可以使用选项”-Xmn”设置新生代最大内存大小 这个参数一般使用默认值就可以了。 为什么实际操作中Eden : From : to并不符合8 : 1 : 1的比例 看看实际跑代码时候Eden : From : to的比例123456789101112131415161718/** * -Xms600m -Xmx600m * * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2. * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8 * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略 （暂时用不到） * -Xmn:设置新生代的空间的大小。 （一般不设置） */public class EdenSurvivorTest &#123; public static void main(String[] args) &#123; System.out.println(\"我只是来打个酱油~\"); try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 设置-Xms600m -Xmx600m运行后查看jvisualvm,比例是6 : 1 : 1而不是8 : 1 : 1 为什么和官方文档的结论不同因为JVM有其他策略,比如就存在自适应的内存分配策略 网上很多文章说关闭自适应的内存分配策略就行关闭自适应的内存分配策略然而结果依旧是6 : 1 : 1 正确操作是强制配置-XX:SurvivorRatio=8,这样JVM其他会干涉到分配的机制都会不起作用,就能看到想要的结果了 图解对象分配过程概念为新对象分配内存是一件非常严谨和复杂的任务，JM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。 new的对象先放伊甸园区。此区有大小限制。 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区 然后将伊甸园中的剩余对象移动到幸存者0区。 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。 啥时候能去养老区呢？可以设置次数。默认是15次。 可以设置参数：-XX:MaxTenuringThreshold= &lt;N&gt; 进行设置 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。 图解过程我们创建的对象，一般都是存放在Eden区的，当我们Eden区满了后，就会触发GC操作，一般被称为 YGC / Minor GC操作 当我们进行一次垃圾收集后，红色的将会被回收，而绿色的还会被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，一次回收后就是1。 同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象 进行一次收集，把存活的对象放到 Survivor To区，同时让年龄 + 1 我们继续不断的进行对象生成 和 垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion晋升的操作，也就是将年轻代中的对象 晋升到 老年代中 思考：幸存区区满了后？特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作 如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代 举例：以当兵为例，正常人的晋升可能是 ： 新兵 -&gt; 班长 -&gt; 排长 -&gt; 连长 但是也有可能有些人因为做了非常大的贡献，直接从 新兵 -&gt; 排长 对象分配的特殊情况 代码演示对象分配过程我们不断的创建大对象 123456789101112131415161718192021import java.util.ArrayList;import java.util.Random;/** * -Xms600m -Xmx600m */public class HeapInstanceTest &#123; byte[] buffer = new byte[new Random().nextInt(1024 * 200)]; public static void main(String[] args) &#123; ArrayList&lt;HeapInstanceTest&gt; list = new ArrayList&lt;HeapInstanceTest&gt;(); while (true) &#123; list.add(new HeapInstanceTest()); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 然后设置JVM参数 1-Xms600m -Xmx600m 然后cmd输入下面命令，打开VisualVM图形化界面 1jvisualvm 然后通过执行上面代码，通过VisualGC进行动态化查看最终，在老年代和新生代都满了，就出现OOM 123Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at com.atguigu.java.chapter08.HeapInstanceTest.&lt;init&gt;(HeapInstanceTest.java:13) at com.atguigu.java.chapter08.HeapInstanceTest.main(HeapInstanceTest.java:17) 常用的调优工具 JDK命令行 Eclipse：Memory Analyzer Tool Jconsole Visual VM（实时监控 推荐~） Jprofiler（推荐~） Java Flight Recorder（实时监控） GCViewer GCEasy 总结 针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to 关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不再永久代和元空间进行收集 新生代采用复制算法的目的：是为了减少内碎片 Minor GC，MajorGC、Full GC Minor GC：新生代的GC Major GC：老年代的GC Full GC：整堆收集，收集整个Java堆和方法区的垃圾收集 我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW的问题 而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上 JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC） 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： 新生代收集（MinorGC/YoungGC）：只是新生代的垃圾收集 老年代收集（MajorGC/o1dGC）：只是老年代的圾收集。 目前，只有CMSGC会有单独收集老年代的行为。 注意，很多时候Major GC会和Fu11GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。 目前，只有G1 GC会有这种行为 整堆收集（FullGC）：收集整个java堆和方法区的垃圾收集。 Minor GC当年轻代空间不足时，就会触发MinorGC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。（每次Minor GC会清理年轻代的内存。） 因为Java对象大多都具备 朝生夕灭 的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。 Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 STW：stop the word Major GC指发生在老年代的GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了 出现了MajorGc，经常会伴随至少一次的Minor GC（但非绝对的，在Paralle1 Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程） 也就是在老年代空间不足时，会先尝试触发MinorGc。如果之后空间还不足，则触发Major GC Major GC的速度一般会比MinorGc慢10倍以上，STW的时间更长，如果Major GC后，内存还不足，就报OOM了 Full GC触发Fu11GC执行的情况有如下五种： 调用System.gc（）时，系统建议执行Fu11GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、survivor spacee（From Space）区向survivor spacel（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些 GC 举例我们编写一个OOM的异常，因为我们在不断的创建字符串，是存放在元空间的 1234567891011121314151617181920212223242526import java.util.ArrayList;import java.util.List;/** * 测试MinorGC 、 MajorGC、FullGC * -Xms9m -Xmx9m -XX:+PrintGCDetails */public class GCTest &#123; public static void main(String[] args) &#123; int i = 0; try &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); String a = \"atguigu.com\"; while (true) &#123; list.add(a); a = a + a; i++; &#125; &#125; catch (Throwable t) &#123; t.printStackTrace(); System.out.println(\"遍历次数为：\" + i); &#125; &#125;&#125; 设置JVM启动参数 1-Xms9m -Xmx9m -XX:+PrintGCDetails 打印出的日志 触发OOM的时候，一定是进行了一次Full GC，因为只有在老年代空间不足时候，才会爆出OOM异常 堆空间分代思想(能不能不分代?) 为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。 新生代：有Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。 其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。 内存分配策略内存分配策略基本说明如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。对象在survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代 对象晋升老年代的年龄阀值，可以通过选项-XX:MaxTenuringThreshold来设置 针对不同年龄段的对象分配原则如下所示： 优先分配到Eden 大对象直接分配到老年代 所谓大对象,一般指在内存空间是连续的,需要一个比较长的连续的内存空间对象 开发中比较长的字符串或者数组就属于大对象 尽量避免程序中出现过多的大对象 最痛苦的事情莫过于出现大对象,更痛苦的事情莫过于这个大对象是朝生夕死 因为大对象会直接分配到老年代，又由于老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢 长期存活的对象分配到老年代 动态对象年龄判断 如果survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。 空间分配担保 -XX:HandlePromotionFailure 大量对象经过Minor GC后存活,极端情况下经过Minor GC后，所有的对象都存活，此时又因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。而老年代要能容纳Survivor无法容纳的对象的前提是需要有空间进行容纳 证明大对象直接进入老年代12345678/** 测试：大对象直接进入老年代 * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails */public class YoungOldAreaTest &#123; public static void main(String[] args) &#123; byte[] buffer = new byte[1024 * 1024 * 20];//20m &#125;&#125; 设置JVM启动参数 1-Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails 打印出的日志 为对象分配内存：TLAB问题：堆空间都是共享的么？不一定，因为还有TLAB这个概念，在堆中划分出一块区域，为每个线程所独占 为什么有TLAB？TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 什么是TLAB从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。 在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间。 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1，当然我们可以通过选项“-Xx:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。 TLAB分配过程对象首先是通过TLAB开辟空间，如果不能放入，那么需要通过Eden来进行分配 判断TLAB是否启用 运行如下代码12345678910111213/** * 测试-XX:UseTLAB参数是否开启的情况:默认情况是开启的 */public class TLABArgsTest &#123; public static void main(String[] args) &#123; System.out.println(\"我只是来打个酱油~\"); try &#123; Thread.sleep(1000000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 判断TLAB是否启用 堆空间的参数设置小结 -XX：+PrintFlagsInitial：查看所有的参数的默认初始值 -XX：+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值） -Xms：初始堆空间内存（默认为物理内存的1/64） -Xmx：最大堆空间内存（默认为物理内存的1/4） -Xmn：设置新生代的大小。（初始值及最大值） -XX:NewRatio：配置新生代与老年代在堆结构的占比 -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例 -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄 -XX：+PrintGCDetails：输出详细的GC处理日志 打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc -XX:HandlePromotionFalilure：是否设置空间分配担保 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。I 如果大于，则此次Minor GC是安全的 如果小于，则虚拟机会查看-xx:HandlePromotionFailure设置值是否允担保失败。 如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的； 如果小于，则改为进行一次FullGC。 如果HandlePromotionFailure=false，则改为进行一次Ful1 Gc。 在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行FullGC。 堆是分配对象的唯一选择么？在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述： 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。 此外，前面提到的基于openJDk深度定制的TaoBaovm，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 逃逸分析逃逸分析基本说明如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。逃逸分析的基本行为就是分析对象动态作用域： 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。 参数设置在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析 如果使用的是较早的版本，开发人员则可以通过： 选项”-XX:+DoEscapeAnalysis”显式开启逃逸分析 通过选项”-xx:+PrintEscapeAnalysis”查看逃逸分析的筛选结果 逃逸分析举例没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧，也就是发生逃逸分析 123456public void my_method() &#123; V v = new V(); // use v // .... v = null;&#125; 针对下面的代码 123456public static StringBuffer createStringBuffer(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb;&#125; 如果想要StringBuffer sb不发生逃逸，可以这样写 123456public static String createStringBuffer(String s1, String s2) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); return sb.toString();&#125; 完整的逃逸分析代码举例 1234567891011121314151617181920212223242526272829303132333435363738/** * 逃逸分析 * 如何快速的判断是否发生了逃逸分析，大家就看new的对象是否在方法外被调用。 */public class EscapeAnalysis &#123; public EscapeAnalysis obj; /** * 方法返回EscapeAnalysis对象，发生逃逸 * @return */ public EscapeAnalysis getInstance() &#123; return obj == null ? new EscapeAnalysis():obj; &#125; /** * 为成员属性赋值，发生逃逸 */ public void setObj() &#123; this.obj = new EscapeAnalysis(); &#125; /** * 对象的作用于仅在当前方法中有效，没有发生逃逸 */ public void useEscapeAnalysis() &#123; EscapeAnalysis e = new EscapeAnalysis(); &#125; /** * 引用成员变量的值，发生逃逸 */ public void useEscapeAnalysis2() &#123; EscapeAnalysis e = getInstance(); // getInstance().XXX 发生逃逸 &#125;&#125; 结论开发中能使用局部变量的，就不要使用在方法外定义。 逃逸分析之代码优化使用逃逸分析，编译器可以对代码做如下优化： 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。 这句话不局限与JAVA语言 这句话的改成针对JAVA语言的表述为:对象可以不用存储在堆空间中,而是存储在栈空间中 栈上分配JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。 常见的栈上分配的场景 在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。 我们通过举例来说明 开启逃逸分析 和 未开启逃逸分析时候的情况 123456789101112131415161718192021222324252627/** * 栈上分配 * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails */class User &#123; private String name; private String age; private String gender; private String phone;&#125;public class StackAllocation &#123; public static void main(String[] args) throws InterruptedException &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) &#123; alloc(); &#125; long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start) + \" ms\"); // 为了方便查看堆内存中对象个数，线程sleep Thread.sleep(10000000); &#125; private static void alloc() &#123; User user = new User(); &#125;&#125; 设置JVM参数，表示未开启逃逸分析 1-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails 运行结果，同时还触发了GC操作 1花费的时间为：664 ms 然后查看内存的情况，发现有大量的User存储在堆中我们在开启逃逸分析 1-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails 然后查看运行时间，我们能够发现花费的时间快速减少，同时不会发生GC操作 1花费的时间为：5 ms 然后在看内存情况，我们发现只有很少的User对象，说明User发生了逃逸，因为他们存储在栈中，随着栈的销毁而消失 同步省略(锁消除)线程同步的代价是相当高的，同步的后果是降低并发性和性能。 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。 例如下面的代码 123456public void f() &#123; Object hellis = new Object(); synchronized(hellis) &#123; System.out.println(hellis); &#125;&#125; 代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成： 1234public void f() &#123; Object hellis = new Object(); System.out.println(hellis);&#125; 我们将其转换成字节码 分离对象和标量替换标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。 相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。 1234567891011public static void main(String args[]) &#123; alloc();&#125;class Point &#123; private int x; private int y;&#125;private static void alloc() &#123; Point point = new Point(1,2); System.out.println(\"point.x\" + point.x + \";point.y\" + point.y);&#125; 以上代码，经过标量替换后，就会变成 12345private static void alloc() &#123; int x = 1; int y = 2; System.out.println(\"point.x = \" + x + \"; point.y=\" + y);&#125; 可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。 那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。 我们通过举例来说明 开启标量替换 和 未开启标量替换 时候的情况 123456789101112131415161718192021222324252627/** * 标量替换测试 * -Xmx100m -Xms100m -XX:+DoEscapeAnalysis * -XX:+PrintGC =&gt; 逃逸分析开关 * -XX:-EliminateAllocations =&gt; 标量替换开关 */public class ScalarReplace &#123; public static class User &#123; public int id; public String name; &#125; public static void alloc() &#123; User u = new User();//未发生逃逸 u.id = 5; u.name = \"abc\"; &#125; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000000; i++) &#123; alloc(); &#125; long end = System.currentTimeMillis(); System.out.println(\"花费的时间为： \" + (end - start) + \" ms\"); &#125;&#125; 这里设置参数说明： 参数-server：启动Server模式，因为在server模式下，才可以启用逃逸分析。 参数-XX:+DoEscapeAnalysis：启用逃逸分析 参数-Xmx10m：指定了堆空间最大为10MB 参数-XX:+PrintGC：将打印Gc日志。 参数-XX：+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配 开启逃逸分析,不开启标量替换 1-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations 运行结果上述代码在主函数中进行了10000000次alloc。调用进行对象创建，由于User对象实例需要占据约16字节的空间，因此累计分配空间达到150MB左右,而我们设置了堆空间为100MB,所以必然会发生GC。 开启逃逸分析,开启标量替换 1-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations 运行结果 逃逸分析的不足 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JvM设计者的选择。据我所知，oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上(这是一个否定之否定的观点)。 小结年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。 老年代放置长生命周期的对象，通常都是从survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为MinorGc。 当GC发生在老年代时则被称为MajorGc或者FullGC。一般的，MinorGc的发生频率要比MajorGC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"JVM从入门到精通_07_本地方法栈","date":"2018-08-25T11:21:34.000Z","path":"2018/08/25/JVM从入门到精通-07-本地方法栈/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 本地方法栈Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。 本地方法栈，也是线程私有的。 允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。 本地方法是使用C语言实现的。 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。 它甚至可以直接使用本地处理器中的寄存器 直接从本地内存的堆中分配任意数量的内存。 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"JVM从入门到精通_06_本地方法接口","date":"2018-08-25T11:04:54.000Z","path":"2018/08/25/JVM从入门到精通-06-本地方法接口/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 什么是本地方法简单地讲，一个Native Methodt是一个Java调用非Java代码的接囗。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “c” 告知c++编译器去调用一个c的函数。 “A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现） 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。 代码举例说明Native方法是如何编写的 123456789101112/** * 本地方法 */public class IHaveNatives &#123; public native void Native1(int x); public native static long Native2(); private native synchronized float Native3(Object o); native void Native4(int[] ary) throws Exception;&#125; 需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外 为什么使用Native Method？Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。 与Java环境的交互有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。 与操作系统的交互JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun’s JavaSun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setpriority（）方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriorityo（）。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority（）ApI。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVw调用。 现状目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"JVM从入门到精通_05_虚拟机栈","date":"2018-08-21T15:49:02.000Z","path":"2018/08/21/JVM从入门到精通-05-虚拟机栈/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 先对虚拟机栈有一个整体认识虚拟机栈出现的背景由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆（heap）和Java栈（stack）？为什么？ 首先栈是运行时的单位，而堆是存储的单位 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。 堆解决的是数据存储的问题，即数据怎么放，放哪里 Java虚拟机栈是什么Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。 是线程私有的 生命周期生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了 作用主管Java程序的运行，它保存方法的局部变量(8种基本数据类型,对象的引用地址)、部分结果，并参与方法的调用和返回。 局部变量，它是相比于成员变量来说的（或属性） 基本数据类型变量 VS 引用类型变量（类、数组、接口） 栈的特点栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器(程序计数器是最快的,没人能超过它)。 JVM直接对Java栈的操作只有两个： 每个方法执行，伴随着进栈（入栈、压栈） 执行结束后的出栈工作 对于栈来说不存在垃圾回收问题（栈存在溢出的情况） 开发中遇到哪些异常？栈中可能出现的异常 Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 栈溢出异常:如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常(栈溢出异常)。 内存不足异常:如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 outofMemoryError 异常(内存不足异常)。 代码实现抛出栈溢出异常12345678910/** * 演示栈中的异常：StackOverflowError */public class StackErrorTest &#123; private static int count = 1; public static void main(String[] args) &#123; System.out.println(count++); main(args); &#125;&#125; 当栈深度达到9803的时候，就出现栈内存空间不足 设置栈内存大小 设置栈内存大小的参数我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度 12-Xss1m-Xss1k 代码验证1234567891011121314151617/** * 演示栈中的异常:StackOverflowError * @author shkstart * @create 2020 下午 9:08 * * 默认情况下：count : 11420 * 设置栈的大小： -Xss256k : count : 2465 */public class StackErrorTest &#123; private static int count = 1; public static void main(String[] args) &#123; System.out.println(count); count++; main(args); &#125;&#125; 再看看栈内部的结构栈的存储单位的基本说明栈中存储什么？ 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在。 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）,即方法和栈帧是一一对应关系,就是下图,也是前面出现的图。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。 JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class）。 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 下面写一个简单的代码 12345678910111213141516171819202122232425262728/** * 栈帧 */public class StackFrameTest &#123; public static void main(String[] args) &#123; method01(); &#125; private static int method01() &#123; System.out.println(\"方法1的开始\"); int i = method02(); System.out.println(\"方法1的结束\"); return i; &#125; private static int method02() &#123; System.out.println(\"方法2的开始\"); int i = method03();; System.out.println(\"方法2的结束\"); return i; &#125; private static int method03() &#123; System.out.println(\"方法3的开始\"); int i = 30; System.out.println(\"方法3的结束\"); return i; &#125;&#125; 输出结果为 123456方法1的开始方法2的开始方法3的开始方法3的结束方法2的结束方法1的结束 满足栈先进后出的概念，通过Idea的 DEBUG，能够看到栈信息 栈运行原理不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。 Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常(指的是没有处理的异常)。不管使用哪种方式，都会导致栈帧被弹出。 栈帧的内部结构每个栈帧中存储着： 局部变量表（Local Variables） 操作数栈（operand Stack）（或表达式栈） 动态链接（DynamicLinking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息 并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈能放多少个栈帧由栈帧的大小决定,而栈帧的大小主要由局部变量表和操作数栈决定的 局部变量表 分开来看:”局部变量”和”表” 局部变量就是变量分类中的一种 表,这里指的是一维的表,JVM中用数组进行实现,所以用索引的方式进行访问 局部变量表基本说明 局部变量表：Local Variables，被称之为局部变量数组或本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量,这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。(如下图,两种方式查看) 使用javap命令,查看class文件的反编译文件 使用前面文章安装的idea插件 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 关于Slot的理解 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。 局部变量表，最基本的存储单元是Slot（变量槽） 局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。 在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。 byte、short、char 在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。 long和double则占据两个slot。 JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量） 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。 Slot可以重复利用栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 静态变量与局部变量的对比变量的分类： 按数据类型分：基本数据类型、引用数据类型 按类中声明的位置分： 成员变量（类变量，实例变量）,在使用前都经历过默认初始化状态 类变量：linking的prepare阶段，给类变量默认赋值，初始化阶段给类变量显示赋值即静态代码块(如果有) 实例变量：随着对象创建，会在堆空间中分配实例变量空间，并进行默认赋值 局部变量：在使用前必须进行显式赋值，不然编译不通过。 123456789101112/*变量的分类：按照数据类型分：① 基本数据类型 ② 引用数据类型按照在类中声明的位置分：① 成员变量：在使用前，都经历过默认初始化赋值 类变量： linking的prepare阶段：给类变量默认赋值 ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值② 局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过 */public void test5Temp()&#123; int num; //System.out.println(num);//错误信息：变量num未进行初始化&#125; 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。 补充说明 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 操作数栈 操作数栈(Operand Stack)名词解释:这个栈是为了操作数据而存在的 栈可以用数组也可以用链表进行实现,操作数栈使用的是数组实现方式,数组实现栈之后就只能先进后出,而不再拥有索引 操作数栈基本说明 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack） 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop） 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈 比如：执行复制、交换、求和等操作 代码举例 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问 栈中的任何一个元素都是可以任意的Java数据类型 32bit的类型占用一个栈单位深度 64bit的类型占用两个栈单位深度 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。 代码追踪我们给定代码 12345public void testAddOperation() &#123; byte i = 15; int j = 8; int k = i + j;&#125; 使用javap 命令反编译class文件： javap -v 类名.class byte、short、char、boolean 内部都是使用int型来进行保存的 从上面的代码我们可以知道，我们都是通过bipush对操作数 15 和 8进行入栈操作 同时使用的是 iadd方法进行相加操作，i -&gt; 代表的就是 int，也就是int类型的加法操作 执行流程如下所示： 首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入栈。执行完后，让PC + 1，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置，我们可以看到局部变量表的已经增加了一个元素 为什么局部变量表不是从0开始的呢？ 其实局部变量表也是从0开始的，但是因为0号位置存储的是this指针，所以说就直接省略了 然后PC+1，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中 然后从局部变量表中，依次将数据放在操作数栈中 然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置 最后PC寄存器的位置指向10，也就是return方法，则直接退出方法 面试问题:i++和++i的区别1234567891011121314151617181920212223242526272829/*程序员面试过程中， 常见的i++和++i 的区别，放到字节码篇章时再介绍。 */public void add()&#123; //第1类问题： int i1 = 10; i1++; int i2 = 10; ++i2; //第2类问题： int i3 = 10; int i4 = i3++; int i5 = 10; int i6 = ++i5; //第3类问题： int i7 = 10; i7 = i7++; int i8 = 10; i8 = ++i8; //第4类问题： int i9 = 10; int i10 = i9++ + ++i9;&#125; 栈顶缓存技术(Top Of Stack Cashing)前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。 寄存器：指令更少，执行速度快 动态链接(Dynamic Linking)–指向运行时常量池的方法引用链接静态链接 符号引用到直接引用的转换在编译期间可以确定下来就称之为静态链接 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时，这种情况下调用方法的符号引用转换为直接引用的过程称之为静态链接 动态链接动态链接基本说明 符号引用到直接引用的转换在编译期间无法确定下来就称之为动态链接 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用,包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。 比如：invokedynamic指令 动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区 动态链接作用 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Reference）保存在class文件的常量池里。 比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 面向对象,有多态,虚拟机该如何知道调用的是哪个方法 为什么需要运行时常量池？ 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，节省了空间 常量池的作用：就是为了提供一些符号和常量，便于指令的识别 绑定机制对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 代码说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.java2;/** * 说明早期绑定和晚期绑定的例子 * @author shkstart * @create 2020 上午 11:59 */class Animal&#123; public void eat()&#123; System.out.println(\"动物进食\"); &#125;&#125;interface Huntable&#123; void hunt();&#125;class Dog extends Animal implements Huntable&#123; @Override public void eat() &#123; System.out.println(\"狗吃骨头\"); &#125; @Override public void hunt() &#123; System.out.println(\"捕食耗子，多管闲事\"); &#125;&#125;class Cat extends Animal implements Huntable&#123; public Cat()&#123; super();//表现为：早期绑定 &#125; public Cat(String name)&#123; this();//表现为：早期绑定 &#125; @Override public void eat() &#123; super.eat();//表现为：早期绑定 System.out.println(\"猫吃鱼\"); &#125; @Override public void hunt() &#123; System.out.println(\"捕食耗子，天经地义\"); &#125;&#125;public class AnimalTest &#123; public void showAnimal(Animal animal)&#123; animal.eat();//表现为：晚期绑定 &#125; public void showHunt(Huntable h)&#123; h.hunt();//表现为：晚期绑定 &#125;&#125; 调用指令说明在后文 表现为：早期绑定 表现为：晚期绑定 早晚期绑定的发展历史 面向过程只具备早期绑定 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。 Java中任何一个普通的方法其实都具备虚函数的特征(所谓虚函数的特征就是具备晚期绑定的特点,即在运行期才能确定下来)，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 Java中任何一个普通的方法其实都具备虚函数的特征,即Java中任何一个普通方法都能被继承,重写 Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法,这和我们认知相当,带final标记的方法是不能被重写的 方法调用在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 虚方法和非虚方法 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。 静态方法、私有方法、fina1方法、实例构造器、父类方法都是非虚方法。 其他方法称为虚方法。 子类对象的多态的使用前提 类的继承关系 方法的重写 调用指令虚拟机中提供了以下几条方法调用指令： 普通调用指令： 表明非虚方法 invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本 表明非虚方法 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令： invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。 invokednamic指令: JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现动态类型语言】支持而做的一种改进。 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。 Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。 动态类型语言和静态类型语言 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。 说的再直白一点就是 静态类型语言是判断变量自身的类型信息； 动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。 12Java：String info = &quot;mogu blog&quot;; (Java是静态类型语言的，会先编译就进行类型检查)JS：var name = &quot;shkstart&quot;; var name = 10; （运行时才进行检查） 方法重写的本质Java 语言中方法重写的本质： 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodsError异常。 IllegalAccessError介绍(非法访问异常)程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 虚方法表–提高方法的调用的效率虚方法表作用–提高方法的调用的效率 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 虚方法表什么时候被创建?虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。 如上图所示：如果类中重写了方法，那么调用的时候，就会直接在虚方法表中查找，否则将会直接连接到Object的方法中。 方法返回地址存放调用该方法的pc寄存器的值。 一个方法的结束，有两种方式： 正常执行完成 出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 当一个方法开始执行后，只有两种方式可以退出这个方法： 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口； 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。 在字节码指令中，返回指令包含ireturn（当返回值是boolean，byte，char，short和int类型时使用），lreturn（Long类型），freturn（Float类型），dreturn（Double类型），areturn(返回引用)。另外还有一个return指令声明为void的方法，实例初始化方法，类和接口的初始化方法使用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * * 返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、 * lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、 * 实例初始化方法、类和接口的初始化方法使用。 */public class ReturnAddressTest &#123; // 返回ireturn public boolean methodBoolean() &#123; return false; &#125; // 返回ireturn public byte methodByte() &#123; return 0; &#125; // 返回ireturn public short methodShort() &#123; return 0; &#125; // 返回ireturn public char methodChar() &#123; return 'a'; &#125; // 返回ireturn public int methodInt() &#123; return 0; &#125; // 返回lreturn public long methodLong() &#123; return 0L; &#125; // 返回freturn public float methodFloat() &#123; return 0.0f; &#125; // 返回dreturn public double methodDouble() &#123; return 0.0; &#125; // 返回areturn public String methodString() &#123; return null; &#125; // 返回areturn public Date methodDate() &#123; return null; &#125; // 返回return public void methodVoid() &#123; &#125;&#125; 在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。 方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 一些附加信息栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。 栈的相关面试题 举例栈溢出的情况？（StackOverflowError） 通过 -Xss设置栈的大小 调整栈大小，就能保证不出现溢出么？ 不能保证不溢出 分配的栈内存越大越好么？ 不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个空间是有限的。 垃圾回收是否涉及到虚拟机栈？ 不会 方法中定义的局部变量是否线程安全？ 具体问题具体分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 面试题 * 方法中定义局部变量是否线程安全？具体情况具体分析 * 何为线程安全？ * 如果只有一个线程才可以操作此数据，则必是线程安全的 * 如果有多个线程操作，则此数据是共享数据，如果不考虑共享机制，则为线程不安全 */public class StringBuilderTest &#123; // s1的声明方式是线程安全的 public static void method01() &#123; // 线程内部创建的，属于局部变量 StringBuilder s1 = new StringBuilder(); s1.append(\"a\"); s1.append(\"b\"); &#125; // 这个也是线程不安全的，因为有返回值，有可能被其它的程序所调用 public static StringBuilder method04() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"a\"); stringBuilder.append(\"b\"); return stringBuilder; &#125; // stringBuilder 是线程不安全的，操作的是共享数据 public static void method02(StringBuilder stringBuilder) &#123; stringBuilder.append(\"a\"); stringBuilder.append(\"b\"); &#125; /** * 同时并发的执行，会出现线程不安全的问题 */ public static void method03() &#123; StringBuilder stringBuilder = new StringBuilder(); new Thread(() -&gt; &#123; stringBuilder.append(\"a\"); stringBuilder.append(\"b\"); &#125;, \"t1\").start(); method02(stringBuilder); &#125; // StringBuilder是线程安全的，但是String也可能线程不安全的 public static String method05() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"a\"); stringBuilder.append(\"b\"); return stringBuilder.toString(); &#125;&#125; 总结一句话就是：如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。 运行时数据区，是否存在Error和GC？ 运行时数据区 是否存在Error 是否存在GC 程序计数器 否 否 虚拟机栈 是 否 本地方法栈 是 否 方法区 是（OOM） 是 堆 是 是","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"JVM从入门到精通_04_程序计数器","date":"2018-08-21T15:13:16.000Z","path":"2018/08/21/JVM从入门到精通-04-程序计数器/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 介绍JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。 作用PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。 既没有GC也没有OOM 代码演示我们首先写一个简单的代码 1234567public class PCRegisterTest &#123; public static void main(String[] args) &#123; int i = 10; int j = 20; int k = i + j; &#125;&#125; 然后将代码进行编译成字节码文件，我们再次查看 ，发现在字节码的左边有一个行号标识，它其实就是指令地址，用于指向当前执行到哪里。 1234567890: bipush 102: istore_13: bipush 205: istore_26: iload_17: iload_28: iadd9: istore_310: return 通过PC寄存器，我们就可以知道当前程序执行到哪一步了 两个问题使用PC寄存器存储字节码指令地址有什么用呢？换句话说,为什么使用PC寄存器记录当前线程的执行地址呢? 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 PC寄存器为什么被设定为私有的？我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。 这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。 CPU时间片CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。 在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"JVM从入门到精通_03_运行时数据区概述及线程","date":"2018-08-21T11:39:46.000Z","path":"2018/08/21/JVM从入门到精通-03-运行时数据区概述及线程/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 前言本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段 当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异(主要是方法区的不同)。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。 我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁 运行时数据区的完整图 Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区 其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。 另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 对于底下这张图,红色对应一个进程一份,灰色对应一个线程一份灰色的为单独线程私有的，红色的为多个线程共享的。即： 每个线程：独立包括程序计数器、栈、本地栈。 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）,一般意义上的方法区 关于线程间共享的说明每个JVM只有一个Runtime实例。即为运行时环境,相当于内存结构的中间的那个框框,运行时环境。 线程线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。 操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。 JVM系统线程如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。这些主要的后台系统线程在Hotspot JVM里主要是以下几个： 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持。 编译线程：这种线程在运行时会将字节码编译成到本地代码。 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理。","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"JVM从入门到精通_02_类加载子系统","date":"2018-08-20T17:18:40.000Z","path":"2018/08/21/JVM从入门到精通_02_类加载子系统/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 概述 完整图如下 英文版 中文版如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？ 类加载器 执行引擎 类加载器子系统作用类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。 ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射） class file存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。 class file加载到JVM中，被称为DNA元数据模板，放在方法区。 在.class文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。 类的加载过程例如下面的一段简单的代码 12345678/** * 类加载子系统 */public class HelloLoader &#123; public static void main(String[] args) &#123; System.out.println(\"我已经被加载啦\"); &#125;&#125; 它的加载过程是怎么样的呢? 完整的流程图如下所示 加载阶段细分 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载class文件阶段加载class文件的方式 从本地系统中直接加载 通过网络获取，典型场景：Web Applet 从zip压缩包中读取，成为日后jar、war格式的基础 运行时计算生成，使用最多的是：动态代理技术 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 链接阶段验证 Verify 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证 文件格式验证 元数据验证 字节码验证 符号引用验证 工具：Binary Viewer查看如果出现不合法的字节码文件，那么将会验证不通过 同时我们可以通过安装IDEA的插件，来查看我们的Class文件安装完成后，我们编译完一个class文件后，点击view即可显示我们安装的插件来查看字节码方法了 准备 Prepare为类变量分配内存并且设置该类变量的默认初始值，即零值。 123456public class HelloApp &#123; private static int a = 1; // 准备阶段为0，在下个阶段，也就是初始化的时候才是1 public static void main(String[] args) &#123; System.out.println(a); &#125;&#125; 上面的变量a在准备阶段会赋初始值，但不是1，而是0。 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化； 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 解析 Resolve将常量池内的符号引用转换为直接引用的过程。 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等 初始化阶段 初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。 即,clinit方法会将我们的显示初始化和静态代码初始化合并显示在一起 也就是说，当我们代码中包含static变量的时候，才会有clinit方法 &lt;clinit&gt;()构造器方法中指令按语句在源文件中出现的顺序执行。 要注意,这里number变量的声明虽然可以卸载static代码块底下,但是我们不能打印,会报非法的前行引用错误 &lt;clinit&gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()） 任何一个类在声明后，都有生成一个构造器，默认是空参构造器 若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。 虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。 即:初始化后，只能够执行一次初始化，这也就是同步加锁的过程1234567891011121314151617181920212223public class DeadThreadTest &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"\\t 线程t1开始\"); new DeadThread(); &#125;, \"t1\").start(); new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"\\t 线程t2开始\"); new DeadThread(); &#125;, \"t2\").start(); &#125;&#125;class DeadThread &#123; static &#123; if (true) &#123; System.out.println(Thread.currentThread().getName() + \"\\t 初始化当前类\"); while(true) &#123; &#125; &#125; &#125;&#125; 上面的代码，输出结果为 123线程t2开始线程t1开始线程t2 初始化当前类 线程t2抢到初始化工作,但由于死循环出不来,会导致堵塞,是的线程t1无法进入 类加载器的分类分类规则 JVM支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示： ExtClassLoader继承ClassLoader AppClassLoader继承ClassLoader 这里的四者之间是包含关系，不是上层和下层，也不是子系统的继承关系 加载器的上下级关系的代码查看123456789101112131415161718192021222324public class ClassLoaderTest &#123; public static void main(String[] args) &#123; //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //获取其上层：扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@1540e19d //获取其上层：获取不到引导类加载器 ClassLoader bootstrapClassLoader = extClassLoader.getParent(); System.out.println(bootstrapClassLoader);//null //对于用户自定义类来说：默认使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。 ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(classLoader1);//null &#125;&#125; 得到的结果，从结果可以看出 根加载器无法直接通过代码获取，同时目前用户代码所使用的加载器为系统类加载器。同时我们通过获取String类型的加载器，发现是null，那么说明String类型是通过根加载器进行加载的，也就是说Java的核心类库都是使用根加载器进行加载的。 12345sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@677327b6nullsun.misc.Launcher$AppClassLoader@18b4aac2null 虚拟机自带的加载器启动类加载器（引导类加载器，Bootstrap ClassLoader） 这个类加载使用C/C++语言实现的，嵌套在JVM内部。 它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类 并不继承自ava.lang.ClassLoader，没有父加载器。 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 扩展类加载器（Extension ClassLoader） Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 应用程序类加载器（系统类加载器，AppClassLoader） javI语言编写，由sun.misc.LaunchersAppClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 通过classLoader#getSystemclassLoader()方法可以获取到该类加载器 用户自定义类加载器在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？ 隔离加载类 修改类加载的方式 扩展加载源 防止源码泄漏 用户自定义类加载器实现步骤 开发人员可以通过继承抽象类ava.1ang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。 用户自定义类加载器代码实现12345678910111213141516171819202122232425262728293031323334353637import java.io.FileNotFoundException;public class CustomClassLoader extends ClassLoader &#123; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; byte[] result = getClassFromCustomPath(name); if(result == null)&#123; throw new FileNotFoundException(); &#125;else&#123; return defineClass(name,result,0,result.length); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; throw new ClassNotFoundException(name); &#125; private byte[] getClassFromCustomPath(String name)&#123; //从自定义路径中加载指定类:细节略 //如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。 return null; &#125; public static void main(String[] args) &#123; CustomClassLoader customClassLoader = new CustomClassLoader(); try &#123; Class&lt;?&gt; clazz = Class.forName(\"One\",true,customClassLoader); Object obj = clazz.newInstance(); System.out.println(obj.getClass().getClassLoader()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 类加载器的加载路径1234567891011121314151617181920212223public class ClassLoaderTest1 &#123; public static void main(String[] args) &#123; System.out.println(\"**********启动类加载器**************\"); //获取BootstrapClassLoader能够加载的api的路径 URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for (URL element : urLs) &#123; System.out.println(element.toExternalForm()); &#125; //从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器 ClassLoader classLoader = Provider.class.getClassLoader(); System.out.println(classLoader); System.out.println(\"***********扩展类加载器*************\"); String extDirs = System.getProperty(\"java.ext.dirs\"); for (String path : extDirs.split(\";\")) &#123; System.out.println(path); &#125; //从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器 ClassLoader classLoader1 = CurveDB.class.getClassLoader(); System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@1540e19d &#125;&#125; 得到的结果 12345678910111213**********启动类加载器**************file:/usr/lib/jvm/java-8-oracle/jre/lib/resources.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/rt.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/sunrsasign.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/jsse.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/jce.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/charsets.jarfile:/usr/lib/jvm/java-8-oracle/jre/lib/jfr.jarfile:/usr/lib/jvm/java-8-oracle/jre/classesnull***********扩展类加载器*************/usr/lib/jvm/java-8-oracle/jre/lib/ext:/usr/java/packages/lib/extsun.misc.Launcher$ExtClassLoader@5cad8086 关于ClassLoaderClassLoader基本说明ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）sun.misc.Launcher 它是一个java虚拟机的入口应用 获取ClassLoader的途径 作用 代码 获取当前ClassLoader clazz.getClassLoader() 获取当前线程上下文的ClassLoader Thread.currentThread().getContextClassLoader() 获取系统的ClassLoader ClassLoader.getSystemClassLoader() 获取调用者的ClassLoader DriverManager.getCallerClassLoader() 代码说明12345678910111213141516171819public class ClassLoaderTest2 &#123; public static void main(String[] args) &#123; try &#123; //1. ClassLoader classLoader = Class.forName(\"java.lang.String\").getClassLoader(); System.out.println(classLoader); //2. ClassLoader classLoader1 = Thread.currentThread().getContextClassLoader(); System.out.println(classLoader1); //3. ClassLoader classLoader2 = ClassLoader.getSystemClassLoader().getParent(); System.out.println(classLoader2); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 双亲委派机制Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。 工作原理 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 双亲委派机制举例当我们加载jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI核心类，然后在加载SPI接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar的加载。 双亲委派机制的优势通过上面的例子，我们可以知道，双亲机制可以 避免类的重复加载 保护程序安全，防止核心API被随意篡改 自定义类：java.lang.String 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类） 沙箱安全机制自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\\lang\\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。 其它如何判断两个class对象是否相同在JVM中表示两个class对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名。 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。 JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。 类的主动使用和被动使用Java程序对类的使用方式分为：主动使用和被动使用。 主动使用，又分为七种情况： 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName(“com.atguigu.Test”)） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF getStatic、REF putStatic、REF invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"JVM从入门到精通_01_JVM与Java体系结构","date":"2018-08-20T14:14:10.000Z","path":"2018/08/20/JVM从入门到精通_01_JVM与Java体系结构/","text":"写在前面 系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记 是基于这个学习笔记进行修订 前言作为Java工程师的你曾被伤害过吗？你是否也遇到过这些问题？ 运行着的线上系统突然卡死，系统无法访问，甚至直接OOMM！ 想解决线上JVM GC问题，但却无从下手。 新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了 每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。 大部分Java开发人员，除会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。 一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。 计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言 架构师每天都在思考什么？ 应该如何让我的系统更快？ 如何避免系统出现瓶颈？ 知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？ 参与现有系统的性能优化，重构，保证平台性能和稳定性 根据业务场景和需求，决定技术方向，做技术选型 能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求 解决各类潜在系统风险，核心功能的架构与代码编写 分析系统瓶颈，解决各种疑难杂症，性能调优等 为什么要学习JVM 面试的需要（BATJ、TMD，PKQ等面试都爱问） 中高级程序员必备技能 项目管理、调优的需求 追求极客的精神 比如：垃圾回收算法、JIT（及时编译器）、底层原理 Java vs C++垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。C语言需要自己来分配内存和回收内存，Java全部交给JVM进行分配和回收。 推荐书籍 Java生态圈Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。 作为一个平台，Java虚拟机扮演着举足轻重的作用 Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分 作为灯种文化，Java几乎成为了“开源”的代名词。 第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。 就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。 作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。 每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过Java虚拟机进行运行和处理随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。 Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。 字节码我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。 Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式—Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。 多语言混合编程Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。 试想一下，在一个项目之中，并行处理用clojure语言编写，展示层使用JRuby/Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。 对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如Da Vinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。 Java发展的重大事件 1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为oak，后期命名为Java 1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。 1996年1月23日sun Microsystems发布了JDK 1.0。 1998年，JDK1.2版本发布。同时，sun发布了JSP/Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。 2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。 2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。 2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。 2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。 2006年，JDK6发布。同年，Java开源并建立了openJDK。顺理成章，Hotspot虚拟机也成为了openJDK中的默认虚拟机。 2007年，Java平台迎来了新伙伴Clojure。 2008年，oracle收购了BEA，得到了JRockit虚拟机。 2009年，Twitter宣布把后台大部分程序从Ruby迁移到scala，这是Java平台的又一次大规模应用。 2010年，oracle收购了sun，获得Java商标和最真价值的HotSpot虚拟机。此时，oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit 2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。 2017年，JDK9发布。将G1设置为默认Gc，替代CMS 同年，IBM的J9开源，形成了现在的open J9社区 2018年，Android的Java侵权案判决，Google赔偿oracle计88亿美元 同年，oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会 同年，JDK11发布，LTS版本的JDK，发布革命性的zGc，调整JDK授权许可 2019年，JDK12发布，加入RedHat领导开发的shenandoah GC在JDK11之前，oracleJDK中还会存在一些openJDK中没有的、闭源的功能。但在JDK11中，我们可以认为openJDK和oracleJDK代码实质上已经完全一致的程度。 虚拟机与Java虚拟机虚拟机所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。 大名鼎鼎的Visual Box，Mware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 Java虚拟机Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。 Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。 特点： 一次编译，到处运行 自动内存管理 自动垃圾回收功能 JVM的位置JVM是运行在操作系统之上的，它与硬件没有直接的交互Java的体系结构 JVM整体结构 HotSpot VM是目前市面上高性能虚拟机的代表作之一。 它采用解释器与即时编译器并存的架构。 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。执行引擎包含三部分：解释器，及时编译器，垃圾回收器 Java代码执行流程只是能生成被Java虚拟机所能解释的字节码文件，那么理论上就可以自己设计一套代码了 JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别： 基于栈式架构的特点 设计和实现更简单，适用于资源受限的系统； 避开了寄存器的分配难题：使用零地址指令方式分配。 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。 不需要硬件支持，可移植性更好，更好实现跨平台 基于寄存器架构的特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。 指令集架构则完全依赖硬件，可移植性差 性能优秀和执行更高效 花费更少的指令去完成一项操作。 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主方水洋 举例同样执行2+3这种逻辑操作，其指令分别如下： 基于栈的计算流程（以Java虚拟机为例）： 12345678iconst_2 //常量2入栈istore_1iconst_3 // 常量3入栈istore_2iload_1iload_2iadd //常量2/3出栈，执行相加istore_0 // 结果5入栈 而基于寄存器的计算流程 12mov eax,2 //将eax寄存器的值设为1add eax,3 //使eax寄存器的值加3 字节码反编译我们编写一个简单的代码，然后查看一下字节码的反编译后的结果 1234567/** */public class StackStruTest &#123; public static void main(String[] args) &#123; int i = 2 + 3; &#125;&#125; 然后我们找到编译后的 class文件，使用下列命令进行反编译 1javap -v StackStruTest.class 得到的文件为 12345678910111213141516171819202122232425public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: iconst_2 1: istore_1 2: iconst_3 3: istore_2 4: iload_1 5: iload_2 6: iadd 7: istore_3 8: return LineNumberTable: line 9: 0 line 10: 2 line 11: 4 line 12: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; 2 7 1 i I 4 5 2 j I 8 1 3 k I 小结由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpotVM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？ 栈 跨平台性 指令集小 指令多 执行性能比寄存器差 JVM生命周期虚拟机的启动Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。 程序开始执行时他才运行，程序结束时他就停止。 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 虚拟机的退出有如下的几种情况： 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统用现错误而导致Java虚拟机进程终止 某线程调用Runtime类或system类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。 JVM发展历程Sun Classic VM 早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。 这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。 如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。 现在hotspot内置了此虚拟机。 Exact VM为了解决上一个虚拟机问题，jdk1.2时，sun提供了此虚拟机。 Exact Memory Management：准确式内存管理 也可以叫Non-Conservative/Accurate Memory Management 虚拟机可以知道内存中某个位置的数据具体是什么类型。 具备现代高性能虚拟机的维形 热点探测（寻找出热点代码进行缓存） 编译器与解释器混合工作模式 只在solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换 HotSpot VMHotSpot历史 最初由一家名为“Longview Technologies”的小公司设计 1997年，此公司被sun收购； 2009年，Sun公司被甲骨文收购。 JDK1.3时，HotSpot VM成为默认虚拟机 目前Hotspot占有绝对的市场地位，称霸武林。 不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot Sun/oracle JDK和openJDK的默认虚拟机 因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的Gc机制。（比如其他两个商用虚机都没有方法区的概念） 从服务器、桌面到移动端、嵌入式都有应用。 名称中的HotSpot指的就是它的热点代码探测技术。 通过计数器找到最具编译价值代码，触发即时编译或栈上替换 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡 JRockit专注于服务器端应用 它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。 大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。 使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。 优势：全面的Java运行时解决方案组合 JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要 MissionControl服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。 2008年，JRockit被oracle收购。 oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。 高斯林：目前就职于谷歌，研究人工智能和水下机器人 IBM的J9全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9 市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。 目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。 2017年左右，IBM发布了开源J9VM，命名为openJ9，交给EClipse基金会管理，也称为Eclipse OpenJ9 OpenJDK -&gt; 是JDK开源了，包括了虚拟机 KVM和CDC / CLDC Hotspotoracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品目前移动领域地位尴尬，智能机被Angroid和ioS二分天下。 KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场 智能控制器、传感器 老人手机、经济欠发达地区的功能手机 所有的虚拟机的原则：一次编译，到处运行。 Azul VM前面三大“高性能Java虚拟机”使用在通用硬件平台上这里Azu1VW和BEALiquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机I 高性能Java虚拟机中的战斗机。 Azul VM是Azu1Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的ava虚拟机。 每个Azu1VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。 2010年，AzulSystems公司开始从硬件转向软件，发布了自己的zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。 Liquid VM高性能Java虚拟机中的战斗机。 BEA公司开发的，直接运行在自家Hypervisor系统上Liquid VM即是现在的JRockit VE（Virtual Edition）， Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。 随着JRockit虚拟机终止开发，Liquid vM项目也停止了。 Apache MarmonyApache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。 它是IElf和Inte1联合开发的开源JVM，受到同样开源的openJDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK 虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。 Micorsoft JVM微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。 只能在window平台下运行。但确是当时Windows下性能最好的Java VM。 1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软windowsXPSP3中抹掉了其VM。现在windows上安装的jdk都是HotSpot。 Taobao JVM由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。 基于openJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。 基于openJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。 创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且Gc不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升Gc的回收效率的目的。 GCIH中的对象还能够在多个Java虚拟机进程中实现共享 使用crc32指令实现JvM intrinsic降低JNI的调用开销 PMU hardware的Java profiling tool和诊断协助功能 针对大数据场景的ZenGc taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能 目前已经在淘宝、天猫上线，把oracle官方JvM版本全部替换了。 Dalvik VM谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。 Dalvik y只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范 不能直接执行Java的Class文件 基于寄存器架构，不是jvm的栈架构。 执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。 它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。 Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。 Graal VM2018年4月，oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。 GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。 如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。 总结具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以oracle HotSpot VM为默认虚拟机。","tags":[{"name":"JVM","slug":"JVM","permalink":"https://zjinc36.github.io/tags/JVM/"}]},{"title":"Java中的反射机制有什么用","date":"2018-07-09T11:09:03.000Z","path":"2018/07/09/Java中的反射机制有什么用/","text":"来源反射机制有什么用 说明反射不需要改代码只需要改配置文件而非反射方式，必须修改代码，而且要重新编译运行 step1:业务类首先准备两个业务类，这两个业务类很简单，就是各自都有一个业务方法，分别打印不同的字符串 Service1.java 12345678package reflection;public class Service1 &#123; public void doService1() &#123; System.out.println(\"业务方法1\"); &#125;&#125; Service2.java 12345678package reflection;public class Service2 &#123; public void doService2() &#123; System.out.println(\"业务方法2\"); &#125;&#125; step2:非反射方式当需要从第一个业务方法切换到第二个业务方法的时候，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果 调用Service1 12345678package reflection;public class Test &#123; public static void main(String[] args) &#123; new Service1().doService1(); &#125;&#125; 现在需要调用Service2,需要修改代码 1234567public class Test &#123; public static void main(String[] args) &#123;// new Service1().doService1(); new Service2().doService2(); &#125;&#125; step3:反射方式 使用反射方式，首先准备一个配置文件，就叫做spring.txt吧, 放在src目录下。 里面存放的是类的名称，和要调用的方法名。 1234// spring.txt内容class=reflection.Service1method=doService1 在测试类Test中，首先取出类名称和方法名，然后通过反射去调用这个方法。 当需要从调用第一个业务方法，切换到调用第二个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件spring.txt，再运行即可。 这也是Spring框架的最基本的原理，只是它做的更丰富，安全，健壮。 123456789101112131415161718192021222324252627282930313233package reflection; import java.io.File;import java.io.FileInputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties; public class Test &#123; @SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;) public static void main(String[] args) throws Exception &#123; //从spring.txt中获取类名称和方法名称 File springConfigFile = new File(\"e:\\\\project\\\\j2se\\\\src\\\\spring.txt\"); Properties springConfig= new Properties(); springConfig.load(new FileInputStream(springConfigFile)); String className = (String) springConfig.get(\"class\"); String methodName = (String) springConfig.get(\"method\"); //根据类名称获取类对象 Class clazz = Class.forName(className); //根据方法名称，获取方法对象 Method m = clazz.getMethod(methodName); //获取构造器 Constructor c = clazz.getConstructor(); //根据构造器，实例化出对象 Object service = c.newInstance(); //调用对象的指定方法 m.invoke(service); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"Ubuntu18.04安装ibus拼音输入","date":"2018-05-12T09:52:51.000Z","path":"2018/05/12/Ubuntu18-04安装ibus拼音输入/","text":"安装ibus 打开install/remove languages里面，勾选上chinese 安装iBus框架 1$ sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4 启动iBus框架 1$ im-config -s ibus 安装ibus拼音输入引擎 1$ sudo apt-get install ibus-pinyin 启用ibus-pinyin 1$ ibus-setup 在系统设置的区域与语言中添加iBus的智能拼音输入法如下图 输入法不生效怎么办Cannot input Chinese if only “Chinese (Intelligent Pinyin)” is set Try to clear the cache: rm ~/.cache/ibus/pinyin/* ~/.cache/ibus/libpinyin/* and then relogin.","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Zsh添加环境变量","date":"2018-05-10T19:09:39.000Z","path":"2018/05/11/Zsh添加环境变量/","text":"临时添加环境变量给 Linux/Unix 系统增加环境变量，是使用export命令。 永久增加环境变量为了永久性生效，则需要考虑加入到登录的profile中。 这个时候要考虑你当前使用的shell 对于默认的bash shell，则可编辑用户根目录下的隐藏文件./bash_profile 对于zsh 而言，需要编辑.zshrc这个文件 举例123vim ~/.zshrcexport PATH=/usr/local/python-2.7.6/bin:$PATH 解释： 环境变量中，各个值是以冒号分隔开的。上面的语句表示给 PATH 这个变量重新赋值，让它等于usr/local/python-2.7.6/bin,同时后面加上原来的 $PATH","tags":[{"name":"Linux配置","slug":"Linux配置","permalink":"https://zjinc36.github.io/tags/Linux配置/"}]},{"title":"Ubuntu的gnome的使用与常用扩展","date":"2018-05-06T10:26:32.000Z","path":"2018/05/06/Ubuntu的gnome的使用与常用扩展/","text":"gnome中的一些快捷键 Alt+F2 快速使用命令(r命令重启shell，rt命令重载shell主题） Alt+Space 可以弹出标题栏右键菜单 按住Alt键时关机按钮会变成暂停（suspend）按钮 鼠标滚轮/鼠标中键点击dock上的图标会打开一个程序的新窗口 按住Ctrl时鼠标左键点击dock上的图标会打开一个程序的新窗口 拖动窗口到屏幕左/右边缘（或按下win+左右箭头）会平铺该窗口到屏幕左/右 gnome3.24自带夜光功能，无需使用redshift或xflux 常用扩展AApplications Menu 提供的外观效果对于每位曾使用过GNOME 2的朋友来说都显得相当熟悉。它采用的默认应用启动器常见于以往几年中的各类主流Linux发行版。对我来说，调整启动器并不仅仅是为了找到以往的熟悉感觉，而是希望更快更轻松地找到自己需要的应用程序。这款方案能够对应用程序列表进行类别分组，并按应用名称排序而不仅显示对应图标。如此一来，我将能够更快地找到使用频繁较低的工具 开启application menu扩展可以在右上角添加分类程序菜单（默认alt+f1) CClipboard Indicato如果大家需要经常使用剪贴板，那么这项扩展绝对不可错过。在安装之后，Clipboard Indicator会出现在顶部面板当中，用以提供曾经复制至剪贴板的全部历史记录。只需要点击该标识而后选择要使用的文本内容，再配合Ctrl+V即可完成历史文本复制。 Calculator Button快速打开gnome-calculator计算器 DDrop down terminal能从屏幕边缘快捷唤出终端，不用时再按快捷键缩回去 dash-to-dockdock设置 EEasyScreenCast屏幕录像，做演示时比较方便 FgTile可以将窗口按不同的大小组合显示在屏幕上，当你有很多窗口需要一起显示的时候很有用 LLunar Calendar 农历显示农历 MMulti Monitors Add-On默认情况下，GNOME并不能充分利用额外的显示器——或者说效果并不能令人满意。默认的第二显示器缺少顶部面板，这意味着我们仍然需要通过第一显示器进行各类设置。这个扩展能够帮助我们添加此面板，设置缩略图、活动按钮以及对应的应用程序菜单 modern-calc右侧滑入滑出的计算器，装逼必备 NNotes Sticky notes for the GNOME Shell desktop gnome shell桌面的便签笔记 PPlaces Status Indicator添加菜单以快速导航系统中的位置 RRecent items在顶部面板中为最近使用的项添加一个图标; 点击清除列表; 左键单击：打开文件，右键单击：打开包含文件夹; 设置：项目数，“更多”项下的项目数和黑名单选项在extension.js的顶部定义. SScreenshot Tool屏幕截图工具，但是没有好用的编辑工具 TTop Panel Workspace Scroll自从开始使用 Linux 以来，我发现这套桌面的最佳特性就是能够提供高效的工作区。过去我们能够快速在不同工作区间往来切换，但如今的新版本却放弃了这一重要特性。好在 Top Panel Workspace Scroll 能够帮助我们重拾这一功能，通过鼠标滚轮或者触摸板双指操作完成工作区切换。 Todo.txtGTD应用，顶栏显示比较醒目","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"番茄工作法","date":"2018-04-22T11:58:09.000Z","path":"2018/04/22/番茄工作法/","text":"目标“番茄工作法”是一套简单易行的时间管理方法,用以提升你个人和所在团队的生产力,从而做到 减轻时间焦虑 集中注意力,减少中断 增强决策意识 唤醒激励和持久激励 巩固达成目标的决心 精确地预估工作量 改进工作学习流程 强化决断力,快刀斩乱麻 术语番茄钟 厨房定时器,用来衡量25分钟的时间段,在这段时间内专注于一项工作 工作法的名称来自与发明人最初使用的番茄形状计时器,也可以用电脑或手机软件计时器代替 活动 要完成的工作任务 番茄工作法适用于多种类型的活动,从软件开发者到学童,无论是组织聚会,管理项目或按时完成作业均有效 内部中断番茄钟时间内,来自自身的干扰,想要离开座位拿点喝的,或用一分钟刷刷网页 外部中断番茄时间内,在社交场合工作的人士会遇到,同学找你问作业,电脑提醒收到新邮件,即使消息等外界干扰 预估 定性预估:预测某项目由哪些活动组成 定量预估:某活动需要多少番茄钟完成 通过长期实践番茄工作法努力减少预估误差 所需工具 番茄钟一枚 铅笔一支(最好带橡皮) 纸制表格三张(白纸即可,横格纸更好) “今日待办”表格 “活动清单”表格 记录表格 基本方法规划活动 将近期要完成的活动全部填入”活动清单”表格 每天早晨,从其中选出数项要在今天进行的活动,抄入”今日待办”表格 开始工作 在”今日待办”表格选择一项要完成的任务 启动番茄钟,时间设定为25分钟 开始工作,直到番茄钟响铃 在”今日待办”表格上标一个x 休息片刻(3~5分钟) 开始下一个番茄钟,继续该任务,如此循环直到完成,在”今日待办”表格上划掉它 每四个番茄钟后,多休息一会(15~30分钟) 中断应用番茄工作法时,中断是难以避免的问题,如何处理中断? 内部终端 应使这一类中断清晰可见,每次你想要做其他活动,在要记录当前番茄钟的x位置旁边画一个撇号&#39; 在”今日待办”表格的”计划外紧急”区域记下这项活动,今天完成 或在”活动清单”表格记下这项活动,改天完成(标U代表”计划外”,如需要还可写上最后期限) 再接再厉完成当前番茄钟,直到番茄钟响铃 外部中断 应使这一类中断清晰可见,每次有人打断你的工作,在要记录当前番茄钟的x位置旁边画一个减号- 采取告知-协商-回电策略与中断者进行沟通 与前述内部中断相同的步骤,记下相关活动,继续完成当前番茄钟 多数看似紧急的外部中断,其实可以推迟25分钟或2小时(4个番茄钟)再来处理 番茄钟期间,可以关闭电子邮件和即使通讯软件 规则和技巧 番茄钟不可分割 如果一项活动要花费5~7番茄钟,则应拆分为更小的活动 如果一项活动花费不足1番茄钟,则可与其他活动合并 一旦番茄钟启动,就必须走到响铃 下一个番茄钟会更好 番茄工作法不要用于假期和休息期间的活动,好好享受生活","tags":[]},{"title":"Java中的Lambda表达式(匿名内部类)","date":"2018-04-09T21:01:09.000Z","path":"2018/04/10/Java中的Lambda表达式/","text":"演变过程调用外部类 外部类 12345678910Java中的Lambda表达式ckage com.zjinc36.lambda;public class ListenSong implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"一边听歌\"); &#125; &#125;&#125; 调用类 123456789package com.zjinc36.lambda;public class LambdaDemo &#123; public void run() &#123; new Thread(new ListenSong()).start(); &#125;&#125; 测试 123456789101112131415package com.zjinc36.lambda;import static org.junit.Assert.*;import org.junit.Test;public class LambdaDemoTest &#123; @Test public void test() &#123; LambdaDemo lambdaDemo = new LambdaDemo(); lambdaDemo.run(); &#125;&#125; 内部类由于上述的类只使用一次,因此可以将外部类放在内部类内,如下 12345678910111213141516package com.zjinc36.lambda;public class LambdaDemo &#123; public class ListenSong implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"一边听歌\"); &#125; &#125; &#125; public void run() &#123; new Thread(new ListenSong()).start(); &#125;&#125; 局部内部类我们还可以将外部类放在内部类的某一方法内,这里我们放到run方法内,如下 12345678910111213141516package com.zjinc36.lambda;public class LambdaDemo &#123; public void run() &#123; class ListenSong implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"一边听歌\"); &#125; &#125; &#125; new Thread(new ListenSong()).start(); &#125;&#125; 匿名内部类继续简化,由于我们只是用一次类,那么就没有必要创建类(也就是说不需要类的名字),故可以如下 1234567891011121314package com.zjinc36.lambda;public class LambdaDemo &#123; public void run() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"一边听歌\"); &#125; &#125; &#125;).start(); &#125;&#125; jdk8进一步简化内部类(Lambda)简化对于比较简单的逻辑,我们只需要关注传什么参数,实现什么东西就可以了,所以可以如下进一步简化(当然,这里要注意JDK的版本) 1234567891011package com.zjinc36.lambda;public class LambdaDemo &#123; public void run() &#123; new Thread(()-&gt; &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"一边听歌\"); &#125; &#125;).start(); &#125;&#125; 为什么能像上述那样进行简化 其实,我们并不能在代码的任何地方任性的写Lambda表达式,事实上,能够使用Lambda的依据是必须有相应的函数接口,这一点也跟Java是强类型语言吻合 也就是说,实际上Lambda的类型就是对应函数接口的类型 更具体来说,只有上下文提供的信息足够编译器推导出参数表的类型才不需要显示指明 Lambda的使用Lambda表达式中传入参数从外部类到jdk8简化lambda已经推到完了,接下去,说明需要传入参数该怎么写(与上述推到代码无关,直接写Lambda表达式) 123456789101112131415161718192021package com.zjinc36.lambda;import java.util.Arrays;import java.util.Collections;import java.util.List;public class LambdaDemo2 &#123; public void run() &#123; List&lt;String&gt; list = Arrays.asList(\"i\", \"love\", \"you\"); Collections.sort(list, (s1, s2) -&gt; &#123; if (s1 == null) &#123; return -1; &#125; if (s2 == null) &#123; return 1; &#125; return s1.length() - s2.length(); &#125;); &#125;&#125; 其他合法的写法省略花括号 代码 12345678910package com.zjinc36.lambda;public class LambdaDemo3 &#123; public void run() &#123; // 代码内容只有一行,可以省略花括号,并将所有内容写到同一行 Runnable run = () -&gt; System.out.println(\"Hello world\"); new Thread(run).start(); &#125;&#125; 测试 123456789101112131415package com.zjinc36.lambda;import static org.junit.Assert.*;import org.junit.Test;public class LambdaDemo3Test &#123; @Test public void test() &#123; LambdaDemo3 lambdaDemo2 = new LambdaDemo3(); lambdaDemo2.run(); &#125;&#125; 注意,多行代码不能省略花括号 1234Runnable multiLine = () -&gt; &#123;// 3 代码块 System.out.print(\"Hello\"); System.out.println(\" Hoolee\");&#125;; 一个参数一行代码12ActionListener listener = event -&gt; System.out.println(\"button clicked\"); 有返回值123BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y;// 4BinaryOperator&lt;Long&gt; addImplicit = (x, y) -&gt; x + y;// 5 类型推断 自定义函数接口简单的使用 自定义函数接口自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可12345// 自定义函数接口@FunctionalInterfacepublic interface ConsumerInterface&lt;T&gt;&#123; void accept(T t);&#125; 其中,@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范(就像加入@Override标注会检查是否重载了函数一样) 使用1ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str); 还可以这样使用123456789101112class MyStream&lt;T&gt;&#123; private List&lt;T&gt; list; ... public void myForEach(ConsumerInterface&lt;T&gt; consumer)&#123;// 1 for(T t : list)&#123; consumer.accept(t); &#125; &#125;&#125;MyStream&lt;String&gt; stream = new MyStream&lt;String&gt;();stream.myForEach(str -&gt; System.out.println(str));// 使用自定义函数接口书写Lambda表达式 参考关于Java Lambda表达式看这一篇就够了多线程_推导lambda_简化教程","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"设计模式之外观模式","date":"2018-02-26T23:09:40.000Z","path":"2018/02/27/设计模式之外观模式/","text":"外观模式参考 外观模式 外观模式（Facade Pattern） - 最易懂的设计模式解析 作用 通过创建一个统一的外观类，用来包装子系统中一个 / 多个复杂的类，客户端可通过调用外观类的方法来调用内部子系统中所有方法 引入外观角色之后，用户只需要与外观角色交互 用户与子系统之间的复杂逻辑关系由外观角色来实现 定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问,提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。 避免了系统与系统之间的高耦合度,实现客户类与子系统类的松耦合 使得复杂的子系统用法变得简单,降低原有系统的复杂度 UML图 Facade: 外观角色 SubSystem:子系统角色 使用步骤 创建子系统角色A 1234// 子系统角色Apublic class SystemA () &#123; public void operationA();&#125; 创建子系统角色B 1234// 子系统角色Bpublic class SystemB () &#123; public void operationB();&#125; 创建子系统角色C 1234// 子系统角色Cpublic class SystemC () &#123; public void operationC();&#125; 创建外观角色 123456789101112131415161718// 外观角色public class Facade() &#123; // 这一部分代码是调用子系统的代码,不一定这样写,像Spring里可以用自动载入\"@Autowried\"等注释进行注入,辨证的看就好 private SystemA systemA; private SystemB systemB; private SystemC systemC; public Facade (SystemA systemA, SystemB systemB, SystemC systemC) &#123; this.systemA = systemA; this.systemB = systemB; this.systemC = systemC; &#125; // 包裹操作 public void wrapOpration() &#123; systemA.operationA(); systemB.operationB(); systemC.operationC(); &#125;&#125; 调用 12345678910public static void main(String[] args) &#123; // 1. 实例化子系统(方法不唯一) SystemA systemA = new SystemA(); SystemB systemB = new SystemB(); SystemC systemC = new SystemC(); // 2. 创建外观角色 Facade facade = new Facade(systemA, systemB, systemC); // 3. 调用操作 facade.wrapOpration();&#125; 优点和缺点优点 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。 缺点 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 适用环境 当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。 客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zjinc36.github.io/tags/设计模式/"}]},{"title":"设计模式之装饰者模式","date":"2018-02-26T22:58:29.000Z","path":"2018/02/27/设计模式之装饰者模式/","text":"装饰者模式参考 装饰模式 学习、探究Java设计模式——装饰者模式 Java设计模式之装饰者模式(Decorator pattern) 装饰者模式（decorator）完全解析 作用给一个类或对象增加行为 模式动机一般有两种方式可以实现给一个类或对象增加行为： 继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。 关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。 定义 在不改变原类文件以及不使用继承的情况下，动态地将额外的职责(Responsibility)附加到对象上，从而实现动态拓展一个对象的功能。 它是通过创建一个包装对象，也就是装饰来包裹真实的对象。 其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。 根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。 UML图 Component: 抽象构件 ConcreteComponent: 具体构件 Decorator: 抽象装饰类 ConcreteDecorator: 具体装饰类 使用步骤 创建抽象构件用以保证装饰类和被装饰类都有一个相同的方法 123public abstract class Component () &#123; public void operation();&#125; 创建具体构建(被装饰类) 12345public class ConcreteComponent extends Component() &#123; public void operation() &#123; // do something ... &#125;&#125; 创建抽象装饰类 12345678public abstract class Decorator extends Component() &#123; private Component component; public Decorator (Component component) &#123; this.component = component; &#125; public void operation();&#125; 创建具体装饰类A 123456789public class ConcreteDecoratorA extends Decorator() &#123; public ConcreteDecoratorA (Component component) &#123; super(component); &#125; public void operation() &#123; // do something ... &#125;&#125; 创建具体装饰类B 123456789public class ConcreteDecoratorB extends Decorator() &#123; public ConcreteComponentB (Component component) &#123; super(component); &#125; public void operation() &#123; // do something ... &#125;&#125; 调用 12345678910111213public static void main(String[] args) &#123; // 1. 被装饰类 ConcreteComponent concreteComponent = new ConcreteComponent(); // 具体进行装饰写法 // 2. 具体装饰类A Decorator decorator = new ConcreteDecoratorA(concreteComponent); decorator.operation(); // 3. 具体装饰类A + B decorator = new ConcreteDecoratorB(new ConcreteDecoratorA(concreteComponent)); decorator.operation();&#125; 实例讲解背景 你有一家服装店，卖各式各样的衣服，现在需要用一个系统来记录客户所要购买的衣服的总价，以便方便地结算。那么在这个例子里面，我们可以用装饰者模式，把客户当做被装饰者，衣服是装饰者，这很直观形象，接着我们来一步步实现需求。 也就是说”用衣服装饰人”或者”将衣服穿在人身上” 实现 创建抽象构件用以保证装饰类和被装饰类都有一个相同的方法 1234// 这里我们可以将\"人\"抽象出来,这个\"人\"是对裸体的人,有穿衣服的人,戴首饰的人等的抽象public abstract class Person () &#123; public void show();&#125; 创建具体构建(被装饰类) 123456// 被装饰类表示的是一个全裸的人public class NakedPerson extends Person() &#123; public void show() &#123; return \"一丝不挂\"; &#125;&#125; 创建抽象装饰类 123456789// 抽象装饰类表示的是人身上的衣物public abstract class DressedPerson extends Person() &#123; private Person person; public Decorator (Person person) &#123; this.person = person; &#125; public void show();&#125; 创建具体装饰类A 123456789public class DressedCoatPerson extends DressedPerson() &#123; public DressedCoatPerson (Person person) &#123; super(person); &#125; public void show() &#123; return person.show + \"穿上衣\"; &#125;&#125; 创建具体装饰类B 123456789public class DressedPantsPerson extends DressedPerson() &#123; public DressedPantsPerson (Person person) &#123; super(person); &#125; public void show() &#123; return person.show + \"穿裤子\"; &#125;&#125; 调用 12345678910111213141516public static void main(String[] args) &#123; // 1. 被装饰类 // -&gt; 一丝不挂的人 NakedPerson nakedPerson = new NakedPerson(); // 具体进行装饰写法 // 2. 具体装饰类A // -&gt; 穿上衣 DressedPerson dressedPerson = new DressedCoatPerson(nakedPerson); system.out.println(decorator.show()); // 2. 具体装饰类A + B // -&gt; 穿上衣 + 穿裤子 decorator = new DressedPantsPerson(new DressedCoatPerson(nakedPerson)); system.out.println(decorator.show());&#125; 适用环境在以下情况下可以使用装饰模式： 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责 需要动态地给一个对象增加功能，这些功能也可以动态地被撤销当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长 第二类是因为类定义不能继承（如final类）. 要注意的问题装饰模式的简化-需要注意的问题: 一个装饰类的接口必须与被装饰类的接口保持相同，对于客户端来说无论是装饰之前的对象还是装饰之后的对象都可以一致对待 尽量保持具体构件类Component作为一个“轻”类，也就是说不要把太多的逻辑和状态放在具体构件类中 如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zjinc36.github.io/tags/设计模式/"}]},{"title":"设计模式之桥接模式","date":"2018-02-25T23:11:44.000Z","path":"2018/02/26/设计模式之桥接模式/","text":"桥接模式参考 桥接模式 Java设计模式之十五（桥接模式） UML图 Client:Bridge模式的使用者 Abstraction:抽象类接口（接口或抽象类）,维护对行为实现（Implementor）的引用 Refined Abstraction:Abstraction子类,具体抽象类 Implementor:行为实现类接口 (Abstraction接口定义了基于Implementor接口的更高层次的操作) ConcreteImplementor:Implementor子类 使用步骤 创建抽象类Abstraction 123456789101112131415161718// 抽象类public abstract class Abstraction() &#123; private Implementor pImp(); public Implementor getPImp() &#123; return pImp; &#125; public void setPImp(Implementor implementor) &#123; this.pImp = implementor; &#125; // 操作 public abstract void operation(); // 构造方法 public void Abstraction(Implementor implementor) &#123; this.pImp = implementor; &#125;&#125; 创建具体抽象类 1234567891011// 具体抽象类public abstract class RefinedAbstraction extends Abstraction() &#123; @Override public void operation() &#123; this.getPImp().operationImp(); &#125; public RefinedAbstraction(Implementor implementor) &#123; super(pImp); // 调用父类的构造方法 &#125;&#125; 创建实现类接口 12345// 实现类接口public interface Implementor() &#123; // 操作实施者 public void operationImp();&#125; 创建具体实现类A 1234567// 具体实施者Apublic class ConcreteImplementorA implement Implementor() &#123; @Override public void operationImp() &#123; // do something ... &#125;&#125; 创建具体实现类B 1234567// 具体实施者Bpublic class ConcreteImplementorB implement () &#123; @Override public void operationImp() &#123; // do something ... &#125;&#125; Client调用 123456789101112public class Client &#123; public static void main(String[] args) &#123; Implementor concreteImplementorA = new ConcreteImplementorA(); Implementor concreteImplementorB = new ConcreteImplementorB(); Abstraction refinedAbstraction = new RefinedAbstraction(concreteImplementorA); refinedAbstraction.operation(); Abstraction refinedAbstraction = new RefinedAbstraction(concreteImplementorB); refinedAbstraction.operation(); &#125;&#125; 具体实现 创建抽象类Abstraction 123456789101112131415161718// 抽象类// Car是对车进行抽象public abstract class Car &#123; private Engine engine; public Engine getEngine() &#123; return engine; &#125; public void setEngine(Engine engine) &#123; this.engine = engine; &#125; // 构造方法 public Car(Engine engine) &#123; this.engine = engine; &#125; // 操作 public abstract void runEngine();&#125; 创建具体抽象类 1234567891011121314// 具体抽象类// Bus是对巴士进行抽象,即也是抽象,但同时是Car的一部分,比Car具体一点public class Bus extends Car &#123; public Bus(Engine engine) &#123; super(engine); // 调用父类的构造方法 &#125; @Override public void runEngine() &#123; System.out.print(\"Bus\"); this.getEngine().installEngine(); &#125;&#125; 创建实现类接口 123456// 实现类接口public interface Engine &#123; // 操作实施者 // 安装发动引擎 public void installEngine();&#125; 创建具体实现类A 12345678// 具体实施者A// 引擎2200public class Engine2200 implements Engine &#123; @Override public void installEngine() &#123; System.out.println(\"安装2200CC发动引擎\"); &#125;&#125; 创建具体实现类B 12345678// 具体实施者B// 引擎2000public class Engine2000 implements Engine &#123; @Override public void installEngine() &#123; System.out.println(\"安装2000CC发动引擎\"); &#125;&#125; Client调用 123456789101112public class MainClass &#123; public static void main(String[] args) &#123; Engine engine2000 = new Engine2000(); Engine engine2200 = new Engine2200(); Car bus = new Bus(engine2000); bus.installEngine(); Car jeep = new Jeep(engine2200); jeep.installEngine(); &#125;&#125; 优点和缺点优点 分离抽象接口及其实现部分。 桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 实现细节对客户透明，可以对用户隐藏实现细节。 缺点 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。 应用场景 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zjinc36.github.io/tags/设计模式/"}]},{"title":"设计模式之适配器模式","date":"2018-02-25T22:39:51.000Z","path":"2018/02/26/设计模式之适配器模式/","text":"适配器模式参考 适配器模式（Adapter Pattern）- 最易懂的设计模式解析 适配器模式 作用把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作 模式动机 通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。 在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。 在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。 适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 分类适配器模式的形式分为： 类的适配器模式 对象的适配器模式 类的适配器模式是使用继承关系连接到Adaptee类,对象的适配器模式是使用委派关系连接到Adaptee类。 类的适配器模式UML图 Client:客户 Target:目标 Adapter:适配器 adaptee:适应者 UML图说明 冲突:Target期待调用Request方法,而这个方法在Adaptee并没有(这就是所谓不兼容) 解决方案:为使Target能够使用Adaptee类里的SpecificRequest方法,需要添加一个中间环节Adapter类,Adapter类继承Adaptee,同时实现Target接口,把Adaptee的API与Target的API衔接起来(适配) 使用步骤步骤1： 创建Target接口 123456public interface Target &#123; //这是源类Adapteee没有的方法 public void Request();&#125; 步骤2： 创建源类（Adaptee） 12345public class Adaptee &#123; public void SpecificRequest()&#123; &#125;&#125; 步骤3： 创建适配器类（Adapter） 1234567891011//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。public class Adapter extends Adaptee implements Target &#123; //目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request() //因此适配器补充上这个方法名 //但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容 //所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已 @Override public void Request() &#123; this.SpecificRequest(); &#125;&#125; 步骤4：定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 1234567// Client访问适配器public class AdapterPattern &#123; public static void main(String[] args)&#123; Target mAdapter = new Adapter()； mAdapter.Request(); &#125;&#125; 实例讲解背景 背景：小成买了一个进口的电视机 冲突：进口电视机要求电压（110V）与国内插头标准输出电压（220V）不兼容 解决方案：设置一个适配器将插头输出的220V转变成110V 具体实现步骤1： 创建Target接口 1234public interface Target &#123; // 进口电视需要一个110v的插座口 public void socket_110v();&#125; 步骤2： 创建源类（Adaptee） -&gt; 原来就具有的类 12345public class Adaptee &#123; public void socket_220v()&#123; &#125;&#125; 步骤3： 创建适配器类（Adapter） 1234567891011//适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。public class Adapter extends Adaptee implements Target &#123; // 1. 由于实现了接口,所以这个适配器会有一个110v的插座口 @Override public void socket_110v() &#123; // 2. 这个插座口的目的是复用原有的220v插座口 // 3. 由于继承了Adaptee,所以适配器类拥有220v插座口 this.socket_220v(); &#125;&#125; 步骤4：定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 1234567// Client访问适配器public class AdapterPattern &#123; public static void main(String[] args)&#123; Target mAdapter = new Adapter()； mAdapter.socket_110v(); &#125;&#125; 对象的适配器模式UML图 UML图说明在上图中可以看出： 冲突：Target期待调用Request方法，而Adaptee并没有（这就是所谓的不兼容了）。 解决方案：为使Target能够使用Adaptee类里的SpecificRequest方法，故提供一个中间环节Adapter（包装了一个Adaptee的实例），把Adaptee的API与Target的API衔接起来（适配）。 Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。 使用步骤（代码解析）步骤1： 创建Target接口； 1234public interface Target &#123; //这是源类Adapteee没有的方法 public void Request();&#125; 步骤2： 创建源类（Adaptee） ； 12345public class Adaptee &#123; public void SpecificRequest()&#123; &#125;&#125; 步骤3： 创建适配器类（Adapter）（不适用继承而是委派） 123456789101112131415class Adapter implements Target&#123; // 直接关联被适配类 private Adaptee adaptee; // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter (Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void Request() &#123; // 这里是使用委托的方式完成特殊功能 this.adaptee.SpecificRequest(); &#125;&#125; 步骤4：定义具体使用目标类，并通过Adapter类调用所需要的方法从而实现目标 1234567public class AdapterPattern &#123; public static void main(String[] args)&#123; //需要先创建一个被适配类的对象作为参数 Target mAdapter = new Adapter(new Adaptee())； mAdapter.Request(); &#125;&#125; 适配器优缺点优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 类适配器模式还具有如下优点： 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对象适配器模式还具有如下优点： 一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 缺点类适配器模式的缺点如下： 对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。 对象适配器模式的缺点如下： 与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 应用场景适配器的使用场景 系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们 类和对象适配器模式的使用场景灵活使用时：选择对象的适配器模式 类适配器使用对象继承的方式，是静态的定义方式； 而对象适配器使用对象组合的方式，是动态组合的方式。 需要同时配源类和其子类：选择对象的适配器 对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了； 对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 需要重新定义Adaptee的部分行为：选择类适配器 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 仅仅希望使用方便时：选择类适配器 对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 对于对象适配器，需要额外的引用来间接得到Adaptee。 总结建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zjinc36.github.io/tags/设计模式/"}]},{"title":"Ubuntu环境变量的位置与配置","date":"2018-02-08T21:12:03.000Z","path":"2018/02/09/Ubuntu环境变量的位置与配置/","text":"参考https://blog.csdn.net/netwalk/article/details/9455893https://blog.csdn.net/White_Idiot/article/details/78253004 Ubuntu环境变量在哪里Ubuntu Linux系统环境变量配置文件分为两种 系统级文件 用户级文件 系统级文件 /etc/profile:在登录时,操作系统定制用户环境时使用的第一个文件，此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。并从/etc/profile.d目录的配置文件中搜集shell的设置。这个文件一般就是调用/etc/bash.bashrc文件。 /etc/bash.bashrc：系统级的bashrc文件，为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. /etc/environment:在登录时操作系统使用的第二个文件,系统在读取你自己的profile前,设置环境文件的环境变量。 用户级文件 ~/.profile:在登录时用到的第三个文件 是.profile文件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! 默认情况下,他设置一些环境变量,执行用户的.bashrc文件。 ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。不推荐放到这儿，因为每开一个shell，这个文件会读取一次，效率 上讲不好。 ~/.bash_profile：每个用户都可使用该文件输入专用于自己 使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。.bash_profile是交互式,login 方式进入 bash 运行的.bashrc是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。 ~./bash_login:不推荐使用这个，这些不会影响图形界面。而且.bash_profile优先级比bash_login高。当它们存在时，登录shell启动时会读取它们。 ~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. ~/.pam_environment：用户级的环境变量设置文件。 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是”父子”关系。 查看环境变量查看环境变量有三个命令： env：env命令是environment的缩写，用于列出所有的环境变量； export：单独使用export命令也可以像env列出所有的环境变量，不过export命令还有其他额外的功能； echo $PATH：echo $PATH用于列出变量PATH的值，里面包含了已添加的目录。 设置环境变量设置环境变量通常有两种方式。 把你的路径加入PATH可以直接添加到环境变量PATH中。$PATH表示变量PATH的值，包含已有的目录。 这种方法需要注意路径的顺序，如果遇到有同名的命令，那么PATH里面哪个目录先被查询，则那个目录下的命令就会被先执行，如下所示： 12345# 加到PATH末尾export PATH=$PATH:/path/to/your/dir# 加到PATH开头export PATH=/path/to/your/dir:$PATH 命名一个新的环境变量也可以直接命名一个新的环境变量，用于其它程序引用： 1export VAR_NAME=value 作用域环境变量的作用域通常有三个。 用于当前终端打开一个终端，输入添加环境变量的语句： 1export CLASS_PATH=./JAVA_HOME/lib:$JAVA_HOME/jre/lib 终端所添加的环境变量是临时的，只适用于当前终端，关闭当前终端或在另一个终端中，添加的环境变量无效。 用于当前用户如果只需要添加的环境变量对当前用户有效，可以写入用户主目录下的.bashrc文件： 1234567vim ~/.bashrc# 添加语句：export CLASS_PATH=./JAVA_HOME/lib:$JAVA_HOME/jre/lib# 注销或者重启可以使修改生效，如果要使添加的环境变量马上生效：source ~/.bashrc 用于所有用户要使环境变量对所有用户有效，可以修改profile文件： 1234567sudo vim /etc/profile# 添加语句：export CLASS_PATH=./JAVA_HOME/lib:$JAVA_HOME/jre/lib# 注销或者重启可以使修改生效，如果要使添加的环境变量马上生效：source /etc/profile","tags":[{"name":"Linux配置","slug":"Linux配置","permalink":"https://zjinc36.github.io/tags/Linux配置/"}]},{"title":"Junit之Jacoco测试率覆盖工具","date":"2018-02-06T20:59:47.000Z","path":"2018/02/07/Junit之Jacoco测试率覆盖工具/","text":"介绍JaCoCoJava Code Coverage是一种分析单元测试覆盖率的工具，使用它运行单元测试后，可以给出代码中哪些部分被单元测试测到，哪些部分没有没测到，并且给出整个项目的单元测试覆盖情况百分比，看上去一目了然。 JaCoCo会生成以下指标的度量： Instructions (C0 Coverage)主要是计算字节码文件的覆盖率。 Branches (C1 Coverage)JaCoCo也计算分支覆盖所有if和 switch语句。主要是计算分支的。 没有覆盖：在该行没有分支机构已执行（红钻） 部分覆盖：只有在该行分支机构的一部分已经被执行（黄钻） 全覆盖：在该行各分支机构已执行（绿钻） Cyclomatic Complexity 圈复杂度(Cyclomatic Complexity)是一种代码复杂度的衡量标准。它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和维护。程序的可能错误和高的圈复杂度有着很大关系。请注意，JaCoCo不考虑异常处理的分支机构try-catch块也不会增加复杂性。总体和分支正相关。实际上，过去几年的各种研究已经确定：一个方法的圈复杂度（或 CC）大于 10 的方法存在很大的出错风险。 Lines主要计算基于覆盖的实际源代码行类和源文件行覆盖。通常会标识三种状态。 没有覆盖：在该行任何指令执行（红色背景） 部分覆盖：只有在该行的指示的一部分已经被执行（黄色背景） 全覆盖：在该行的所有指令已执行（绿色背景） Methods每个非抽象方法包含至少一个指令。构造函数和静态初始化都算作方法。 单元测试Eclipse插件EclEmmaEclEmma的安装 启动eclipse,点击Help菜单,Install New Software,在弹出的对话框中,点击Add 输入Name,例如EclEmma.输入Location:update.eclemma.org/ 在Work With处选择刚刚输入的Location地址 安装后重新启动eclipse,如果安装成功,工具栏上会出现一个新的按钮 EclEmma的使用 编写单元测试用例。现在支持以下测试： 123456789+ Local Java application+ Eclipse/RCP application+ Equinox OSGi framework+ JUnit test+ TestNG test+ JUnit plug-in test+ JUnit RAP test+ SWTBot test+ Scala application 以Junit为例,在测试用例文件上右键,选择Coverage As -&gt; Junit Test 会在测试的文件中显示出运行结果 123+ 绿色:完整执行+ 红色:没执行+ 黄色:部分执行 通过点击调出Coverage窗口,它是用来统计程序的覆盖测试率 点击红色矩形框的按钮能将多次测试的覆盖数据综合起来进行查看 在Coverage视图主区域中点击右键,出现的快捷菜单中选择Export Report... 出现Export界面,选项如下: 123+ Available session:要导出的session+ Format:选择报告的类型(HTML/XML/Text/EMMA session)+ Destination:导出的session存放的位置 IDEA插件无 运行时测试JaCoCo支持程序运行中监控执行情况.下面介绍直接运行和tomcat服务器两种监控方式. 准备在jacoco官网下载jacoco包,下载链接www.jacoco.org/jacoco/下载的包中包括三个jar,此处使用jacocoagent.jar和jacococli.jar 直接运行 假如直接运行的是test.jar,运行以下命令:java -javaagent:jacoco\\jacocoagent.jar=includes=*-jar test.jar 其中jacoco\\jacocoagent.jar处指的是准备中的jar包,后面为参数 相关参数参考https://www.jacoco.org/jacoco/trunk/doc/agent.html 待程序运行结束后,会在test.jar统计目录生成jacoco.exec文件,此文件为jacoco获取的运行情况文件. 获取需要分析的class文件,假设test.jar中的源代码生成的文件位于com文件夹中,将此文件夹放入和jacoco.exec同一文件夹下. 执行命令即可生成报告java -jar jacoco\\jacococli.jar report jacoco.exec --classfiles com --html report 此处jacoco\\jacococli.jar为准备中的jar包 report表明生成报告 jacoco.eexec为运行监控文件 --classfiles为生成报告正对的class文件 --html为报告格式 后一个report为报告文件夹 详细参数请参考https://www.jacoco.org/jacoco/trunk/doc/cli.html tomcat运行tomcat运行与直接运行的方式基本相同,唯一不同的是指明jacocoagent.jar的方式 windows下,在$TOMCAT_HOME/bin/catalina.bat的前面 Linux下,在$TOMCAT_HOME/bin/catalina.sh的前面增加如下设置set &quot;JAVA_OPTS=-javaagent:=jacoco\\jacocoagent.jar=includes=*&quot;如果在参数中未指明exec文件的生成路径,那么会在$TOMCAT_HOME/bin文件夹下生成,其余操作与上述相同","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"},{"name":"Junit","slug":"Junit","permalink":"https://zjinc36.github.io/tags/Junit/"}]},{"title":"Junit单元测试","date":"2018-01-19T16:12:07.000Z","path":"2018/01/20/Junit单元测试/","text":"参考 https://www.liaoxuefeng.com/wiki/1252599548343744/1255945269146912 https://blog.csdn.net/Dream_Weave/article/details/83860190 https://juejin.im/post/5c6ac82ee51d451b240a878a#heading-8 https://blog.csdn.net/10km/article/details/50282179 测试的分类 黑盒测试 白盒测试 压力测试 覆盖率测试 性能测试 单元测试什么是单元测试 单元测试就是针对最小的功能单元编写测试代码 而java程序的最小测试单元就是”方法” 单元测试就是针对单个java方法的测试 单元测试与测试驱动开发(TDD)基本流程如下 使用main方法测试的缺点 只能有一个main()方法,不能把测试代码分离 没有打印出测试结果和期望结果=&gt; 需要一种测试框架,帮我们编写测试 单元测试的好处 确保单个方法运行正常 如果修改了方法代码,只需确保其对应的单元测试通过 测试代码本身就可以作为示例代码 可以自动化运行所有测试并获得报告,报告不仅可以报告成功的测试和失败的测试,还能报告单元测试的覆盖率(即:有多少代码被测试了) Junit介绍Junit是一个开源的Java语言的单元测试框架 专门针对Java语言设计,使用最广泛 Junit是事实上的标准单元测试框架 Junit特点 使用断言(Assertion)测试期望结果 可以方便地组织和运行测试 可以方便地查看测试结果 常用IDE都继承了Junit 可以方便地集成到Maven Juint的设计 TestCase:一个TestCase表示一个测试 TestSuite:一个TestSuite包含一组TestCase,表示一组测试 TestFixture:一个TestFixture表示一个测试环境 TestResult:用于收集测试结果 TestRunner:用于运行测试 TestListener:用于监听测试结果,收集测试数据 Assert:用于断言测试结果是否正确 Juint版本说明 版本 Junit3.x Junit4 Junit5 JDK JDK &lt; 1.5 JDK &gt;= 1.5 JDK &gt;= 1.8 class class MyTest extends TestCase{} class MyTest{} class MyTest{} method public testAbc(){} @Test public abc(){} @Test public abc() {} 使用使用eclipse如何创建测试类使用eclipse创建测试类在需要创建Junit的类上 -&gt; 右键 -&gt; new -&gt; Other -&gt; 找到Junit Test Case 在刚才选择的source folder下创建了测试类 入门案例代码结构如上 被测试代码 123456789101112131415package com.zjc.junit;import java.util.Arrays;public class Calculator &#123; public int calculate(String expression) &#123; String[] ss = expression.split(\"\\\\+\"); System.out.println(expression + \" =&gt; \" + Arrays.toString(ss)); int sum = 0; for(String s : ss) &#123; sum = sum + Integer.parseInt(s); &#125; return sum; &#125;&#125; 测试代码 12345678910111213141516171819202122package com.zjc.junit;import static org.junit.Assert.*;import org.junit.Test;public class CalculatorTest &#123; @Test public void testCalculate() &#123; assertEquals(3, new Calculator().calculate(\"1+2\")); assertEquals(6, new Calculator().calculate(\"1+2+3\")); &#125; /** * 测试用户输入不规范时,是否能通过测试 */ @Test public void testCalculateWithSpace() &#123; assertEquals(3, new Calculator().calculate(\" 1 + 2\")); // 这里输入不规范,被测试代码会报错 &#125;&#125; 对测试结果进行处理 小结 一个TestCase包含一组相关的测试方法 使用Assert断言测试结果(注意浮点数assertEquals要指定delta) 每个测试方法必须完全独立,也就是说不能预测测试方法的运行顺序 测试代码必须非常简单 不能为测试代码再编写测试 测试需要覆盖各种输入条件,特别是边界条件 使用Asser断言import static org.junit.Assert.* 断言相等:assertEquals(100, x) 断言数组相等:assertArrayEquals({1, 2, 3}, x) 浮点数断言相等:assertEquals(3.1416, x, 0.0001) // 其中0.0001是误差值 断言为null:assertNull(x) 断言为true/false:assertTrue(x &gt; 0) assertFalse(x &lt; 0) 其他:assertNotEquals/assertNotNull Junit Fixture(Before和After)初始化测试资源称为Fixture @Before:初始化测试对象,例如:input = new FileInputStream(); @After:销毁@Before创建的测试对象,例如:input.close(); @BeforeClass:初始化非常耗时的资源,例如数据库 @AfterClass:清理@BeforeClass创建的资源,例如:删除数据库 使用@Before和@After 在@Before方法中初始化测试资源(Before方法初始化的对象要全部放在实例字段中,底下有示例代码) 在@After方法中释放测试资源 使用@Before和@After可以保证 单个@Test方法执行前会创建新的XxxTest实例,实例变量的状态不会传递给下一个@Test方法 单个@Test方法执行前后会执行@Before和@After方法 1234567891011121314151617181920212223242526272829303132package com.zjc.junit;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;public class CalculatorTest &#123; StringBuilder builder; // Before方法初始化的对象要全部放在实例字段中 Calculator calculator; // Before方法初始化的对象要全部放在实例字段中 @Before public void setUp() &#123; builder = new StringBuilder(); calculator = new Calculator(); &#125; @Test public void testCalculate() &#123;// assertEquals(3, new Calculator().calculate(\"1+2\"));// assertEquals(6, new Calculator().calculate(\"1+2+3\")); assertEquals(6, calculator.calculate(\"1+2+3\")); &#125; /** * 测试用户输入不规范时,是否能通过测试 */ @Test public void testCalculateWithSpace() &#123;// assertEquals(3, new Calculator().calculate(\" 1 + 2\")); // 这里输入不规范,被测试代码会报错 assertEquals(3, calculator.calculate(\" 1 + 2\")); // 这里输入不规范,被测试代码会报错 &#125;&#125; 使用@BeforeClass和@AfterClass @BeforeClass静态方法初始化的对象只能存放在静态字段中 静态字段的状态会影响到所有的@Test 123456789101112131415package com.zjc.junit;import static org.junit.Assert.*;import org.junit.Before;import org.junit.Test;public class CalculatorTest &#123; static StringBuilder builder; @BeforeClass public void setUp() &#123; builder = new StringBuilder(); &#125; ......&#125; 小结Junit执行逻辑12345678invokeBeforeClass(CalculatorTest.class); //@Beforefor (Method testMethod : findTestMethods(CalculatorTest.class)) &#123; CalculatorTest test = new CalculatorTest(); // 创建Test实例 test.setUp(); //@Before testMethod.invoke(test); //@Test test.setDown(); //@After&#125;invokeAfterClass(CalculatorTest.class); //@AfterClass Junit执行测试的生命周期 @Before用于初始化测试对象,测试对象以实例变量存放 @After用于清理@Before对象创建的对象 @BeforeClass用于初始化耗时资源,以静态变量存放 @AfterClass用于清理@BeforeClass创建的资源 异常测试(使用@Test(expected = 异常))对可能抛出的异常进行测试 异常本身是方法签名的一部分public static int parseInt(String s) throws NumberFormatException 测试错误的输入是否导致特定的异常123Integer.parseInt(null)Integer.parseInt(&quot;&quot;)Integer.parseInt(&quot;xyz&quot;) 如何测试异常 很常规,但是写出来会被鄙视的代码123456789@Testpublic void testNumberFormatException() &#123; try &#123; Integer.parseInt(null); fail(\"Should throw exception\"); // 没有捕获到异常,就用Junit提供的fail()函数表示测试失败 &#125; catch (NumberFormatException e) &#123; // do somethint... &#125;&#125; 这样需要写很多try…catch…代码 使用expected测试异常1234@Test(expected = NumberFormatException.class)public void testNumberFormatException() &#123; Integer.parseInt(null);&#125; 如果抛出了指定类型的异常,测试通过;如果没有抛出异常,或者抛出的异常类型不对,测试失败. 测试不通过例子 对代码进行修改 小结 测试异常可以使用@Test(expected = Exception.class) 对可能发生的每种类型的异常进行测试 超时测试Junit可以为单个测试设置超时 超时设置为1秒:@Test(timeout=1000) 单位是毫秒 当代码运行时间超过我们设定的时间,报错 超时测试不能取代性能测试和压力测试 参数化测试 对于同一个函数,不能只测试一个输入输出就完事,要测试一组数据 使用@ParameterizedTest注解 只有一个参数(使用@ValueSource注解)假设对函数Math.abs()进行测试 12345@ParameterizedTest@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)void testAbs(int x) &#123; assertEquals(x, Math.abs(x));&#125; 注意这里没有@Test,使用的是@ParameterizedTest注释 输入只有一个参数的时候使用@ValueSource注释 有多个参数 被测试函数12345678public class StringUtils &#123; public static String capitalize(String s) &#123; if (s.length() == 0) &#123; return s; &#125; return Character.toUpperCase(s.charAt(0)) + s.substring(1).toLowerCase(); &#125;&#125; 该被测的函数会把字符串的第一个字母变为大写，后续字母变为小写 方法一:使用@MethodSource注解通过@MethodSource注解，它允许我们编写一个同名的静态方法来提供测试参数 1234567891011121314// 使用的注解@ParameterizedTest@MethodSourcevoid testCapitalize(String input, String result) &#123; assertEquals(result, StringUtils.capitalize(input));&#125;// 同名的静态方法来提供测试参数static List&lt;Arguments&gt; testCapitalize() &#123; return List.of( // arguments: Arguments.arguments(\"abc\", \"Abc\"), // Arguments.arguments(\"APPLE\", \"Apple\"), // Arguments.arguments(\"gooD\", \"Good\"));&#125; 方法二:使用@CsvSource注解12345@ParameterizedTest@CsvSource(&#123; \"abc, Abc\", \"APPLE, Apple\", \"gooD, Good\" &#125;)void testCapitalize(String input, String result) &#123; assertEquals(result, StringUtils.capitalize(input));&#125; 写在代码中只能是少量数据,如果数据较多,可以放在csv文件中(其实从@CsvSource这个注解中略知一二),代码如下写法 12345@ParameterizedTest@CsvFileSource(resources = &#123; \"/test-capitalize.csv\" &#125;)void testCapitalizeUsingCsvFile(String input, String result) &#123; assertEquals(result, StringUtils.capitalize(input));&#125; 套件测试(使用@RunWith和@Suite) 测试套件意味着捆绑几个单元测试用例并且一起执行他们。在 JUnit 中，@RunWith和@Suite注释用来运行套件测试 被测试函数 Arithmetic.java 12345678910package in.co.javatutorials;/** * @author javatutorials.co.in */public class Arithmetic &#123; public int add(int i, int j) &#123; return i + j; &#125;&#125; Geometric.java 123456789package in.co.javatutorials;/** * @author javatutorials.co.in */public class Geometry &#123; public int squareArea(int length) &#123; return length * length; &#125;&#125; 测试代码 ArithmeticTest.java 1234567891011121314151617package in.co.javatutorials;import static org.junit.Assert.*;import org.junit.Test;/** * @author javatutorials.co.in */public class ArithmeticTest &#123; @Test public void testAdd() &#123; Arithmetic arithmetic = new Arithmetic(); int actualResult = arithmetic.add(1 , 2); int expectedResult = 3; assertEquals(expectedResult, actualResult); &#125;&#125; GeometricTest.java 123456789101112131415161718package in.co.javatutorials;import static org.junit.Assert.*;import org.junit.Test;/** * @author javatutorials.co.in */public class GeometryTest &#123; @Test public void testSquareArea() &#123; Geometry geometry = new Geometry(); int actualResult = geometry.squareArea(2); int expectedResult = 4; assertEquals(expectedResult, actualResult); &#125;&#125; 让上面两个被测试代码一起执行 1234567891011121314package in.co.javatutorials;import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses;/** * @author javatutorials.co.in */@RunWith(Suite.class)@SuiteClasses(&#123; ArithmeticTest.class, GeometryTest.class &#125;)public class AllTests &#123;&#125; 忽略测试(使用@ignore注解)在需要忽略或者禁止junit 测试类中的任意测试方法上，使用@ignore注解 控制执行顺序(@FixMethodOrder) 原则上不要控制执行顺序 使用@FixMethodOrder注解来控制测试方法的执行顺序 @FixMethodOrder注解的参数是org.junit.runners.MethodSorters对象,在枚举类org.junit.runners.MethodSorters中定义了如下三种顺序类型 三种顺序类型 MethodSorters.JVMLeaves the test methods in the order returned by the JVM. Note that the order from the JVM may vary from run to run (按照JVM得到的方法顺序，也就是代码中定义的方法顺序) MethodSorters.DEFAULT(默认的顺序)Sorts the test methods in a deterministic, but not predictable, order() (以确定但不可预期的顺序执行) MethodSorters.NAME_ASCENDINGSorts the test methods by the method name, in lexicographic order, with Method.toString() used as a tiebreaker (按方法名字母顺序执行) 示例代码 12345678910111213141516171819202122232425package test;import org.junit.Assert;import org.junit.FixMethodOrder;import org.junit.runners.MethodSorters;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;@FixMethodOrder(MethodSorters.JVM)//指定测试方法按定义的顺序执行public class TestJNI &#123; private static final Logger logger = LoggerFactory.getLogger(TestJNI.class); @Test public void testAddAndGet()&#123; logger.info(\"test 'addBean' and 'getBean' \"); &#125; @Test public final void testSearch() &#123; logger.info(\"test search CODE from JNI memory...\"); &#125; @Test public final void testRemove() &#123; logger.info(\"test remove CODE from JNI memory...\"); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"},{"name":"Junit","slug":"Junit","permalink":"https://zjinc36.github.io/tags/Junit/"}]},{"title":"Eclipse中解决git冲突","date":"2017-12-23T22:13:42.000Z","path":"2017/12/24/eclipse中解决git冲突/","text":"0、来源eclipse 中git解决冲突 1、工程-&gt;Team-&gt;同步： 2、从远程pull至本地，就会出现如下内容： 3、使用Merge Tool，执行第二项使用HEAD合并后的效果： 4、再手动修改 5、修改后的文件需要添加到git index中去： 6、冲突文件变为修改图标样式，再提交至本地，此时的提交便是merge合并： 7、此时需要pull的向下箭头和数量没了，注意图标的变化： 8、现在可以直接push到远程了：此时configure -&gt; save and push一步步执行冲突就搞定了。","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"}]},{"title":"org.xml.sax.SAXParseException:元素类型input必须由匹配的结束标记/input终止","date":"2017-11-12T10:36:16.000Z","path":"2017/11/12/Thymeleaf错误-org-xml-sax-SAXParseException-元素类型input必须由匹配的结束标记-input-终止/","text":"参考与引用https://github.com/thymeleaf/thymeleaf/issues/390http://nekohtml.sourceforge.net/NekoHTML 学习笔记Thymeleaf 3 引入了新的解析系统 问题如果你的代码使用了 HTML5 的标准，而Thymeleaf 版本来停留在 2.x ，那么如果没有把&lt;input&gt;闭合，如下： 1234567&lt;form&gt; First name:&lt;br&gt; &lt;input type=\"text\" name=\"firstname\"&gt; &lt;br&gt; Last name:&lt;br&gt; &lt;input type=\"text\" name=\"lastname\"&gt;&lt;/form&gt; 就会抛出如下错误 1org.xml.sax.SAXParseException: 元素类型 &quot;input&quot; 必须由匹配的结束标记 &quot;&lt;/input&gt;&quot; 终止。 解决方案沿用 Thymeleaf 老版本的情况方案一(废话)如果你的 Thymeleaf 不能变更，那么你的 HTML 标准也只能停留在老版本了。你必须严格遵守 XML 定义，在&lt;input&gt;加上结束标记&lt;/input&gt;。这显然，对于 HTML5 不友好。 方案二:使用第三方包nekohtml12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.15&lt;/version&gt;&lt;/dependency&gt; NekoHTML 是一个简单地HTML扫描器和标签补偿器(tag balancer) ,使得程序能解析HTML文档并用标准的XML接口来访问其中的信息。这个解析器能投扫描HTML文件并“修正”许多作者（人或机器）在编写HTML文档过程中常犯的错误。NekoHTML 能增补缺失的父元素、自动用结束标签关闭相应的元素，以及不匹配的内嵌元素标签。NekoHTML 的开发使用了Xerces Native Interface (XNI)，后者是Xerces2的实现基础。 方案三:升级至 Thymeleaf 3 新版本是时候尝试下使用 Thymeleaf 3 了。Thymeleaf 3 使用了新的解析系统。 Thymeleaf 3 不再是基于XML结构的。由于引入新的解析引擎，模板的内容格式不再需要严格遵守XML规范。即不在要求标签闭合，属性加引号等等。当然，出于易读性考虑，还是推荐你按找XML的标准去编写模板。 Thymeleaf 3 使用一个名为 AttoParser 2的新解析器。 一个新的、基于事件（不符合SAX标准）的解析器，AttoParser由 Thymeleaf 的作者开发，符合 Thymeleaf 的风格。 AttoParser 提供 Thymeleaf 3 两个重要功能： 完全支持XML和HTML5（非XML化）标记，从而不再需要外部标记平衡操作。 无损解析，以便在处理的输出的标记类似于具有最高精度的原始模板。 所以下面的格式在 Thymeleaf 3 里面是合法的： 1&lt;div&gt;&lt;img alt=logo th:src=&apos;@&#123;/images/logo.png&#125;&apos;&gt; Thymeleaf 3 其他方面的解析改进 启用验证的解析在 Thymeleaf 2.1提供了两种VALID*模板模式，名为VALIDXHTML和VALIDXML，在而 Thymeleaf 3 中将不再存在。 新的解析基础结构不提供HTML或XML验证，即在解析期间无法验证模板标记是否符合指定的DTD或XML模式定义。 不再需要&lt;![CDATA[ ... ]]&gt; Thymeleaf 2.1 要求将&lt;script&gt;标记的内容封装在 CDATA 中，以便所使用的任何&lt;或&gt;符号不会干扰基于XML的解析： 12345678&lt;script&gt;/*&lt;![CDATA[*/ var user = ... if (user.signupYear &lt; 1990) &#123; alert('You\\'ve been here for a long time!'); &#125;/*]]&gt;*/&lt;/script&gt; 而在 Thymeleaf 3 中则不需要这样做，代码立马变得简洁干净： 123456&lt;script&gt; var user = ... if (user.signupYear &lt; 1990) &#123; alert('You\\'ve been here for a long time!'); &#125;&lt;/script&gt;","tags":[{"name":"Java细节","slug":"Java细节","permalink":"https://zjinc36.github.io/tags/Java细节/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://zjinc36.github.io/tags/Thymeleaf/"}]},{"title":"SpringMVC的@RequestMapping注解的作用","date":"2017-11-12T10:24:34.000Z","path":"2017/11/12/SpringMVC的-RequestMapping注解的作用/","text":"参考与引用@RequestMapping 用法详解之地址映射 @RequestMapping作用RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 @Requestmapping的属性说明RequestMapping注解有六个属性，下面我们把她分成三类进行说明。 value， method； value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）； method： 指定请求的method类型， GET、POST、PUT、DELETE等； value的uri值为以下三类： A） 可以指定为普通的具体值； B) 可以指定为含有某变量的一类值(URI Template Patterns with Path Variables)； C) 可以指定为含正则表达式的一类值( URI Template Patterns with Regular Expressions);如下示例 1234567891011121314151617181920212223242526272829303132333435@Controller@RequestMapping(\"/appointments\")public class AppointmentsController &#123; private AppointmentBook appointmentBook; @Autowired public AppointmentsController(AppointmentBook appointmentBook) &#123; this.appointmentBook = appointmentBook; &#125; @RequestMapping(method = RequestMethod.GET) public Map&lt;String, Appointment&gt; get() &#123; return appointmentBook.getAppointmentsForToday(); &#125; @RequestMapping(value=\"/&#123;day&#125;\", method = RequestMethod.GET) public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) &#123; return appointmentBook.getAppointmentsForDay(day); &#125; @RequestMapping(value=\"/new\", method = RequestMethod.GET) public AppointmentForm getNewForm() &#123; return new AppointmentForm(); &#125; @RequestMapping(method = RequestMethod.POST) public String add(@Valid AppointmentForm appointment, BindingResult result) &#123; if (result.hasErrors()) &#123; return \"appointments/new\"; &#125; appointmentBook.addAppointment(appointment); return \"redirect:/appointments\"; &#125;&#125; 1234@RequestMapping(value=\"/owners/&#123;ownerId&#125;\", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) &#123; //...&#125; 12345@RequestMapping(\"/spring-web/&#123;symbolicName:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;.&#123;extension:\\.[a-z]&#125;\") public void handle(@PathVariable String version, @PathVariable String extension) &#123; // ... &#125;&#125; consumes，produces； consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； cousumes的样例： 12345@Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) &#123; // implementation omitted&#125; 方法仅处理request Content-Type为“application/json”类型的请求。 produces的样例： 12345@Controller@RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\")public void addPet(@RequestBody Pet pet, Model model) &#123; // implementation omitted&#125; 方法仅处理request请求中Accept头中包含了”application/json”的请求，同时暗示了返回的内容类型为application/json; params，headers； params： 指定request中必须包含某些参数值是，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 params的样例： 123456789@Controller@RequestMapping(\"/owners/&#123;ownerId&#125;\")public class RelativePathUriTemplateController &#123; @RequestMapping(value = \"/pets/&#123;petId&#125;\", method = RequestMethod.GET, params=\"myParam=myValue\") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123; // implementation omitted &#125;&#125; 仅处理请求中包含了名为“myParam”，值为“myValue”的请求； headers的样例： 12345678910@Controller@RequestMapping(\"/owners/&#123;ownerId&#125;\")public class RelativePathUriTemplateController &#123;@RequestMapping(value = \"/pets\", method = RequestMethod.GET, headers=\"Referer=http://www.ifeng.com/\") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123; // implementation omitted &#125;&#125; 仅处理request的header中包含了指定“Refer”请求头和对应值为http://www.ifeng.com/的请求；","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC的自定义参数绑定","date":"2017-10-30T22:26:51.000Z","path":"2017/10/31/SpringMVC的自定义参数绑定/","text":"为什么需要自动绑定理解自动绑定 springmvc能将request的参数自动绑定 自动绑定 -&gt; request参数与变量形成一一映射 -&gt; 即:request的参数名与java的变量名要一致,同时参数名的类型和变量名的类型要一致 参数名和变量名不一致会发生什么?400错误 参数名和变量名名称一致,但类型不一致时,spring如何处理能够进行自定义参数绑定,可以按照如下进行理解 request参数要自动绑定到变量,首先找到与自己”名字”一致的变量 找到之后,判断是否类型一致 一致 -&gt; 绑定就行 不一致 -&gt; 看是否设定转换器 未设置转换器 -&gt; 400错误 设置转换器 -&gt; 使用转换器,将request参数的类型转换成java变量的类型后,进行绑定 代码代码结构 页面index.jsp 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;c:set var=\"now\" value=\"&lt;%=new java.util.Date()%&gt;\" /&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;spring MVC POJO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testPojo.action\" method=\"post\"&gt; 时间:&lt;input name=\"times\" value=\"2019-10-31 09:32:13\" /&gt; &lt;br/&gt; &lt;input type=\"submit\" value=\"testPojoSubmit\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 控制器123456789101112131415161718192021222324252627package com.zjc.springmvc.controller;import java.util.Date;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.zjc.springmvc.pojo.User;@Controllerpublic class TestPojoController &#123; private static final String SUCCESS = \"success\"; @RequestMapping(value=\"/index\") public ModelAndView testPojoIndex() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(\"index\"); return mav; &#125; @RequestMapping(value=\"/testPojo\") public String testPojo(User user, String[] ids, Date times) &#123; System.out.println(times); return SUCCESS; &#125;&#125; 转换器123456789101112131415161718192021222324252627282930package com.zjc.springmvc.utils;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;// 要注意继承的是哪个接口import org.springframework.core.convert.converter.Converter;/** * 日期转换器 * S:source要转换的源类型 * T:target要转换成的数据 * @author zjc * *///public class DateConvert implements Converter&lt;S, T&gt; &#123;//&#125;public class DateConvert implements Converter&lt;String, Date&gt; &#123; private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); public Date convert(String source) &#123; try &#123; return simpleDateFormat.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 让spring识别转换器(配置springmvc.xml)1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;!-- 配置controller扫描包 --&gt; &lt;context:component-scan base-package=\"com\" /&gt; &lt;!-- 配置注解驱动,相当于同时使用最新处理器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 配置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 配置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt; &lt;!-- 自定义转化器 --&gt; &lt;!-- 使用 mvc:annotation-driven 代替上边注解映射器和注解适配器配置 mvc:annotation-driven 默认加载很多的参数绑定方法， 比如json转换解析器就默认加载了，如果使用 mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用 mvc:annotation-driven --&gt; &lt;mvc:annotation-driven conversion-service=\"myConversionService\" /&gt; &lt;!-- 自定义参数绑定 --&gt; &lt;bean id=\"myConversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;!-- 转换器 --&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class=\"com.zjc.springmvc.utils.DateConvert\"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC的List参数绑定","date":"2017-10-24T23:39:54.000Z","path":"2017/10/25/SpringMVC的List参数绑定/","text":"基本代码项目基础代码SpringMVC的数组参数绑定底下代码基本相同 本文中的文件结构 页面这个页面有改动,改动部分如图 index.jsp 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;spring MVC POJO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testPojo.action\" method=\"post\"&gt; 用户名:&lt;input name=\"username\" /&gt;&lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; 省:&lt;input name=\"address.province\" /&gt;&lt;br&gt; 市:&lt;input name=\"address.city\" /&gt;&lt;br&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=\"ids\" type=\"checkbox\" value=\"run\" /&gt;&lt;/td&gt; &lt;td&gt;跑步&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=\"ids\" type=\"checkbox\" value=\"soccer\"/&gt;&lt;/td&gt; &lt;td&gt;踢球&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=\"ids\" type=\"checkbox\" value=\"ski\"/&gt;&lt;/td&gt; &lt;td&gt;滑雪&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 课程名：&lt;input type=\"text\"name=\"scores[0].coursename\"/&gt;成绩：&lt;input type=\"text\"name=\"scores[0].score\"/&gt;&lt;br/&gt; 课程名：&lt;input type=\"text\"name=\"scores[1].coursename\"/&gt;成绩：&lt;input type=\"text\"name=\"scores[1].score\"/&gt;&lt;br/&gt; 课程名：&lt;input type=\"text\"name=\"scores[2].coursename\"/&gt;成绩：&lt;input type=\"text\"name=\"scores[2].score\"/&gt;&lt;br/&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"testPojoSubmit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;spring MVC POJO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testPojo.action\" method=\"post\"&gt; username:&lt;input name=\"username\" /&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; province:&lt;input name=\"address.province\" /&gt;&lt;br&gt; city:&lt;input name=\"address.city\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"testPojoSubmit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; pojo 下方pojo代码使用了Lombok的注解语法 可以看这里:Lombok简化你的代码 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.14.4&lt;/version&gt;&lt;/dependency&gt; User.java这个文件也有改动,增加List类型的变量scores 1234567891011121314package com.zjc.springmvc.pojo;import java.util.List;import lombok.Data;@Datapublic class User &#123; private String username; private String password; private Address address; private String[] ids; private List&lt;StudentScore&gt; scores;&#125; StudentScore.java新增StudentScore.java文件 123456789package com.zjc.springmvc.pojo;import lombok.Data;@Datapublic class StudentScore &#123; private String coursename; private Float score;&#125; Address.java 1234567891011package com.zjc.springmvc.pojo;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class Address &#123; private String province; private String city;&#125; 控制器12345678910111213141516171819202122232425262728293031package com.zjc.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.zjc.springmvc.pojo.User;@Controllerpublic class TestPojoController &#123; private static final String SUCCESS = \"success\"; @RequestMapping(value=\"/index\") public ModelAndView testPojoIndex() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(\"index\"); return mav; &#125; @RequestMapping(value=\"/testPojo\") public String testPojo(User user, String[] ids) &#123; System.out.println(user); System.out.println(\"---------------------\"); for (String id : ids) &#123; System.out.println(id); System.out.println(\"--------\"); &#125; return SUCCESS; &#125;&#125; 跑项目访问http://localhost:8080/springhello/index.action,输入数据提交在eclipse控制台中打出如下数据","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC的数组参数绑定","date":"2017-10-23T23:15:27.000Z","path":"2017/10/24/SpringMVC的数组参数绑定/","text":"基本代码项目基础代码SpringMVC的pojo参数绑定/底下代码基本相同 本文中的文件结构 页面这个页面有改动,增加checkbox,用以传到服务器的变量的内容是一个参数 index.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;spring MVC POJO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testPojo.action\" method=\"post\"&gt; 用户名:&lt;input name=\"username\" /&gt;&lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; 省:&lt;input name=\"address.province\" /&gt;&lt;br&gt; 市:&lt;input name=\"address.city\" /&gt;&lt;br&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=\"ids\" type=\"checkbox\" value=\"run\" /&gt;&lt;/td&gt; &lt;td&gt;跑步&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=\"ids\" type=\"checkbox\" value=\"soccer\"/&gt;&lt;/td&gt; &lt;td&gt;踢球&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=\"ids\" type=\"checkbox\" value=\"ski\"/&gt;&lt;/td&gt; &lt;td&gt;滑雪&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"testPojoSubmit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;spring MVC POJO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testPojo.action\" method=\"post\"&gt; username:&lt;input name=\"username\" /&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; province:&lt;input name=\"address.province\" /&gt;&lt;br&gt; city:&lt;input name=\"address.city\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"testPojoSubmit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; pojo 下方pojo代码使用了Lombok的注解语法 可以看这里:Lombok简化你的代码 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.14.4&lt;/version&gt;&lt;/dependency&gt; User.java 123456789101112package com.zjc.springmvc.pojo;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User &#123; private String username; private String password; private Address address;&#125; Address.java 1234567891011package com.zjc.springmvc.pojo;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class Address &#123; private String province; private String city;&#125; 控制器这个代码有改动,新增了String[] ids用以接受页面传进来的数值 1234567891011121314151617181920212223242526272829303132333435package com.zjc.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.zjc.springmvc.pojo.User;@Controllerpublic class TestPojoController &#123; private static final String SUCCESS = \"success\"; @RequestMapping(value=\"/index\") public ModelAndView testPojoIndex() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(\"index\"); return mav; &#125; @RequestMapping(value=\"/testPojo\") public String testPojo(User user, String[] ids) &#123; System.out.println( \"username=\" + user.getUsername() + \",password=\" + user.getPassword() + \",province=\" + user.getAddress().getProvince() + \",city=\" + user.getAddress().getCity() ); System.out.println(\"---------------------\"); for (String id : ids) &#123; System.out.println(id); System.out.println(\"--------\"); &#125; return SUCCESS; &#125;&#125; 跑项目访问http://localhost:8080/springhello/index.action,可以看到如下页面,输入数据提交 在eclipse控制台中打出如下数据 问题:如果后台中有两个相同的变量用以接收前台传进来的变量,此时会怎样?做一点改造 在User.java中增加ids变量 1234567891011package com.zjc.springmvc.pojo;import lombok.Data;@Datapublic class User &#123; private String username; private String password; private Address address; private String[] ids;&#125; 控制器中打印user变量和ids变量 123456789101112131415161718192021222324252627282930package com.zjc.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.zjc.springmvc.pojo.User;@Controllerpublic class TestPojoController &#123; private static final String SUCCESS = \"success\"; @RequestMapping(value=\"/index\") public ModelAndView testPojoIndex() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(\"index\"); return mav; &#125; @RequestMapping(value=\"/testPojo\") public String testPojo(User user, String[] ids) &#123; System.out.println(user); System.out.println(\"---------------------\"); for (String id : ids) &#123; System.out.println(id); System.out.println(\"--------\"); &#125; return SUCCESS; &#125;&#125; 跑项目访问http://localhost:8080/springhello/index.action,输入数据提交在eclipse控制台中打出如下数据 结论只要名字相同,会将前台传进来的变量赋值给每个名字相同的变量","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"Lombok简化你的代码","date":"2017-10-22T16:38:00.000Z","path":"2017/10/23/Lombok简化你的代码/","text":"原文地址使用Lombok简化你的代码:http://kriszhang.com/lombok/ 什么是Lokmob Lombok意味龙目岛，该岛是巴厘岛的一座附属岛屿，风景优美 本文要介绍的Lombok，是java的一个强大工具，能极大的减少代码量，并使代码更加整洁清晰。总结 -&gt; 减少java代码量的工具 添加Lombok支持eclipse添加Lombok支持 下载Lombok的jar包,放在eclipse的根目录下 安装在根目录下使用弹出如下页面,进行安装 安装完毕可以在eclipse.ini文件看到新增了如下内容 IDEA添加Lombok支持原文里面有 项目添加maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.14.4&lt;/version&gt;&lt;/dependency&gt; 基本用法生成Getter/Setter方法考虑实体对象Community，有四个属性，一般情况下我们会使用idea生成工具，生成Getter和Setter方法。如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Community &#123; private String communityId; private String name; private String title; private int type; /** * Getter method for property communityId. * * @return property value of communityId */ public String getCommunityId() &#123; return communityId; &#125; /** * Setter method for property communityId. * * @param communityId value to be assigned to property communityId */ public void setCommunityId(String communityId) &#123; this.communityId = communityId; &#125; /** * Getter method for property name. * * @return property value of name */ public String getName() &#123; return name; &#125; /** * Setter method for property name. * * @param name value to be assigned to property name */ public void setName(String name) &#123; this.name = name; &#125; /** * Getter method for property title. * * @return property value of title */ public String getTitle() &#123; return title; &#125; /** * Setter method for property title. * * @param title value to be assigned to property title */ public void setTitle(String title) &#123; this.title = title; &#125; /** * Getter method for property type. * * @return property value of type */ public int getType() &#123; return type; &#125; /** * Setter method for property type. * * @param type value to be assigned to property type */ public void setType(int type) &#123; this.type = type; &#125;&#125; 采用lombok则可以直接： 12345678910public class Community &#123; @Getter @Setter private String communityId; @Getter @Setter private String name; @Getter @Setter private String title; @Getter @Setter private int type;&#125; @Getter和@Setter都可以单独定义函数的访问等级： 1234567891011121314public class Community &#123; @Getter (AccessLevel.PUBLIC) @Setter(AccessLevel.PRIVATE) private String communityId; @Getter(AccessLevel.PUBLIC) @Setter(AccessLevel.PUBLIC) private String name; @Getter(AccessLevel.PUBLIC) @Setter(AccessLevel.PUBLIC) private String title; @Getter(AccessLevel.PUBLIC) @Setter(AccessLevel.PUBLIC) private int type;&#125; 如果都是public，则代码可以更加简洁： 1234567@Getter @Setterclass Community &#123; private String communityId; private String name; private String title; private int type;&#125; 生成构造方法如果我们要给Community实体类生成构造方法，那么可以如下代码示例： 123456789101112131415161718public class Community &#123; private String communityId; private String name; private String title; private int type; public Community(String communityId, String name, String title, int type) &#123; this.communityId = communityId; this.name = name; this.title = title; this.type = type; &#125; public Community() &#123; &#125; public Community(String communityId, String name) &#123; this.communityId = communityId; this.name = name; &#125;&#125; 可以看到很麻烦，也很混乱，如果使用lombok则变得清晰简洁： 123456789@AllArgsConstructor@NoArgsConstructor@RequiredArgsConstructor(staticName=\"of\")class Community &#123; private String communityId; @NonNull private String name; @NonNull private String title; private int type;&#125; 其中 @AllArgsConstructor用来指定全参数构造器 @NoArgsConstructor用来指定无参数构造器 @RequiredArgsConstructor用来指定参数（采用静态方法of访问） 生成equals、hashcode、toString我们在来看，如果需要生成equals、hashcode、toString呢？按照平常的做法： 1234567891011121314151617181920212223242526272829303132333435public class Community &#123; private String communityId; private String name; private String title; private int type; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; Community community = (Community)o; if (type != community.type) &#123; return false; &#125; if (communityId != null ? !communityId.equals(community.communityId) : community.communityId != null) &#123; return false; &#125; if (name != null ? !name.equals(community.name) : community.name != null) &#123; return false; &#125; return title != null ? title.equals(community.title) : community.title == null; &#125; @Override public int hashCode() &#123; int result = communityId != null ? communityId.hashCode() : 0; result = 31 * result + (name != null ? name.hashCode() : 0); result = 31 * result + (title != null ? title.hashCode() : 0); result = 31 * result + type; return result; &#125; @Override public String toString() &#123; return \"Community&#123;\" + \"communityId='\" + communityId + '\\'' + \", name='\" + name + '\\'' + \", title='\" + title + '\\'' + \", type=\" + type + '&#125;'; &#125;&#125; 可以看到，代码相当的恼人，如果使用lombok： 12345678@ToString@EqualsAndHashCodeclass Community &#123; private String communityId; private String name; private String title; private int type;&#125; 如果我们只需要是否name作为equals和hashcode的运算字段，并且不想将title toString出来： 12345678@ToString(exclude = &#123;\"title\"&#125;)@EqualsAndHashCode(of = &#123;\"name\"&#125;)class Community &#123; private String communityId; private String name; private String title; private int type;&#125; 结合上面所有的实例，我们可以使用如下代码就能完成平常需要上百行代码才能完成的事情： 123456789101112@AllArgsConstructor@NoArgsConstructor@RequiredArgsConstructor(staticName=\"of\")@Getter @Setter@ToString(exclude = &#123;\"title\"&#125;)@EqualsAndHashCode(of = &#123;\"name\"&#125;)public class Community &#123; private String communityId; @NonNull private String name; @NonNull private String title; private int type;&#125; @Data一个等于所有我们可以看到，上节中类上面打了好多注解，还是显得有些乱。如果我们没有要求那么多定制化需求，则可以直接使用@Data注解，他包含了：@Getter @Setter @ToString @EqualsAndHashCode RequiredArgsConstructor注解，因此可以简化为： 123456789@NoArgsConstructor@AllArgsConstructor@Data(staticConstructor=\"of\")public class Community &#123; private String communityId; @NonNull private String name; @NonNull private String title; private int type;&#125; Builder模式有的时候，我们喜欢采用Builder模式去构造一个对象，比如如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Community &#123; private String communityId; private String name; private String title; private int type; @java.beans.ConstructorProperties(&#123;\"communityId\", \"name\", \"title\", \"type\"&#125;) Community(String communityId, String name, String title, int type) &#123; this.communityId = communityId; this.name = name; this.title = title; this.type = type; &#125; public static CommunityBuilder builder() &#123;return new CommunityBuilder();&#125; public static class CommunityBuilder &#123; private String communityId; private String name; private String title; private int type; CommunityBuilder() &#123;&#125; public Community.CommunityBuilder communityId(String communityId) &#123; this.communityId = communityId; return this; &#125; public Community.CommunityBuilder name(String name) &#123; this.name = name; return this; &#125; public Community.CommunityBuilder title(String title) &#123; this.title = title; return this; &#125; public Community.CommunityBuilder type(int type) &#123; this.type = type; return this; &#125; public Community build() &#123; return new Community(communityId, name, title, type); &#125; public String toString() &#123; return \"com.qunar.kris.share.misc.lombok.Community.CommunityBuilder(communityId=\" + this.communityId + \", name=\" + this.name + \", title=\" + this.title + \", type=\" + this.type + \")\"; &#125; &#125;&#125; 然后我们可以这么使用： 1234567public static void main(String[] args) &#123; Community community = Community.builder() .communityId(\"zzz\") .name(\"xxx\") .title(\"yyy\") .type(1).build();&#125; 上述创建builder的方式是在是太麻烦了，这只是4个参数，如果更多的参数，可想而知代码量啊！使用Lombok则很简单： 1234567@Builderclass Community &#123; private String communityId; private String name; private String title; private int type;&#125; 以上均是在日常项目中非常常用的特性，我们再来看一些使用频率较低的特性 其他特性异常处理捕获全局异常，我们经常使用如下代码： 1234567891011public void doMethod() &#123; try &#123; invokeMethodMayThrowExeption(); &#125; catch(Exception e) &#123; if (e instanceof MyException) &#123; throw e; &#125; else &#123; //swallow it &#125; &#125;&#125; 使用lombok可以简化为： 1234@SneakyThrows(MyException.class)public void doMethod() &#123; invokeMethodMayThrowExeption();&#125; logger如果我们要打日志，经常创建如下日志静态对象： 123public class Community &#123; private static final Logger logger = LoggerFactory.getLogger(\"MY-LOGGER\");&#125; 我们采用lombok简化一下： 1234@Slf4j(topic = \"MY-LOGGER\")public class Community &#123;&#125; 没有用slf4j?没有关系，除了slf4j还支持如下Logger: @XSlf4j @Log4j @Log4j2 @Log @CommonsLog 空指针异常的快速失败123public void doMethod(@NonNull String name, @NonNull String title) &#123;&#125; 以上代码，当name或者title为空的时候，则会直接抛出NPE，快速失败。 简化烦人的类型有的时候，我们可能会有非常长的泛型，很恼人： 1234Map&lt;String, Map&lt;String, List&lt;Community&gt;&gt;&gt; map = new HashMap&lt;String, Map&lt;String, List&lt;Community&gt;&gt;(); for (Entry&lt;String, Map&lt;String, List&lt;Community&gt;&gt;&gt; entry : map.entrySet()) &#123; //..... &#125; 采用lombok可以简化为： 1234val map = Maps.&lt;String, Map&lt;String, List&lt;Community&gt;&gt;&gt;newHashMap();for (val entry : map.entrySet()) &#123; //.....&#125; 当然，在jdk8下，一般使用foreach进行遍历。 基本实现原理lombok魔法并不神秘，他采用JSR269所提出的插入式注解处理(Pluggable Annotation Processing)，并结合动态代码生成技术所开发的。如下图所示：上图展示了一个一般javac的编译过程，java文件首先通过进行解析构建出一个AST，然后执行注解处理，最后经过分析优化生成二进制的.class文件。 我们能做到的是，在注解处理阶段进行一些相应处理。首先我们在META-INF.services下创建如下文件： 文件中指定我们的注解处理器：com.alipay.kris.other.lombok.MyAnnotaionProcessor 然后我们接可以编写自己的注解处理器，一个简单的实例代码如下： 123456789101112131415161718@SupportedSourceVersion(SourceVersion.RELEASE_8)@SupportedAnnotationTypes(\"com.alipay.kris.other.lombok.*\")public class MyAnnotaionProcessor extends AbstractProcessor &#123; public MyAnnotaionProcessor() &#123; super(); &#125; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations,RoundEnvironment roundEnv) &#123; for (Element elem : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) &#123; MyAnnotation annotation = elem.getAnnotation(MyAnnotation.class); String message = \"annotation found in \" + elem.getSimpleName() + \" with \" + annotation.value(); addToString(elem); processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message); &#125; return true; // no further processing of this annotation type &#125;&#125; 我们能做到的也就是这么多，但lombok在此基础之上，对AST进行修改，将Setter/Getter等上文提到过的方法’挂载’到AST中","tags":[{"name":"Lombok","slug":"Lombok","permalink":"https://zjinc36.github.io/tags/Lombok/"}]},{"title":"SpringMVC的pojo参数绑定","date":"2017-10-22T16:16:49.000Z","path":"2017/10/23/SpringMVC的pojo参数绑定/","text":"基本代码项目基础代码SpringMVC的快速入门 本文中的文件结构 页面 index.jsp 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;spring MVC POJO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testPojo.action\" method=\"post\"&gt; username:&lt;input name=\"username\" /&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; province:&lt;input name=\"address.province\" /&gt;&lt;br&gt; city:&lt;input name=\"address.city\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"testPojoSubmit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;spring MVC POJO&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"testPojo.action\" method=\"post\"&gt; username:&lt;input name=\"username\" /&gt;&lt;br&gt; password:&lt;input type=\"password\" name=\"password\" /&gt;&lt;br&gt; province:&lt;input name=\"address.province\" /&gt;&lt;br&gt; city:&lt;input name=\"address.city\" /&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"testPojoSubmit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; pojo 下方pojo代码使用了Lombok的注解语法 可以看这里:Lombok简化你的代码 添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.14.4&lt;/version&gt;&lt;/dependency&gt; User.java 123456789101112package com.zjc.springmvc.pojo;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class User &#123; private String username; private String password; private Address address;&#125; Address.java 1234567891011package com.zjc.springmvc.pojo;import lombok.Getter;import lombok.Setter;@Getter@Setterpublic class Address &#123; private String province; private String city;&#125; 控制器1234567891011121314151617181920212223242526272829303132package com.zjc.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.zjc.springmvc.pojo.User;@Controllerpublic class TestPojoController &#123; private static final String SUCCESS = \"success\"; @RequestMapping(value=\"/index\") public ModelAndView testPojoIndex() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(\"index\"); return mav; &#125; @RequestMapping(value=\"/testPojo\") public String testPojo(User user) &#123; System.out.println( \"username=\" + user.getUsername() + \",password=\" + user.getPassword() + \",province=\" + user.getAddress().getProvince() + \",city=\" + user.getAddress().getCity() ); return SUCCESS; &#125;&#125; 解决post乱码问题在web.xml中加入: 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 跑项目访问http://localhost:8080/springhello/index.action,可以看到如下页面,输入数据提交 在eclipse控制台中打出如下数据","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC的简单的参数绑定","date":"2017-10-07T21:18:53.000Z","path":"2017/10/08/SpringMVC的简单的参数绑定/","text":"参数绑定的三种方式这是截图,具体代码在底下 方式一:使用HttpServletRequest使用HttpServletRequest获取参数 1234567@RequestMapping(\"getParameter1\")public String getParameter1(HttpServletRequest request) &#123; // get方式获取参数 String id = request.getParameter(\"id\"); System.out.println(id); return \"\";&#125; 方式二:保持变量名一致浏览器中使用如下url进行访问,浏览器中的参数名要和方法中的参数保持一致http://localhost:8080/springhello/hello.action?id=1 代码如下 12345@RequestMapping(\"getParameter2\")public String getParameter2(Integer id) &#123; System.out.println(id); return \"\";&#125; 支持的数据类型为包装类数据类型 方式三:使用@RequestParam浏览器中使用如下url进行访问http://localhost:8080/springhello/hello.action?id=1 代码如下 12345@RequestMapping(\"getParameter3\")public String getParameter3(@RequestParam(value=\"id\", required=true, defaultValue=\"1\") Integer idaaaaaa) &#123; System.out.println(idaaaaaa); return \"\";&#125; 其中@RequestParam的参数 value=”id”,这里要和url中的id保持一致 required=true,该参数必须要有(如果没有默认值会报错) defaultValue=”1”,当请求中没有传入id的时候,id的默认值为1","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC的默认组件加载","date":"2017-10-06T15:59:06.000Z","path":"2017/10/06/SpringMVC的默认组件加载/","text":"默认组件加载选择配置处理器映射器和处理器适配器从Spring3.1版本开始,废除了DefaultAnnotationHandlerMapping的使用,推荐使用RequestMappingHanddlerMapping完成注解处理器映射而处理器映射器和处理器适配器是成对出现的,所以要跟着改(事实上只该处理器映射器,没改处理器适配器的情况下,运行是会直接报500错误的) 方法一 处理器映射器在Spring的核心配置文件进行配置 1&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" /&gt; 处理器适配器在Spring的核心配置文件进行配置 12&lt;!-- 配置处理器适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" /&gt; 完整的springmvc.xml文件如下 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;!-- 配置controller扫描包 --&gt; &lt;context:component-scan base-package=\"com\" /&gt; &lt;!-- 配置处理器映射 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" /&gt; &lt;!-- 配置处理器适配器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" /&gt;&lt;/beans&gt; 方法二配置注解驱动,相当于同时使用最新的处理器映射器和处理器适配器,同时提供对json数据响应的支持具体代码 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;!-- 配置controller扫描包 --&gt; &lt;context:component-scan base-package=\"com\" /&gt; &lt;!-- 配置注解驱动,相当于同时使用最新处理器 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; 配置视图解析器 作用 要实现上述效果,需要如下配置视图解析器 具体代码123456&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 配置前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 配置后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 核心类与接口参考:https://www.iteye.com/blog/elf8848-875830 先来了解一下，几个重要的接口与类。现在不知道他们是干什么的没关系，先混个脸熟，为以后认识他们打个基础。 DispatcherServlet – 前置控制器 HandlerMapping接口 – 处理请求的映射 HandlerMapping接口的实现类 SimpleUrlHandlerMapping 通过配置文件，把一个URL映射到Controller DefaultAnnotationHandlerMapping 通过注解，把一个URL映射到Controller类上 HandlerAdapter接口 – 处理请求的映射 AnnotationMethodHandlerAdapter类，通过注解，把一个URL映射到Controller类的方法上 Controller接口 – 控制器由于我们使用了@Controller注解，添加了@Controller注解注解的类就可以担任控制器（Action）的职责,所以我们并没有用到这个接口。 HandlerInterceptor 接口–拦截器无图，我们自己实现这个接口，来完成拦截的器的工作 ViewResolver接口的实现类 UrlBasedViewResolver类 通过配置文件，把一个视图名交给到一个View来处理 InternalResourceViewResolver类，比上面的类，加入了JSTL的支持 View接口 JstlView类 LocaleResolver接口 HandlerExceptionResolver接口 –异常处理 SimpleMappingExceptionResolver实现类 ModelAndView类无图","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC的基本流程","date":"2017-10-05T21:10:09.000Z","path":"2017/10/06/SpringMVC的基本流程/","text":"从请求到响应 访问http://localhost:8080/springhello/hello.action web.xml文件配置了拦截规则 web.xml文件中规定要加载的核心控制器 web.xml文件中规定了要对*.action的请求进行拦截 web.xml文件中规定了要加载的SpingMVC的核心配置文件(其实就是底层的Spring) springmvc.xml文件中规定了要扫描的包是com 这里用HelloController.java进行说明 由于我们需要扫描的包是com,所有com底下的所有类都需要扫 扫描包下所有的文件,找出所有有@Controller标记的类 找到所有@RequestMapping标记,此时可以知道,我们存在映射hello 由于我们访问的url是hello.action,所以需要执行被@RequestMapping(&quot;/hello&quot;)标记的函数(也就是控制器内的函数),最后返回hello.jsp文件 画图说明 组件说明在这里SpringMVC的默认组件加载","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"Eclipse中如何查询一个类的继承关系","date":"2017-10-05T20:19:12.000Z","path":"2017/10/06/eclipse中如何查询一个类的继承关系/","text":"方法一：ctrl+shift+H 输入类名打开之后可以看到如下页面 方法二：点选类名 按 F4 方法三:点选类名,按ctrl+t一次或者两次 按一次是查看父类 按两次是倒序查看父类和接口","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"}]},{"title":"SpringMVC的快速入门","date":"2017-10-03T21:49:39.000Z","path":"2017/10/04/SpringMVC的快速入门/","text":"快速入门案例创建一个maven工程修改pom.xml文件1234567891011121314151617181920212223242526272829303132333435363738&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zjc&lt;/groupId&gt; &lt;artifactId&gt;springhello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;springVersion&gt;3.2.5.RELEASE&lt;/springVersion&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 测试用 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加springmvc依赖包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;springVersion&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;springVersion&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl标签 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 本质上载入如下包稍微解释一下 与spring有关的包 aop -&gt; aop beans -&gt; bean工厂 context -&gt; 上下文 core -&gt; 核心 expression -&gt; 表达式 commons-logging -&gt; spring的依赖 与springMVC有关的包 spring-web spring-webmvc 配置web.xmlweb.xml从来都是与Servlet相关 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;display-name&gt;springhello&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt; &lt;!-- 核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 这里要配置springmvc.xml文件 --&gt; &lt;!-- xml文件,文件名随意 --&gt; &lt;!-- 因为底层是spring,所以这里要配置spinrg要扫描哪些包 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;lasspath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- Map all requests to the DispatcherServlet for handling --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 入门代码123456789101112131415161718192021package com.zjc.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller //标识控制器public class HelloController &#123; @RequestMapping(\"/hello\") //用以绑定请求地址 public ModelAndView hello() &#123; System.out.println(\"Hello SpringMVC...\"); ModelAndView mav = new ModelAndView(); // 设置模型数据,用于传递到jsp mav.addObject(\"msg\", \"hellomvc....\"); // 设定视图名字,用于响应用户 mav.setViewName(\"/WEB-INF/jsp/hello.jsp\"); return mav; &#125;&#125; 配置包扫描12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\"&gt; &lt;!-- 配置controller扫描包 --&gt; &lt;context:component-scan base-package=\"com\" /&gt;&lt;/beans&gt; 将项目加入tomcat,浏览器访问","tags":[{"name":"Spring","slug":"Spring","permalink":"https://zjinc36.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://zjinc36.github.io/tags/SpringMVC/"}]},{"title":"原子类AtomicInteger的ABA问题","date":"2017-08-19T11:30:56.000Z","path":"2017/08/19/原子类AtomicInteger的ABA问题/","text":"连环套路从AtomicInteger引出下面的问题 CAS -&gt; Unsafe -&gt; CAS底层思想 -&gt; ABA -&gt; 原子引用更新 -&gt; 如何规避ABA问题 ABA问题是什么狸猫换太子 假设现在有两个线程，分别是T1 和 T2，然后T1执行某个操作的时间为10秒，T2执行某个时间的操作是2秒，最开始AB两个线程，分别从主内存中获取A值，但是因为B的执行速度更快，他先把A的值改成B，然后在修改成A，然后执行完毕，T1线程在10秒后，执行完毕，判断内存中的值为A，并且和自己预期的值一样，它就认为没有人更改了主内存中的值，就快乐的修改成B，但是实际上 可能中间经历了 ABCDEFA 这个变换，也就是中间的值经历了狸猫换太子。 所以ABA问题就是，在进行获取主内存值的时候，该内存值在我们写入主内存的时候，已经被修改了N次，但是最终又改成原来的值了 CAS导致ABA问题 CAS算法实现了一个重要的前提，需要取出内存中某时刻的数据，并在当下时刻比较并替换，那么这个时间差会导致数据的变化。 比如说一个线程one从内存位置V中取出A，这时候另外一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功 尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的 ABA问题CAS只管开头和结尾，也就是头和尾是一样，那就修改成功，中间的这个过程，可能会被人修改过 原子引用原子引用其实和原子包装类是差不多的概念，就是将一个java类，用原子引用类进行包装起来，那么这个类就具备了原子性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 原子引用 * @author: 陌溪 * @create: 2020-03-11-22:12 */class User &#123; String userName; int age; public User(String userName, int age) &#123; this.userName = userName; this.age = age; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125;public class AtomicReferenceDemo &#123; public static void main(String[] args) &#123; User z3 = new User(\"z3\", 22); User l4 = new User(\"l4\", 25); // 创建原子引用包装类 AtomicReference&lt;User&gt; atomicReference = new AtomicReference&lt;&gt;(); // 现在主物理内存的共享变量，为z3 atomicReference.set(z3); // 比较并交换，如果现在主物理内存的值为z3，那么交换成l4 System.out.println(atomicReference.compareAndSet(z3, l4) + \"\\t \" + atomicReference.get().toString()); // 比较并交换，现在主物理内存的值是l4了，但是预期为z3，因此交换失败 System.out.println(atomicReference.compareAndSet(z3, l4) + \"\\t \" + atomicReference.get().toString()); &#125;&#125; 基于原子引用的ABA问题我们首先创建了两个线程，然后T1线程，执行一次ABA的操作，T2线程在一秒后修改主内存的值 123456789101112131415161718192021222324252627282930313233/** * ABA问题的解决，AtomicStampedReference * @author: 陌溪 * @create: 2020-03-12-15:34 */public class ABADemo &#123; /** * 普通的原子引用包装类 */ static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; // 把100 改成 101 然后在改成100，也就是ABA atomicReference.compareAndSet(100, 101); atomicReference.compareAndSet(101, 100); &#125;, \"t1\").start(); new Thread(() -&gt; &#123; try &#123; // 睡眠一秒，保证t1线程，完成了ABA操作 TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 把100 改成 101 然后在改成100，也就是ABA System.out.println(atomicReference.compareAndSet(100, 2019) + \"\\t\" + atomicReference.get()); &#125;, \"t2\").start(); &#125;&#125; 我们发现，它能够成功的修改，这就是ABA问题 解决ABA问题新增一种机制，也就是修改版本号，类似于时间戳的概念 12T1： 100 1 2019 2T2： 100 1 101 2 100 3 如果T1修改的时候，版本号为2，落后于现在的版本号3，所以要重新获取最新值，这里就提出了一个使用时间戳版本号，来解决ABA问题的思路 方案一:AtomicStampedReference时间戳原子引用，来这里应用于版本号的更新，也就是每次更新的时候，需要比较期望值和当前值，以及期望版本号和当前版本号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * ABA问题的解决，AtomicStampedReference * @author: 陌溪 * @create: 2020-03-12-15:34 */public class ABADemo &#123; /** * 普通的原子引用包装类 */ static AtomicReference&lt;Integer&gt; atomicReference = new AtomicReference&lt;&gt;(100); // 传递两个值，一个是初始值，一个是初始版本号 static AtomicStampedReference&lt;Integer&gt; atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1); public static void main(String[] args) &#123; System.out.println(\"============以下是ABA问题的产生==========\"); new Thread(() -&gt; &#123; // 把100 改成 101 然后在改成100，也就是ABA atomicReference.compareAndSet(100, 101); atomicReference.compareAndSet(101, 100); &#125;, \"t1\").start(); new Thread(() -&gt; &#123; try &#123; // 睡眠一秒，保证t1线程，完成了ABA操作 TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 把100 改成 101 然后在改成100，也就是ABA System.out.println(atomicReference.compareAndSet(100, 2019) + \"\\t\" + atomicReference.get()); &#125;, \"t2\").start(); System.out.println(\"============以下是ABA问题的解决==========\"); new Thread(() -&gt; &#123; // 获取版本号 int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + \"\\t 第一次版本号\" + stamp); // 暂停t3一秒钟 try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 传入4个值，期望值，更新值，期望版本号，更新版本号 atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName() + \"\\t 第二次版本号\" + atomicStampedReference.getStamp()); atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp()+1); System.out.println(Thread.currentThread().getName() + \"\\t 第三次版本号\" + atomicStampedReference.getStamp()); &#125;, \"t3\").start(); new Thread(() -&gt; &#123; // 获取版本号 int stamp = atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + \"\\t 第一次版本号\" + stamp); // 暂停t4 3秒钟，保证t3线程也进行一次ABA问题 try &#123; TimeUnit.SECONDS.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean result = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp+1); System.out.println(Thread.currentThread().getName() + \"\\t 修改成功否：\" + result + \"\\t 当前最新实际版本号：\" + atomicStampedReference.getStamp()); System.out.println(Thread.currentThread().getName() + \"\\t 当前实际最新值\" + atomicStampedReference.getReference()); &#125;, \"t4\").start(); &#125;&#125; 运行结果为： 我们能够发现，线程t3，在进行ABA操作后，版本号变更成了3，而线程t4在进行操作的时候，就出现操作失败了，因为版本号和当初拿到的不一样 方案二:LongAdder（CAS机制优化）LongAdder是java8为我们提供的新的类，跟AtomicLong有相同的效果。是对CAS机制的优化 1234567LongAdder：//变量声明public static LongAdder count = new LongAdder();//变量操作count.increment();//变量取值count 为什么有了AtomicLong还要新增一个LongAdder呢原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。如果竞争不激烈的时候，修改成功率很高，否则失败率很高。在失败的时候，这些重复的原子性操作会耗费性能。（不停的自旋，进入一个无限重复的循环中） 核心思想：将热点数据分离。比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。这相当于将AtomicLong的单点的更新压力分担到各个节点上。在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。而在高并发的时候通过分散提高了性能。 12345678910111213public void increment() &#123; add(1L);&#125;public void add(long x) &#123; `Cell[]` as; long b, v; int m; Cell a; if ((as = cells) != null || !casBase(b = base, b + x)) &#123; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[getProbe() &amp; m]) == null || !(uncontended = a.cas(v = a.value, v + x))) longAccumulate(x, null, uncontended); &#125;&#125; 但是这个CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicInteger，可能有很多线程会不停的自旋，进入一个无限重复的循环中。 这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。 在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。 于是，当当当当，Java 8推出了一个新的类，LongAdder，他就是尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！ 在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。 接着如果发现并发更新的线程数量过多，在发生竞争的情况下，会有一个Cell数组用于将不同线程的操作离散到不同的节点上去 ==(会根据需要扩容，最大为CPU核）==就会开始施行分段CAS的机制，也就是内部会搞一个Cell数组，每个数组是一个数值分段。 这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！ 这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！ 而且他内部实现了自动分段迁移的机制，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。 这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。 最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。 如上图所示，LongAdder则是内部维护多个Cell变量，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候， 如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。 LongAdder维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型。 Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是伪共享。所以这在性能上是一个提升。（补充：可以看到Cell类用Contended注解修饰，这里主要是解决false sharing(伪共享的问题)，不过个人认为伪共享翻译的不是很好，或者应该是错误的共享，比如两个volatile变量被分配到了同一个缓存行，但是这两个的更新在高并发下会竞争，比如线程A去更新变量a，线程B去更新变量b，但是这两个变量被分配到了同一个缓存行，因此会造成每个线程都去争抢缓存行的所有权，例如A获取了所有权然后执行更新这时由于volatile的语义会造成其刷新到主存，但是由于变量b也被缓存到同一个缓存行，因此就会造成cache miss，这样就会造成极大的性能损失） LongAdder的add操作图 可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对Cell[]数组中的单元Cell。 如果Cell[]数组未初始化，会调用父类的longAccumelate去初始化Cell[]，如果Cell[]已经初始化但是冲突发生在Cell单元内，则也调用父类的longAccumelate，此时可能就需要对Cell[]扩容了。 另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。 如上图代码： 例如32、64位操作系统的缓存行大小不一样，因此JAVA8中就增加了一个注@sun.misc.Contended解用于解决这个问题,由JVM去插入这些变量，具体可以参考openjdk.java.net/jeps/142 ，但是通常来说对象是不规则的分配到内存中的，但是数组由于是连续的内存，因此可能会共享缓存行，因此这里加一个Contended注解以防cells数组发生伪共享的情况。 为了降低高并发下多线程对一个变量CAS争夺失败后大量线程会自旋而造成降低并发性能问题，LongAdder内部通过根据并发请求量来维护多个Cell元素(一个动态的Cell数组)来分担对单个变量进行争夺资源。 可以看到LongAdder继承自Striped64类，Striped64内部维护着三个变量，LongAdder的真实值其实就是base的值与Cell数组里面所有Cell元素值的累加，base是个基础值，默认是0，cellBusy用来实现自旋锁，当创建Cell元素或者扩容Cell数组时候用来进行线程间的同步。 在无竞争下直接更新base，类似AtomicLong高并发下，会将每个线程的操作hash到不同的cells数组中，从而将AtomicLong中更新一个value的行为优化之后，分散到多个value中 从而降低更新热点，而需要得到当前值的时候，直接 将所有cell中的value与base相加即可，但是跟AtomicLong(compare and change -&gt; xadd)的CAS不同，incrementAndGet操作及其变种可以返回更新后的值，而LongAdder返回的是void。 由于Cell相对来说比较占内存，因此这里采用懒加载的方式，在无竞争的情况下直接更新base域，在第一次发生竞争的时候(CAS失败)就会创建一个大小为2的cells数组，每次扩容都是加倍，只到达到CPU核数。同时我们知道扩容数组等行为需要只能有一个线程同时执行，因此需要一个锁，这里通过CAS更新cellsBusy来实现一个简单的spin lock。 数组访问索引是通过Thread里的threadLocalRandomProbe域取模实现的，这个域是ThreadLocalRandom更新的，cells的数组大小被限制为CPU的核数，因为即使有超过核数个线程去更新，但是每个线程也只会和一个CPU绑定，更新的时候顶多会有cpu核数个线程，因此我们只需要通过hash将不同线程的更新行为离散到不同的slot即可。 我们知道线程、线程池会被关闭或销毁，这个时候可能这个线程之前占用的slot就会变成没人用的，但我们也不能清除掉，因为一般web应用都是长时间运行的，线程通常也会动态创建、销毁，很可能一段时间后又会被其他线程占用，而对于短时间运行的，例如单元测试，清除掉有啥意义呢？ 参考 AtomicLong与LongAdder（CAS机制的优化） 大白话聊聊Java并发面试问题之Java 8如何优化CAS性能？ https://blog.csdn.net/wolf_love666/article/details/87693771","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"CAS底层原理","date":"2017-08-18T20:53:32.000Z","path":"2017/08/19/CAS底层原理/","text":"CAS(Compare-And-Swap)基本说明 什么是CAS:比较当前工作内存中的值和主内存中的值,如果相同则执行规定操作,否则继续比较直到主内存和工作内存中的值一致为止 CAS保证数据的原子性,是硬件对于并发操作共享数据的支持 凭什么不加synchronized也能保证原子性 =&gt; 原子整型不用加synchronized也能保证原子性,是因为底层用的是Unsafe类 自旋锁 unsafe 先明白Unsafe类是什么?追atomiclInteger.getAndlncrement()方法的源代码atomiclInteger.getAndlncrement()方法的源代码unsafe变量对应Unsafe类,如下图源码继续追源码,可以看见Unsafe.class文件里有用native关键字进行修饰的语句 说明Unsafe类是什么 Unsafe类来自rt.jar/sun/misc包里面,rt.jar及runtime需要的jar包,所以Unsafe.class是从娘胎开始就带着的类 Unsafe是CAS的核心类,由于Java方法无法直接访问底层系统,需要通过本地(native)方法来访问,Unsafe相当于一个后门,基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中,其内部方法操作可以像C的指针一样直接操作内存,因为Java中CAS操作的执行依赖于Unsafe类的方法。 注意Unsafe类中的所有方法都是native修饰的,也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 变量valueOffset,表示该变量值在内存中的偏移地址,因为Unsafe就是根据内存偏移地址获取数据的 变量value用volatile修饰,保证了多线程之间的内存可见性 再弄懂CAS是什么CAS是什么 CAS的全称为Compare-And-Swap,它是一条CPU并发原语,它的功能是判断内存某个位置的值是否为预期值,如果是则更改为新的值,这个过程是原子的。 CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用UnSafe类中的CAS方法,JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能,通过它实现了原子操作。再次强调,由于CAS是一种系统原语,原语属于操作系统用语范畴,是由若干条指令组成的,用于完成某个功能的一个过程,并且原语的执行必须是连续的,在执行过程中不允许被中断,也就是说CAS是一条CPU的原子指令,不会造成所谓的数据不一致问题。 通过getAndAddInt源码进行说明源码说明说明:var5就是我们从主内存中拷贝到工作内存中的值,那么操作的时候，需要比较工作内存中的值，和主内存中的值进行比较,假设执行 compareAndSwapInt返回false，那么就一直执行 while方法，直到期望的值和真实值一样 var1：AtomicInteger对象本身 var2：该对象值得引用地址 var4：需要变动的数量 var5：用var1和var2找到的内存中的真实值 用该对象当前的值与var5比较 如果相同，更新var5 + var4 并返回true 如果不同，继续取值然后再比较，直到更新完成 模拟运行假设线程A和线程B同时执行getAndInt操作（分别跑在不同的CPU上） AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的 value 为3，根据JMM模型，线程A和线程B各自持有一份价值为3的副本，分别存储在各自的工作内存 线程A通过getIntVolatile(var1 , var2) 拿到value值3，这时因为各种情况线程A被挂起（该线程失去CPU执行权） 线程B也通过getIntVolatile(var1, var2)方法获取到value值也是3，此时刚好线程B没有被挂起，并执行了compareAndSwapInt方法，比较内存的值也是3，成功修改内存值为4，线程B打完收工，一切OK 这是线程A恢复，执行CAS方法，比较发现自己手里的数字3和主内存中的数字4不一致，说明该值已经被其它线程抢先一步修改过了，那么A线程本次修改失败，只能够重新读取后在来一遍了，也就是在执行do while 线程A重新获取value值，因为变量value被volatile修饰，所以其它线程对它的修改，线程A总能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。 Unsafe类中的compareAndSwapInt为什么能保证原子性 Unsafe类中的compareAndSwapInt是一个本地方法,该方法的实现位于unsafe.cpp中,需要汇编的知识 CAS缺点CAS不加锁，保证原子性，但是需要多次比较 循环时间长，开销大（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环） 只能保证一个共享变量的原子操作 当对一个共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作 但是对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性 引出来ABA问题？ 总结 什么是CAS:比较当前工作内存中的值和主内存中的值,如果相同则执行规定操作,否则继续比较直到主内存和工作内存中的值一致为止 CAS有3个操作数,内存值V,旧的预期值A,要修改的更新值B。当且仅当预期值A和内存值V相同时,将内存值V修改为B,否则什么都不做.","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"理解Java中的volatile关键字","date":"2017-08-12T10:43:16.000Z","path":"2017/08/12/理解Java中的volatile关键字/","text":"JMM什么是JMMJMM(Java内仔模型JavaMemoryModel,简称JMM)本身是一种抽象的概念并不真实存在,它描述的是一组规则或规范,通过这组规范定义了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式 三个特性 可见性 =&gt; 修改完变量之后,让其他线程第一时间可以看到 原子性 有序性 JMM关于同步规定 线程解锁前,必须把共享变量的值刷新回主内存 线程加锁前,必须读取主内存的最新值到自己的工作内存 加锁解锁是同一把锁 由于 JVM 运行程序的实体是线程,而每个线程创建时 JVM 都会为其创建一个工作内存(有些地方成为栈空间),工作内存是每个线程的私有数据区域,而 Java 内存模型中规定所有变量都存储在主内存,主内存是共享内存区域,所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,此案成间的通讯(传值)必须通过主内存来完成,其简要访问过程如下图: 可见性通过前面对 JMM 的介绍,我们知道各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存操作后再写回主内存中的.这就可能存在一个线程 AAA 修改了共享变量 X 的值还未写回主内存中时 ,另外一个线程BBB 又对内存中的一个共享变量 X 进行操作,但此时 A 线程工作内存中的共享比那里 X 对线程 B 来说并不不可见.这种工作内存与主内存同步延迟现象就造成了可见性问题 volatile是Java虚拟机提供的轻量级的同步机制,是JMM的一个子集实现 三个特性 保证可见性 =&gt; 对应JMM的可见性 不保证原子性 =&gt; 对应JMM的原子性 =&gt; volatile不满足 禁止指令重排 =&gt; 对应JMM的有序性 volatile的保证可见性int number = 0没有volatile关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zjc.collection;import java.util.concurrent.TimeUnit;/** * 验证volate的可见性 */public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData myData = new MyData(); // 资源类 // 第一个线程 new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"\\t 线程进入\"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; myData.setNumber(60); System.out.println(Thread.currentThread().getName() + \"\\t 更新number值\" + myData.getNumber()); &#125;, \"AAA\").start(); // 第二个线程 new Thread(()-&gt;&#123; // 此处，如果循环判断的时number,没有加volatile修饰，就会一直死循环下去， // 但是如果没有这个循环，等待2s之后直接获取，则能获取到线程A改变后的值，因为，主线程，是在线程A修改之后才拿到的数据； while (myData.getNumber() == 0) &#123; // 如果数字一直没变就死循环 // 这里面写点代码会触发可见性,所以死循环里面代码为空 &#125; System.out.println(Thread.currentThread().getName() + \"\\t 任务完成,读取的number为\" + myData.getNumber()); &#125;, \"BBB\").start(); &#125;&#125;class MyData &#123; int number = 0; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125;&#125; 运行结果: int number = 0添加volatile关键字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.zjc.collection;import java.util.concurrent.TimeUnit;/** * 验证volate的可见性 */public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData myData = new MyData(); // 资源类 // 第一个线程 new Thread(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + \"\\t 线程进入\"); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; myData.setNumber(60); System.out.println(Thread.currentThread().getName() + \"\\t 更新number值\" + myData.getNumber()); &#125;, \"AAA\").start(); // 第二个线程 new Thread(()-&gt;&#123; // 此处，如果循环判断的时number,没有加volatile修饰，就会一直死循环下去， // 但是如果没有这个循环，等待2s之后直接获取，则能获取到线程A改变后的值，因为，主线程，是在线程A修改之后才拿到的数据； while (myData.getNumber() == 0) &#123; // 如果数字一直没变就死循环 // 这里面写点代码会触发可见性,所以死循环里面代码为空 &#125; System.out.println(Thread.currentThread().getName() + \"\\t 任务完成,读取的number为\" + myData.getNumber()); &#125;, \"BBB\").start(); &#125;&#125;class MyData &#123; // 添加volatile关键字 volatile int number = 0; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125;&#125; 运行结果 volatile不保证原子性验证volatile不保证原子性 number++在多线程下是非线程安全的,即使number用volatile进行修饰,也不保证原子性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zjc.collection;import java.util.concurrent.TimeUnit;/** * * 2. 验证volatile不保证原子性 * =&gt; 2.1 原子性指的是什么意思? * =&gt; =&gt; =&gt; 不可分割,完整性,即在某个线程正在做某个具体业务时,中间不可以被加塞. * =&gt; =&gt; =&gt; 需要整体完整,要么同时成功,要么同时失败 * =&gt; 2.2 验证是否保证原子性 */public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData myData = new MyData(); for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; myData.addPlusPlus(); &#125; &#125;, String.valueOf(i)).start(); &#125; // 需要等待上面20个线程全部计算完成后,在用main线程取得最终的结果值看是多少? // 运行时,默认有两个线程,一个是main线程,一个是gc线程 while (Thread.activeCount() &gt; 2) &#123; // 礼让线程,即让当前main线程不执行,将线程从运行状态转入就绪状态 Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + \"\\t finally number value:\" + myData.number); &#125;&#125;class MyData &#123; volatile int number = 0; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; public void addPlusPlus() &#123; number++; &#125;&#125; 如果volatile保证原子性,那么运行结果应该是20000,但上述代码运行结果如下 为什么volatile不保证原子性为了方便查看字节码,新起一个文件,写一段相同的代码,并查看字节码,如图 让我们从程序执行的步骤开始分析，查看源码的字节码文件,我们可以发现，底层指令中可以分成4个指令 1234getfieldiconst_1iaddputfield A线程和B线程都进入了add方法中，也就是A线程和B线程都从主内存获取n的值; 假设此时n=1，此时A线程执行完指令iadd，n的数值变为2，并执行putfield指令将数据写回主内存; 此时B线程执行到了iadd执行，由于同一时间只能有一个线程往主内存中更新n的数值，所以B线程在iadd指令这里挂起了; 当A线程将n更新为2后，来不及通知其他线程n的数值已经更新为2的,所以此时B内存接着执行putfield的指令将n数值再次更新为了2，即出现了重复写的情况; 因为n++不同于n = 30之类的指令，它是由4个指令组成的操作，会出现线程加塞的情况。 如何解决number++在多线程下的线程安全问题 增加synchronized的关键字 12345678910111213class MyData &#123; volatile int number = 0; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; public synchronized void addPlusPlus() &#123; number++; &#125;&#125; 使用JUC下的原子变量atomic 12345678910111213141516171819202122232425262728293031package com.zjc.collection;import java.util.concurrent.atomic.AtomicInteger;public class VolatileDemo &#123; public static void main(String[] args) &#123; MyData02 myData02 = new MyData02(); for (int i = 0; i &lt; 20; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; myData02.addAtomic(); &#125; &#125;, String.valueOf(i)).start(); &#125; // 需要等待上面20个线程全部计算完成后,在用main线程取得最终的结果值看是多少? // 运行时,默认有两个线程,一个是main线程,一个是gc线程 while (Thread.activeCount() &gt; 2) &#123; // 礼让线程,即让当前main线程不执行,将线程从运行状态转入就绪状态 Thread.yield(); &#125; System.out.println(Thread.currentThread().getName() + \"\\t finally number value:\" + myData02.number); &#125;&#125;class MyData02 &#123; AtomicInteger number = new AtomicInteger(); public void addAtomic() &#123; number.getAndIncrement(); &#125;&#125; 运行结果如下 指令重排打比方参加高考,老师会交待:同学们,先做会做的题目,再做不会做的,争取考高分也就是说,计算机为了性能(争取考高分),会重派指令(先做会做的题目,再做不会做的),而不会按照原先的顺序(高考试卷题目的顺序)进行操作 指令重排计算机在执行程序时,为了提高性能,编译器和处理器常常会做指令重排,一把分为以下3种 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。 处理器在进行重新排序是必须要考虑指令之间的数据依赖性。 多线程环境中线程交替执行,由于编译器优化重排的存在,两个线程使用的变量能否保持一致性是无法确定的,结果无法预测 内存屏障(Memory Barrier)又称内存栅栏,是一个CPU指令,它的作用有两个: 保证特定操作的执行顺序 保证某些变量的内存可见性(利用该特性实现volatile的内存可见性质) 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。 内存屏障的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读到这些数据的最新版本 对Volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将内存中的共享变量值刷新回到主内存 对Volatile进行读操作时候，会在读操作前加入一条load屏障指令，从内存中读取共享变量 volatile的应用JUC包里面大规模使用volatile比如atomic =&gt; package java.util.concurrent.atomic; 单例模式单例模式在多线程环境下可能存在安全问题 普通写法的单例模式在单线程环境下的运行情况12345678910111213141516171819202122package com.zjc.volatiledemo;public class SingletonDemo &#123; private static SingletonDemo instance = null; private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + \"\\t 我是构造方法SingletonDemo\"); &#125; public static SingletonDemo getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; return instance; &#125; public static void main(String[] args) &#123; System.out.println(SingletonDemo.getInstance()); System.out.println(SingletonDemo.getInstance()); System.out.println(SingletonDemo.getInstance()); &#125;&#125; 单线程情况下,我是构造方法SingletonDemo执行一次,完全没有问题,运行如下但我们用多线程调用会出问题 普通写法的单例模式在多线程环境下的运行情况12345678910111213141516171819202122232425package com.zjc.volatiledemo;public class SingletonDemo &#123; private static SingletonDemo instance = null; private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + \"\\t 我是构造方法SingletonDemo\"); &#125; public static SingletonDemo getInstance() &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; return instance; &#125; public static void main(String[] args) &#123; // 并发多线程后,情况发生了很大变化 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; SingletonDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 理论上,对于单例模式,构造方法里的内容只能执行一次,但我们运行代码之后,如下构造方法里的内容不止执行一次 如何解决使用DCL(Double Check Lock)双重检查锁定机制底下代码关注getInstance()方法的变化 123456789101112131415161718192021222324252627282930package com.zjc.volatiledemo;public class SingletonDemo &#123; private static SingletonDemo instance = null; private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + \"\\t 我是构造方法SingletonDemo\"); &#125; // DCL(Double Check Lock)双端检查锁定机制 public static SingletonDemo getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo.class) &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; // 并发多线程后,情况发生了很大变化 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; SingletonDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 运行结果如下构造方法里的内容只执行一次,貌似万事大吉了,但其实并不是(只是99%大吉),因为双端检查锁定机制不一定是线程安全的 为什么双端检查锁定机制不一定是线程安全的原因因为有指令重排的存在 说明针对上述代码,当某一个线程执行到第一次检测,读取到的instance部位null时,instance的引用对象可能没有完成初始化instance = new SingletonDemo();可以分为一下3步完成(伪代码) 1234561. 分配对象内存空间memory = allocate();2. 初始化对象instance(memory);3. 设置instance指向刚分配的内存地址,此时instance != nullinstance = memory; 步骤2和步骤3不存在数据依赖关系,而昆无论重排前还是重排后程序的执行结果在单线程中并没有改变,因此这种重排优化是允许的 1234561. 分配对象内存空间memory = allocate();3. 设置instance指向刚分配的内存地址,此时instance != null,但是对象还没有初始化完成instance = memory;2. 初始化对象instance(memory); 由于指令重排只会保证串行语义的执行的一致性(单线程),并不会关心多线程间的语义一致性,所以当一条线程访问instance不为null时,由于instance实力未必已初始化完成,也就造成了线程安全问题 写出伪代码再一次说明根据上面的分析,我们得到如下伪代码 123456789101112131415161718// DCL(Double Check Lock)双端检查锁定机制public static SingletonDemo getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo.class) &#123; if (instance == null) &#123; //instance = new SingletonDemo(); // 伪代码 // 1. 分配对象内存空间 memory = allocate(); // 3. 设置instance指向刚分配的内存地址,此时instance != null,但是对象还没有初始化完成 instance = memory; // 2. 初始化对象 instance(memory); &#125; &#125; &#125; return instance;&#125; 对于重排后的代码,A线程设置instance指向刚分配的内存地址,即instance != null,但还未初始化对象 此时B线程调用getInstance()方法,由于instance != null,所以直接return instance,继续执行,但拿到的instance其实是null,会报错 多线程环境中单例模式代码增加了volatile用以禁止重排 12345678910111213141516171819202122232425262728293031package com.zjc.volatiledemo;public class SingletonDemo &#123; // 增加volatile关键字禁止重排 private static volatile SingletonDemo instance = null; private SingletonDemo() &#123; System.out.println(Thread.currentThread().getName() + \"\\t 我是构造方法SingletonDemo\"); &#125; // DCL(Double Check Lock)双重检查锁定机制 public static SingletonDemo getInstance() &#123; if (instance == null) &#123; synchronized (SingletonDemo.class) &#123; if (instance == null) &#123; instance = new SingletonDemo(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; // 并发多线程后,情况发生了很大变化 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; SingletonDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 总结 工作内存与主内存同步延迟现象导致的可见性问题可以使用synchronized或volatile关键字解决,它们都可以使一个线程修改后的变量立即对其他线程可见。 于指令重排导致的可见性问题和有序性问题可以利用volatile关键字解决,因为volatile的另外一个作用就是禁止重排序优化","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"Java多线程中锁的八种情况","date":"2017-08-12T10:19:53.000Z","path":"2017/08/12/Java多线程中锁的八种情况/","text":"公平锁和非公平锁概念公平锁是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列 非公平锁是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁） 如何创建并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁 1234/*** 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁*/Lock lock = new ReentrantLock(true); 两者区别 公平锁：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己 非公平锁： 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。 题外话Java ReenttrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，对于synchronized而言，也是一种非公平锁 可重入锁和递归锁ReentrantLock概念 可重入锁就是递归锁 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 也就是说：线程可以进入任何一个它已经拥有的锁所同步的代码块 ReentrantLock / Synchronized 就是一个典型的可重入锁 代码可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁 1234567public synchronized void method1() &#123; method2();&#125;public synchronized void method2() &#123;&#125; 也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。 作用可重入锁的最大作用就是避免死锁 可重入锁验证证明Synchronized123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 可重入锁（也叫递归锁） * 指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁 * * 也就是说：`线程可以进入任何一个它已经拥有的锁所同步的代码块` * @author: 陌溪 * @create: 2020-03-15-12:12 *//** * 资源类 */class Phone &#123; /** * 发送短信 * @throws Exception */ public synchronized void sendSMS() throws Exception&#123; System.out.println(Thread.currentThread().getName() + \"\\t invoked sendSMS()\"); // 在同步方法中，调用另外一个同步方法 sendEmail(); &#125; /** * 发邮件 * @throws Exception */ public synchronized void sendEmail() throws Exception&#123; System.out.println(Thread.currentThread().getId() + \"\\t invoked sendEmail()\"); &#125;&#125;public class ReenterLockDemo &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); // 两个线程操作资源列 new Thread(() -&gt; &#123; try &#123; phone.sendSMS(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, \"t1\").start(); new Thread(() -&gt; &#123; try &#123; phone.sendSMS(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;, \"t2\").start(); &#125;&#125; 在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为： 1234t1 invoked sendSMS()t1 invoked sendEmail()t2 invoked sendSMS()t2 invoked sendEmail() 这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入 12345t1 invoked sendSMS() t1线程在外层方法获取锁的时候t1 invoked sendEmail() t1在进入内层方法会自动获取锁t2 invoked sendSMS() t2线程在外层方法获取锁的时候t2 invoked sendEmail() t2在进入内层方法会自动获取锁 证明ReentrantLock1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 资源类 */class Phone implements Runnable&#123; Lock lock = new ReentrantLock(); /** * set进去的时候，就加锁，调用set方法的时候，能否访问另外一个加锁的set方法 */ public void getLock() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t get Lock\"); setLock(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void setLock() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t set Lock\"); &#125; finally &#123; lock.unlock(); &#125; &#125; @Override public void run() &#123; getLock(); &#125;&#125;public class ReenterLockDemo &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); /** * 因为Phone实现了Runnable接口 */ Thread t3 = new Thread(phone, \"t3\"); Thread t4 = new Thread(phone, \"t4\"); t3.start(); t4.start(); &#125;&#125; 现在我们使用ReentrantLock进行验证，首先资源类实现了Runnable接口，重写Run方法，里面调用get方法，get方法在进入的时候，就加了锁 123456789public void getLock() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t get Lock\"); setLock(); &#125; finally &#123; lock.unlock(); &#125;&#125; 然后在方法里面，又调用另外一个加了锁的setLock方法 12345678public void setLock() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t set Lock\"); &#125; finally &#123; lock.unlock(); &#125;&#125; 最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层 1234t3 get Lockt3 set Lockt4 get Lockt4 set Lock 当我们在getLock方法加两把锁会是什么情况呢？ (阿里面试)1234567891011public void getLock() &#123; lock.lock(); lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t get Lock\"); setLock(); &#125; finally &#123; lock.unlock(); lock.unlock(); &#125;&#125; 最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开 当我们在getLock方法加两把锁，但是只解一把锁会出现什么情况呢？12345678910public void getLock() &#123; lock.lock(); lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t get Lock\"); setLock(); &#125; finally &#123; lock.unlock(); &#125;&#125; 得到结果 12t3 get Lockt3 set Lock 也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁 当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？12345678910public void getLock() &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t get Lock\"); setLock(); &#125; finally &#123; lock.unlock(); lock.unlock(); &#125;&#125; 这个时候，运行程序会直接报错 123456789101112131415161718t3 get Lockt3 set Lockt4 get Lockt4 set LockException in thread &quot;t3&quot; Exception in thread &quot;t4&quot; java.lang.IllegalMonitorStateException at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151) at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261) at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457) at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52) at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67) at java.lang.Thread.run(Thread.java:745)java.lang.IllegalMonitorStateException at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151) at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261) at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457) at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52) at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67) at java.lang.Thread.run(Thread.java:745) 自旋锁概念 自旋锁：spinlock，是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU 原来提到的比较并交换，底层使用的就是自旋，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。 优缺点 优点：循环比较获取直到成功为止，没有类似于wait的阻塞 缺点：当不断自旋的线程越来越多的时候，会因为执行while循环不断的消耗CPU资源 手写自旋锁通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 手写一个自旋锁 * * 循环比较获取直到成功为止，没有类似于wait的阻塞 * * 通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5秒，B随后进来发现当前有线程持有锁，不是null，所以只能通过自旋等待，直到A释放锁后B随后抢到 * @author: 陌溪 * @create: 2020-03-15-15:46 */public class SpinLockDemo &#123; // 现在的泛型装的是Thread，原子引用线程 AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;(); public void myLock() &#123; // 获取当前进来的线程 Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + \"\\t come in \"); // 开始自旋，期望值是null，更新值是当前线程，如果是null，则更新为当前线程，否者自旋 while(!atomicReference.compareAndSet(null, thread)) &#123; &#125; &#125; /** * 解锁 */ public void myUnLock() &#123; // 获取当前进来的线程 Thread thread = Thread.currentThread(); // 自己用完了后，把atomicReference变成null atomicReference.compareAndSet(thread, null); System.out.println(Thread.currentThread().getName() + \"\\t invoked myUnlock()\"); &#125; public static void main(String[] args) &#123; SpinLockDemo spinLockDemo = new SpinLockDemo(); // 启动t1线程，开始操作 new Thread(() -&gt; &#123; // 开始占有锁 spinLockDemo.myLock(); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 开始释放锁 spinLockDemo.myUnLock(); &#125;, \"t1\").start(); // 让main线程暂停1秒，使得t1线程，先执行 try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 1秒后，启动t2线程，开始占用这个锁 new Thread(() -&gt; &#123; // 开始占有锁 spinLockDemo.myLock(); // 开始释放锁 spinLockDemo.myUnLock(); &#125;, \"t2\").start(); &#125;&#125; 最后输出结果 12345t1 come in .....五秒后.....t1 invoked myUnlock()t2 come in t2 invoked myUnlock() 首先输出的是 t1 come in 然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放 独占锁（写锁） / 共享锁（读锁） / 互斥锁概念 独占锁：指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁 共享锁：指该锁可以被多个线程锁持有 对ReentrantReadWriteLock其读锁是共享，其写锁是独占,即写的时候只能一个人写，但是读的时候，可以多个人同时读 为什么会有写锁和读锁原来我们使用ReentrantLock创建锁的时候，是独占锁，也就是说一次只能一个线程访问，但是有一个读写分离场景，读的时候想同时进行，因此原来独占锁的并发性就没这么好了，因为读锁并不会造成数据不一致的问题，因此可以多个人共享读 多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行，但是如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写 读-读：能共存 读-写：不能共存 写-写：不能共存 代码实现实现一个读写缓存的操作，假设开始没有加锁的时候，会出现什么情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 读写锁 * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行 * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写 * * @author: 陌溪 * @create: 2020-03-15-16:59 */import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;/** * 资源类 */class MyCache &#123; private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // private Lock lock = null; /** * 定义写操作 * 满足：原子 + 独占 * @param key * @param value */ public void put(String key, Object value) &#123; System.out.println(Thread.currentThread().getName() + \"\\t 正在写入：\" + key); try &#123; // 模拟网络拥堵，延迟0.3秒 TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key, value); System.out.println(Thread.currentThread().getName() + \"\\t 写入完成\"); &#125; public void get(String key) &#123; System.out.println(Thread.currentThread().getName() + \"\\t 正在读取:\"); try &#123; // 模拟网络拥堵，延迟0.3秒 TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Object value = map.get(key); System.out.println(Thread.currentThread().getName() + \"\\t 读取完成：\" + value); &#125;&#125;public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); // 线程操作资源类，5个线程写 for (int i = 0; i &lt; 5; i++) &#123; // lambda表达式内部必须是final final int tempInt = i; new Thread(() -&gt; &#123; myCache.put(tempInt + \"\", tempInt + \"\"); &#125;, String.valueOf(i)).start(); &#125; // 线程操作资源类， 5个线程读 for (int i = 0; i &lt; 5; i++) &#123; // lambda表达式内部必须是final final int tempInt = i; new Thread(() -&gt; &#123; myCache.get(tempInt + \"\"); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 我们分别创建5个线程写入缓存 12345678// 线程操作资源类，5个线程写for (int i = 0; i &lt; 5; i++) &#123; // lambda表达式内部必须是final final int tempInt = i; new Thread(() -&gt; &#123; myCache.put(tempInt + \"\", tempInt + \"\"); &#125;, String.valueOf(i)).start();&#125; 5个线程读取缓存， 12345678// 线程操作资源类， 5个线程读for (int i = 0; i &lt; 5; i++) &#123; // lambda表达式内部必须是final final int tempInt = i; new Thread(() -&gt; &#123; myCache.get(tempInt + \"\"); &#125;, String.valueOf(i)).start();&#125; 最后运行结果： 12345678910111213141516171819200 正在写入：04 正在写入：43 正在写入：31 正在写入：12 正在写入：20 正在读取:1 正在读取:2 正在读取:3 正在读取:4 正在读取:2 写入完成4 写入完成4 读取完成：null0 写入完成3 读取完成：null0 读取完成：null1 写入完成3 写入完成1 读取完成：null2 读取完成：null 我们可以看到，在写入的时候，写操作都没其它线程打断了，这就造成了，还没写完，其它线程又开始写，这样就造成数据不一致 解决方法上面的代码是没有加锁的，这样就会造成线程在进行写入操作的时候，被其它线程频繁打断，从而不具备原子性，这个时候，我们就需要用到读写锁来解决了 12345/*** 创建一个读写锁* 它是一个读写融为一体的锁，在使用的时候，需要转换*/private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); 当我们在进行写操作的时候，就需要转换成写锁 12345// 创建一个写锁rwLock.writeLock().lock();// 写锁 释放rwLock.writeLock().unlock(); 当们在进行读操作的时候，在转换成读锁 12345// 创建一个读锁rwLock.readLock().lock();// 读锁 释放rwLock.readLock().unlock(); 这里的读锁和写锁的区别在于，写锁一次只能一个线程进入，执行写操作，而读锁是多个线程能够同时进入，进行读取的操作 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * 读写锁 * 多个线程 同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行 * 但是，如果一个线程想去写共享资源，就不应该再有其它线程可以对该资源进行读或写 * * @author: 陌溪 * @create: 2020-03-15-16:59 */import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * 资源类 */class MyCache &#123; /** * 缓存中的东西，必须保持可见性，因此使用volatile修饰 */ private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); /** * 创建一个读写锁 * 它是一个读写融为一体的锁，在使用的时候，需要转换 */ private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock(); /** * 定义写操作 * 满足：原子 + 独占 * @param key * @param value */ public void put(String key, Object value) &#123; // 创建一个写锁 rwLock.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t 正在写入：\" + key); try &#123; // 模拟网络拥堵，延迟0.3秒 TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key, value); System.out.println(Thread.currentThread().getName() + \"\\t 写入完成\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 写锁 释放 rwLock.writeLock().unlock(); &#125; &#125; /** * 获取 * @param key */ public void get(String key) &#123; // 读锁 rwLock.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + \"\\t 正在读取:\"); try &#123; // 模拟网络拥堵，延迟0.3秒 TimeUnit.MILLISECONDS.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Object value = map.get(key); System.out.println(Thread.currentThread().getName() + \"\\t 读取完成：\" + value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 读锁释放 rwLock.readLock().unlock(); &#125; &#125; /** * 清空缓存 */ public void clean() &#123; map.clear(); &#125;&#125;public class ReadWriteLockDemo &#123; public static void main(String[] args) &#123; MyCache myCache = new MyCache(); // 线程操作资源类，5个线程写 for (int i = 1; i &lt;= 5; i++) &#123; // lambda表达式内部必须是final final int tempInt = i; new Thread(() -&gt; &#123; myCache.put(tempInt + \"\", tempInt + \"\"); &#125;, String.valueOf(i)).start(); &#125; // 线程操作资源类， 5个线程读 for (int i = 1; i &lt;= 5; i++) &#123; // lambda表达式内部必须是final final int tempInt = i; new Thread(() -&gt; &#123; myCache.get(tempInt + \"\"); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 运行结果： 12345678910111213141516171819201 正在写入：11 写入完成2 正在写入：22 写入完成3 正在写入：33 写入完成4 正在写入：44 写入完成5 正在写入：55 写入完成2 正在读取:3 正在读取:1 正在读取:4 正在读取:5 正在读取:2 读取完成：21 读取完成：14 读取完成：43 读取完成：35 读取完成：5 从运行结果我们可以看出，写入操作是一个一个线程进行执行的，并且中间不会被打断，而读操作的时候，是同时5个线程进入，然后并发读取操作","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"Java容器线程不安全该如何处理","date":"2017-08-11T15:50:45.000Z","path":"2017/08/11/Java容器线程不安全该如何处理/","text":"ArrayList新建与扩容 新建 =&gt; 新建一个长度为10的object数组(确切来说,是一个空引用,当第一次add,才新建一个长度为10的数组) 第一次扩容 =&gt; 增加原先值的一半,即扩容到(10 * 3) / 2 + 1 = 16 第二次扩容 =&gt; 增加原先值的一半,即扩容 (16 * 3) / 2 + 1 = 25 源码如下 线程不安全 =&gt; 如何证明与解决方案故障现象1234567891011121314151617package com.zjc.collection;import java.util.ArrayList;import java.util.UUID;public class ArrayListDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); &#125;).start(); &#125; &#125;&#125; 会出现并发修改异常 ConcurrentModificationException:当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。 迭代器是依赖于集合而存在的，在判断成功后，集合的中新添加了元素，而迭代器却不知道，所以就报错了，这个错叫并发修改异常。 简单描述就是：迭代器遍历元素的时候，通过集合是不能修改元素的。 导致原因多线程并发争抢同一个类,且没有加锁 解决方法 使用Vector,线程安全,但是降低并发 1234567891011121314151617package com.zjc.collection;import java.util.ArrayList;import java.util.UUID;public class ArrayListDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new Vector&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); &#125;).start(); &#125; &#125;&#125; 使用Collections集合接口的工具类(Collection =&gt; 集合的接口) 12345678910111213141516171819package com.zjc.collection;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.UUID;public class ArrayListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); &#125;).start(); &#125; &#125;&#125; 写时复制 123456789101112131415161718package com.zjc.collection;import java.util.List;import java.util.UUID;import java.util.concurrent.CopyOnWriteArrayList;public class ArrayListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; list.add(UUID.randomUUID().toString().substring(0, 8)); System.out.println(list); &#125;).start(); &#125; &#125;&#125; CopyOnWrite容器说明参考 CopyOnWriteArrayList原理，优缺点，使用场景 聊聊并发-Java中的Copy-On-Write容器 什么是CopyOnWrite容器 CopyOnWrite容器即写时复制的容器。 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器 然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器 有什么好处 我们可以对CopyOnWrite容器进行并发的读，而不需要加锁,因为当前容器不会添加任何元素。 所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 CopyOnWrite在多线程场景中的使用 具体代码中的区别如下(CopyOnWriteArrayList)1234567891011121314151617181920212223242526272829/** * 多线程 * 使用普通的ArrayList,不使用CopyOnWriteArrayList的情况 */public void syncContainer1() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt; &#123; // 需要写同步块 synchronized (list) &#123; list.add(Thread.currentThread().getName()); &#125; &#125;).start(); &#125;&#125;/** * 多线程 * 使用CopyOnWriteArrayList的情况 */public void syncContainer2() &#123; CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt; &#123; // 不需要写同步块 list.add(Thread.currentThread().getName()); &#125;).start(); &#125;&#125; CopyOnWriteArrayList的实现原理 上述代码使用了CopyOnWriteArrayList，接下去我们看看其源码是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。 以下源码基于jdk1.8 更新版本其实可以在搜索synchronized,是使用这个关键字实现的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; // 当前线程进行写前要加锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); // 获取旧数组长度 int len = elements.length; // 创建一个新的数组,长度比旧数组多1,并将旧数组拷贝进新的数组 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将要添加的元素添加进新的数组 newElements[len] = e; // 将原来指向旧数组的指针指向新的数组 setArray(newElements); // 返回true表示成功 return true; &#125; finally &#123; // 写结束,解锁 lock.unlock(); &#125;&#125;/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125;/** * Replaces the element at the specified position in this list with the * specified element. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 应用场景 读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为开始读的那一刻已经确定了读的对象是旧对象。 CopyOnWrite并发容器用于读多写少的并发场景 比如白名单，黑名单等场景 CopyOnWrite的缺点CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。 内存占用问题 因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。 针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。 数据一致性问题 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。 优化建议 高并发情况下,可以使用JUC里的CopyOnWriteArrayList java出现20年,不是极端情况下,大部分问题前人已经遇到过了,不建议重复造轮子 HashMap新建与扩容 HashMap的位桶数组，初始大小为16 实际使用时，显然大小是可变的 如果位桶数组中的元素达到(0.75*数组 length)，就重新调整数组大小变为原来2倍大小 扩容很耗时 扩容的本质是定义新的更大的数组，并将旧数组内容挨个拷贝到新数组中1231. 新建 =&gt; 长度为162. 第一次扩容 =&gt; 原先值的一倍,即扩容到323. 第二次扩容 =&gt; 原先值的一倍,即扩容到64 线程不安全 =&gt; 如何证明与解决方案故障现象1234567891011121314151617package com.zjc.collection;import java.util.HashMap;import java.util.Map;import java.util.UUID;public class ArrayListDemo &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8)); System.out.println(map); &#125;).start(); &#125; &#125;&#125; 解决方法 使用HashTable 12+ HashMap: 线程不安全，效率高。允许key或value为null。+ HashTable: 线程安全，效率低。不允许key或value为null。 使用JUC里的ConcurrentHashMap 123456789101112131415161718package com.zjc.collection;import java.util.Map;import java.util.UUID;import java.util.concurrent.ConcurrentHashMap;public class ArrayListDemo &#123; public static void main(String[] args) &#123; // 使用ConcurrentHashMap替代HashMap Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;(); for (int i = 0; i &lt; 30; i++) &#123; new Thread(() -&gt; &#123; map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8)); System.out.println(map); &#125;).start(); &#125; &#125;&#125; HashSetHashSet是否安全 HashSet底层是HashMap 为什么HashSet的add方法只需要一个元素 =&gt; 是因为 所以HashSet是不安全的 解决方法1CopyOnWriteArraySet&lt;Object&gt; copyOnWriteArraySet = new CopyOnWriteArraySet&lt;&gt;();","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"Java中的容器","date":"2017-08-11T15:42:39.000Z","path":"2017/08/11/Java中的容器/","text":"Java集合层次图 Collection接口Collection 表示一组对象，它是集中、收集的意思。Collection接口的两个子接口是List、Set接口。由于List、Set是Collection的子接口，意味着所有List、Set的实现类都有上面的方法。 List系列List特点和常用方法List基本说明List是有序、可重复的容器。 有序：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。 可重复：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。 除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法，参见下表：List接口常用的实现类有3个：ArrayList、LinkedList和Vector。 List的常用方法 代码12345678910111213141516171819202122232425public class TestList &#123; /** * 测试add/remove/size/isEmpty/contains/clear/toArrays等方法 */ public static void test01() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); System.out.println(list.isEmpty()); // true,容器里面没有元素 list.add(\"刘备\"); System.out.println(list.isEmpty()); // false,容器里面有元素 list.add(\"关羽\"); list.add(\"张飞\"); System.out.println(list); System.out.println(\"list的大小：\" + list.size()); System.out.println(\"是否包含指定元素：\" + list.contains(\"关羽\")); list.remove(\"刘备\"); System.out.println(list); Object[] objs = list.toArray(); System.out.println(\"转化成Object数组：\" + Arrays.toString(objs)); list.clear(); System.out.println(\"清空所有元素：\" + list); &#125; public static void main(String[] args) &#123; test01(); &#125;&#125; 两个List之间的元素处理123456789101112131415161718192021222324252627public class TestList &#123; public static void main(String[] args) &#123; test02(); &#125; /** * 测试两个容器之间元素处理 */ public static void test02() &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"刘备\"); list.add(\"关羽\"); list.add(\"张飞\"); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); list2.add(\"刘备\"); list2.add(\"张三\"); list2.add(\"李四\"); System.out.println(list.containsAll(list2)); //false list是否包含list2中所有元素 System.out.println(list); list.addAll(list2); //将list2中所有元素都添加到list中 System.out.println(list); list.removeAll(list2); //从list中删除同时在list和list2中存在的元素 System.out.println(list); list.retainAll(list2); //取list和list2的交集 System.out.println(list); &#125;&#125; ArrayList特点和底层实现特点 查询效率高，增删效率低，线程不安全。 底层实现 ArrayList底层使用Object数组来存储元素数据。所有的方法，都围绕这个核心的Object数组来开展。源码如下: 数组新建与扩容 1231. 新建 =&gt; 新建一个长度为10的object数组(确切来说,是一个空引用,当第一次add,才新建一个长度为10的数组)2. 第一次扩容 =&gt; 增加原先值的一半,即扩容到 (10 * 3) / 2 + 1 = 163. 第二次扩容 =&gt; 增加原先值的一半,即扩容 (16 * 3) / 2 + 1 = 25 源码如下 LinkedList特点和底层实现特点 查询效率低，增删效率高，线程不安全。 底层实现 LinkedList底层用双向链表实现的存储 每个节点都应该有3部分内容 12345class Node &#123; Node previous; //前一个节点 Object element; //本节点保存的数据 Node next; //后一个节点&#125; LinkedList的源码，可以看到里面包含了双向链表的相关代码 Vector向量 Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。 比如，indexOf方法就增加了synchronized同步标记。 如何选用ArrayList、LinkedList、Vector? 需要线程安全时，用Vector。 不存在线程安全问题时，并且查找较多用ArrayList(一般使用它)。 不存在线程安全问题时，增加或删除元素较多用LinkedList。 Map系列 Map就是用来存储“键(key)-值(value) 对”的 Map类中存储的“键值对”通过键来标识，所以“键对象”不能重复 Map 接口的实现类有HashMap、TreeMap、HashTable、Properties等 Map接口中常用的方法 HashMapHashMap基本说明 HashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。 HashMap在查找、删除、修改方面都有非常高的效率 HashMap中的常用方法123456789101112131415161718192021public class TestMap &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; m1 = new HashMap&lt;Integer, String&gt;(); Map&lt;Integer, String&gt; m2 = new HashMap&lt;Integer, String&gt;(); m1.put(1, \"one\"); m1.put(2, \"two\"); m1.put(3, \"three\"); m2.put(1, \"一\"); m2.put(2, \"二\"); System.out.println(m1.size()); System.out.println(m1.containsKey(1)); System.out.println(m2.containsValue(\"two\")); m1.put(3, \"third\"); //键重复了，则会替换旧的键值对 Map&lt;Integer, String&gt; m3 = new HashMap&lt;Integer, String&gt;(); m3.putAll(m1); m3.putAll(m2); System.out.println(\"m1:\" + m1); System.out.println(\"m2:\" + m2); System.out.println(\"m3:\" + m3); &#125;&#125; HashMap底层实现基本结构 数据结构中由数组和链表来实现对数据的存储，他们各有特点 数组：占用空间连续。 寻址容易，查询速度快。但是，增加和删除效率非常低 链表：占用空间不连续。 寻址困难，查询速度慢。但是，增加和删除效率非常高 那么，我们能不能结合数组和链表的优点(即查询快，增删效率也高)呢? 答案就是“哈希表” 哈希表的本质就是“数组+链表”,HashMap底层实现采用了哈希表 打开HashMap源码，发现有如下两个核心内容 其中的Entry[] table就是HashMap的核心数组结构，我们也称之为“位桶数组”。我们再继续看Entry是什么，源码如下： 一个Entry对象存储了 key：键对象 value：值对象 next:下一个节点 hash: 键对象的hash值 显然每一个Entry对象就是一个单向链表结构，而Engtry本身是一个数组,所以我们可以画出一个Entry对象的典型示意 然后，我们画出Entry[]数组的结构(这也是HashMap的结构)： 插入数据过程put(key,value)我们的目的是将”key-value两个对象”成对存放到HashMap的Entry[]数组中。参见以下步骤： (1) 获得key对象的hashcode首先调用key对象的hashcode()方法，获得hashcode。 (2) 根据hashcode计算出hash值(要求在[0, 数组长度-1]区间) hashcode是一个整数，我们需要将它转化成[0, 数组长度-1]的范围。我们要求转化后的hash值尽量均匀地分布在[0,数组长度-1]这个区间，减少“hash冲突” i.一种极端简单和低下的算法是： hash值 = hashcode/hashcode; 也就是说，hash值总是1。意味着，键值对对象都会存储到数组索引1位置，这样就形成一个非常长的链表。相当于每存储一个对象都会发生“hash冲突”，HashMap也退化成了一个“链表”。 ii. 一种简单和常用的算法是(相除取余算法)： hash值 = hashcode%数组长度 这种算法可以让hash值均匀的分布在[0,数组长度-1]的区间。 早期的HashTable就是采用这种算法。但是，这种算法由于使用了“除法”，效率低下。 JDK后来改进了算法。首先约定数组长度必须为2的整数幂，这样采用位运算即可实现取余的效果：hash值 = hashcode&amp;(数组长度-1) 如下为我们自己测试简单的hash算法： 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; int h = 25860399; int length = 16;//length为2的整数次幂,则h&amp;(length-1)相当于对length取模 myHash(h, length); &#125; /** * @param h 任意整数 * @param length 长度必须为2的整数幂 * @return */ public static int myHash(int h,int length)&#123; System.out.println(h&amp;(length-1)); //length为2的整数幂情况下，和取余的值一样 System.out.println(h%length);//取余数 return h&amp;(length-1); &#125;&#125; 运行如上程序，我们就能发现直接取余(h%length)和位运算(h&amp;(length-1))结果是一致的。事实上，为了获得更好的散列效果，JDK对hashcode进行了两次散列处理(核心目标就是为了分布更散更均匀)，源码如下 (3) 生成Entry对象如上所述，一个Entry对象包含4部分：key对象、value对象、hash值、指向下一个Entry对象的引用。我们现在算出了hash值。下一个Entry对象的引用为null。 (4) 将Entry对象放到table数组中如果本Entry对象对应的数组索引位置还没有放Entry对象，则直接将Entry对象存储进数组;如果对应索引位置已经有Entry对象，则将已有Entry对象的next指向本Entry对象，形成链表。 总结如上过程 当添加一个元素(key-value)时，首先计算key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，就形成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。 JDK8中，当链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。 取数据过程get(key) 1) 获得key的hashcode，通过hash()散列算法得到hash值，进而定位到数组的位置。 2) 在链表上挨个比较key对象。调用equals()方法，将key对象和链表上所有节点的key对象进行比较，直到碰到返回true的节点对象为止。 3) 返回equals()为true的节点对象的value对象。 注意:hashcode()和equals方法的关系 Java中规定，两个内容相同(equals()为true)的对象必须具有相等的hashCode。 因为如果equals()为true而两个对象的hashcode不同,那在整个存储过程中就发生了悖论。 扩容问题 HashMap的位桶数组，初始大小为16 实际使用时，显然大小是可变的 如果位桶数组中的元素达到(0.75*数组 length)， 就重新调整数组大小变为原来2倍大小 扩容很耗时 扩容的本质是定义新的更大的数组，并将旧数组内容挨个拷贝到新数组中。 JDK8将链表在大于8情况下变为红黑二叉树 JDK8中，HashMap在存储一个元素时，当对应链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。 HashTableHashTable类和HashMap用法几乎一样，底层实现几乎一样，只不过HashTable的方法添加了synchronized关键字确保线程同步检查，效率较低。 TreeMapTreeMap基本介绍TreeMap和HashMap实现了同样的接口Map，因此，用法对于调用者来说没有区别。 TreeMap底层实现 TreeMap是红黑二叉树的典型实现。我们打开TreeMap的源码，发现里面有一行核心代码： 1private transient Entry&lt;K,V&gt; root = null; root用来存储整个树的根节点。我们继续跟踪Entry(是TreeMap的内部类)的代码： 可以看到里面存储了本身数据、左节点、右节点、父节点、以及节点颜色。 TreeMap的put()/remove()方法大量使用了红黑树的理论。限于篇幅，不再展开 如何选用HashMap,HashTable和TreeMap HashMap: 线程不安全，效率高。允许key或value为null。 HashTable: 线程安全，效率低。不允许key或value为null。 HashMap效率高于TreeMap;在需要排序的Map时才选用TreeMap。 Set系列 Set接口继承自Collection，Set接口中没有新增方法，方法和Collection保持完全一致。 Set容器特点：无序、不可重复。 无序指Set中的元素没有索引，我们只能遍历查找; 不可重复指不允许加入重复的元素。更确切地讲，新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入;甚至，Set中也只能放入一个null元素，不能多个。 Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet。 HashSetHashSet基本使用1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); s.add(\"hello\"); s.add(\"world\"); System.out.println(s); s.add(\"hello\"); //相同的元素不会被加入 System.out.println(s); s.add(null); System.out.println(s); s.add(null); System.out.println(s); &#125;&#125; HashSet底层实现 HashSet是采用哈希算法实现，底层实际是用HashMap实现的(HashSet本质就是一个简化版的HashMap)，因此，查询效率和增删效率都比较高。我们来看一下HashSet的源码： 我们发现里面有个map属性，这就是HashSet的核心秘密。我们再看add()方法，发现增加一个元素说白了就是在map中增加一个键值对，键对象就是这个元素，值对象是名为PRESENT的Object对象。说白了，就是“往set中加入元素，本质就是把这个元素作为key加入到了内部的map中”。 由于map中key都是不可重复的，因此，Set天然具有“不可重复”的特性。 TreeSetTreeSet基本使用 TreeSet底层实际是用TreeMap实现的，内部维持了一个简化版的TreeMap，通过key来存储Set的元素。 TreeSet内部需要对存储的元素进行排序，因此，我们对应的类需要实现Comparable接口。这样，才能根据compareTo()方法比较对象之间的大小，才能进行内部排序。 TreeSet底层实现12345678910111213141516171819202122232425262728293031323334public class Test &#123; public static void main(String[] args) &#123; User u1 = new User(1001, \"高淇\", 18); User u2 = new User(2001, \"高希希\", 5); Set&lt;User&gt; set = new TreeSet&lt;User&gt;(); set.add(u1); set.add(u2); &#125;&#125; class User implements Comparable&lt;User&gt; &#123; int id; String uname; int age; public User(int id, String uname, int age) &#123; this.id = id; this.uname = uname; this.age = age; &#125; /** * 返回0 表示 this == obj 返回正数表示 this &gt; obj 返回负数表示 this &lt; obj */ @Override public int compareTo(User o) &#123; if (this.id &gt; o.id) &#123; return 1; &#125; else if (this.id &lt; o.id) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125; 使用TreeSet要点 由于是二叉树，需要对元素做内部排序。 如果要放入TreeSet中的类没有实现Comparable接口，则会抛出异常：java.lang.ClassCastException。 TreeSet中不能放入null元素 使用Iterator迭代器遍历容器迭代器为我们提供了统一的遍历容器的方式，参见以下示例代码 迭代器遍历List123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; aList = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 5; i++) &#123; aList.add(\"a\" + i); &#125; System.out.println(aList); for (Iterator&lt;String&gt; iter = aList.iterator(); iter.hasNext();) &#123; String temp = iter.next(); System.out.print(temp + \"\\t\"); if (temp.endsWith(\"3\")) &#123;// 删除3结尾的字符串 iter.remove(); &#125; &#125; System.out.println(); System.out.println(aList); &#125;&#125; 建议:如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历 迭代器遍历Set123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; 5; i++) &#123; set.add(\"a\" + i); &#125; System.out.println(set); for (Iterator&lt;String&gt; iter = set.iterator(); iter.hasNext();) &#123; String temp = iter.next(); System.out.print(temp + \"\\t\"); &#125; System.out.println(); System.out.println(set); &#125;&#125; 迭代器遍历Map方式一123456789101112public class Test &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"A\", \"高淇\"); map.put(\"B\", \"高小七\"); Set&lt;Entry&lt;String, String&gt;&gt; ss = map.entrySet(); for (Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = ss.iterator(); iterator.hasNext();) &#123; Entry&lt;String, String&gt; e = iterator.next(); System.out.println(e.getKey() + \"--\" + e.getValue()); &#125; &#125;&#125; 方式二123456789101112public class Test &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"A\", \"高淇\"); map.put(\"B\", \"高小七\"); Set&lt;String&gt; ss = map.keySet(); for (Iterator&lt;String&gt; iterator = ss.iterator(); iterator.hasNext();) &#123; String key = iterator.next(); System.out.println(key + \"--\" + map.get(key)); &#125; &#125;&#125; 遍历集合的方法总结遍历List方法一：普通for循环1234for(int i=0;i&lt;list.size();i++)&#123;//list为集合的对象名 String temp = (String)list.get(i); System.out.println(temp);&#125; 方法二：增强for循环(使用泛型!)123for (String temp : list) &#123; System.out.println(temp);&#125; 方法三：使用Iterator迭代器(1)1234for(Iterator iter= list.iterator();iter.hasNext();)&#123; String temp = (String)iter.next(); System.out.println(temp);&#125; 方法四：使用Iterator迭代器(2)123456Iterator iter =list.iterator();while(iter.hasNext())&#123; Object obj = iter.next(); iter.remove();//如果要遍历时，删除集合中的元素，建议使用这种方式！ System.out.println(obj);&#125; 遍历Set方法一：增强for循环123for(String temp:set)&#123; System.out.println(temp);&#125; 方法二：使用Iterator迭代器1234for(Iterator iter = set.iterator();iter.hasNext();)&#123; String temp = (String)iter.next(); System.out.println(temp);&#125; 遍历Map方法一：根据key获取value12345Map&lt;Integer, Man&gt; maps = new HashMap&lt;Integer, Man&gt;();Set&lt;Integer&gt; keySet = maps.keySet();for(Integer id : keySet)&#123; System.out.println(maps.get(id).name);&#125; 方法二：使用entrySet1234Set&lt;Entry&lt;Integer, Man&gt;&gt; ss = maps.entrySet();for (Iterator iterator = ss.iterator(); iterator.hasNext();) &#123; Entry e = (Entry) iterator.next(); System.out.println(e.getKey()+\"--\"+e.getValue()); Collections工具类Collections工具类基本说明类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。 void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。 void shuffle(List) //对List容器内的元素进行随机排列。 void reverse(List) //对List容器内的元素进行逆续排列 。 void fill(List, Object) //用一个特定的对象重写整个List容器。 int binarySearch(List, Object)//对于顺序的List容器，采用折半查找的方法查找特定对象。 Collections工具类的常用方法123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; aList = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 5; i++)&#123; aList.add(\"a\" + i); &#125; System.out.println(aList); Collections.shuffle(aList); // 随机排列 System.out.println(aList); Collections.reverse(aList); // 逆续 System.out.println(aList); Collections.sort(aList); // 排序 System.out.println(aList); System.out.println(Collections.binarySearch(aList, \"a2\")); Collections.fill(aList, \"hello\"); System.out.println(aList); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"调整Eclipse左边包的显示方式","date":"2017-08-10T11:06:22.000Z","path":"2017/08/10/调整eclipse左边包的显示方式/","text":"Eclipse 中包结构展开有两种方式 平坦方式（flat） 分层方式（hierarchical） 包结构显示方式设置","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"}]},{"title":"使用Awk命令处理文本","date":"2017-07-11T15:10:40.000Z","path":"2017/07/11/使用awk命令处理文本/","text":"案例 使用awk批量修改文件名 1234567891011121314151617181920212223242526# 命令# 将01_abc_def文件名变更为0100_abc_def文件名ll | awk '&#123;print $9&#125;' | awk -F '_' '&#123;if ($1 * 100 &lt; 3901 &amp;&amp; $1 * 100 &gt; 1)&#123;if ($3)&#123;printf(\"mv %s \\t %s \\n\", $0, $1 \"00_\"$2 \"_\"$3)&#125; else &#123;printf(\"mv %s \\t %s \\n\", $0, $1 \"00_\"$2)&#125;&#125;&#125;' | sh# 稍微分解一下# 查看所有文件ll# 获取文件名列awk '&#123;print $9&#125;'# 处理文本,得到\"mv 01_abc_def 0100_abc_def\"语句awk -F '_' '&#123;if ($1 * 100 &lt; 3901 &amp;&amp; $1 * 100 &gt; 1)&#123;if ($3)&#123;printf(\"mv %s \\t %s \\n\", $0, $1 \"00_\"$2 \"_\"$3)&#125; else &#123;printf(\"mv %s \\t %s \\n\", $0, $1 \"00_\"$2)&#125;&#125;&#125;'# ====&gt; 相当与 &lt;====awk -F '_' # 分割字符串,分割符为'_'&#123; if ($1 * 100 &lt; 3901 &amp;&amp; $1 * 100 &gt; 1) &#123; # 排除一些不需要修改的 if ($3) &#123; # 当第三列存在时 printf(\"mv %s \\t %s \\n\", $0, $1 \"00_\"$2 \"_\"$3) # 拼接字符串用双引号将要拼接的字符串引起来 &#125; else &#123; # 当第三列不存在时 printf(\"mv %s \\t %s \\n\", $0, $1 \"00_\"$2) &#125; &#125;&#125;sh # 执行前面的文本 使用 awk 过滤 history 输出，找到最常用的命令 1history | awk '&#123;a[$2]++&#125;END&#123;for(i in a)&#123;print a[i] \" \" i&#125;&#125;' | sort -rn | head 过滤文件中重复行 1awk '!x[$0]++' &lt;file&gt; 将一行长度超过 72 字符的行打印 1awk 'length&gt;72' file 查看最近哪些用户使用系统 1last | grep -v \"^$\" | awk '&#123; print $1 &#125;' | sort -nr | uniq -c 假设有一个文本，每一行都是一个 int 数值，想要计算这个文件每一行的和，可以使用 1awk '&#123;s+=$1&#125; ENG &#123;printf \"%.0f\", s&#125;' /path/to/file 调用awk123456789101112131.命令行方式awk [-F field-separator] &apos;commands&apos; input-file(s)其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。2.shell脚本方式将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。相当于shell脚本首行的：#!/bin/sh可以换成：#!/bin/awk3.将所有的awk命令插入一个单独文件，然后调用：awk -f awk-script-file input-file(s)其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。 使用说明基本格式1awk [options] 'script' file awk 同时处理多个文件1awk '&#123;print FILENAME \"\\t\" $0&#125;' demo1.txt demo2.txt awk 自定义分隔符1234awk -F ':' '&#123;print $1&#125;' /etc/passwd# nectarine(200g)2008 -&gt; nectarine 200g 2008awk -F '[()]' '&#123;print $1, $2, $3&#125;' some.log awk 默认的分割符为空格和制表符 分割后的字段依次用 $1, $2,$3 来表示 $0 表示字符串本身 在 -F 参数中使用一对方括号来指定多个分隔符，awk 处理 some.log 文件时就会使用 “(“ 或者 “)” 来对文件的每一行进行分割 在 awk 中使用正则表达式12345678910111213141516171819202122232425262728293031323334353637383940# 待匹配文本This above all: to thine self be trueThere is nothing either good or bad, but thinking makes it soThere’s a special providence in the fall of a sparrowNo matter how dark long, may eventually in the day arrival# 匹配字符串 “There” ，将包含这个字符串的行打印并输出awk '/There/&#123;print $0&#125;' poetry.txtThere is nothing either good or bad, but thinking makes it soThere’s a special providence in the fall of a sparrow# 匹配一个包含字母 t 和字母 e 并且 t 和 e 中间只能有任意单个字符的行awk '/t.e/&#123;print $0&#125;' poetry.txtThere is nothing either good or bad, but thinking makes it soThere’s a special providence in the fall of a sparrowNo matter how dark long, may eventually in the day arrival# 以 “The” 字符串开头的行awk '/^The/&#123;print $0&#125;' poetry.txt# 以 “true” 字符串结尾的行awk '/true$/&#123;print $0&#125;' poetry.txt# /s[a-z]/ 表示匹配包含字符 s 然后后面跟着任意 a 到 z 之间的单个字符的字符串awk '/s[a-z]/&#123;print $0&#125;' poetry.txt# 字母 \"o\" 只能可以出现 2 次，3 次，4 次，5 次，6 次 ... 一直到 10 次awk '/go&#123;2,10&#125;d/&#123;print $0&#125;' poetry.txt# 字母 \"o\" 必须至少出现 2 次或着 2 次以上awk '/go&#123;2,&#125;d/&#123;print $0&#125;' poetry.txt# 星号表示字符匹配 0 次或者多次# 加号表示字符匹配 1 个或者 1 个以上# 问号字符只能出现 0 次 或者 1 次awk '/go*d/&#123;print $0&#125;' poetry.txtawk '/go+d/&#123;print $0&#125;' poetry.txtawk '/go?d/&#123;print $0&#125;' poetry.txt 使用 AWK 移除行中特定模式文件中有行数据 12/abc/def/123 456/abc/def/222 456 想要移除 123，保留之前的字母和后面的数字，则可以使用 1awk 'sub(/[0-9]+/,\"\",$1)' /path/to/file print和printf awk中同时提供了print和printf两种打印输出的函数。 print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已 printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂 awk 编程BEGIN 和 END 关键字的使用 BEGIN:会在开始读取一个文件之前，运行一次 BEGIN 关键字后面的脚本代码段 END:读取并且处理完文件的所有内容行之后，才会执行 END 后面的脚本代码段 12345678cat /etc/passwd |awk -F ':' 'BEGIN &#123;print \"name,shell\"&#125; &#123;print $1\",\"$7&#125; END &#123;print \"blue,/bin/nosh\"&#125;'name,shell # BEGIN多这一行root,/bin/bashdaemon,/bin/shbin,/bin/shsys,/bin/sh....blue,/bin/nosh # END多这一行 在 awk 中使用变量可以在 awk 脚本中声明和使用变量1awk '&#123;msg=\"hello world\"; print msg&#125;' /etc/passwd awk 声明的变量可以在任何多个花括号脚本中使用 1awk 'BEGIN &#123;msg=\"hello world\"&#125; &#123;print msg&#125;' /etc/passwd 在 awk 中使用数学运算，在 awk 中，像其他编程语言一样，它也支持一些基本的数学运算操作 1awk '&#123;a = 12; b = 24; print a + b&#125;' company.txt 上面这段脚本表示，先声明两个变量 a = 12 和 b = 24，然后用 print 打印出 a 加上 b 的结果awk 还支持其他的数学运算符 12345+ 加法运算符- 减法运算符* 乘法运算符/ 除法运算符% 取余运算符 awk 内置变量的使用 0这个表示文本处理时的当前行，1 表示文本行被分隔后的第 1 个字段列，2表示文本行被分割后的第2个字段列，3 表示文本行被分割后的第 3 个字段列，$n 表示文本行被分割后的第 n 个字段列 NR 表示文件中的行号，表示当前是第几行 123456awk '&#123;print NR \"\\t\" $0&#125;' fruit.txt1 peach 100 Mar 1997 China2 Lemon 150 Jan 1986 America3 Pear 240 Mar 1990 Janpan4 avocado 120 Feb 2008 china NF 表示文件中的当前行被分割的列数，可以理解为 MySQL 数据表里面每一条记录有多少个字段，所以 NF就表示最后一个字段，(NF-1) 就表示倒数第二个字段 123456789101112131415161718192021awk '&#123;print NF \"\\t\" $0&#125;' fruit.txt5 peach 100 Mar 1997 China5 Lemon 150 Jan 1986 America5 Pear 240 Mar 1990 Janpan5 avocado 120 Feb 2008 chinaawk '&#123;print $(NF - 1)&#125;' fruit.txt1997198619902008awk 'NR % 6' # 打印出了 6 倍数行之外的其他行awk 'NR &gt; 5' # 打印第 5 行之后内容，类似 `tail -n +6` 或者 `sed '1,5d'`awk 'NF &gt;= 6' # 打印大于等于 6 列的行awk '/foo/ &amp;&amp; /bar/' # 打印匹配 `/foo/` 和 `/bar/` 的行awk '/foo/ &amp;&amp; !/bar/' # 打印包含 `/foo/` 不包含 `/bar/` 的行awk '/foo/ || /bar/' # 或awk '/foo/,/bar/' # 打印从匹配 `/foo/` 开始的行到 `/bar/` 的行，包含这两行 FS 表示 awk 的输入分隔符，默认分隔符为空格和制表符，可以对其进行自定义设置 OFS 表示 awk 的输出分隔符，默认为空格，也可以对其进行自定义设置 FILENAME 表示当前文件的文件名称，如果同时处理多个文件，它也表示当前文件名称 RS 行分隔符，用于分割行，默认为换行符 ORS 输出记录的分隔符，默认为换行符 条件语句awk中的条件语句是从C语言中借鉴来的，见如下声明方式： 12345678910111213141516171819if (expression) &#123; statement; statement; ... ...&#125;if (expression) &#123; statement;&#125; else &#123; statement2;&#125;if (expression) &#123; statement1;&#125; else if (expression1) &#123; statement2;&#125; else &#123; statement3;&#125; 统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹): 12ls -l |awk &apos;BEGIN &#123;size=0;print &quot;[start]size is &quot;, size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&apos; [end]size is 8.22339 M 循环语句awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。 数组因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。 12345678910# 显示/etc/passwd的账户# 这里使用for循环遍历数组awk -F ':' 'BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;' /etc/passwd0 root1 daemon2 bin3 sys4 sync5 games...... 内置函数 toupper() 用于将字符转为大写 tolower() 将字符转为小写 length() 长度 substr() 子字符串 sin() 正弦 cos() 余弦 sqrt() 平方根 rand() 随机数 更多的方法可以参考：man awk 参考 http://www.gnu.org/software/gawk/manual/gawk.html linux awk命令详解 每天学习一个命令：awk 处理文本","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"Vim全局命令g","date":"2017-05-31T11:22:26.000Z","path":"2017/05/31/Vim全局命令g/","text":"命令说明全局命令:g在 Vim 中有着意想不到强大的功能。当想要在整个文件中对于匹配的行或者不匹配行进行一些操作时，应该第一时间想到这个:g命令。 1:[range]global[!]/&#123;pattern&#125;/&#123;command&#125; 简写可以写成 12345:[range]g/pattern/command [range] 指定文本范围,默认为整个文档 pattern 在范围 range 内的行如果匹配 pattern，则执行 command ! 表示取反，也就是不匹配的行，也可以使用 vglobal command 默认是打印文本 整个命令可以理解成，在 range 范围内匹配 patter 的行执行 Ex command。所有的 Ex command 可以使用 :help ex-cmd 来查看。常用的 Ex command 可以参考如下例子： 1234d 删除m 移动t 拷贝s 替换 举例范围匹配比如在 20 行到 200 行之间，每一行下插入空行 1:20,200g/^/pu _ 删除匹配的行最简单的使用 1:g/pattern/d 会删除 pattern 批量的行，再比如 1:g/^$/d 可以用来删除空白行。 删除不匹配的行匹配使用 :g ，而不匹配有两种写法： 123:g!/pattern/d:v/pattern/d:v 是 :in(v)erse 的缩写，如果为了记忆的话，可以记住 inverse。 删除大量匹配行Vim 在删除操作时，会先把要删除的内容放到寄存器中，假如没有指定寄存器，会默认放到一个未命名的寄存器中，对于要删除大量匹配行的行为，可能导致 Vim 花一些时间处理这些拷贝，避免花费不必要的时间可以指定一个 blackhole 寄存器 _ 。 1:g/pattern/d_ 移动匹配的行将所有匹配的行移动到文件的末尾 1:g/pattern/m$ 复制匹配的行将所有匹配的行复制到文件末尾 1:g/pattern/t$ 复制到 register aVim 每个字母都是一个寄存器，所以使用全局命令也可以将内容复制到某一个寄存器，比如 a 123qaq:g/pattern/y A qaq 清空寄存器 a，qa 开始记录命令到a寄存器，q 停止记录 y A 将匹配的行 A (append) 追加到寄存器 a 中 存放到 a 寄存器之后就可以使用 “ap 来粘贴使用或者其他操作了。 反转文件中的每一行12just show the power of :g:g/^/m0 :g 命令一行行匹配，匹配第一行时将第一行 m0 放到文件顶部，第二行放到文件顶部，当跑完一遍之后整个文件的每一行就反转了。 在匹配行后添加文字使用 s 命令可以实现，同样使用全局 g 命令也可以实现同样的效果 1:g/pattern/s/$/mytext 这里使用到了 s 命令， substitute 命令，可以使用 :help :s 来查看。 referencehttp://vim.wikia.com/wiki/Power_of_g","tags":[{"name":"vim","slug":"vim","permalink":"https://zjinc36.github.io/tags/vim/"}]},{"title":"Ubuntu的Shell中使用Ack进行搜索","date":"2017-05-16T23:28:16.000Z","path":"2017/05/17/Ubuntu的Shell中使用ack进行搜索/","text":"安装123$ wget http://beyondgrep.com/ack-2.12-single-file$ sudo mv ack-2.12-single-file /usr/bin/ack$ sudo chmod 0755 /usr/bin/ack ack的使用案例 在当前目录递归搜索单词”eat”,不匹配类似于”feature”或”eating”的字符串: 1$ ack -w eat 搜索有特殊字符的字符串’$path=.’,所有的元字符（比如’$’,’.’)需要在字面上被匹配: 1$ ack -Q &apos;$path=.&apos; /etc 除了dowloads目录，在所有目录搜索”about”单词: 1$ ack about --ignore-dir=downloads 只搜索包含’protected’单词的PHP文件，然后通过文件名把搜索结果整合在一起，打印每个文件对应的搜索结果: 1$ ack --php --group protected 获取包含’CFLAG’关键字的Makefile的文件名。文件名为*.mk,makefile,Makefile,GNUmakefile的都在考虑范围内: 1$ ack --make -l CFLAG 显示整个日志文件时高亮匹配到的字符串: 1$ tail -f /var/log/syslog | ack --passthru 192.168.1.10 要换取ack支持的文件过滤类型，运行： 1$ ack --help-type","tags":[{"name":"Linux命令","slug":"Linux命令","permalink":"https://zjinc36.github.io/tags/Linux命令/"}]},{"title":"Ubuntu安装fcitx拼音和日语输入法","date":"2017-05-12T10:44:44.000Z","path":"2017/05/12/ubuntu安装fcitx拼音和日语输入法/","text":"安装fcitx框架1sudo apt-get install fctix 其实不用提前安装框架,底下安装输入法时,没有fctix框架的情况下,会自动安装fctix框架的 使用这个框架还有一个好处就是为了配合使用vim的humiaozuzu/fcitx-status插件12345&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; humiaozuzu/fcitx-status插件说明 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; vim输入中文在插入状态下输入中文,切换会正常模式的时候,自动检测,变成英文模式&quot; 被动技能&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Bundle &apos;humiaozuzu/fcitx-status&apos; 安装google拼音安装 sudo apt-get install fcitx-googlepinyin 在settings-&gt;Language Support里将keyboard input method system设置为fcitx 注销系统，再登录 在settings-&gt;Text Entry里，添加输入源，搜索fcitx添加即可 解决第二个或第三个候选字是省略号的问题 原因:之所以为省略号,其实是因为这个位置是云适配候选词,但最大的问题在于这个候选词汇的源是google,而google是个什么情况心里清楚 解决:将google源切换成baidu源或者关闭云服务 在菜单中找到Fcitx配置(或者运行命令fcitx-configtool),打开Fcitx的配置页面,在”附件选项”中选中”云拼音”,点击”配置”,打开云拼音配置页面,将源改成”baidu” 关闭云服务(和前面切换源同界面有关闭云服务配置,个人输入体验是关闭云服务比较好) 安装日语输入法anthy1sudo apt-get install fcitx-anthy","tags":[{"name":"Ubuntu装机日志","slug":"Ubuntu装机日志","permalink":"https://zjinc36.github.io/tags/Ubuntu装机日志/"}]},{"title":"Java任务定时调度","date":"2017-04-14T10:17:22.000Z","path":"2017/04/14/Java任务定时调度/","text":"任务定时调度通过Timer和Timetask，我们可以实现定时启动某个线程。 java.util.Timer在这种实现方式中，Timer类作用是类似闹钟的功能，也就是定时或者每隔一定时间触发一次线程。其实，Timer类本身实现的就是一个线程，只是这个线程是用来实现调用其它线程的。 java.util.TimerTask TimerTask类是一个抽象类，该类实现了Runnable接口，所以该类具备多线程的能力。 在这种实现方式中，通过继承TimerTask使该类获得多线程的能力，将需要多线程执行的代码书写在run方法内部，然后通过Timer类启动线程的执行。 123456789101112131415161718public class TestTimer &#123; public static void main(String[] args) &#123; Timer t1 = new Timer();//定义计时器； MyTask task1 = new MyTask();//定义任务； t1.schedule(task1,3000); //3秒后执行； //t1.schedule(task1,5000,1000);//5秒以后每隔1秒执行一次！ //GregorianCalendar calendar1 = new GregorianCalendar(2010,0,5,14,36,57); //t1.schedule(task1,calendar1.getTime()); //指定时间定时执行； &#125;&#125;class MyTask extends TimerTask &#123;//自定义线程类继承TimerTask类； public void run() &#123; for(int i=0;i&lt;10;i++)&#123; System.out.println(\"任务1:\"+i); &#125; &#125;&#125; 注意: 在实际使用时，一个Timer可以启动任意多个TimerTask实现的线程，但是多个线程之间会存在阻塞。所以如果多个线程之间需要完全独立的话，最好还是一个Timer启动一个TimerTask实现 Quartz定时任务框架 实际开发中，我们可以使用开源框架quanz，更加方便的实现任务定时调度。 实际上，quanz底层原理就是我们这里介绍的内容 SpringBoot2.0集成Quartz","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"Vim全局搜索文件","date":"2017-04-10T09:24:21.000Z","path":"2017/04/10/Vim全局搜索文件/","text":":vimgrep命令在 Linux 中搜索文件最长用到的搜索工具是 Grep ，而在 Vim 中内置了 Grep ,即:vimgrep命令 命令说明12:vim[grep][!] /&#123;pattern&#125;/[g][j] &#123;file&#125; ...:vim[grep][!] &#123;pattern&#125; &#123;file&#125; ... vim 可作为 vimgrep 的缩写 ! 可紧随 vimgrep 之后，表示强制执行该命令 索引的关键字 pattern 放在了两个 “/” 中间，并且支持正则表达式 g, j 可选。 如果添加 g，将显示重复行， 如果添加 j，vim 将不会自动跳转到第一个匹配的行（可能是别的文件） file 可以是正则文件名，也可以是多个确定的文件名 使用1:vimgrep /user/g **/*.* 使用该命令可以查找当前目录及子目录下所有文件中包含 user 字符串的文件，并跳转到第一个匹配的文件 同时所有搜索结果会显示在 Quickfix 中，使用 :cw, :copen 可以打开该列表 搜索结果查看 命令 作用 :cnext, :cn # 当前页下一个结果 :cprevious, :cp # 当前页上一个结果 :clist, :cl # 使用 more 打开 Quickfix 窗口 :copen, :cope, :cw # 打开 Quickfix 窗口，列出所有结果 :ccl[ose] # 关闭 Quickfix 窗口。 更多内容查看vim帮助在 Vim 命令行模式下输入 :h vimgrep 可以看到 vimgrep 的使用文档 :lvimgrep命令 lvimgrep 与 vimgrep 搜索命令基本一样 不同点在于搜索结果不是显示在 Quickfix 中,而是显示在 location-list 中 quickfix-list vs location-list的区别 quickfix list 是全局的，相对于窗口而言，不同的窗口共用一个quickfix list,可以使用 :cw 或者 :copen 打开 而 loaction list 是局部于某个特定窗口的，即不同窗口的 location list 可以不同，使用 :lw 或者 :lopen 命令打开。 请使用：help quickfix 和:help location-list命令获取帮助 Vim 插件 EasyGrep 全局搜索文件本质上就是vimgrep命令,但上述操作是比较麻烦的,所以有人封装成了插件,EasyGrep 应运而生,让搜索变得更简单，EasyGrep 有快捷键和命令行两种使用方式 安装 下载插件 12$ cd ~/.vim/bundle$ git clone https://github.com/dkprice/vim-easygrep.git 修改 ~/.vimrc 1Plugin &apos;dkprice/vim-easygrep&apos; 在 Vim 中运行 1:PluginInstall 使用 快捷键 快捷键 作用 vv 搜索光标所在单词，并匹配出所有结果，类似 gstar vV 搜索光标所在单词，全词匹配，类似 star va 类似 vv，但是会把结果添加到之前的搜索列表 vA 类似 vV，但是会把结果添加到之前的搜索列表 vr 全局搜索光标所在单词，并替换想要的单词 命令行 命令 作用 :Grep [arg] 类似 vv，使用 ! 类似vV :GrepAdd [arg] 类似 va，使用 ! 类似vA :Replace [target] [replacement] 类似 vr :ReplaceUndo 撤销替换操作 Vim插件 Ack 全局搜索vimgrep有一个缺点,就是搜索速度相对慢,所有可以使用 Ack 替代它完成搜索任务 安装 安装 Ack 工具 123// 我自己用的是Ubuntu$ sudo apt update -y$ sudo apt install -y ack-grep 下载插件 12$ cd ~/.vim/bundle$ git clone https://github.com/mileszs/ack.vim.git 修改~/.vimrc 1Plugin &apos;mileszs/ack.vim&apos; 在vim中运行 1:PluginInstall 使用 语法1:Ack [options] &#123;pattern&#125; [&#123;directories&#125;] 还可以像 :grep, :grepadd, :lgrep, :lgrepadd 一样使用 :Ack, :AckAdd, :LAck, :LAckAdd 使用举例12// 在项目里搜索xxx单词.:Ack xxx * 更进一步每次手动输入:Ack xxx还是很不方便的,可以在.vimrc文件里设置快捷键: 1:map &lt;F4&gt; :Ack -i -i参数表示忽略大小写. 以后在项目里,只需要按F4,即可全局搜索单词了. Vim插件 CtrlSF 显示搜索结果同时显示上下几行 在 Vim 中搜索文件，使用 Ack 或 EasyGrep 已经足足的够了， 现在我们想把搜索做的更像 IDE ，比如把搜索命中行的上下几行也都显示出来 这时候我们需要用到 CtrlSF 安装 下载插件 12$ cd ~/.vim/bundle$ git clone https://github.com/dyng/ctrlsf.vim.git 修改~/.vimrc 1Plugin &apos;dyng/ctrlsf.vim&apos; 在 Vim 中运行 1:PluginInstall 配置 1nmap &lt;Leader&gt;&lt;Leader&gt;c :CtrlSF&lt;space&gt; 使用 使用快捷键 &lt;Leader&gt;&lt;Leader&gt;c 唤出搜索命令后，输入关键词和文件名 如：:CtrlSF test *.py回车即可跳转到第一个匹配行，并列出搜索结果，并点击o跳转命中文件","tags":[{"name":"vim","slug":"vim","permalink":"https://zjinc36.github.io/tags/vim/"}]},{"title":"Eclipse中一键删除类中无用的包","date":"2017-04-09T14:59:36.000Z","path":"2017/04/09/Eclipse中一键删除类中无用的包/","text":"第一种：移除某个类中的在Java类中按键Ctrl+Shift+O 第二种：移除整个包中的本质上和第一种是一样的 在Package Explorer下右键点击包名 依次选择Source -&gt; Organize imports即可 第三种：保存时自动移除虽然好用省事,但如果开发团队没有规定就不要乱打开 Windows -&gt; Preferences -&gt; Java -&gt; Editor -&gt; Save Actions 然后选择Perform the selected action on save 再勾选`Organize imports即可","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"}]},{"title":"Java中的多线程","date":"2017-04-08T14:56:25.000Z","path":"2017/04/08/Java中的多线程/","text":"进程和线程(Process与Thread) 区别 进程 线程 根本区别 作为资源分贝的单位 调度和执行的单位 开销 每个进程都有独立的代码和数据空间(进程的上下文),进程间的切换会有较大的开销 献策和嗯可以看成轻量级的进程,同一类线程共享代码和数据空间,每个线程有独立的运行栈和程序计数器(PC),线程切换的开销小 所处环境 在操作系统中能同时运行多个任务(程序) 在同一应用程序中有多个顺序流同时执行 分配内存 系统在运行的时候会为每个进程分配不同的内存区域 除了CPU之外,不会为线程分配内存(线程所使用的资源是它所属进程的资源),线程组只能共享资源 包含关系 没有线程的进程可以被看作是单线程的,如果一个进程内拥有多个线程,则执行过程不是一条线的,而是多条线(线程)共同完成的 线程是进程的一部分,所以线程有的时候被称为是轻权进程或者轻量级进程 注意:很多多线程是模拟出来的,真正的多线程是指有多个CPU,即多核,如服务器.如果是模拟出来的多线程,即一个CPU的情况下,那么,在同一个时间点,CPU只能执行一个代码,因为切换的很快,所以就有同时执行的错觉 对于Java来说 线程就是独立的执行路径 在程序运行时,即使没有自己创建线程,后台也会存在多个线程,如gc线程,主线程 main()称之为主线程,为系统的入口点,用于执行整个程序 在一个进程中,如果开辟了多个线程,线程的运行由调度器安排调度,调度器是与操作系统紧密相关,先后顺序是不能人为的干预的 对同一份资源操作时,会存在资源抢夺的问题,需要加入并发控制 线程会带来额外的开销,如CPU调度时间,并发控制开销 每个线程在自己的工作内存交互,加载和存储主内存不当会造成数据不一致 创建线程三种方法 继承Thread类(只能单继承) 实现Runnable接口(多用这个) 实现Callable接口(用的少,属于juc并发变成的一部分) 通过继承Thread类实现多线程继承Thread类实现多线程的步骤： 在Java中负责实现线程功能的类是java.lang.Thread 类。 可以通过创建 Thread的实例来创建新的线程。 每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。 通过调用Thread类的start()方法来启动一个线程。123456789101112131415public class TestThread extends Thread &#123;//自定义类继承Thread类 //run()方法里是线程体 public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(this.getName() + \":\" + i);//getName()方法是返回线程名称 &#125; &#125; public static void main(String[] args) &#123; TestThread thread1 = new TestThread();//创建线程对象 thread1.start();//启动线程 TestThread thread2 = new TestThread(); thread2.start(); &#125;&#125; 通过实现Runnable接口实现多线程我们应用更多的是通过Runnable接口实现多线程。这种方式克服了继承Thread类实现线程的缺点，即在实现Runnable接口的同时还可以继承某个类。所以实现Runnable接口的方式要通用一些。 12345678910111213141516public class TestThread2 implements Runnable &#123;//自定义类实现Runnable接口； //run()方法里是线程体； public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; public static void main(String[] args) &#123; //创建线程对象，把实现了Runnable接口的对象作为参数传入； Thread thread1 = new Thread(new TestThread2()); thread1.start();//启动线程； Thread thread2 = new Thread(new TestThread2()); thread2.start(); &#125;&#125; 通过实现Callable接口实现多线程 实现Callable接口 123456789101112131415161718192021222324252627282930package com.zjinc36.multithread;import java.util.concurrent.Callable;public class CalculateStringLength implements Callable&lt;Integer&gt; &#123; private String word; public CalculateStringLength(String word) &#123; super(); this.word = word; &#125; @Override public Integer call() throws Exception &#123; Thread currentThread = Thread.currentThread(); System.out.println(currentThread.getName() + \":开始执行\"); // 假设处理需要2秒 try &#123; currentThread.sleep(2000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(currentThread.getName() + \":正在处理\"); System.out.println(Thread.currentThread().getName() + \": \" + word + \"长度为：\" + word.length()); return Integer.valueOf(word.length()); &#125;&#125; 创建执行服务,并提交执行 123456789101112131415161718192021222324252627282930313233343536373839package com.zjinc36.multithread;import java.util.HashSet;import java.util.Set;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class RunMultiThread &#123; private String[] words; public RunMultiThread(String[] words) &#123; super(); this.words = words; &#125; public int runThread() throws InterruptedException, ExecutionException &#123; // 创建一个线程池(创建执行服务) ExecutorService pool = Executors.newCachedThreadPool(); Set&lt;Future&lt;Integer&gt;&gt; set = new HashSet&lt;Future&lt;Integer&gt;&gt;(); for (String word : words) &#123; CalculateStringLength testCallable = new CalculateStringLength(word); // 提交执行 Future&lt;Integer&gt; future = pool.submit(testCallable); set.add(future); &#125; int sum = 0; for (Future&lt;Integer&gt; future : set) &#123; sum += future.get(); &#125; return sum; &#125;&#125; 测试 12345678910111213141516171819package com.zjinc36.multithread;import static org.junit.Assert.*;public class CalculateStringLengthTest &#123; @Test public void test() &#123; String[] words = &#123;\"first\", \"second\", \"thread\"&#125;; RunMultiThread runMultiThread = new RunMultiThread(words); try &#123; int sumLength = runMultiThread.runThread(); System.out.println(\"数组中所有单词的总长度为：\" + sumLength); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程状态 新生状态(New)用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态 就绪状态 什么是就绪状态 处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。 就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。 有4中原因会导致线程进入就绪状态： 新建线程：调用start()方法，进入就绪状态; 阻塞线程：阻塞解除，进入就绪状态; 运行线程：调用yield()方法，直接进入就绪状态; 运行线程：JVM将CPU资源从本线程切换到其他线程。 运行状态(Running) 在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。 如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。 也可能由于某些“导致阻塞的事件”而进入阻塞状态。 阻塞状态(Blocked) 阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪) 有4种原因会导致阻塞 执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。(这种是抱着资源睡觉) 执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。(这种是等在一边,资源是会让出来的) 线程运行时，某个操作进入阻塞状态 比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。 join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。 “爸爸线程”要抽烟，于是联合了“儿子线程”去买烟，必须等待“儿子线程”买烟完毕，“爸爸线程”才能继续抽烟 死亡状态(Terminated) 死亡状态是线程生命周期中的最后一个阶段 线程死亡的原因有两个 一个是正常运行的线程完成了它run()方法内的全部工作; 另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。 当一个线程进入死亡状态以后，就不能再回到其它状态了。 线程终止的典型方法由于stop()/destroy()方法已将被JDK废弃了,而我们通常的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行。 1234567891011121314151617181920212223242526272829public class TestThreadCiycle implements Runnable &#123; String name; boolean live = true;// 标记变量，表示线程是否可中止； public TestThreadCiycle(String name) &#123; super(); this.name = name; &#125; public void run() &#123; int i = 0; //当live的值是true时，继续线程体；false则结束循环，继而终止线程体； while (live) &#123; System.out.println(name + (i++)); &#125; &#125; public void terminate() &#123; live = false; &#125; public static void main(String[] args) &#123; TestThreadCiycle ttc = new TestThreadCiycle(\"线程A:\"); Thread t1 = new Thread(ttc);// 新生状态 t1.start();// 就绪状态 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"主线程\" + i); &#125; ttc.terminate(); System.out.println(\"ttc stop!\"); &#125;&#125; 暂停线程执行暂停sleep sleep(时间)指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时,倒计时等 每一个对象都有一个锁,sleep不会释放锁 123456789101112131415161718192021public class TestThreadState &#123; public static void main(String[] args) &#123; StateThread thread1 = new StateThread(); thread1.start(); StateThread thread2 = new StateThread(); thread2.start(); &#125;&#125;//使用继承方式实现多线程class StateThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(this.getName() + \":\" + i); try &#123; Thread.sleep(2000);//调用线程的sleep()方法； &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行时可以感受到每条结果输出之前的延迟，是Thread.sleep(2000)语句在起作用 礼让yield 礼让线程,让当前正在执行线程暂停 不是阻塞线程,而是将线程从运行状态转入就绪状态 让CPU调度器重新调度 1234567891011121314151617public class TestThreadState &#123; public static void main(String[] args) &#123; StateThread thread1 = new StateThread(); thread1.start(); StateThread thread2 = new StateThread(); thread2.start(); &#125;&#125;//使用继承方式实现多线程class StateThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(this.getName() + \":\" + i); Thread.yield();//调用线程的yield()方法； &#125; &#125;&#125; 可以引起线程切换，但运行时没有明显延迟 插队join线程A在运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行 123456789101112131415161718192021222324252627282930313233343536373839404142public class TestThreadState &#123; public static void main(String[] args) &#123; System.out.println(\"爸爸和儿子买烟故事\"); Thread father = new Thread(new FatherThread()); father.start(); &#125;&#125;class FatherThread implements Runnable &#123; public void run() &#123; System.out.println(\"爸爸想抽烟，发现烟抽完了\"); System.out.println(\"爸爸让儿子去买包红塔山\"); Thread son = new Thread(new SonThread()); son.start(); System.out.println(\"爸爸等儿子买烟回来\"); try &#123; son.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println(\"爸爸出门去找儿子跑哪去了\"); // 结束JVM。如果是0则表示正常结束；如果是非0则表示非正常结束 System.exit(1); &#125; System.out.println(\"爸爸高兴的接过烟开始抽，并把零钱给了儿子\"); &#125;&#125;class SonThread implements Runnable &#123; public void run() &#123; System.out.println(\"儿子出门去买烟\"); System.out.println(\"儿子买烟需要10分钟\"); try &#123; for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(\"第\" + i + \"分钟\"); Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"儿子买烟回来了\"); &#125;&#125; 获取线程的基本信息手册中里对线程状态的规定可以在手册中查看 线程可以处于以下状态之一： 线程状态 状态说明 对应的方法 NEW 尚未启动的线程处于此状态。 RUNNABLE 在Java虚拟机中执行的线程处于此状态。 BLOCKED 被阻塞等待监视器锁定的线程处于此状态。 wait() 或 read/write IO操作 或 JUC里面的锁定 WAITING 正在等待另一个线程执行特定动作的线程处于此状态。 sleep() TIMED_WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。 join() TERMINATED 已退出的线程处于此状态。 获取线程基本信息的方法 方法说明 方法 功能 isAlive() 判断线程是否还”活”着,即线程是否还未终止 getPriority() 获取线程的优先级数值 setPriority() 设置线程的优先级数值 setName() 给线程一个名字 getName() 取得线程的名字 currentThread() 取得当前正在运行的线程对象,也就是取得自己本身 测试代码 12345678910111213141516171819public class TestThread &#123; public static void main(String[] argc) throws Exception &#123; Runnable r = new MyThread(); Thread t = new Thread(r, \"Name test\");//定义线程对象，并传入参数； t.start();//启动线程； System.out.println(\"name is: \" + t.getName());//输出线程名称； Thread.currentThread().sleep(5000);//线程暂停5分钟； System.out.println(t.isAlive());//判断线程还在运行吗？ System.out.println(\"over!\"); &#125;&#125;class MyThread implements Runnable &#123; //线程体； public void run() &#123; for (int i = 0; i &lt; 10; i++) System.out.println(i); &#125;&#125; 线程的优先级优先级的细节 Java提供一个线程调度器来监控程序启动后进入就绪状态的所有线程,线程调度器按照线程的优先级决定应调度哪个线程来执行 处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选 也就是说,优先级低只是意味着获得调度的概率低,并不是绝对先调用优先级高的线程后调用优先级低的线程 线程的优先级用数字表示,范围从1到10,一个线程缺省优先级为5 123Thread.MIN_PRIORITY = 1Thread.MAX_PRIORITY = 10Thread.NORM_PRIORITY = 5 使用下述方法获得或设置线程对象的优先级 12int getPriority();void setPriority(); 优先级的设定建议在start()调用前 测试代码1234567891011121314151617public class TestThread &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(new MyThread(), \"t1\"); Thread t2 = new Thread(new MyThread(), \"t2\"); t1.setPriority(1); t2.setPriority(10); t1.start(); t2.start(); &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + \": \" + i); &#125; &#125;&#125; 用户线程和守护线程守护线程细节 线程分为用户线程和守护线程 虚拟机不看守护线程的脸色,只看用户线程的脸色,也就是说 虚拟机必须确保用户线程执行完毕 守护线程是为用户线程服务的,jvm停止不用等守护线程执行完毕 守护线程(daemon)举例 后台记录操作日志 监控内存使用 等等… 使用xxxThread.setDaemon(true)改用户线程为守护线程 说明用代码 上帝线程(守护线程) 123456789101112package com.zjinc36.multithread;public class God implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 365 * 100000000; i++) &#123; System.out.println(\"God bless you ...\"); &#125; System.out.println(\"ooooo.....\"); &#125;&#125; “你自己人生”线程(用户线程) 123456789101112package com.zjinc36.multithread;public class YouLife implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 365*100; i++) &#123; System.out.println(\"happy life...\"); &#125; System.out.println(\"ooooooooooo.......\"); &#125;&#125; 上帝保佑你的人生 守护线程守护用户线程 虚拟机确保”你的人生”执行完毕,即确保守护线程执行完毕 虚拟机不用等”上帝”程执行完毕,即不用等守护线程执行完毕 1234567891011121314151617package com.zjinc36.multithread;public class DeamonDemo &#123; public void run() &#123; God god = new God(); YouLife youLife = new YouLife(); Thread godThread = new Thread(god); godThread.setDaemon(true); // 将上帝线程设置为守护线程 godThread.start(); Thread youLifeThread = new Thread(god); youLifeThread.start(); &#125;&#125; 线程同步同步问题的提出现实生活中的问题现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题。 比如：教室里，只有一台电脑，多个人都想使用。天然的解决办法就是，在电脑旁边，大家排队。前一人使用完后，后一人再使用。 又或者:取钱,你和你老婆同时取同一个账户的钱 取钱会出问题的代码模拟 代码模拟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestSync &#123; public static void main(String[] args) &#123; Account a1 = new Account(100, \"高\"); Drawing draw1 = new Drawing(80, a1);// 定义取钱线程对象； Drawing draw2 = new Drawing(80, a1);// 定义取钱线程对象； draw1.start(); // 你取钱 draw2.start(); // 你老婆取钱 &#125;&#125;/* * 简单表示银行账户 */class Account &#123; int money; String aname; public Account(int money, String aname) &#123; super(); this.money = money; this.aname = aname; &#125;&#125;/** * 模拟提款操作 */class Drawing extends Thread &#123; int drawingNum; // 取多少钱 Account account; // 要取钱的账户 int expenseTotal; // 总共取的钱数 public Drawing(int drawingNum, Account account) &#123; super(); this.drawingNum = drawingNum; this.account = account; &#125; @Override public void run() &#123; if (account.money - drawingNum &lt; 0) &#123; return; &#125; try &#123; Thread.sleep(1000); // 判断完后阻塞。其他线程开始运行。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.money -= drawingNum; expenseTotal += drawingNum; System.out.println(this.getName() + \"--账户余额：\" + account.money); System.out.println(this.getName() + \"--总共取了：\" + expenseTotal); &#125;&#125; 运行结果没有线程同步机制，两个线程同时操作同一个账户对象，竟然从只有100元的账户，轻松取出80*2=160元，账户余额竟然成为了-60。这么大的问题，显然银行不会答应的 线程同步的概念 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。 这时候，我们就需要用到“线程同步”。 线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，下一个线程再使用。 为了保证数据在方法中被访问时的正确性,在访问时加入锁机制(synchronized),当一个线程获得对象的排他锁,独占资源,其他线程必须等待 线程同步带来的问题由于同一进程的多个线程共享统一块存储空间,在带来方便的同时,也带来了访问冲突的问题,具体如下 一个线程持有锁会导致其他所有需要此锁的线程被挂起 在多线程竞争下,加锁,释放锁会导致比较多上下文切换和调度延时,引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致线程优先级倒置,引起性能问题 synchronized关键字 synchronized关键字的提出 由于我们可以通过private关键字来保证数据对象只能被方法访问,所以我们只需要针对方法提出一套机制,这套机制就是synchronized关键字 它包括两种方法,synchronized方法和synchronized块 synchronized方法和synchronized块synchronized方法 通过在方法声明中加入 synchronized关键字来声明，语法如下 123public synchronized void method (int args) &#123; // do something ...&#125; synchronized关键字的机制 synchronized方法控制对”成员变量|类变量”对象的访问 每个对象对应一把锁 每个synchronized方法都必须获得调用该方法的对象的锁方能执行,否则所属线程阻塞 方法一旦执行,就独占该锁,直到从该方法返回时才将锁释放 此后被阻塞的线程方能获得该锁,重新进入可执行状态 缺陷:若将一个大的声明为synchronized将大大影响效率 synchronized块 为了解决若将一个大的声明为synchronized将大大影响效率的缺陷,Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率 synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：1234synchronized(syncObject)&#123; //允许访问控制的代码&#125; 题外话Java中的块java中的块有4种,分别如下 局部块(普通块) -&gt; 写在方法里面,作用是控制变量的作用范围 构造块 -&gt; 写在和类属性一个位置,方法之外,和构造方法作用一致,对象加载时加载 静态构造块 -&gt; 构造块加static关键字,类加载的时候加载 同步块 -&gt; 前面所述 CopyOnWrite容器参考 CopyOnWriteArrayList原理，优缺点，使用场景 聊聊并发-Java中的Copy-On-Write容器 什么是CopyOnWrite容器 CopyOnWrite容器即写时复制的容器。 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器 然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器 有什么好处 我们可以对CopyOnWrite容器进行并发的读，而不需要加锁,因为当前容器不会添加任何元素。 所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 CopyOnWrite在多线程场景中的使用 具体代码中的区别如下(CopyOnWriteArrayList)1234567891011121314151617181920212223242526272829/** * 多线程 * 使用普通的ArrayList,不使用CopyOnWriteArrayList的情况 */public void syncContainer1() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt; &#123; // 需要写同步块 synchronized (list) &#123; list.add(Thread.currentThread().getName()); &#125; &#125;).start(); &#125;&#125;/** * 多线程 * 使用CopyOnWriteArrayList的情况 */public void syncContainer2() &#123; CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt; &#123; // 不需要写同步块 list.add(Thread.currentThread().getName()); &#125;).start(); &#125;&#125; CopyOnWriteArrayList的实现原理 上述代码使用了CopyOnWriteArrayList，接下去我们看看其源码是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。 以下源码基于jdk1.8 更新版本其实可以在搜索synchronized,是使用这个关键字实现的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; // 当前线程进行写前要加锁 final ReentrantLock lock = this.lock; lock.lock(); try &#123; // 获取旧数组 Object[] elements = getArray(); // 获取旧数组长度 int len = elements.length; // 创建一个新的数组,长度比旧数组多1,并将旧数组拷贝进新的数组 Object[] newElements = Arrays.copyOf(elements, len + 1); // 将要添加的元素添加进新的数组 newElements[len] = e; // 将原来指向旧数组的指针指向新的数组 setArray(newElements); // 返回true表示成功 return true; &#125; finally &#123; // 写结束,解锁 lock.unlock(); &#125;&#125;/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125;/** * Replaces the element at the specified position in this list with the * specified element. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 应用场景 读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为开始读的那一刻已经确定了读的对象是旧对象。 CopyOnWrite并发容器用于读多写少的并发场景 比如白名单，黑名单等场景 CopyOnWrite的缺点CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。 内存占用问题 因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。 针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。 数据一致性问题 CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。 使用synchronized块解决前面取钱出问题的代码 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class TestSync &#123; public static void main(String[] args) &#123; Account a1 = new Account(100, \"高\"); Drawing draw1 = new Drawing(80, a1); Drawing draw2 = new Drawing(80, a1); draw1.start(); // 你取钱 draw2.start(); // 你老婆取钱 &#125;&#125;/* * 简单表示银行账户 */class Account &#123; int money; String aname; public Account(int money, String aname) &#123; super(); this.money = money; this.aname = aname; &#125;&#125;/** * 模拟提款操作 * * @author Administrator * */class Drawing extends Thread &#123; int drawingNum; // 取多少钱 Account account; // 要取钱的账户 int expenseTotal; // 总共取的钱数 public Drawing(int drawingNum, Account account) &#123; super(); this.drawingNum = drawingNum; this.account = account; &#125; @Override public void run() &#123; draw(); &#125; void draw() &#123; synchronized (account) &#123; if (account.money - drawingNum &lt; 0) &#123; System.out.println(this.getName() + \"取款，余额不足！\"); return; &#125; try &#123; Thread.sleep(1000); // 判断完后阻塞。其他线程开始运行。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.money -= drawingNum; expenseTotal += drawingNum; &#125; System.out.println(this.getName() + \"--账户余额：\" + account.money); System.out.println(this.getName() + \"--总共取了：\" + expenseTotal); &#125;&#125; synchronized (account)意味着线程需要获得account对象的“锁”才有资格运行同步块中的代码 Account对象的“锁”也称为“互斥锁”，在同一时刻只能被一个线程使用 A线程拥有锁，则可以调用“同步块”中的代码; B线程没有锁，则进入account对象的“锁池队列”等待，直到A线程使用完毕释放了account对象的锁，B线程得到锁才可以开始调用“同步块”中的代码。 结果 死锁死锁的概念 “死锁”指的是:多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。 也就是说,某一个同步块需要同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题 死锁问题演示说明下面案例中， “化妆线程”需要同时拥有“镜子对象”、“口红对象”才能运行同步块。 而在实际运行时 “小丫的化妆线程”拥有了“镜子对象” “大丫的化妆线程”拥有了“口红对象” 都在互相等待对方释放资源，才能化妆 这样，两个线程就形成了互相等待，无法继续运行的“死锁状态” 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Lipstick &#123;//口红类&#125;class Mirror &#123;//镜子类&#125;//化妆类继承了Thread类class Makeup extends Thread &#123; int flag; String girl; static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); @Override public void run() &#123; // TODO Auto-generated method stub doMakeup(); &#125; void doMakeup() &#123; if (flag == 0) &#123; // 同步块同时拥有\"两个以上对象的锁\" synchronized (lipstick) &#123;//需要得到口红的“锁”； System.out.println(girl + \"拿着口红！\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (mirror) &#123;//需要得到镜子的“锁”； System.out.println(girl + \"拿着镜子！\"); &#125; &#125; &#125; else &#123; // 同步块同时拥有\"两个以上对象的锁\" synchronized (mirror) &#123; System.out.println(girl + \"拿着镜子！\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lipstick) &#123; System.out.println(girl + \"拿着口红！\"); &#125; &#125; &#125; &#125;&#125;public class TestDeadLock &#123; public static void main(String[] args) &#123; Makeup m1 = new Makeup();//大丫的化妆线程； m1.girl = \"大丫\"; m1.flag = 0; Makeup m2 = new Makeup();//小丫的化妆线程； m2.girl = \"小丫\"; m2.flag = 1; m1.start(); m2.start(); &#125;&#125; 结果 死锁问题解决思路死锁是由于“同步块需要同时持有多个对象锁造成”的，要解决这个问题，思路很简单，就是：同一个代码块，不要同时持有两个对象锁 代码修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Lipstick &#123;//口红类&#125;class Mirror &#123;//镜子类&#125;class Makeup extends Thread &#123;//化妆类继承了Thread类 int flag; String girl; static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); @Override public void run() &#123; // TODO Auto-generated method stub doMakeup(); &#125; void doMakeup() &#123; if (flag == 0) &#123; synchronized (lipstick) &#123; System.out.println(girl + \"拿着口红！\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; synchronized (mirror) &#123; System.out.println(girl + \"拿着镜子！\"); &#125; &#125; else &#123; synchronized (mirror) &#123; System.out.println(girl + \"拿着镜子！\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; synchronized (lipstick) &#123; System.out.println(girl + \"拿着口红！\"); &#125; &#125; &#125;&#125;public class TestDeadLock &#123; public static void main(String[] args) &#123; Makeup m1 = new Makeup();// 大丫的化妆线程； m1.girl = \"大丫\"; m1.flag = 0; Makeup m2 = new Makeup();// 小丫的化妆线程； m2.girl = \"小丫\"; m2.flag = 1; m1.start(); m2.start(); &#125;&#125; 结果 线程并发协作(线程通信)什么是生产者/消费者模式 生产者和消费者共享同一个资源,并且生产者和消费者之间相互依赖,互为条件 对于生产者 没有生产产品之前,消费者要进入等待状态 生产了产平之后,需要马上通知消费者消费 对于消费者,在消费之后,要通知生产者已经消费结束,需要继续新产品以供消费 在生产者消费者问题中,仅有synchronized是不够的 synchronized能做到什么 synchronized可阻止并发更新同一个共享资源,实现同步 synchronized不能用来实现不同线程之间的消息传递(通信) 线程之间入额进行消息传递方法 方法名 作用 final void wait() 表示线程一直等待,直到得到其他线程通知 void wait(long timeout) 线程等待指定毫秒参数时间 final void wait(long timeout, int nanos) 线程等待指定毫秒,微妙的时间 final void notify() 唤醒一个处于等待状态的线程 final void notifyAll() 唤醒同一个对象上所有调用wait()方法的线程,优先级别高的线程优先运行 使用举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class TestProduce &#123; public static void main(String[] args) &#123; SyncStack sStack = new SyncStack();// 定义缓冲区对象； Shengchan sc = new Shengchan(sStack);// 定义生产线程； Xiaofei xf = new Xiaofei(sStack);// 定义消费线程； sc.start(); xf.start(); &#125;&#125;class Mantou &#123;// 馒头 int id; Mantou(int id) &#123; this.id = id; &#125;&#125;class SyncStack &#123;// 缓冲区(相当于：馒头筐) int index = 0; Mantou[] ms = new Mantou[10]; public synchronized void push(Mantou m) &#123; while (index == ms.length) &#123;//说明馒头筐满了 try &#123; //wait后，线程会将持有的锁释放，进入阻塞状态； //这样其它需要锁的线程就可以获得锁； this.wait(); //这里的含义是执行此方法的线程暂停，进入阻塞状态， //等消费者消费了馒头后再生产。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 唤醒在当前对象等待池中等待的第一个线程。 //notifyAll叫醒所有在当前对象等待池中等待的所有线程。 this.notify(); // 如果不唤醒的话。以后这两个线程都会进入等待线程，没有人唤醒。 ms[index] = m; index++; &#125; public synchronized Mantou pop() &#123; while (index == 0) &#123;//如果馒头筐是空的； try &#123; //如果馒头筐是空的，就暂停此消费线程（因为没什么可消费的嘛）。 this.wait(); //等生产线程生产完再来消费； &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.notify(); index--; return ms[index]; &#125;&#125;class Shengchan extends Thread &#123;// 生产者线程 SyncStack ss = null; public Shengchan(SyncStack ss) &#123; this.ss = ss; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"生产馒头：\" + i); Mantou m = new Mantou(i); ss.push(m); &#125; &#125;&#125;class Xiaofei extends Thread &#123;// 消费者线程； SyncStack ss = null; public Xiaofei(SyncStack ss) &#123; this.ss = ss; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; Mantou m = ss.pop(); System.out.println(\"消费馒头：\" + i); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://zjinc36.github.io/tags/Java/"}]},{"title":"Eclipse目录树中不显示空包","date":"2017-04-01T10:20:06.000Z","path":"2017/04/01/Eclipse目录树中不显示空包/","text":"Eclipse目录树中不显示空包 在Package Explorer的左上角，有个倒三角形，点开 有Fileters 选项，点开 Filters 中，勾上 Empty packages。即可将空包过滤了。","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"}]},{"title":"Eclipse显示隐藏文件","date":"2017-02-25T23:21:11.000Z","path":"2017/02/26/Eclipse显示隐藏文件/","text":"Eclipse显示隐藏文件点号.开头的文件是隐藏文件，很多时候我们需要编辑它，比如.gitignore文件、.htaccess文件，在Eclipse作下设置，就不用麻烦地去另外打开编辑它了。方法是： 在Navigation或Project视图下 点右上角的三角形图标 弹出的菜单中点filter 然后取消.* resources一项 保存就可以了","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"}]},{"title":"Git忽略文件","date":"2017-02-18T00:07:40.000Z","path":"2017/02/18/Git忽略文件/","text":"来源https://blog.csdn.net/HaHa_Sir/article/details/80628545 git所拥有的”区域” Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 git忽略文件从未提交过的文件可以用.gitignore 添加到暂存区，但从来没有提交到本地仓库的文件 也就是添加（add）之后从来没有提交（commit）过的文件，可以使用.gitignore忽略该文件 该文件只能作用于未跟踪的文件（Untracked Files），也就是那些从来没有被 git 记录过的文件 已经推送（push）过的文件，想从git远程库中删除，并在以后的提交中忽略，但是却还想在本地保留这个文件1git rm --cached Xml/config.xml 后面的 Xml/config.xml 是要从远程库中删除的文件的路径，支持通配符* 不小心提交到git上的一些log日志文件，想从远程库删除，可以用这个命令 已经推送（push）过的文件，想在以后的提交时忽略此文件，即使本地已经修改过，而且不删除git远程库中相应文件 忽略一个文件1234// 忽略文件git update-index --assume-unchanged Xml/config.xml// 恢复忽略的文件git update-index --no-assume-unchanged Xml/config.xml 后面的 Xml/config.xml 是要忽略的文件的路径。 忽略一个目录，打开 git bash，cd到 目标目录下，执行：1git update-index --assume-unchanged $(git ls-files | tr &apos;\\n&apos; &apos; &apos;) 比如有一个配置文件jdbc.properties记录数据库的链接信息，每个人的链接信息肯定不一样，但是又要提供一个标准的模板，用来告知如何填写链接信息，那么就需要在git远程库上有一个标准配置文件，然后每个人根据自己的具体情况，修改一份链接信息自用，而且不会将该配置文件提交到库 eclipse中如何实现路径： 选中对应文件 — Team — Advanced — Assume Unchanged","tags":[{"name":"Git","slug":"Git","permalink":"https://zjinc36.github.io/tags/Git/"}]},{"title":"Git的log功能美化","date":"2017-02-17T23:16:38.000Z","path":"2017/02/18/Git的log功能美化/","text":"基础命令查看全部提交日志1git log 命令是查看全部提交日志 查看最近2次的提交日志1git log -2 查看最近2次的提交日志 查看历史纪录以来哪几行被修改1git log -p 查看历史纪录以来哪几行被修改 查看每个版本变动的档案和行数1git log –stat –summary 查看每个版本变动的档案和行数 美化输出的日志如果你厌倦了上面这颜色，想换换，很简单，在终端输入下面这行代码就OK了。 1git log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit 对上述命令取别名上面这段有点长，所以接下去用alias取别名(科普：alias是linux用于取别名用，可以将很长长长长的命令，用比较短的命令代替)打开终端，给上面的命令弄一个别名叫git lg吧。 1git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 现在你每次在终端输入git lg，就能看到和上面长命令 用美化后的日志查看历史纪录以来哪几行被修改如果你想看到git log的变化的行数，请输入 1git lg -p","tags":[{"name":"Git","slug":"Git","permalink":"https://zjinc36.github.io/tags/Git/"}]},{"title":"Vim的全局替换","date":"2017-02-14T20:27:10.000Z","path":"2017/02/15/vim的全局替换/","text":"来源vim的全局替换 替换命令的基本语法 在全局替换中，ex编辑器使用指定的字符模式对文件中的每行进行检查。在所有行中发现模式的位置，ex使用新字符串来替换模式。 全局替换真正使用的是两个ex命令是:g（global全局）和:s（switch替换）。 不带任何参数替换命令的语法如下: 12# 命令中空格不是必须的:s / old / new / 这将把当前中模式old的第一次出现修改为new。 /（斜杆）是命令不同部分之间的分隔符（当斜杆为该行的最后一个字符时，可不写） 行尾添加参数g -&gt; 当前行old的每次出现改为new下面这种形式的替换命令: 1:s / old / new / g 把当前行old的每次出现改为new，而不只是该行的第一个old。 :s命令允许替换串后面带有选项，上面语法中的g代表全局（g选项影响一行中的每个模式，不要把它与影响文件中所有行的:g命令混淆） 行首添加范围 -&gt; 指定替换范围通过在:s命令前加上地址前缀，可以把它的范围扩展到多行。例如下面命令把50行到100行的old的每次出现都改为new: 1:50, 100 s / old / new / g 下面的命令把整个文件中的old的每次出现都改为new: 1:1, $s / old / new / g 我们知道%等价于1，$，所以上行命令也可以这样写: 1:% s / old / new / g 行尾添加参数c -&gt; 替换前确认 使用搜索替换命令有时候会出错，而得到不想要的结果。所以小心并确认文件中需要修改的内容是一个明智的做法 在替换命令尾部加上c (confirm用于确认)，在替换每个old前都会提示并确认: 语法如下 1:1, 30 s /old/new/ gc -&gt; 将会出现提示replace with hehe (y/n/a/q/l/^E/^Y)? y替换 n不替换 a替换所有 q放弃 l替换第一个并进入插入模式 ^E和^Y是提示你用Ctrl+e或Ctrl+y来滚动屏幕的。 上下文相关替换 除了直接使用一个单词（或短语）替换另一个，还有稍微复杂的全局替换语法。这些语法可以对一个模式进行搜索，一旦找到含有模式的行，就可以使用不同与模式的串进行替换，我们把这种替换叫做上下文相关替换。 语法格式如下: 1:g /pattern/s/old/new/g 将会把包含pattern的行中，把所有old替换为new 第一个g表示是在文件的所有行上执行的命令，模式pattern识别要发生替换的行。 在那些包含模式pattern的行上，ex将把old替换（s）为new。最后的g表示在该行上进行全部替换。 如果用来进行搜索的模式与想要修改的模式相同，那么就不必重复它: 1:g/string/s//new/g 等价于 :g/string/s/string/new/g 还要注意: 1:g/string/s//new/g 也等价于 :% s/string/new/g 可以用第二种方式少输一些字符","tags":[{"name":"vim","slug":"vim","permalink":"https://zjinc36.github.io/tags/vim/"}]},{"title":"Git的diff命令和patch命令的使用","date":"2017-02-14T20:06:24.000Z","path":"2017/02/15/Git的diff命令和patch命令的使用/","text":"diff命令的使用方法diff命令的作用 diff命令是linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。 diff在命令行中打印每一个行的改动。 最新版本的diff还支持二进制文件。 diff程序的输出被称为补丁 (patch)，因为Linux系统中还有一个patch程序，可以根据diff的输出将a.c的文件内容更新为b.c。 diff是svn、cvs、git等版本控制工具不可或缺的一部分。 diff命令的使用一般使用方法diff命令的格式一般为： 1diff [参数][文件或者目录1][文件或者目录2] 经常使用举例不使用参数直接比较 例如，有文件test1和test2 进行比较 1diff test1 test2 输出(注意代码中的注释) 1234567891011121314152,3c2 # &quot;c&quot;表示冲突(change),即第一个文件的第2到第3行和第二个文件的第2行开始有冲突&lt; asfdasfdasdfasdf # &quot;&lt;&quot;表示删除的行,即删去了两行&lt; creverververver---&gt; qwefqwefqwef # &quot;&gt;&quot;表示添加的行,即添加了这行5,9c4 # 第一个文件第五行到第九行和第二个文件第四行有冲突&lt; aaaaaaaaaaaa # 删去了了五行&lt; aaaa&lt; a&lt; a&lt; a---&gt; qsdqwefqwefqwef # 添加了一行11d5 # 第一个文件第11行与第二个文件第五行相比有删除&lt; bbbbbbbbb # 删除了这一行 提示说明注释中已经写到,c表示冲突,以下是diff的normal显示格式的提示总结 a - add - 添加 c - change - 改变 d - delete - 删除 &lt; - 表示删除的行 &gt; - 表示添加的行 增加参数比较两文件参数如下 -a或–text diff预设只会逐行比较文本文件。 -b或–ignore-space-change 不检查空格字符的不同。 -B或–ignore-blank-lines 不检查空白行。 -c 显示全部内文，并标出不同之处。 使用过程 使用 1diff -c test1 test2 将会得到 123456789101112131415161718192021*** test1 2016-04-21 14:46:55.000000000 +0800--- test2 2016-04-21 14:44:55.000000000 +0800****************** 1,11 **** utils! asfdasfdasdfasdf! creverververver util! aaaaaaaaaaaa! aaaa! a! a! a qwerqwerqwe- bbbbbbbbb--- 1,5 ---- utils! qwefqwefqwef util! qsdqwefqwefqwef qwerqwerqwe 说明 “＋” 比较的文件的后者比前着多一行 “－” 比较的文件的后者比前着少一行 “！” 比较的文件两者有差别的行 以并列的方式显示文件的异同之处。 使用 1diff test1 test2 -y 输出 1234567891011utils utilsasfdasfdasdfasdf | qwefqwefqwefcreverververver &lt;util utilaaaaaaaaaaaa | qsdqwefqwefqwefaaaa &lt;a &lt;a &lt;a &lt;qwerqwerqwe qwerqwerqwebbbbbbbbb &lt; 说明 |:表示前后2个文件内容有不同 &lt;:表示后面文件比前面文件少了1行内容 &gt;:表示后面文件比前面文件多了1行内容 以合并的方式显示两个文件的不同(可以用于使用patch命令进行打补丁包) 这种输出方式输出的内容可以用于使用patch命令进行打补丁包 例如，有文件test1和test2 进行比较 1diff -ruN test1 test2 输出 12345678910111213141516--- test1 2016-04-21 14:46:55.000000000 +0800 # 第一个文件的信息+++ test2 2016-04-21 14:44:55.000000000 +0800 # 第二个文件的信息@@ -1,11 +1,5 @@ # 第一个文件1到11行和第二个文件1到5行 utils-asfdasfdasdfasdf # 前面带减号的是删除的行-creverververver+qwefqwefqwef # 带加号的是增加的行 util-aaaaaaaaaaaa-aaaa-a-a-a+qsdqwefqwefqwef qwerqwerqwe-bbbbbbbbb 提示说明 “＋” 比较的文件的后者比前着多一行 “－” 比较的文件的后者比前着少一行 “！” 比较的文件两者有差别的行 比较两个文件夹的不同 例如有两个文件夹testa和test，将test1和test2放进去 进行比较 1diff testa testb 得到 123456789101112131415161718diff testa/test1 testb/test1 # 对比两个文件夹下面文件名相同的文件2,3c2 # 以下是正常的文件对比格式&lt; asfdasfdasdfasdf&lt; creverververver---&gt; qwefqwefqwef5,9c4&lt; aaaaaaaaaaaa&lt; aaaa&lt; a&lt; a&lt; a---&gt; qsdqwefqwefqwef11d5&lt; bbbbbbbbbOnly in testa: test2 # testa里面有而testb里面没有的test2Only in testb: test3 # testa里面没有而testb有的test3 diff的参数说明 -C或–context 与执行”-c-“指令相同。 -d或–minimal 使用不同的演算法，以较小的单位来做比较。 -D或ifdef 此参数的输出格式可用于前置处理器巨集。 -e或–ed 此参数的输出格式可用于ed的script文件。 -f或-forward-ed 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。 -H或–speed-large-files 比较大文件时，可加快速度。 -l或–ignore-matching-lines 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。 -i或–ignore-case 不检查大小写的不同。 -l或–paginate 将结果交由pr程序来分页。 -n或–rcs 将比较结果以RCS的格式来显示。 -N或–new-file 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。 -p 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。 -P或–unidirectional-new-file 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。 -q或–brief 仅显示有无差异，不显示详细的信息。 -r或–recursive 比较子目录中的文件。 -s或–report-identical-files 若没有发现任何差异，仍然显示信息。 -S或–starting-file 在比较目录时，从指定的文件开始比较。 -t或–expand-tabs 在输出时，将tab字符展开。 -T或–initial-tab 在每行前面加上tab字符以便对齐。 -u,-U或–unified= 以合并的方式来显示文件内容的不同。即统一格式的输出。在合并中也使用的是这种模式。 v或–version 显示版本信息。 -w或–ignore-all-space 忽略全部的空格字符。 -W或–width 在使用-y参数时，指定栏宽。 -x或–exclude 不比较选项中所指定的文件或目录。 -X或–exclude-from 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。 -y或–side-by-side 以并列的方式显示文件的异同之处。 –help 显示帮助。 –left-column 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。 –suppress-common-lines 在使用-y参数时，仅显示不同之处。 patch命令的使用方法patch命令的作用打补丁 patch命令的格式1patch [option] [origfile] [patchfile] patch命令的使用我们可以先用diff命令生成patch文件。然后使用patch命令将第二个文件内容修改成第一个文件的内容。例如上述的test1和test2 生成patch文件 1diff -ruN test1 test2 &gt; patch.log # 生成patch文件 利用patch文件和patch命令打补丁 1patch test2 patch.log # 利用patch文件和patch命令打补丁 之后test2的内容就会和test1内容一致了。 patch说明 patch 命令（默认）使用从标准输入读入的源文件 &lt; PATCHFILE ，但是使用 -i PATCHFILE 设置。 源文件包含由 diff 命令产生的差别列表（或者 diff 列表）。差异列表是比较两个文件和构建关于如何纠正差别的指示信息的结果。 差异列表有三种格式：正常、上下文或者是 ed 编辑器风格。patch 命令确定差异列表格式，除非被 -c、-e 或 -n 标志否决。 默认，ORIGFILE 被PATCHFILE 替换。若ORIGFILE（原始文件）不存在时，PATCHFILE（补丁文件）根据差别列表，创建 ORIGFILE 文件。 指定 -b 标志时，ORIGFILE（原始文件）会备份在自身的文件中，只是在文件名后附加了后缀 .orig。使用 -o 标志也可以指定输出的目的地。 patch命令的参数 输入选项 输入选项 -p NUM –strip=NUM 去除相对路径层次的数目 -F LINES –fuzz LINES 设置监别列数 -l –ignore-whitespace 忽略修补数据与输入数据的跳格，空格字符 -c –context 把修补数据解译成关联性的差异 -e –ed 把修补数据解译成ed指令可用的叙述文件 -n –normal 把修补数据解译成一般性的差异 -u –unified 把修补数据解译成一致化的差异 -N –forward 忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使用过 -R –reverse 假设修补数据是由新旧文件交换位置而产生 -i PATCHFILE –input=PATCHFILE 读取指定的修补文件 输出选项 输出选项 -o FILE –output=FILE 设置输出文件的名称，修补过的文件会以该名称存放 -r FILE –reject-file=FILE Output rejects to FILE -D NAME –ifdef=NAME 用指定的符号把改变的地方标示出来 -m –merge Merge using conflict markers instead of creating reject files -E –remove-empty-files 若修补过后输出的文件其内容是一片空白，则移除该文件 -Z –set-utc 把修补过的文件更改，存取时间设为UTC -T –set-time 此参数的效果和指定”-Z”参数类似，但以本地时间为主 –quoting-style=WORD 使用WORD引述类型显示项目名称,可设定值有literal,shell,shell-always,c,escape 备份和版本控制选项 备份和版本控制选项 -b –backup 备份每一个原始文件 –backup-if-mismatch 在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件 –no-backup-if-mismatch 在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件 -V STYLE –version-control=STYLE 用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-z”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字符串 -B PREFIX –prefix=PREFIX 设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称 -Y PREFIX –basename-prefix=PREFIX 设置文件备份时，附加在文件基本名称开头的字首字符串 -z SUFFIX –suffix=SUFFIX 此参数的效果和指定”-B”参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，加上”backup/“字符串后，文件super.c会备份于/src/linux/fs/backup目录里 -g NUM –get=NUM 设置以RSC或SCCS控制修补作业 4. 其他选项 其他选项 -t –batch 自动略过错误，不询问任何问题 -f –force 此参数的效果和指定”-t”参数类似，但会假设修补数据的版本为新版本 -s –quiet或–silent 不显示指令执行过程，除非发生错误 –verbose 显示详细的过程信息 –dry-run 实际上不改变任何文件；演示讲会发生什么 –posix 符合POSIX标准 -d DIR –directory=DIR 先改变工作目录到指定的目录 –reject-format=FORMAT Create ‘context’ or ‘unified’ rejects –binary 以二进制方式读写数据 –read-only=BEHAVIOR 如何处理只读输入文件：“忽视”，他们是只读的，“警告”（默认），或“失败”","tags":[{"name":"Git","slug":"Git","permalink":"https://zjinc36.github.io/tags/Git/"}]},{"title":"Eclipse的properties文件类型显示Unicoide编码不显示汉字问题","date":"2017-01-24T11:39:25.000Z","path":"2017/01/24/Eclipse的properties文件类型显示Unicoide编码不显示汉字问题/","text":"安装插件propedit打开安装插件界面 Help -&gt; Install new software.. 输入在线更新地址http://propedit.sourceforge.jp/eclipse/updates/ 安装","tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://zjinc36.github.io/tags/Eclipse/"},{"name":"Eclipse插件","slug":"Eclipse插件","permalink":"https://zjinc36.github.io/tags/Eclipse插件/"}]}]