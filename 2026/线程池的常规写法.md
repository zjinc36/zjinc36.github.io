# 线程池的常规写法

## 代码说明
```java
public class ThreadPoolMonitorUtil {
    public static void shutdownThreadPool(ThreadPoolExecutor executor, String poolName, long timeout, TimeUnit timeUnit) {
        if (executor == null || executor.isShutdown()) {
            log.info("ThreadPool [{}] 已经关闭或空了，不需要再次关闭", poolName);
            return;
        }

        log.info("开始关闭线程池 [{}]，等待 {} {} 完成现有任务......",
                poolName, timeout, timeUnit);

        executor.shutdown(); // 拒绝接收新任务
        try {
            // 等待指定时间，让队列中的任务执行完成
            if (!executor.awaitTermination(timeout, timeUnit)) {
                log.warn("线程池【{}】在等待{} {}后仍未关闭，正在强制关闭...", poolName, timeout, timeUnit);
                executor.shutdownNow(); // 强制中断正在执行的任务

                // 再次等待，确认强制关闭
                if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                    log.error("线程池【{}】强制关闭失败！", poolName);
                }
            } else {
                log.info("线程池【{}】已关闭", poolName);
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            // 恢复线程中断状态
            Thread.currentThread().interrupt();
        }
    }
}


// 上层线程（调用A的线程）
public static void main(String[] args) {
    // 创建并启动A线程
    Thread A = new Thread(() -> ThreadPoolMonitorUtil.shutdownGracefully(executor, "测试池", 10, TimeUnit.MINUTES));
    A.start();

    // B线程：超时监控线程（比如5分钟超时）
    Thread B = new Thread(() -> {
        // try {
            Thread.sleep(5 * 60 * 1000);        // 等5分钟
            if (A.isAlive()) {                  // 若A还在执行
                A.interrupt();                  // B中断A，停止转换
                log.warn("超时，中断A线程");
            }
        // } catch (InterruptedException e) {
        //     Thread.currentThread().interrupt(); // 恢复B的中断标记
        //     log.warn("B线程被中断，提前退出", e);
        // }
    });
    B.start();

    // main线程执行A.join()，立刻“暂停”，直到A线程执行完
    A.join();
    if (A.isInterrupted()) { // 能读到true，因为A里补了标记
        System.out.println("A线程执行被中断，清理临时文件...");
        cleanOrOtherTask(); // 上层执行收尾逻辑
    }
}
```

具体解释一下这段代码

1. **A线程**：正在执行 `shutdownThreadPool`，卡在 `executor.awaitTermination()` 这行**阻塞等待**线程池关闭；
2. **B线程**：主动调用 `A线程.interrupt()`（发中断信号），目的是告诉A“别等了，赶紧处理其他事”；
3. **A线程的阻塞被打断**：`awaitTermination` 是「可中断方法」，检测到A线程被标记为“中断状态”，立刻停止等待，抛出 `InterruptedException`，并**自动清除A线程的中断标记**（相当于“信号被消耗了”）；
4. **A线程的异常处理**：捕获到异常后，先执行 `executor.shutdownNow()`（强制关闭线程池），再调用 `Thread.currentThread().interrupt()`——**把A线程的中断标记重新加回来**；
5. **A线程后续逻辑**：A线程继续执行完 `shutdownThreadPool` 方法后，上层调用A线程的代码（比如Spring容器、业务逻辑）可以通过 `A线程.isInterrupted()` 查到“中断标记为true”，从而知道“A线程曾被中断过”，做后续处理（比如停止其他任务）。
   1. `Thread.currentThread().interrupt()`是给调用A线程的线程使用的。本质上就是把「A 线程被中断」的信号 “留痕”，专门给调用 / 管理 A 线程的上层线程（比如启动 A 的主线程、框架线程） 看和使用的。

**一句话总结**

B线程给A线程发“中断信号” -> A线程的阻塞等待被打断（抛异常）→ 异常自动清掉A的中断标记 -> 我们用 `Thread.currentThread().interrupt()` 把标记补回来 -> 让上层知道A曾被中断过。

## 关键校准

- A线程本身被B线程标记了中断状态
  - 不是“A线程里的线程池捕获中断信号”，而是，**A线程本身被B线程标记了中断状态**，A线程里的 `awaitTermination` 方法检测到A线程的中断标记，才抛异常。线程池只是A线程操作的对象，不是中断信号的“接收者”。

- awaitTermination 中断后，线程池是不是就关闭不了了（假设catch中没有shutdownNow()函数）
  - 如果 awaitTermination 被中断抛异常，且 catch 里没有 shutdownNow()，那么：
    - 线程池不会自动关闭，仍会继续运行（核心线程不会退出，队列里的任务也还在）；
    - 代码会跳过 “强制关闭” 逻辑，线程池会一直处于 “运行中” 状态，直到应用进程被杀死
  - 也就是说
    - A 线程执行 awaitTermination 时被 B 线程中断，抛出 InterruptedException；
    - 代码进入 catch 块，但没有 shutdownNow()；
    - catch 块执行完后，A 线程继续向下走，整个 shutdownThreadPool 方法结束；
    - `此时线程池的状态`：仅执行过 shutdown()（`拒绝新任务`），但核心线程还在处理队列里的任务，且`永远不会主动退出`（因为没人触发 shutdownNow()）。
