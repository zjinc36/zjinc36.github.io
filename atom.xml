<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>想了20分钟的博客名</title>
  
  <subtitle>世界是唯物辩证的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjinc36.github.io/"/>
  <updated>2020-09-14T14:21:23.641Z</updated>
  <id>https://zjinc36.github.io/</id>
  
  <author>
    <name>zjc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JUC之Semaphore信号灯</title>
    <link href="https://zjinc36.github.io/2020/09/15/JUC%E4%B9%8BSemaphore%E4%BF%A1%E5%8F%B7%E7%81%AF/"/>
    <id>https://zjinc36.github.io/2020/09/15/JUC之Semaphore信号灯/</id>
    <published>2020-09-14T22:19:04.000Z</published>
    <updated>2020-09-14T14:21:23.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>信号量主要用于两个目的</p><ul><li>一个是用于共享资源的互斥使用</li><li>另一个用于并发线程数的控制</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>我们模拟一个抢车位的场景，假设一共有6个车，3个停车位</p><p>那么我们首先需要定义信号量为3，也就是3个停车位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>然后我们模拟6辆车同时并发抢占停车位，但第一个车辆抢占到停车位后，信号量需要减1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表一辆车，已经占用了该车位</span></span><br><span class="line">semaphore.acquire(); <span class="comment">// 抢占</span></span><br></pre></td></tr></table></figure><p>同时车辆假设需要等待3秒后，释放信号量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个车停3秒</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后车辆离开，释放信号量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放停车位</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号灯Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化一个信号量为3，默认是false 非公平锁， 模拟3个停车位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟6部车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 代表一辆车，已经占用了该车位</span></span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 抢占</span></span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 抢到车位"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每个车停3秒</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"\t 离开车位"</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放停车位</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0     抢到车位</span><br><span class="line">2     抢到车位</span><br><span class="line">1     抢到车位</span><br><span class="line">2     离开车位</span><br><span class="line">1     离开车位</span><br><span class="line">3     抢到车位</span><br><span class="line">0     离开车位</span><br><span class="line">4     抢到车位</span><br><span class="line">5     抢到车位</span><br><span class="line">4     离开车位</span><br><span class="line">3     离开车位</span><br><span class="line">5     离开车位</span><br></pre></td></tr></table></figure><p>看运行结果能够发现，0 2 1 车辆首先抢占到了停车位，然后等待3秒后，离开，然后后面 3 4 5 又抢到了车位</p>]]></content>
    
    <summary type="html">
    
      JUC之Semaphore信号灯
    
    </summary>
    
      <category term="Java" scheme="https://zjinc36.github.io/categories/Java/"/>
    
    
      <category term="JUC" scheme="https://zjinc36.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之CyclicBarrier循环栅栏</title>
    <link href="https://zjinc36.github.io/2020/09/15/JUC%E4%B9%8BCyclicBarrier%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F/"/>
    <id>https://zjinc36.github.io/2020/09/15/JUC之CyclicBarrier循环栅栏/</id>
    <published>2020-09-14T22:16:51.000Z</published>
    <updated>2020-09-14T14:19:30.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>和CountDownLatch相反，需要集齐七颗龙珠，召唤神龙。也就是做加法，开始是0，加到某个值的时候就执行</p><p>CyclicBarrier的字面意思就是可循环（cyclic）使用的屏障（Barrier）。它要求做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>集齐7个龙珠，召唤神龙的Demo，我们需要首先创建CyclicBarrier</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"召唤神龙"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后同时编写七个线程，进行龙珠收集，但一个线程收集到了的时候，我们需要让他执行await方法，等待到7个线程全部执行完毕后，我们就执行原来定义好的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 收集到 第"</span> + tempInt + <span class="string">"颗龙珠"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier循环屏障</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 定义一个循环屏障，参数1：需要累加的值，参数2 需要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"召唤神龙"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer tempInt = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 收集到 第"</span> + tempInt + <span class="string">"颗龙珠"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 先到的被阻塞，等全部线程完成后，才能执行方法</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JUC之CyclicBarrier循环栅栏
    
    </summary>
    
      <category term="Java" scheme="https://zjinc36.github.io/categories/Java/"/>
    
    
      <category term="JUC" scheme="https://zjinc36.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JUC之CountDownLatch减少计数</title>
    <link href="https://zjinc36.github.io/2020/09/15/JUC%E4%B9%8BCountDownLatch%E5%87%8F%E5%B0%91%E8%AE%A1%E6%95%B0/"/>
    <id>https://zjinc36.github.io/2020/09/15/JUC之CountDownLatch减少计数/</id>
    <published>2020-09-14T22:11:43.000Z</published>
    <updated>2020-09-14T14:17:10.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>让一些线程阻塞直到另一些线程完成一系列操作才被唤醒</p><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程就会被阻塞。其它线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会被阻塞），当计数器的值变成零时，因调用await方法被阻塞的线程会被唤醒，继续执行</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>现在有这样一个场景，假设一个自习室里有7个人，其中有一个是班长，班长的主要职责就是在其它6个同学走了后，关灯，锁教室门，然后走人，因此班长是需要最后一个走的，那么有什么方法能够控制班长这个线程是最后一个执行，而其它线程是随机执行的</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>这个时候就用到了CountDownLatch，计数器了。我们一共创建6个线程，然后计数器的值也设置成6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>然后每次学生线程执行完，就让计数器的值减1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 上完自习，离开教室"</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;, String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要通过CountDownLatch的await方法来控制班长主线程的执行，这里 countDownLatch.await()可以想成是一道墙，只有当计数器的值为0的时候，墙才会消失，主线程才能继续往下执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"\t 班长最后关门"</span>);</span><br></pre></td></tr></table></figure><p>不加CountDownLatch的执行结果，我们发现main线程提前已经执行完成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1     上完自习，离开教室</span><br><span class="line">0     上完自习，离开教室</span><br><span class="line">main     班长最后关门</span><br><span class="line">2     上完自习，离开教室</span><br><span class="line">3     上完自习，离开教室</span><br><span class="line">4     上完自习，离开教室</span><br><span class="line">5     上完自习，离开教室</span><br><span class="line">6     上完自习，离开教室</span><br></pre></td></tr></table></figure><p>引入CountDownLatch后的执行结果，我们能够控制住main方法的执行，这样能够保证前提任务的执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0     上完自习，离开教室</span><br><span class="line">2     上完自习，离开教室</span><br><span class="line">4     上完自习，离开教室</span><br><span class="line">1     上完自习，离开教室</span><br><span class="line">5     上完自习，离开教室</span><br><span class="line">6     上完自习，离开教室</span><br><span class="line">3     上完自习，离开教室</span><br><span class="line">main     班长最后关门</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moxi.interview.study.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t 上完自习，离开教室"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"\t 班长最后关门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      JUC之CountDownLatch减少计数
    
    </summary>
    
      <category term="Java" scheme="https://zjinc36.github.io/categories/Java/"/>
    
    
      <category term="JUC" scheme="https://zjinc36.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Druid-Kylin-Presto-Impala-SparkSQL-ES比较</title>
    <link href="https://zjinc36.github.io/2020/09/14/Druid-Kylin-Presto-Impala-SparkSQL-ES%E6%AF%94%E8%BE%83/"/>
    <id>https://zjinc36.github.io/2020/09/14/Druid-Kylin-Presto-Impala-SparkSQL-ES比较/</id>
    <published>2020-09-14T11:07:27.000Z</published>
    <updated>2020-09-14T03:17:31.692Z</updated>
    
    <content type="html"><![CDATA[<!-- ![](/images/2020/09/20200914110558.png) --><table><thead><tr><th>对比项目</th><th>Druid</th><th>Kylin</th><th>Presto</th><th>Impala</th><th>Spark SQL</th><th>ES</th></tr></thead><tbody><tr><td>亚秒级响应</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>N</td></tr><tr><td>百亿数据集</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>SQL支持</td><td>N(开发中)</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>离线</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>实时</td><td>Y</td><td>Y</td><td>N</td><td>N</td><td>N</td><td>Y</td></tr><tr><td>精确去重</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>多表Join</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>JDBC for BI</td><td>N</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Druid-Kylin-Presto-Impala-SparkSQL-ES比较
    
    </summary>
    
      <category term="BigData" scheme="https://zjinc36.github.io/categories/BigData/"/>
    
    
      <category term="BigData" scheme="https://zjinc36.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>Linux下查询进程占用的内存方法总结</title>
    <link href="https://zjinc36.github.io/2020/09/01/2020-20200901-Linux%E4%B8%8B%E6%9F%A5%E8%AF%A2%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://zjinc36.github.io/2020/09/01/2020-20200901-Linux下查询进程占用的内存方法总结/</id>
    <published>2020-09-01T11:07:08.000Z</published>
    <updated>2020-09-01T03:08:09.399Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000004147558" target="_blank" rel="noopener">linux下查询进程占用的内存方法总结</a></p>]]></content>
    
    <summary type="html">
    
      Linux下查询进程占用的内存方法总结
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Linux命令" scheme="https://zjinc36.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>解决Github-Page无法访问的其中一种情况</title>
    <link href="https://zjinc36.github.io/2020/08/26/2020-20200826-%E8%A7%A3%E5%86%B3Github-Page%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>https://zjinc36.github.io/2020/08/26/2020-20200826-解决Github-Page无法访问的其中一种情况/</id>
    <published>2020-08-26T12:56:43.000Z</published>
    <updated>2020-08-26T05:16:57.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改ip"><a href="#修改ip" class="headerlink" title="修改ip"></a>修改ip</h1><p>网上很多帖子,但是我修改之后无效</p><h1 id="修改dns服务器"><a href="#修改dns服务器" class="headerlink" title="修改dns服务器"></a>修改dns服务器</h1><ol><li>查看域名指向哪里<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup github.io</span><br></pre></td></tr></table></figure></li></ol><p>我本地如下,指向了127.0.0.1,所以确认是需要修改dns服务器地址了<br><img src="/images/2020/08/20200826130349.png" alt></p><ol start="2"><li>修改dns服务器地址<br>修改文件 /etc/resolvconf/resolv.conf.d/head（这个文件默认为空），添加以下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure></li></ol><p>执行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvconf -u</span><br></pre></td></tr></table></figure><p>通过 /etc/resolv.conf 查看 DNS 设置,可看到多了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>此时nslookup可以看到如下<br><img src="/images/2020/08/20200826130600.png" alt><br>然后能成功访问<br><img src="/images/2020/08/20200826130832.png" alt></p>]]></content>
    
    <summary type="html">
    
      解决Github-Page无法访问的其中一种情况
    
    </summary>
    
      <category term="未分类" scheme="https://zjinc36.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu中修改DNS的方法</title>
    <link href="https://zjinc36.github.io/2020/08/26/2020-20200826-Ubuntu%E4%B8%AD%E4%BF%AE%E6%94%B9DNS%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://zjinc36.github.io/2020/08/26/2020-20200826-Ubuntu中修改DNS的方法/</id>
    <published>2020-08-26T12:43:41.000Z</published>
    <updated>2020-08-26T04:53:47.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改DNS的方法"><a href="#修改DNS的方法" class="headerlink" title="修改DNS的方法"></a>修改DNS的方法</h1><p>修改文件 <code>/etc/resolvconf/resolv.conf.d/head</code>（这个文件默认为空），添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>:wq 保存退出</p><p>执行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvconf -u</span><br></pre></td></tr></table></figure><p>通过 <code>/etc/resolv.conf</code> 查看 DNS 设置:</p><p>可看到多了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><h1 id="etc-resolv-conf基本说明"><a href="#etc-resolv-conf基本说明" class="headerlink" title="/etc/resolv.conf基本说明"></a>/etc/resolv.conf基本说明</h1><p>/etc/resolv.conf是DNS名称解析器库的主要配置文件。</p><p>解析程序是C库中的一组函数，提供对Internet域名系统 （ DNS ）的访问。 这些功能被配置为检查/etc/hosts文件或多个DNSNameservers中的条目，或者使用主机的网络信息服务 （ NIS ）数据库。</p><p>在使用systemd（系统和服务管理器）的现代Linux系统上，DNS或名称解析服务通过systemd解析的服务提供给本地应用程序。</p><p>默认情况下，此服务具有四种用于处理域名解析的模式，并在默认操作模式下使用systemd DNS存根文件（ /run/systemd/resolve/stub-resolv.conf ）。</p><p>DNS存根文件包含本地存根127.0.0.53作为唯一的DNS服务器，并且重定向到/etc/resolv.conf文件，该文件用于添加系统使用的Nameservers。</p><p>如果在/etc/resolv.conf上运行以下ls命令 ，您将看到该文件是/run/systemd/resolve/stub-resolv.conf文件的符号链接。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /etc/resolv.conf</span></span><br><span class="line">lrwxrwxrwx 1 root root 39 Feb 15  2019 /etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br></pre></td></tr></table></figure><p>不幸的是，由于/etc/resolv.conf是由systemd解析的服务间接管理的，在某些情况下是由网络服务（通过使用initscripts或NetworkManager ）间接管理的，因此，用户手动进行的任何更改都无法永久保存或仅保存持续一会儿。</p><h1 id="为什么要修改-etc-resolv-conf文件？"><a href="#为什么要修改-etc-resolv-conf文件？" class="headerlink" title="为什么要修改 /etc/resolv.conf文件？"></a>为什么要修改 /etc/resolv.conf文件？</h1><p>主要原因可能是因为系统DNS设置配置错误，或者您更喜欢使用特定的Nameservers或您自己的Nameservers。 以下cat命令在我的Ubuntu系统上的/etc/resolv.conf文件中显示默认Nameservers。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure><p><img src="/images/2020/08/20200826124922.png" alt></p><h2 id="检查DNSNameservers"><a href="#检查DNSNameservers" class="headerlink" title="检查DNSNameservers"></a>检查DNSNameservers</h2><p>在这种情况下，当APT程序包管理器之类的本地应用程序尝试访问本地网络上的FQDN （ 完全合格的域名 ）时，结果是“ 名称解析临时失败 ”错误，如下图所示。<br><img src="/images/2020/08/20200826125005.png" alt></p><h2 id="临时故障解决"><a href="#临时故障解决" class="headerlink" title="临时故障解决"></a>临时故障解决</h2><p>当您运行ping命令时，也会发生同样的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping google.com</span><br></pre></td></tr></table></figure><p><img src="/images/2020/08/20200826125029.png" alt></p><p>名称解析暂时失败</p><p>因此，当用户尝试手动设置Nameservers时，更改不会持续很长时间，也不会在重新启动后被撤销。 要解决此问题，您可以安装并使用reolvconf实用程序使更改永久生效 。</p><p>要安装下一部分中所示的resolvconf软件包，首先需要在/etc/resolv.conf文件中手动设置以下Nameservers，以便在Internet上访问Ubuntu仓库服务器的FQDM。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.4.4</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><h1 id="在Ubuntu和Debian中安装resolvconf"><a href="#在Ubuntu和Debian中安装resolvconf" class="headerlink" title="在Ubuntu和Debian中安装resolvconf"></a>在Ubuntu和Debian中安装resolvconf</h1><p>首先，更新系统软件包，然后通过运行以下命令从官方系统信息库安装resolvconf 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install resolvconf</span><br></pre></td></tr></table></figure><p>一旦resolvconf安装完成， systemd将触发resolvconf.service自动启动和启用。 要检查它是否已启动并正在运行，请发出以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status resolvconf.service</span><br></pre></td></tr></table></figure><p>如果由于某种原因未启动并自动启用该服务，则可以按以下步骤启动并启用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start resolvconf.service</span><br><span class="line">$ sudo systemctl enable resolvconf.service</span><br><span class="line">$ sudo systemctl status resolvconf.service</span><br></pre></td></tr></table></figure><h1 id="在Ubuntu和Debian中设置永久DNSNameservers"><a href="#在Ubuntu和Debian中设置永久DNSNameservers" class="headerlink" title="在Ubuntu和Debian中设置永久DNSNameservers"></a>在Ubuntu和Debian中设置永久DNSNameservers</h1><p>接下来，打开/etc/resolvconf/resolv.conf.d/head配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/resolvconf/resolv.conf.d/head</span><br></pre></td></tr></table></figure><p>并在其中添加以下几行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8 </span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure><p><img src="/images/2020/08/20200826125154.png" alt></p><p>在Resolvconf中设置永久DNSNameservers</p><p>保存更改，然后重新启动resolvconf.service或重新引导系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start resolvconf.service</span><br></pre></td></tr></table></figure><p>现在，当您检查/etc/resolv.conf文件时，Nameservers条目应永久存储在此处。 从今以后，您将不会在系统上遇到任何有关名称解析的问题<br><img src="/images/2020/08/20200826125212.png" alt><br>永久DNSNameservers</p>]]></content>
    
    <summary type="html">
    
      Ubuntu中修改DNS的方法
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Linux命令" scheme="https://zjinc36.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Nslookup命令-查DNS信息用</title>
    <link href="https://zjinc36.github.io/2020/08/26/2020-20200826-nslookup%E5%91%BD%E4%BB%A4-%E6%9F%A5DNS%E4%BF%A1%E6%81%AF%E7%94%A8/"/>
    <id>https://zjinc36.github.io/2020/08/26/2020-20200826-nslookup命令-查DNS信息用/</id>
    <published>2020-08-26T12:35:29.000Z</published>
    <updated>2020-08-26T04:55:14.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h1><p> nslookup命令是常用域名查询工具，就是查DNS信息用的命令。</p><p>nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p><p>进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>nslookup(选项)(参数)</p><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><ul><li>-sil：不显示任何警告信息。</li></ul><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>域名：指定要查询域名。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nslookup www.linuxde.net</span><br><span class="line">Server:         202.96.104.15</span><br><span class="line">Address:        202.96.104.15#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.linuxde.net canonical name = host.1.linuxde.net.</span><br><span class="line">Name:   host.1.linuxde.net</span><br><span class="line">Address: 100.42.212.8</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.howtoing.com/set-permanent-dns-nameservers-in-ubuntu-debian" target="_blank" rel="noopener">如何在Ubuntu和Debian中设置永久DNSNameservers</a></li><li><a href="https://www.runoob.com/w3cnote/ubuntu-modify-dns.html" target="_blank" rel="noopener">ubuntu 修改 DNS 的方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      nslookup命令-查DNS信息用
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Linux命令" scheme="https://zjinc36.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04中安装flameshot截屏工具</title>
    <link href="https://zjinc36.github.io/2020/08/02/2020-20200801-Ubuntu20-04%E4%B8%AD%E5%AE%89%E8%A3%85flameshot%E6%88%AA%E5%B1%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://zjinc36.github.io/2020/08/02/2020-20200801-Ubuntu20-04中安装flameshot截屏工具/</id>
    <published>2020-08-01T23:27:28.000Z</published>
    <updated>2020-08-02T04:56:22.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>截图工具，可添加文字、箭头等</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在软件商店里有，直接搜索软件名<code>flameshot</code>安装就行</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/images/2020/08/20200802125316.png" alt></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>←、↓、↑、→</td><td>移动选择区域 1px</td></tr><tr><td>Shift + ←、↓、↑、→</td><td>将选择区域大小更改 1px</td></tr><tr><td>Esc</td><td>退出截图</td></tr><tr><td>Ctrl + C</td><td>复制到粘贴板</td></tr><tr><td>Ctrl + S</td><td>将选择区域保存为文件</td></tr><tr><td>Ctrl + Z</td><td>撤销最近的一次操作</td></tr><tr><td>鼠标右键</td><td>展示颜色拾取器</td></tr><tr><td>鼠标滚轮</td><td>改变工具的宽度</td></tr></tbody></table><p>边按住 Shift 键并拖动选择区域的其中一个控制点将会对它相反方向的控制点做类似的拖放操作。</p><h2 id="Flameshot-命令行选项"><a href="#Flameshot-命令行选项" class="headerlink" title="Flameshot 命令行选项"></a>Flameshot 命令行选项</h2><p>Flameshot 支持一系列的命令行选项来延时截图和保存图片到自定义的路径。</p><p>要使用 Flameshot GUI 模式，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui</span><br></pre></td></tr></table></figure><p>要使用 GUI 模式截屏并将你选取的区域保存到一个自定义的路径，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui -p ~/myStuff/captures</span><br></pre></td></tr></table></figure><p>要延时 2 秒后打开 GUI 模式可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui -d 2000</span><br></pre></td></tr></table></figure><p>要延时 2 秒并将截图保存到一个自定义的路径（无 GUI）可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot full -p ~/myStuff/captures -d 2000</span><br></pre></td></tr></table></figure><p>要截图全屏并保存到自定义的路径和粘贴板中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot full -c -p ~/myStuff/captures</span><br></pre></td></tr></table></figure><p>要在截屏中包含鼠标并将图片保存为 PNG 格式可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot screen -r</span><br></pre></td></tr></table></figure><p>要对屏幕 1 进行截屏并将截屏复制到粘贴板中可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot screen -n 1 -c</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/20fc667279ea" target="_blank" rel="noopener">Linux中的截图工具 - Flameshot</a><br><a href="https://www.sinocalife.com/ubuntu-20-04-screenshot-trident-tools-gnome-screenshot-flameshot-shutter" target="_blank" rel="noopener">Ubuntu 20.04 截图软件的使用 (gnome-screenshot、flameshot、shutter 截图编辑三叉戟)</a></p>]]></content>
    
    <summary type="html">
    
      截图工具，可添加文字、箭头等
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu刷新DNS</title>
    <link href="https://zjinc36.github.io/2020/07/31/2020-20200731-Ubuntu%E5%88%B7%E6%96%B0DNS/"/>
    <id>https://zjinc36.github.io/2020/07/31/2020-20200731-Ubuntu刷新DNS/</id>
    <published>2020-07-31T09:59:24.000Z</published>
    <updated>2020-07-31T02:03:00.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方式一-刷新DNS"><a href="#方式一-刷新DNS" class="headerlink" title="方式一:刷新DNS"></a>方式一:刷新DNS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nscd restart</span><br></pre></td></tr></table></figure><p>如果发现提示命令找不到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo: /etc/init.d/nscd: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>需要先安装nscd包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nscd</span><br></pre></td></tr></table></figure><h1 id="方式二-重启网络刷dns"><a href="#方式二-重启网络刷dns" class="headerlink" title="方式二:重启网络刷dns"></a>方式二:重启网络刷dns</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu设置开机自动加/挂载硬盘
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu配置" scheme="https://zjinc36.github.io/tags/Ubuntu%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>循环冗余校验（CRC）算法</title>
    <link href="https://zjinc36.github.io/2020/07/28/2020-20200727-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%EF%BC%88CRC%EF%BC%89%E7%AE%97%E6%B3%95/"/>
    <id>https://zjinc36.github.io/2020/07/28/2020-20200727-循环冗余校验（CRC）算法/</id>
    <published>2020-07-27T22:39:14.000Z</published>
    <updated>2020-07-27T15:27:52.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zhihu.com/question/20303082/answer/158430490" target="_blank" rel="noopener">知乎:https://www.zhihu.com/question/20303082/answer/158430490 – 作者：红猴子</a></li><li><a href="https://blog.csdn.net/liyuanbhu/article/details/7882789" target="_blank" rel="noopener">循环冗余校验（CRC）算法入门引导</a></li></ol><h1 id="从奇偶校验说起"><a href="#从奇偶校验说起" class="headerlink" title="从奇偶校验说起"></a>从奇偶校验说起</h1><p>所谓通讯过程的校验是指在通讯数据后加上一些附加信息，通过这些附加信息来判断接收到的数据是否和发送出的数据相同。比如说RS232串行通讯可以设置奇偶校验位，所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个。比如我们要发送的字节是0x1a，二进制表示为0001 1010。</p><p>采用奇校验，则在数据后补上个0，数据变为0001 1010 0，数据中1的个数为奇数个（3个）</p><p>采用偶校验，则在数据后补上个1，数据变为0001 1010 1，数据中1的个数为偶数个（4个）</p><p>接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错。</p><p>奇偶校验的缺点也很明显，首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大。因此，在高速数据通讯中很少采用奇偶校验。奇偶校验优点也很明显，它很简单，因此可以用硬件来实现，这样可以减少软件的负担。因此，奇偶校验也被广泛的应用着。</p><p>奇偶校验就先介绍到这来，之所以从奇偶校验说起，是因为这种校验方式最简单，而且后面将会知道奇偶校验其实就是CRC 校验的一种(CRC-1)。</p><h1 id="累加和校验"><a href="#累加和校验" class="headerlink" title="累加和校验"></a>累加和校验</h1><p>另一种常见的校验方式是累加和校验。所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后加入一个字节的校验数据。这个字节内容为前面数据包中全部数据的忽略进位的按字节累加和。比如下面的例子：</p><p>我们要传输的信息为： 6、23、4</p><p>加上校验和后的数据包：6、23、4、33</p><p>这里 33 为前三个字节的校验和。接收方收到全部数据后对前三个数据进行同样的累加计算，如果累加和与最后一个字节相同的话就认为传输的数据没有错误。</p><p>累加和校验由于实现起来非常简单，也被广泛的采用。但是这种校验方式的检错能力也比较一般，对于单字节的校验和大概有1/256 的概率将原本是错误的通讯数据误判为正确数据。之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节）</p><h1 id="CRC-Cyclic-Redundancy-算法"><a href="#CRC-Cyclic-Redundancy-算法" class="headerlink" title="CRC(Cyclic Redundancy )算法"></a>CRC(Cyclic Redundancy )算法</h1><p>CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面<br><img src="/images/2020/07/20200727006.png" alt></p><h2 id="发送端计算CRC的过程"><a href="#发送端计算CRC的过程" class="headerlink" title="发送端计算CRC的过程"></a>发送端计算CRC的过程</h2><ul><li>为什么添加4个0后面说明</li><li>什么是生成多项式后面说明</li><li>为什么是XOR后面说明</li></ul><p><img src="/images/2020/07/20200727002.png" alt></p><h2 id="验证码串是否正确"><a href="#验证码串是否正确" class="headerlink" title="验证码串是否正确"></a>验证码串是否正确</h2><p><img src="/images/2020/07/20200727004.png" alt></p><h1 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h1><p>比如说我们有两个二进制数，分别为：1101 和1011。</p><p>1101 与如下的多项式相联系：<br><img src="/images/2020/07/20200727008.png" alt></p><p>1011与如下的多项式相联系：<br><img src="/images/2020/07/20200727009.png" alt></p><p>两个多项式的乘法：<br><img src="/images/2020/07/20200727007.png" alt></p><p>得到结果后，<strong>合并同类项时采用模2运算</strong>。也就是说乘除法采用正常的多项式乘除法，而加减法都采用模2运算。所谓模2运算就是结果除以2后取余数。比如3 mod 2 = 1。<br>因此，上面最终得到的多项式为：<br><img src="/images/2020/07/20200727010.png" alt><br>对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明)</p><p>加减法采用模2运算后其实就成了一种运算了，就是我们通常所说的异或运算：</p><table><thead><tr><th>异或加法</th><th>异或减法</th></tr></thead><tbody><tr><td>0+0=0</td><td>0-0=0</td></tr><tr><td>0+1=1</td><td>1-0=1</td></tr><tr><td>1+0=1</td><td>0-1=1</td></tr><tr><td>1+1=0</td><td>1-1=0</td></tr></tbody></table><p>采用了模2的加减法后，不需要考虑借位的问题，所以除法变简单了。最后得到的余数就是CRC 校验字。为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“生成多项式”。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。好在这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了。</p><p>最常用的几种生成多项式如下：<br><img src="/images/2020/07/20200727005.png" alt></p><h2 id="什么是位宽"><a href="#什么是位宽" class="headerlink" title="什么是位宽"></a>什么是位宽</h2><p>文献中提到的生成多项式经常会说到多项式的位宽（Width，简记为W），这个<strong>位宽不是多项式对应的二进制数的位数，而是位数减1</strong>。</p><p>比如CRC8中用到的位宽为8的生成多项式，其实对应得二进制数有九位：100110001。另外一点，多项式表示和二进制表示都很繁琐，交流起来不方便，因此，文献中多用16进制简写法来表示，因为生成多项式的最高位肯定为1，最高位的位置由位宽可知，<strong>故在简记式中，将最高的1统一去掉了</strong>，如CRC32的生成多项式简记为04C11DB7实际上表示的是104C11DB7。当然，这样简记除了方便外，在编程计算时也有它的用处。</p><h2 id="为什么理论上有7个1但只写了6个"><a href="#为什么理论上有7个1但只写了6个" class="headerlink" title="为什么理论上有7个1但只写了6个"></a>为什么理论上有7个1但只写了6个</h2><ul><li>对于<strong>对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明)</strong>的例子，是将最高的1统一去掉了</li></ul><h2 id="为什么需要补4个0"><a href="#为什么需要补4个0" class="headerlink" title="为什么需要补4个0"></a>为什么需要补4个0</h2><ul><li>对于<strong>发送端计算CRC的过程</strong>的例子，除数是5位数10011，也就是位宽为4（W=4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0。</li></ul><h2 id="奇偶校验与生成多项式的关系"><a href="#奇偶校验与生成多项式的关系" class="headerlink" title="奇偶校验与生成多项式的关系"></a>奇偶校验与生成多项式的关系</h2><p>位宽W=1的生成多项式(CRC1)有两种，分别是X^1和X^1+X^0，读者可以自己证明10 对应的就是奇偶校验中的奇校验，而11对应则是偶校验。因此，写到这里我们知道了奇偶校验其实就是CRC校验的一种特例，这也是我要以奇偶校验作为开篇介绍的原因了。</p>]]></content>
    
    <summary type="html">
    
      循环冗余校验（CRC）算法
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://zjinc36.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu中Rime输入法的安装和配置</title>
    <link href="https://zjinc36.github.io/2020/07/26/2020-20200726-ubuntu%E4%B8%ADRime%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://zjinc36.github.io/2020/07/26/2020-20200726-ubuntu中Rime输入法的安装和配置/</id>
    <published>2020-07-26T12:24:13.000Z</published>
    <updated>2020-07-26T04:36:51.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官方网站及文档"><a href="#官方网站及文档" class="headerlink" title="官方网站及文档"></a>官方网站及文档</h1><p><a href="https://rime.im/" target="_blank" rel="noopener">https://rime.im/</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ibus-rime</span><br></pre></td></tr></table></figure></li><li><p>添加Rime输入法<br><img src="/images/2020/07/20200724004.png" alt></p></li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>Rime的配置是没有界面的</li><li>根据个人喜好修改配置文件：一般用户直接修改<code>default.yaml</code>即可。修改前最好备份一下<ul><li>网上有很多高端教程要大家创建<code>default.custom.yaml</code>，是因为rime升级的时候貌似会进行覆盖操作</li><li>但我实践中还是认为找个地方记下来才靠谱，这种基础配置，除非系统爆炸，否则不会再打开第二次的。增加<code>default.custom.yaml</code>，以后看到反而更容易出现混乱。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.config/ibus/rime/default.yaml</span><br></pre></td></tr></table></figure><p>如下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">schema_list:</span>   </span><br><span class="line"><span class="attr">  - schema:</span> <span class="string">luna_pinyin_simp</span> <span class="comment">#simp是简体，第一位是默认输入法 </span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  page_size:</span> <span class="number">7</span> <span class="comment">#每页候选词个数</span></span><br><span class="line"><span class="attr">ascii_composer:</span></span><br><span class="line"><span class="attr">  switch_key:</span></span><br><span class="line"><span class="attr">    Shift_L:</span> <span class="string">commit_code</span> <span class="comment">#左shift提交字母</span></span><br></pre></td></tr></table></figure><p>修改完之后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus restart</span><br></pre></td></tr></table></figure><h1 id="修改候选字的大小"><a href="#修改候选字的大小" class="headerlink" title="修改候选字的大小"></a>修改候选字的大小</h1><ul><li>安装gnome的插件<code>ibus font setting</code></li><li>地址：<a href="https://extensions.gnome.org/extension/1121/ibus-font-setting/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/1121/ibus-font-setting/</a></li></ul>]]></content>
    
    <summary type="html">
    
      ubuntu中Rime输入法的安装和配置
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04中ibus-Sunpinyin的安装与设置</title>
    <link href="https://zjinc36.github.io/2020/07/26/2020-20200726-Ubuntu18-04%E4%B8%ADibus-sunpinyin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
    <id>https://zjinc36.github.io/2020/07/26/2020-20200726-Ubuntu18-04中ibus-sunpinyin的安装与设置/</id>
    <published>2020-07-26T11:43:09.000Z</published>
    <updated>2020-07-26T04:55:52.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-sunpinyin</span><br></pre></td></tr></table></figure><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><ol><li>配置<br>终端输入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus-setup</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/2020/07/20200726002.png" alt></p><ol start="2"><li>在设置中添加sun-pinyin输入法<br><img src="/images/2020/07/20200726001.png" alt></li></ol><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p><img src="/images/2020/07/20200726004.png" alt></p><h2 id="有可能打不开-问题如下"><a href="#有可能打不开-问题如下" class="headerlink" title="有可能打不开(问题如下)"></a>有可能打不开(问题如下)</h2><ol><li>ubuntu18.04安装了ibus-pinyin, 选用了sunpinyin，但是无法调出sunpinyin的设置窗口。</li><li>当通过命令/usr/lib/ibus/ibus-setup-sunpinyin时，出现如下错误：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/share//ibus-sunpinyin/setup/main.py"</span>, line <span class="number">42</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> ibus</span><br><span class="line">ImportError: No module named ibus</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>需要安装python-ibus，到 <a href="https://launchpad.net/ubuntu/trusty/amd64/python-ibus/1.5.5-1ubuntu3.2" target="_blank" rel="noopener">https://launchpad.net/ubuntu/trusty/amd64/python-ibus/1.5.5-1ubuntu3.2</a> 下载<code>python-ibus_1.5.5-1ubuntu3.2_all.deb</code>安装包，通过命令安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo gdebi python-ibus_1.5.5-1ubuntu3.2_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment">#   如果没有gdebi命令,用如下命令安装</span></span><br><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure><h1 id="修改候选字的大小"><a href="#修改候选字的大小" class="headerlink" title="修改候选字的大小"></a>修改候选字的大小</h1><ul><li>安装gnome的插件<code>ibus font setting</code></li><li>地址：<a href="https://extensions.gnome.org/extension/1121/ibus-font-setting/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/1121/ibus-font-setting/</a></li></ul><h1 id="如果配置没有生效"><a href="#如果配置没有生效" class="headerlink" title="如果配置没有生效"></a>如果配置没有生效</h1><ol><li><p>遇事不决先重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus restart</span><br></pre></td></tr></table></figure></li><li><p>注销系统重新登录</p></li></ol>]]></content>
    
    <summary type="html">
    
      ubuntu18.04中ibus-sunpinyin的安装与设置
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu配置" scheme="https://zjinc36.github.io/tags/Ubuntu%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu设置开机自动加/挂载硬盘</title>
    <link href="https://zjinc36.github.io/2020/07/25/2020-20200724-Ubuntu%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%8A%A0-%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"/>
    <id>https://zjinc36.github.io/2020/07/25/2020-20200724-Ubuntu设置开机自动加-挂载硬盘/</id>
    <published>2020-07-24T18:28:39.000Z</published>
    <updated>2020-07-24T11:00:28.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找到要挂载的磁盘的名称"><a href="#找到要挂载的磁盘的名称" class="headerlink" title="找到要挂载的磁盘的名称"></a>找到要挂载的磁盘的名称</h1><p><img src="/images/2020/07/20200724001.png" alt></p><h1 id="查看磁盘的分区UUID"><a href="#查看磁盘的分区UUID" class="headerlink" title="查看磁盘的分区UUID"></a>查看磁盘的分区UUID</h1><ol><li>新打开一个终端：sudo blkid </li><li>找到分区的UUID与tpye<br><img src="/images/2020/07/20200724003.png" alt></li></ol><h1 id="在-etc-fstab中添加"><a href="#在-etc-fstab中添加" class="headerlink" title="在/etc/fstab中添加"></a>在/etc/fstab中添加</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/fstab: static file system information.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use 'blkid' to print the universally unique identifier for a</span></span><br><span class="line"><span class="comment"># device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="comment"># that works even if disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line"><span class="comment"># # &lt;file system&gt; 磁盘设备名或该设备的Label</span></span><br><span class="line"><span class="comment"># # &lt;mount point&gt; 挂载点（目录）</span></span><br><span class="line"><span class="comment"># # &lt;type&gt; 磁盘分区的文件系统</span></span><br><span class="line"><span class="comment"># # &lt;options&gt; 文件系统参数</span></span><br><span class="line"><span class="comment"># # &lt;dump&gt; 能否被dump命令作用</span></span><br><span class="line"><span class="comment"># # &lt;pass&gt; 是否以fsck检测扇区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># / was on /dev/nvme0n1p5 during installation</span></span><br><span class="line">UUID=81ae4ddb-7784-45bf-b770-47cb89c85aca /               ext4    errors=remount-ro 0       1</span><br><span class="line"><span class="comment"># /boot/efi was on /dev/nvme0n1p1 during installation</span></span><br><span class="line">UUID=3024-823F  /boot/efi       vfat    <span class="built_in">umask</span>=0077      0       1</span><br><span class="line"><span class="comment"># swap was on /dev/nvme0n1p6 during installation</span></span><br><span class="line">UUID=7b9777a0-d735-4c9e-b6ba-109ffce567c2 none            swap    sw              0       0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制前面的</span></span><br><span class="line"><span class="comment"># UUID=81ae4ddb-7784-45bf-b770-47cb89c85aca /               ext4    errors=remount-ro 0       1</span></span><br><span class="line"><span class="comment"># 将UUID改为前面得到的UUID</span></span><br><span class="line"><span class="comment"># 把/改为/media/zjc/otherDocuments</span></span><br><span class="line"><span class="comment"># 把errors=remount-ro改为defaults</span></span><br><span class="line"><span class="comment"># 后面的1改0</span></span><br><span class="line">UUID=EC9CB4199CB3DBF0 /media/zjc/otherDocuments               ntfs    defaults 0       1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu设置开机自动加/挂载硬盘
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04如何固定图标到任务栏</title>
    <link href="https://zjinc36.github.io/2020/07/18/2020-20200718-Ubuntu18-04%E5%A6%82%E4%BD%95%E5%9B%BA%E5%AE%9A%E5%9B%BE%E6%A0%87%E5%88%B0%E4%BB%BB%E5%8A%A1%E6%A0%8F/"/>
    <id>https://zjinc36.github.io/2020/07/18/2020-20200718-Ubuntu18-04如何固定图标到任务栏/</id>
    <published>2020-07-18T14:53:24.000Z</published>
    <updated>2020-07-18T07:15:21.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/softName.desktop</span><br><span class="line">或者</span><br><span class="line">sudo vim ~/.local/share/applications/softName.desktop</span><br></pre></td></tr></table></figure><ul><li>softName就是添加快捷方式的名称，也就是软件的名称</li></ul><p>添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">#!/usr/bin/env xdg-open</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">Name=</span><br><span class="line">Exec=</span><br><span class="line">Icon=</span><br><span class="line">NoDisplay=false</span><br><span class="line">StartupWMClass=</span><br></pre></td></tr></table></figure><p><img src="/images/2020/07/20200701006.png" alt></p><p>说明</p><ul><li>[Desktop Entry] 每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件</li><li>Version = 1.0 标明Desktop Entry的版本（可选）</li><li>Name = IdeaIU 程序名称（必须），这里以创建一个idea的快捷方式为例</li><li>GenericName = IdeaIU 程序通用名称（可选）</li><li>Comment =IdeaIU 程序描述（可选）</li><li>Exec = 程序的启动命令（必选），可以带参数运行</li><li>Icon = 设置快捷方式的图标（可选），当Type为Application，此项有效</li><li>Terminal = false 是否在终端中运行（可选），当Type为Application，此项有效</li><li>Type = Application desktop的类型（必选），常见值有“Application”和“Link”</li><li>Categories = GNOME;Application;Network; //注明在菜单栏中显示的类别（可选）</li></ul><h1 id="将图标放到任务栏"><a href="#将图标放到任务栏" class="headerlink" title="将图标放到任务栏"></a>将图标放到任务栏</h1><p>点击应用按钮，把刚生成的应用图标拖到任务栏中<br><img src="/images/2020/07/20200701003.png" alt></p><p>但是有可能会出现启动应用出现双图标,如下<br><img src="/images/2020/07/20200701004.png" alt></p><p>为了解决这个问题，首先打开应用，然后在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xprop |grep WM_CLASS</span><br></pre></td></tr></table></figure><p>此时鼠标指针会变成一个十字准心，点击已经打开的软件界面，终端会反馈一条信息，包括2个字符串<br><img src="/images/2020/07/20200701005.png" alt><br>把第1个字符串里的内容添加到StartupWMClass里，保存，关闭应用重新打开，将不会出现双图标的情况了</p>]]></content>
    
    <summary type="html">
    
      Ubuntu18.04如何固定图标到任务栏
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中批量下载bilibili网站的视频</title>
    <link href="https://zjinc36.github.io/2020/07/11/2020-20200711-Ubuntu%E4%B8%AD%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDbilibili%E7%BD%91%E7%AB%99%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    <id>https://zjinc36.github.io/2020/07/11/2020-20200711-Ubuntu中批量下载bilibili网站的视频/</id>
    <published>2020-07-11T11:50:44.000Z</published>
    <updated>2020-08-19T03:37:39.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方案一-you-get"><a href="#方案一-you-get" class="headerlink" title="方案一:you-get"></a>方案一:you-get</h1><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">Github地址:https://github.com/soimort/you-get</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get #安装You-Get</span><br><span class="line">pip3 install --upgrade you-get #升级You-Get</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --playlist -o ./ https://www.bilibili.com/video/视频地址\?p\=1</span><br></pre></td></tr></table></figure><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><h2 id="项目地址-1"><a href="#项目地址-1" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/Henryhaohao/Bilibili_video_download" target="_blank" rel="noopener">Github地址:https://github.com/Henryhaohao/Bilibili_video_download</a></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li>将项目克隆到本地</li><li>运行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /your/address/bilibili_video_download.py</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu中批量下载bilibili网站的视频
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装分区管理工具gparted</title>
    <link href="https://zjinc36.github.io/2020/07/08/2020-20200708-Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7gparted/"/>
    <id>https://zjinc36.github.io/2020/07/08/2020-20200708-Ubuntu中安装分区管理工具gparted/</id>
    <published>2020-07-08T15:16:44.000Z</published>
    <updated>2020-07-08T07:21:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li><a href="https://gparted.org/index.php" target="_blank" rel="noopener">官网</a></li><li>GNOME Partition Editor,分区管理工具</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><p><a href="https://gparted.org/download.php" target="_blank" rel="noopener">https://gparted.org/download.php</a></p></li><li><p>Ubuntu安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure></li><li><p>主界面<br><img src="/images/2020/07/20200708001.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装分区管理工具gparted
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中基于Docker安装QQ和WeChat</title>
    <link href="https://zjinc36.github.io/2020/07/08/2020-20200708-Ubuntu%E4%B8%AD%E5%9F%BA%E4%BA%8EDocker%E5%AE%89%E8%A3%85QQ%E5%92%8CWeChat/"/>
    <id>https://zjinc36.github.io/2020/07/08/2020-20200708-Ubuntu中基于Docker安装QQ和WeChat/</id>
    <published>2020-07-08T14:30:14.000Z</published>
    <updated>2020-07-08T06:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github上有这两个项目"><a href="#github上有这两个项目" class="headerlink" title="github上有这两个项目"></a>github上有这两个项目</h1><ul><li><a href="https://github.com/bestwu/docker-wechat" target="_blank" rel="noopener">https://github.com/bestwu/docker-wechat</a></li><li><a href="https://github.com/bestwu/docker-qq" target="_blank" rel="noopener">https://github.com/bestwu/docker-qq</a></li></ul><h1 id="有个管理脚本脚本"><a href="#有个管理脚本脚本" class="headerlink" title="有个管理脚本脚本"></a>有个管理脚本脚本</h1><ul><li><a href="https://github.com/ygcaicn/ubuntu_qq" target="_blank" rel="noopener">https://github.com/ygcaicn/ubuntu_qq</a></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装离线API文档大全Zeal
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装桌面搜索应用DocFetcher</title>
    <link href="https://zjinc36.github.io/2020/07/07/2020-20200707-Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E6%A1%8C%E9%9D%A2%E6%90%9C%E7%B4%A2%E5%BA%94%E7%94%A8DocFetcher/"/>
    <id>https://zjinc36.github.io/2020/07/07/2020-20200707-Ubuntu中安装桌面搜索应用DocFetcher/</id>
    <published>2020-07-07T08:15:49.000Z</published>
    <updated>2020-07-07T00:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>DocFetcher 是一个使用 Java 语言开发的开源桌面搜索应用程序<ul><li>能搜索docx和pdf的内容</li></ul></li></ul><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Windows，Linux 和 OS X</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>基于java,所以需要运行环境：Java Runtime Environment（JRE）1.7 +</li><li>参考官网说明:<a href="http://docfetcher.sourceforge.net/en/download.html" target="_blank" rel="noopener">http://docfetcher.sourceforge.net/en/download.html</a></li></ol><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p>为了快速的进行文本检索，DocFetcher 在检索文档文本前需要建立索引，用户可以根据需要为文件夹或者整个磁盘建立索引，当然，仅仅在第一次检索时需要为所要检索的文件夹或磁盘建立索引，建立索引后，当文件内容发生了变化 DocFetcher 会自动更新索引。以下是建立索引的详细方法：</p><ol><li><p>如图所示，右击[搜索范围]框的空白处，选择弹出菜单中的[建立索引 - 资料夹]。<br><img src="/images/2020/07/20200707003.png" alt></p></li><li><p>在弹出的选择窗口中选择需要检索文档的位置，点击[确认]。<br><img src="/images/2020/07/20200707004.png" alt></p></li><li><p>在弹出的窗口中可以对索引的细节进行设置，可以选择所要检索的文件格式，在排除列表中可以使用正则表达式过滤不需要建立索引的文件和文件格式，其他选项没有特殊要求使用默认值即可。最后选择[执行]，将开始建立索引。<br><img src="/images/2020/07/20200707005.png" alt></p></li><li><p>建立索引的过程耗时较长，具体时间取决于所选建立索引的文件夹中包含的文件数量及文件大小。索引建立完成后在首页的[搜索范围]框内便有了对应的目录。</p></li></ol><h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><p>对于建立好索引的目录，可以通过勾选检索目录、勾选文件类型、设定文件大小、输入关键字来进行文本检索，这里仅对 DocFetcher 的检索语法做简单介绍，详细内容请参照官方文档。</p><ul><li>短语搜索：需要将所要检索的短语放入英文双引号内。如 ：”可转债”，返回包含词语”可转债”的文件；</li><li>布尔运算：支持复杂条件的检索，常用运算符包含 AND、OR 、NOT 等，短语间没有运算符时将默认使用 OR。如 “可转债” AND “可交换债”，返回既包含短语”可转债”又包含短语”可交换债”的文件；</li><li>通配符：问号（’?’）和星号（’<em>‘）可用于表示某些字符未知。如 ：”可”</em>，返回包含”可以”、”可转债”、”可交换债”等包含以”可”开头的语句的文件；</li><li>模糊搜索：可以搜索与给定单词类似的单词。如，roam~，返回包含 foam 和的单词的文档 roams 的文件。</li></ul><h3 id="检索关键字格式"><a href="#检索关键字格式" class="headerlink" title="检索关键字格式"></a>检索关键字格式</h3><p>关键字是默认分词的，中文分词有时候一言难尽，所以<strong>如果想搜索整个词语请务必使用英文双引号括住</strong>，否则将导致 DocFetcher 将词语分词后使用 OR 运算进行检索，最终使检索结果出乎意料</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hacpai.com/article/1568960776746#part1-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">DocFetcher 使用教程——高效的文档文本检索工具</a></p>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装桌面搜索应用DocFetcher
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装离线API文档大全Zeal</title>
    <link href="https://zjinc36.github.io/2020/07/07/2020-20200707-Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E7%A6%BB%E7%BA%BFAPI%E6%96%87%E6%A1%A3%E5%A4%A7%E5%85%A8Zeal/"/>
    <id>https://zjinc36.github.io/2020/07/07/2020-20200707-Ubuntu中安装离线API文档大全Zeal/</id>
    <published>2020-07-07T08:03:04.000Z</published>
    <updated>2020-07-07T00:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://zealdocs.org/" target="_blank" rel="noopener">Zeal</a></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>离线 API 文档大全</p><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Linux 和 Windows </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>参考这里<a href="https://zealdocs.org/download.html" target="_blank" rel="noopener">https://zealdocs.org/download.html</a></li><li>ubuntu安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zeal</span><br></pre></td></tr></table></figure></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="下载文档"><a href="#下载文档" class="headerlink" title="下载文档"></a>下载文档</h2><p>在初次安装 Zeal 之后，需要转到 File → Options → Docsets 先下载文档，然后方能使用<br><img src="/images/2020/07/20200707001.png" alt></p><h2 id="使用文档"><a href="#使用文档" class="headerlink" title="使用文档"></a>使用文档</h2><ul><li>有两种方式来查询文档<ul><li>直接输入 keyword 关键字进行查询，这将搜索已下载的所有文档。</li><li>包含文档类型前缀的查询，例如：python:keyword 这将仅限于搜索 Python 文档。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装离线API文档大全Zeal
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
