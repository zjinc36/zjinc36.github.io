<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>想了20分钟的博客名</title>
  
  <subtitle>世界是唯物辩证的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjinc36.github.io/"/>
  <updated>2020-08-02T04:56:22.421Z</updated>
  <id>https://zjinc36.github.io/</id>
  
  <author>
    <name>zjc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu20.04中安装flameshot截屏工具</title>
    <link href="https://zjinc36.github.io/2020/08/02/Ubuntu20-04%E4%B8%AD%E5%AE%89%E8%A3%85flameshot%E6%88%AA%E5%B1%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://zjinc36.github.io/2020/08/02/Ubuntu20-04中安装flameshot截屏工具/</id>
    <published>2020-08-01T23:27:28.000Z</published>
    <updated>2020-08-02T04:56:22.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>截图工具，可添加文字、箭头等</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在软件商店里有，直接搜索软件名<code>flameshot</code>安装就行</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/images/2020/08/20200802125316.png" alt></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>←、↓、↑、→</td><td>移动选择区域 1px</td></tr><tr><td>Shift + ←、↓、↑、→</td><td>将选择区域大小更改 1px</td></tr><tr><td>Esc</td><td>退出截图</td></tr><tr><td>Ctrl + C</td><td>复制到粘贴板</td></tr><tr><td>Ctrl + S</td><td>将选择区域保存为文件</td></tr><tr><td>Ctrl + Z</td><td>撤销最近的一次操作</td></tr><tr><td>鼠标右键</td><td>展示颜色拾取器</td></tr><tr><td>鼠标滚轮</td><td>改变工具的宽度</td></tr></tbody></table><p>边按住 Shift 键并拖动选择区域的其中一个控制点将会对它相反方向的控制点做类似的拖放操作。</p><h2 id="Flameshot-命令行选项"><a href="#Flameshot-命令行选项" class="headerlink" title="Flameshot 命令行选项"></a>Flameshot 命令行选项</h2><p>Flameshot 支持一系列的命令行选项来延时截图和保存图片到自定义的路径。</p><p>要使用 Flameshot GUI 模式，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui</span><br></pre></td></tr></table></figure><p>要使用 GUI 模式截屏并将你选取的区域保存到一个自定义的路径，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui -p ~/myStuff/captures</span><br></pre></td></tr></table></figure><p>要延时 2 秒后打开 GUI 模式可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui -d 2000</span><br></pre></td></tr></table></figure><p>要延时 2 秒并将截图保存到一个自定义的路径（无 GUI）可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot full -p ~/myStuff/captures -d 2000</span><br></pre></td></tr></table></figure><p>要截图全屏并保存到自定义的路径和粘贴板中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot full -c -p ~/myStuff/captures</span><br></pre></td></tr></table></figure><p>要在截屏中包含鼠标并将图片保存为 PNG 格式可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot screen -r</span><br></pre></td></tr></table></figure><p>要对屏幕 1 进行截屏并将截屏复制到粘贴板中可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot screen -n 1 -c</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/20fc667279ea" target="_blank" rel="noopener">Linux中的截图工具 - Flameshot</a><br><a href="https://www.sinocalife.com/ubuntu-20-04-screenshot-trident-tools-gnome-screenshot-flameshot-shutter" target="_blank" rel="noopener">Ubuntu 20.04 截图软件的使用 (gnome-screenshot、flameshot、shutter 截图编辑三叉戟)</a></p>]]></content>
    
    <summary type="html">
    
      截图工具，可添加文字、箭头等
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu刷新DNS</title>
    <link href="https://zjinc36.github.io/2020/07/31/Ubuntu%E5%88%B7%E6%96%B0DNS/"/>
    <id>https://zjinc36.github.io/2020/07/31/Ubuntu刷新DNS/</id>
    <published>2020-07-31T09:59:24.000Z</published>
    <updated>2020-07-31T02:03:00.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方式一-刷新DNS"><a href="#方式一-刷新DNS" class="headerlink" title="方式一:刷新DNS"></a>方式一:刷新DNS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nscd restart</span><br></pre></td></tr></table></figure><p>如果发现提示命令找不到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo: /etc/init.d/nscd: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>需要先安装nscd包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nscd</span><br></pre></td></tr></table></figure><h1 id="方式二-重启网络刷dns"><a href="#方式二-重启网络刷dns" class="headerlink" title="方式二:重启网络刷dns"></a>方式二:重启网络刷dns</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu设置开机自动加/挂载硬盘
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu配置" scheme="https://zjinc36.github.io/tags/Ubuntu%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>循环冗余校验（CRC）算法</title>
    <link href="https://zjinc36.github.io/2020/07/28/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%EF%BC%88CRC%EF%BC%89%E7%AE%97%E6%B3%95/"/>
    <id>https://zjinc36.github.io/2020/07/28/循环冗余校验（CRC）算法/</id>
    <published>2020-07-27T22:39:14.000Z</published>
    <updated>2020-07-27T15:27:52.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zhihu.com/question/20303082/answer/158430490" target="_blank" rel="noopener">知乎:https://www.zhihu.com/question/20303082/answer/158430490 – 作者：红猴子</a></li><li><a href="https://blog.csdn.net/liyuanbhu/article/details/7882789" target="_blank" rel="noopener">循环冗余校验（CRC）算法入门引导</a></li></ol><h1 id="从奇偶校验说起"><a href="#从奇偶校验说起" class="headerlink" title="从奇偶校验说起"></a>从奇偶校验说起</h1><p>所谓通讯过程的校验是指在通讯数据后加上一些附加信息，通过这些附加信息来判断接收到的数据是否和发送出的数据相同。比如说RS232串行通讯可以设置奇偶校验位，所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个。比如我们要发送的字节是0x1a，二进制表示为0001 1010。</p><p>采用奇校验，则在数据后补上个0，数据变为0001 1010 0，数据中1的个数为奇数个（3个）</p><p>采用偶校验，则在数据后补上个1，数据变为0001 1010 1，数据中1的个数为偶数个（4个）</p><p>接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错。</p><p>奇偶校验的缺点也很明显，首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大。因此，在高速数据通讯中很少采用奇偶校验。奇偶校验优点也很明显，它很简单，因此可以用硬件来实现，这样可以减少软件的负担。因此，奇偶校验也被广泛的应用着。</p><p>奇偶校验就先介绍到这来，之所以从奇偶校验说起，是因为这种校验方式最简单，而且后面将会知道奇偶校验其实就是CRC 校验的一种(CRC-1)。</p><h1 id="累加和校验"><a href="#累加和校验" class="headerlink" title="累加和校验"></a>累加和校验</h1><p>另一种常见的校验方式是累加和校验。所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后加入一个字节的校验数据。这个字节内容为前面数据包中全部数据的忽略进位的按字节累加和。比如下面的例子：</p><p>我们要传输的信息为： 6、23、4</p><p>加上校验和后的数据包：6、23、4、33</p><p>这里 33 为前三个字节的校验和。接收方收到全部数据后对前三个数据进行同样的累加计算，如果累加和与最后一个字节相同的话就认为传输的数据没有错误。</p><p>累加和校验由于实现起来非常简单，也被广泛的采用。但是这种校验方式的检错能力也比较一般，对于单字节的校验和大概有1/256 的概率将原本是错误的通讯数据误判为正确数据。之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节）</p><h1 id="CRC-Cyclic-Redundancy-算法"><a href="#CRC-Cyclic-Redundancy-算法" class="headerlink" title="CRC(Cyclic Redundancy )算法"></a>CRC(Cyclic Redundancy )算法</h1><p>CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面<br><img src="/images/2020/07/20200727006.png" alt></p><h2 id="发送端计算CRC的过程"><a href="#发送端计算CRC的过程" class="headerlink" title="发送端计算CRC的过程"></a>发送端计算CRC的过程</h2><ul><li>为什么添加4个0后面说明</li><li>什么是生成多项式后面说明</li><li>为什么是XOR后面说明</li></ul><p><img src="/images/2020/07/20200727002.png" alt></p><h2 id="验证码串是否正确"><a href="#验证码串是否正确" class="headerlink" title="验证码串是否正确"></a>验证码串是否正确</h2><p><img src="/images/2020/07/20200727004.png" alt></p><h1 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h1><p>比如说我们有两个二进制数，分别为：1101 和1011。</p><p>1101 与如下的多项式相联系：<br><img src="/images/2020/07/20200727008.png" alt></p><p>1011与如下的多项式相联系：<br><img src="/images/2020/07/20200727009.png" alt></p><p>两个多项式的乘法：<br><img src="/images/2020/07/20200727007.png" alt></p><p>得到结果后，<strong>合并同类项时采用模2运算</strong>。也就是说乘除法采用正常的多项式乘除法，而加减法都采用模2运算。所谓模2运算就是结果除以2后取余数。比如3 mod 2 = 1。<br>因此，上面最终得到的多项式为：<br><img src="/images/2020/07/20200727010.png" alt><br>对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明)</p><p>加减法采用模2运算后其实就成了一种运算了，就是我们通常所说的异或运算：</p><table><thead><tr><th>异或加法</th><th>异或减法</th></tr></thead><tbody><tr><td>0+0=0</td><td>0-0=0</td></tr><tr><td>0+1=1</td><td>1-0=1</td></tr><tr><td>1+0=1</td><td>0-1=1</td></tr><tr><td>1+1=0</td><td>1-1=0</td></tr></tbody></table><p>采用了模2的加减法后，不需要考虑借位的问题，所以除法变简单了。最后得到的余数就是CRC 校验字。为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“生成多项式”。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。好在这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了。</p><p>最常用的几种生成多项式如下：<br><img src="/images/2020/07/20200727005.png" alt></p><h2 id="什么是位宽"><a href="#什么是位宽" class="headerlink" title="什么是位宽"></a>什么是位宽</h2><p>文献中提到的生成多项式经常会说到多项式的位宽（Width，简记为W），这个<strong>位宽不是多项式对应的二进制数的位数，而是位数减1</strong>。</p><p>比如CRC8中用到的位宽为8的生成多项式，其实对应得二进制数有九位：100110001。另外一点，多项式表示和二进制表示都很繁琐，交流起来不方便，因此，文献中多用16进制简写法来表示，因为生成多项式的最高位肯定为1，最高位的位置由位宽可知，<strong>故在简记式中，将最高的1统一去掉了</strong>，如CRC32的生成多项式简记为04C11DB7实际上表示的是104C11DB7。当然，这样简记除了方便外，在编程计算时也有它的用处。</p><h2 id="为什么理论上有7个1但只写了6个"><a href="#为什么理论上有7个1但只写了6个" class="headerlink" title="为什么理论上有7个1但只写了6个"></a>为什么理论上有7个1但只写了6个</h2><ul><li>对于<strong>对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明)</strong>的例子，是将最高的1统一去掉了</li></ul><h2 id="为什么需要补4个0"><a href="#为什么需要补4个0" class="headerlink" title="为什么需要补4个0"></a>为什么需要补4个0</h2><ul><li>对于<strong>发送端计算CRC的过程</strong>的例子，除数是5位数10011，也就是位宽为4（W=4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0。</li></ul><h2 id="奇偶校验与生成多项式的关系"><a href="#奇偶校验与生成多项式的关系" class="headerlink" title="奇偶校验与生成多项式的关系"></a>奇偶校验与生成多项式的关系</h2><p>位宽W=1的生成多项式(CRC1)有两种，分别是X^1和X^1+X^0，读者可以自己证明10 对应的就是奇偶校验中的奇校验，而11对应则是偶校验。因此，写到这里我们知道了奇偶校验其实就是CRC校验的一种特例，这也是我要以奇偶校验作为开篇介绍的原因了。</p>]]></content>
    
    <summary type="html">
    
      循环冗余校验（CRC）算法
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://zjinc36.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu中Rime输入法的安装和配置</title>
    <link href="https://zjinc36.github.io/2020/07/26/ubuntu%E4%B8%ADRime%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://zjinc36.github.io/2020/07/26/ubuntu中Rime输入法的安装和配置/</id>
    <published>2020-07-26T12:24:13.000Z</published>
    <updated>2020-07-26T04:36:51.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官方网站及文档"><a href="#官方网站及文档" class="headerlink" title="官方网站及文档"></a>官方网站及文档</h1><p><a href="https://rime.im/" target="_blank" rel="noopener">https://rime.im/</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ibus-rime</span><br></pre></td></tr></table></figure></li><li><p>添加Rime输入法<br><img src="/images/2020/07/20200724004.png" alt></p></li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>Rime的配置是没有界面的</li><li>根据个人喜好修改配置文件：一般用户直接修改<code>default.yaml</code>即可。修改前最好备份一下<ul><li>网上有很多高端教程要大家创建<code>default.custom.yaml</code>，是因为rime升级的时候貌似会进行覆盖操作</li><li>但我实践中还是认为找个地方记下来才靠谱，这种基础配置，除非系统爆炸，否则不会再打开第二次的。增加<code>default.custom.yaml</code>，以后看到反而更容易出现混乱。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.config/ibus/rime/default.yaml</span><br></pre></td></tr></table></figure><p>如下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">schema_list:</span>   </span><br><span class="line"><span class="attr">  - schema:</span> <span class="string">luna_pinyin_simp</span> <span class="comment">#simp是简体，第一位是默认输入法 </span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  page_size:</span> <span class="number">7</span> <span class="comment">#每页候选词个数</span></span><br><span class="line"><span class="attr">ascii_composer:</span></span><br><span class="line"><span class="attr">  switch_key:</span></span><br><span class="line"><span class="attr">    Shift_L:</span> <span class="string">commit_code</span> <span class="comment">#左shift提交字母</span></span><br></pre></td></tr></table></figure><p>修改完之后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus restart</span><br></pre></td></tr></table></figure><h1 id="修改候选字的大小"><a href="#修改候选字的大小" class="headerlink" title="修改候选字的大小"></a>修改候选字的大小</h1><ul><li>安装gnome的插件<code>ibus font setting</code></li><li>地址：<a href="https://extensions.gnome.org/extension/1121/ibus-font-setting/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/1121/ibus-font-setting/</a></li></ul>]]></content>
    
    <summary type="html">
    
      ubuntu中Rime输入法的安装和配置
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04中ibus-Sunpinyin的安装与设置</title>
    <link href="https://zjinc36.github.io/2020/07/26/Ubuntu18.04%E4%B8%ADibus-sunpinyin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
    <id>https://zjinc36.github.io/2020/07/26/Ubuntu18.04中ibus-sunpinyin的安装与设置/</id>
    <published>2020-07-26T11:43:09.000Z</published>
    <updated>2020-07-26T04:55:52.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-sunpinyin</span><br></pre></td></tr></table></figure><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><ol><li>配置<br>终端输入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus-setup</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/2020/07/20200726002.png" alt></p><ol start="2"><li>在设置中添加sun-pinyin输入法<br><img src="/images/2020/07/20200726001.png" alt></li></ol><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p><img src="/images/2020/07/20200726004.png" alt></p><h2 id="有可能打不开-问题如下"><a href="#有可能打不开-问题如下" class="headerlink" title="有可能打不开(问题如下)"></a>有可能打不开(问题如下)</h2><ol><li>ubuntu18.04安装了ibus-pinyin, 选用了sunpinyin，但是无法调出sunpinyin的设置窗口。</li><li>当通过命令/usr/lib/ibus/ibus-setup-sunpinyin时，出现如下错误：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/share//ibus-sunpinyin/setup/main.py"</span>, line <span class="number">42</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> ibus</span><br><span class="line">ImportError: No module named ibus</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>需要安装python-ibus，到 <a href="https://launchpad.net/ubuntu/trusty/amd64/python-ibus/1.5.5-1ubuntu3.2" target="_blank" rel="noopener">https://launchpad.net/ubuntu/trusty/amd64/python-ibus/1.5.5-1ubuntu3.2</a> 下载<code>python-ibus_1.5.5-1ubuntu3.2_all.deb</code>安装包，通过命令安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo gdebi python-ibus_1.5.5-1ubuntu3.2_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment">#   如果没有gdebi命令,用如下命令安装</span></span><br><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure><h1 id="修改候选字的大小"><a href="#修改候选字的大小" class="headerlink" title="修改候选字的大小"></a>修改候选字的大小</h1><ul><li>安装gnome的插件<code>ibus font setting</code></li><li>地址：<a href="https://extensions.gnome.org/extension/1121/ibus-font-setting/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/1121/ibus-font-setting/</a></li></ul><h1 id="如果配置没有生效"><a href="#如果配置没有生效" class="headerlink" title="如果配置没有生效"></a>如果配置没有生效</h1><ol><li><p>遇事不决先重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus restart</span><br></pre></td></tr></table></figure></li><li><p>注销系统重新登录</p></li></ol>]]></content>
    
    <summary type="html">
    
      ubuntu18.04中ibus-sunpinyin的安装与设置
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu配置" scheme="https://zjinc36.github.io/tags/Ubuntu%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu设置开机自动加/挂载硬盘</title>
    <link href="https://zjinc36.github.io/2020/07/25/Ubuntu%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%8A%A0-%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"/>
    <id>https://zjinc36.github.io/2020/07/25/Ubuntu设置开机自动加-挂载硬盘/</id>
    <published>2020-07-24T18:28:39.000Z</published>
    <updated>2020-07-24T11:00:28.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找到要挂载的磁盘的名称"><a href="#找到要挂载的磁盘的名称" class="headerlink" title="找到要挂载的磁盘的名称"></a>找到要挂载的磁盘的名称</h1><p><img src="/images/2020/07/20200724001.png" alt></p><h1 id="查看磁盘的分区UUID"><a href="#查看磁盘的分区UUID" class="headerlink" title="查看磁盘的分区UUID"></a>查看磁盘的分区UUID</h1><ol><li>新打开一个终端：sudo blkid </li><li>找到分区的UUID与tpye<br><img src="/images/2020/07/20200724003.png" alt></li></ol><h1 id="在-etc-fstab中添加"><a href="#在-etc-fstab中添加" class="headerlink" title="在/etc/fstab中添加"></a>在/etc/fstab中添加</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/fstab: static file system information.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use 'blkid' to print the universally unique identifier for a</span></span><br><span class="line"><span class="comment"># device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="comment"># that works even if disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line"><span class="comment"># # &lt;file system&gt; 磁盘设备名或该设备的Label</span></span><br><span class="line"><span class="comment"># # &lt;mount point&gt; 挂载点（目录）</span></span><br><span class="line"><span class="comment"># # &lt;type&gt; 磁盘分区的文件系统</span></span><br><span class="line"><span class="comment"># # &lt;options&gt; 文件系统参数</span></span><br><span class="line"><span class="comment"># # &lt;dump&gt; 能否被dump命令作用</span></span><br><span class="line"><span class="comment"># # &lt;pass&gt; 是否以fsck检测扇区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># / was on /dev/nvme0n1p5 during installation</span></span><br><span class="line">UUID=81ae4ddb-7784-45bf-b770-47cb89c85aca /               ext4    errors=remount-ro 0       1</span><br><span class="line"><span class="comment"># /boot/efi was on /dev/nvme0n1p1 during installation</span></span><br><span class="line">UUID=3024-823F  /boot/efi       vfat    <span class="built_in">umask</span>=0077      0       1</span><br><span class="line"><span class="comment"># swap was on /dev/nvme0n1p6 during installation</span></span><br><span class="line">UUID=7b9777a0-d735-4c9e-b6ba-109ffce567c2 none            swap    sw              0       0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制前面的</span></span><br><span class="line"><span class="comment"># UUID=81ae4ddb-7784-45bf-b770-47cb89c85aca /               ext4    errors=remount-ro 0       1</span></span><br><span class="line"><span class="comment"># 将UUID改为前面得到的UUID</span></span><br><span class="line"><span class="comment"># 把/改为/media/zjc/otherDocuments</span></span><br><span class="line"><span class="comment"># 把errors=remount-ro改为defaults</span></span><br><span class="line"><span class="comment"># 后面的1改0</span></span><br><span class="line">UUID=EC9CB4199CB3DBF0 /media/zjc/otherDocuments               ntfs    defaults 0       1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu设置开机自动加/挂载硬盘
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04如何固定图标到任务栏</title>
    <link href="https://zjinc36.github.io/2020/07/18/Ubuntu18-04%E5%A6%82%E4%BD%95%E5%9B%BA%E5%AE%9A%E5%9B%BE%E6%A0%87%E5%88%B0%E4%BB%BB%E5%8A%A1%E6%A0%8F/"/>
    <id>https://zjinc36.github.io/2020/07/18/Ubuntu18-04如何固定图标到任务栏/</id>
    <published>2020-07-18T14:53:24.000Z</published>
    <updated>2020-07-18T07:15:21.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/softName.desktop</span><br><span class="line">或者</span><br><span class="line">sudo vim ~/.local/share/applications/softName.desktop</span><br></pre></td></tr></table></figure><ul><li>softName就是添加快捷方式的名称，也就是软件的名称</li></ul><p>添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">#!/usr/bin/env xdg-open</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">Name=</span><br><span class="line">Exec=</span><br><span class="line">Icon=</span><br><span class="line">NoDisplay=false</span><br><span class="line">StartupWMClass=</span><br></pre></td></tr></table></figure><p><img src="/images/2020/07/20200701006.png" alt></p><p>说明</p><ul><li>[Desktop Entry] 每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件</li><li>Version = 1.0 标明Desktop Entry的版本（可选）</li><li>Name = IdeaIU 程序名称（必须），这里以创建一个idea的快捷方式为例</li><li>GenericName = IdeaIU 程序通用名称（可选）</li><li>Comment =IdeaIU 程序描述（可选）</li><li>Exec = 程序的启动命令（必选），可以带参数运行</li><li>Icon = 设置快捷方式的图标（可选），当Type为Application，此项有效</li><li>Terminal = false 是否在终端中运行（可选），当Type为Application，此项有效</li><li>Type = Application desktop的类型（必选），常见值有“Application”和“Link”</li><li>Categories = GNOME;Application;Network; //注明在菜单栏中显示的类别（可选）</li></ul><h1 id="将图标放到任务栏"><a href="#将图标放到任务栏" class="headerlink" title="将图标放到任务栏"></a>将图标放到任务栏</h1><p>点击应用按钮，把刚生成的应用图标拖到任务栏中<br><img src="/images/2020/07/20200701003.png" alt></p><p>但是有可能会出现启动应用出现双图标,如下<br><img src="/images/2020/07/20200701004.png" alt></p><p>为了解决这个问题，首先打开应用，然后在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xprop |grep WM_CLASS</span><br></pre></td></tr></table></figure><p>此时鼠标指针会变成一个十字准心，点击已经打开的软件界面，终端会反馈一条信息，包括2个字符串<br><img src="/images/2020/07/20200701005.png" alt><br>把第1个字符串里的内容添加到StartupWMClass里，保存，关闭应用重新打开，将不会出现双图标的情况了</p>]]></content>
    
    <summary type="html">
    
      Ubuntu18.04如何固定图标到任务栏
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中批量下载bilibili网站的视频</title>
    <link href="https://zjinc36.github.io/2020/07/11/Ubuntu%E4%B8%AD%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDbilibili%E7%BD%91%E7%AB%99%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    <id>https://zjinc36.github.io/2020/07/11/Ubuntu中批量下载bilibili网站的视频/</id>
    <published>2020-07-11T11:50:44.000Z</published>
    <updated>2020-08-19T03:37:39.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方案一-you-get"><a href="#方案一-you-get" class="headerlink" title="方案一:you-get"></a>方案一:you-get</h1><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">Github地址:https://github.com/soimort/you-get</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get #安装You-Get</span><br><span class="line">pip3 install --upgrade you-get #升级You-Get</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --playlist -o ./ https://www.bilibili.com/video/视频地址\?p\=1</span><br></pre></td></tr></table></figure><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><h2 id="项目地址-1"><a href="#项目地址-1" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/Henryhaohao/Bilibili_video_download" target="_blank" rel="noopener">Github地址:https://github.com/Henryhaohao/Bilibili_video_download</a></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li>将项目克隆到本地</li><li>运行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /your/address/bilibili_video_download.py</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu中批量下载bilibili网站的视频
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装分区管理工具gparted</title>
    <link href="https://zjinc36.github.io/2020/07/08/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7gparted/"/>
    <id>https://zjinc36.github.io/2020/07/08/Ubuntu中安装分区管理工具gparted/</id>
    <published>2020-07-08T15:16:44.000Z</published>
    <updated>2020-07-08T07:21:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li><a href="https://gparted.org/index.php" target="_blank" rel="noopener">官网</a></li><li>GNOME Partition Editor,分区管理工具</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><p><a href="https://gparted.org/download.php" target="_blank" rel="noopener">https://gparted.org/download.php</a></p></li><li><p>Ubuntu安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure></li><li><p>主界面<br><img src="/images/2020/07/20200708001.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装分区管理工具gparted
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中基于Docker安装QQ和WeChat</title>
    <link href="https://zjinc36.github.io/2020/07/08/Ubuntu%E4%B8%AD%E5%9F%BA%E4%BA%8EDocker%E5%AE%89%E8%A3%85QQ%E5%92%8CWeChat/"/>
    <id>https://zjinc36.github.io/2020/07/08/Ubuntu中基于Docker安装QQ和WeChat/</id>
    <published>2020-07-08T14:30:14.000Z</published>
    <updated>2020-07-08T06:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github上有这两个项目"><a href="#github上有这两个项目" class="headerlink" title="github上有这两个项目"></a>github上有这两个项目</h1><ul><li><a href="https://github.com/bestwu/docker-wechat" target="_blank" rel="noopener">https://github.com/bestwu/docker-wechat</a></li><li><a href="https://github.com/bestwu/docker-qq" target="_blank" rel="noopener">https://github.com/bestwu/docker-qq</a></li></ul><h1 id="有个管理脚本脚本"><a href="#有个管理脚本脚本" class="headerlink" title="有个管理脚本脚本"></a>有个管理脚本脚本</h1><ul><li><a href="https://github.com/ygcaicn/ubuntu_qq" target="_blank" rel="noopener">https://github.com/ygcaicn/ubuntu_qq</a></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装离线API文档大全Zeal
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装桌面搜索应用DocFetcher</title>
    <link href="https://zjinc36.github.io/2020/07/07/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E6%A1%8C%E9%9D%A2%E6%90%9C%E7%B4%A2%E5%BA%94%E7%94%A8DocFetcher/"/>
    <id>https://zjinc36.github.io/2020/07/07/Ubuntu中安装桌面搜索应用DocFetcher/</id>
    <published>2020-07-07T08:15:49.000Z</published>
    <updated>2020-07-07T00:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>DocFetcher 是一个使用 Java 语言开发的开源桌面搜索应用程序<ul><li>能搜索docx和pdf的内容</li></ul></li></ul><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Windows，Linux 和 OS X</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>基于java,所以需要运行环境：Java Runtime Environment（JRE）1.7 +</li><li>参考官网说明:<a href="http://docfetcher.sourceforge.net/en/download.html" target="_blank" rel="noopener">http://docfetcher.sourceforge.net/en/download.html</a></li></ol><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p>为了快速的进行文本检索，DocFetcher 在检索文档文本前需要建立索引，用户可以根据需要为文件夹或者整个磁盘建立索引，当然，仅仅在第一次检索时需要为所要检索的文件夹或磁盘建立索引，建立索引后，当文件内容发生了变化 DocFetcher 会自动更新索引。以下是建立索引的详细方法：</p><ol><li><p>如图所示，右击[搜索范围]框的空白处，选择弹出菜单中的[建立索引 - 资料夹]。<br><img src="/images/2020/07/20200707003.png" alt></p></li><li><p>在弹出的选择窗口中选择需要检索文档的位置，点击[确认]。<br><img src="/images/2020/07/20200707004.png" alt></p></li><li><p>在弹出的窗口中可以对索引的细节进行设置，可以选择所要检索的文件格式，在排除列表中可以使用正则表达式过滤不需要建立索引的文件和文件格式，其他选项没有特殊要求使用默认值即可。最后选择[执行]，将开始建立索引。<br><img src="/images/2020/07/20200707005.png" alt></p></li><li><p>建立索引的过程耗时较长，具体时间取决于所选建立索引的文件夹中包含的文件数量及文件大小。索引建立完成后在首页的[搜索范围]框内便有了对应的目录。</p></li></ol><h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><p>对于建立好索引的目录，可以通过勾选检索目录、勾选文件类型、设定文件大小、输入关键字来进行文本检索，这里仅对 DocFetcher 的检索语法做简单介绍，详细内容请参照官方文档。</p><ul><li>短语搜索：需要将所要检索的短语放入英文双引号内。如 ：”可转债”，返回包含词语”可转债”的文件；</li><li>布尔运算：支持复杂条件的检索，常用运算符包含 AND、OR 、NOT 等，短语间没有运算符时将默认使用 OR。如 “可转债” AND “可交换债”，返回既包含短语”可转债”又包含短语”可交换债”的文件；</li><li>通配符：问号（’?’）和星号（’<em>‘）可用于表示某些字符未知。如 ：”可”</em>，返回包含”可以”、”可转债”、”可交换债”等包含以”可”开头的语句的文件；</li><li>模糊搜索：可以搜索与给定单词类似的单词。如，roam~，返回包含 foam 和的单词的文档 roams 的文件。</li></ul><h3 id="检索关键字格式"><a href="#检索关键字格式" class="headerlink" title="检索关键字格式"></a>检索关键字格式</h3><p>关键字是默认分词的，中文分词有时候一言难尽，所以<strong>如果想搜索整个词语请务必使用英文双引号括住</strong>，否则将导致 DocFetcher 将词语分词后使用 OR 运算进行检索，最终使检索结果出乎意料</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hacpai.com/article/1568960776746#part1-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">DocFetcher 使用教程——高效的文档文本检索工具</a></p>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装桌面搜索应用DocFetcher
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装离线API文档大全Zeal</title>
    <link href="https://zjinc36.github.io/2020/07/07/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E7%A6%BB%E7%BA%BFAPI%E6%96%87%E6%A1%A3%E5%A4%A7%E5%85%A8Zeal/"/>
    <id>https://zjinc36.github.io/2020/07/07/Ubuntu中安装离线API文档大全Zeal/</id>
    <published>2020-07-07T08:03:04.000Z</published>
    <updated>2020-07-07T00:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://zealdocs.org/" target="_blank" rel="noopener">Zeal</a></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>离线 API 文档大全</p><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Linux 和 Windows </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>参考这里<a href="https://zealdocs.org/download.html" target="_blank" rel="noopener">https://zealdocs.org/download.html</a></li><li>ubuntu安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zeal</span><br></pre></td></tr></table></figure></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="下载文档"><a href="#下载文档" class="headerlink" title="下载文档"></a>下载文档</h2><p>在初次安装 Zeal 之后，需要转到 File → Options → Docsets 先下载文档，然后方能使用<br><img src="/images/2020/07/20200707001.png" alt></p><h2 id="使用文档"><a href="#使用文档" class="headerlink" title="使用文档"></a>使用文档</h2><ul><li>有两种方式来查询文档<ul><li>直接输入 keyword 关键字进行查询，这将搜索已下载的所有文档。</li><li>包含文档类型前缀的查询，例如：python:keyword 这将仅限于搜索 Python 文档。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装离线API文档大全Zeal
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的特殊符号</title>
    <link href="https://zjinc36.github.io/2020/07/05/Scala%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>https://zjinc36.github.io/2020/07/05/Scala中的特殊符号/</id>
    <published>2020-07-05T12:00:27.000Z</published>
    <updated>2020-07-05T07:08:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h1><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>[T &lt;: UpperBound]</td><td>上界</td><td>无</td></tr><tr><td>[T &gt;: LowerBound]</td><td>下界</td><td>无</td></tr><tr><td>[T &lt;% ViewBound]</td><td>视界</td><td>比上界多了隐式转换</td></tr><tr><td>[T : ContextBound]</td><td>上下文界</td><td>是隐式参数的语法糖</td></tr><tr><td>[+T]</td><td>协变</td><td>C[+T]：如果A是B的子类，那么C[A]是C[B]的子类，称为协变</td></tr><tr><td>[-T]</td><td>逆变</td><td>C[-T]：如果A是B的子类，那么C[B]是C[A]的子类，称为逆变</td></tr><tr><td>=:=</td><td>A 必须和 B相等</td><td>Scala 2.10 中被移除了</td></tr><tr><td>&lt;:&lt;</td><td>A 必须是 B的子类</td><td>Scala 2.10 中被移除了</td></tr><tr><td>&lt;%&lt;</td><td>A 必须可以被看做是 B</td><td>Scala 2.10 中被移除了</td></tr></tbody></table><p>如果你在尝试使用 &lt;:&lt; 或者 &lt;%&lt; 的时候出错了，那请注意这些符号在 Scala 2.10 中被移除了。Scala School 里的例子仅能在 Scala 2.9.x 下正常工作。你可以使用新版本的 Scala，但可能会遇到错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class Container[A](value: A) &#123; def addIt(implicit evidence: A =:= Int) = 123 + value &#125;</span></span><br><span class="line">defined class Container</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (new Container(123)).addIt</span></span><br><span class="line">res11: Int = 246</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (new Container(<span class="string">"123"</span>)).addIt</span></span><br><span class="line">&lt;console&gt;:10: error: could not find implicit value for parameter evidence: =:=[java.lang.String,Int]</span><br><span class="line"></span><br><span class="line">// 类似地，根据之前的隐式转换，我们可以将约束放松为可视性：</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class Container[A](value: A) &#123; def addIt(implicit evidence: A &lt;%&lt; Int) = 123 + value &#125;</span></span><br><span class="line">defined class Container</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (new Container(<span class="string">"123"</span>)).addIt</span></span><br><span class="line">res15: Int = 246</span><br></pre></td></tr></table></figure><h1 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h1><p>这些符号全都是连接的作用，将元素与集合、集合与集合相连接</p><h2 id="集合拼接-等操作"><a href="#集合拼接-等操作" class="headerlink" title="集合拼接 :: ++:等操作"></a>集合拼接 :: ++:等操作</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a =  <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">a: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">b: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>符号</th><th>位置</th><th>解释</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>::</td><td>前插</td><td>把a当成一个元素，前插到b集合</td><td>a :: b</td><td>List(List(1, 2, 3), 4, 5, 6)</td></tr><tr><td>+:</td><td>前插</td><td>同上</td><td>a +: b</td><td>List(List(1, 2, 3), 4, 5, 6)</td></tr><tr><td>:+</td><td>后插</td><td>把b当成一个元素，后插到a集合</td><td>a :+ b</td><td>List(1, 2, 3, List(4, 5, 6))</td></tr><tr><td>++</td><td>拼接</td><td>a和b集合顺序合并</td><td>a ++ b</td><td>List(1, 2, 3, 4, 5, 6)</td></tr><tr><td>++:</td><td>拼接</td><td>同上</td><td>a ++:b</td><td>List(1, 2, 3, 4, 5, 6)</td></tr><tr><td>:::</td><td>拼接</td><td>同上</td><td>a :::b</td><td>List(1, 2, 3, 4, 5, 6)</td></tr></tbody></table><p><code>::</code>操作符是右结合的，如<code>9 :: 5 :: 2 :: Nil</code>相当于<code>9 :: (5 :: (2 :: Nil))</code>。所以 <code>:: +: :::</code>这些操作符都是在前面插入。<code>:+ ++ ++:</code>这些是追加、拼接。</p><h2 id="集合拼接-–-等操作"><a href="#集合拼接-–-等操作" class="headerlink" title="集合拼接 ++= –= 等操作"></a>集合拼接 ++= –= 等操作</h2><ul><li>++= —= </li><li>++= 用于拼接容器，而 += 用于拼接元素</li></ul><p><strong>加法</strong></p><ul><li>xs += x 把元素 x 添加到集合 xs 中。该操作有副作用，它会返回左操作符，这里是 xs 自身。</li><li>xs += (x, y, z) 添加指定的元素到集合 xs 中，并返回 xs 本身。（同样有副作用）</li><li>xs ++= ys 添加集合 ys 中的所有元素到集合 xs 中，并返回 xs 本身。（表达式有副作用）</li><li>xs add x 把元素 x 添加到集合 xs 中，如集合 xs 之前没有包含 x，该操作返回 true，否则返回 false。</li></ul><p><strong>移除</strong></p><ul><li>xs -= x 从集合 xs 中删除元素 x，并返回 xs 本身。（表达式有副作用）</li><li>xs -= (x, y, z) 从集合 xs 中删除指定的元素，并返回 xs 本身。（表达式有副作用）</li><li>xs –= ys 从集合 xs 中删除所有属于集合 ys 的元素，并返回 xs 本身。（表达式有副作用）</li><li>xs remove x 从集合 xs 中删除元素 x 。如之前 xs 中包含了 x 元素，返回 true，否则返回 false。</li><li>xs retain p 只保留集合 xs 中满足条件 p 的元素。</li><li>xs.clear() 删除集合 xs 中的所有元素。</li></ul><p><strong>更新</strong></p><ul><li>xs(x) = b （ 同 xs.update(x, b) ）参数 b 为布尔类型，如果值为 true 就把元素x加入集合 xs，否则从集合 xs 中删除 x。</li></ul><p><strong>克隆</strong></p><ul><li>xs.clone 产生一个与 xs 具有相同元素的可变集合。</li></ul><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>s 字符串插值器</td><td>在任何字符串前加上s，就可以直接在串中使用变量</td></tr><tr><td>f 插值器</td><td>在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数</td></tr><tr><td>raw 插值器</td><td>除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的</td></tr></tbody></table><p><strong>举例</strong></p><ul><li><p>s 字符串插值器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line"><span class="comment">// $name嵌套在一个将被s字符串插值器处理的字符串中。</span></span><br><span class="line"><span class="comment">// 插值器知道在这个字符串的这个地方应该插入这个name变量的值，以使输出字符串为Hello,James。</span></span><br><span class="line"><span class="comment">// 使用s插值器，在这个字符串中可以使用任何在处理范围内的名字。</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>) <span class="comment">//Hello,James </span></span><br><span class="line"></span><br><span class="line">println(<span class="string">s"1+1=<span class="subst">$&#123;1+1&#125;</span>"</span>) <span class="comment">//将会输出字符串1+1=2。任何表达式都可以嵌入到$&#123;&#125;中。</span></span><br></pre></td></tr></table></figure></li><li><p>f 插值器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> height=<span class="number">1.9</span>d</span><br><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line"><span class="comment">// f 插值器是类型安全的</span></span><br><span class="line">println(<span class="string">f"<span class="subst">$name</span>%s is <span class="subst">$height</span>%2.2f meters tall"</span>)<span class="comment">//James is 1.90 meters tall </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> height:<span class="type">Double</span>=<span class="number">1.9</span>d</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：</span></span><br><span class="line">scala&gt;<span class="string">f"<span class="subst">$height</span>%4d"</span></span><br><span class="line">&lt;console&gt;:<span class="number">9</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found : <span class="type">Double</span></span><br><span class="line"> required: <span class="type">Int</span></span><br><span class="line">           <span class="string">f"<span class="subst">$height</span>%4d"</span></span><br><span class="line">              ^ f 插值器利用了java中的字符串数据格式。这种以%开头的格式在</span><br></pre></td></tr></table></figure></li><li><p>raw 插值器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="string">s"a\nb"</span></span><br><span class="line">res0:<span class="type">String</span>=</span><br><span class="line">a</span><br><span class="line">b </span><br><span class="line"><span class="comment">// 这里，s 插值器用回车代替了\n。而raw插值器却不会如此处理。</span></span><br><span class="line"></span><br><span class="line">scala&gt;<span class="string">raw"a\nb"</span></span><br><span class="line">res1:<span class="type">String</span>=a\nb </span><br><span class="line"><span class="comment">// 当不想输入\n被转换为回车的时候，raw 插值器是非常实用的。</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="（下划线）的用法"><a href="#（下划线）的用法" class="headerlink" title="_（下划线）的用法"></a><code>_</code>（下划线）的用法</h1><ol><li><p>通配符</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_可以起到类似于*作用的通配符</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span>._</span><br></pre></td></tr></table></figure></li><li><p>指代集合中的每一个元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 遍历集合筛选列表中大于某个值的元素。</span></span><br><span class="line"><span class="keyword">val</span> lst = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> lstFilter = lst.filter(_ &gt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>获取元组中指定下标的元素值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ss = (<span class="number">1</span>,<span class="string">"22"</span>,<span class="string">"333"</span>)</span><br><span class="line">println(ss._1)</span><br></pre></td></tr></table></figure></li><li><p>使用模式匹配可以用来获取元组的组员</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">2</span>,<span class="number">2</span> -&gt; <span class="number">4</span>)</span><br><span class="line"><span class="comment">//如果不需要所有部件， 则在不需要的部件使用_； 本例只取key,因此在value处用_</span></span><br><span class="line"><span class="keyword">for</span> ((k,_) &lt;- m) println(k)</span><br></pre></td></tr></table></figure></li><li><p>成员变量而非局部变量添加默认值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s:<span class="type">Int</span>=_</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变长度参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val arr = Array(1,2,3,4,5)</span></span><br><span class="line">arr: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val Array(first, second, _*) = arr</span></span><br><span class="line">first: Int = 1</span><br><span class="line">second: Int = 2</span><br></pre></td></tr></table></figure></li><li><p>不需要的部件使用<code>_</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Some</span>(<span class="number">5</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(_) =&gt; println(<span class="string">"Yes"</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>,_,_) =&gt; <span class="string">" a list with three element and the first element is 1"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(_*)  =&gt; <span class="string">" a list with zero or more elements "</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Map</span>[_,_] =&gt; <span class="string">" matches a map with any key type and any value type "</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (a, _) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (_ &lt;- <span class="number">1</span> to <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要所有部件， 则在不需要的部件使用_； 本例只取key,因此在value处用 _ </span></span><br><span class="line"><span class="keyword">val</span> m = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">2</span>,<span class="number">2</span> -&gt; <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> ((k,_) &lt;- m) println(k)</span><br></pre></td></tr></table></figure></li></ol><h1 id="参数序列处理"><a href="#参数序列处理" class="headerlink" title=":_*参数序列处理"></a><code>:_*</code>参数序列处理</h1><p>:_* 作为一个整体，告诉编译器你希望将某个参数当作参数序列处理</p><p>当函数接收的参数不定长的时候，假如你想输入一个队列，可以在一个队列后加入“:_*”，因此，这里的“1 to 5”也可以改写为：“Seq(1,2,3,4,5)”。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>])=&#123;</span><br><span class="line">    <span class="keyword">val</span> result=sum(<span class="number">1</span> to <span class="number">5</span>:_*)   <span class="comment">// 在后面写上: _*将1 to 5转化为参数序列</span></span><br><span class="line">     println(result)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(parms:<span class="type">Int</span>*)=&#123;</span><br><span class="line">    <span class="keyword">var</span> result=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(parm &lt;- parms)result+=parm</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模式匹配中使用"><a href="#模式匹配中使用" class="headerlink" title="模式匹配中使用 @"></a>模式匹配中使用 @</h1><p><code>@</code>的主要功能是在模式匹配中，匹配到一个模式后，将引用交给<code>@</code>前的参数<br><strong>案例1</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">o <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; println(x)  <span class="comment">// 打印2</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> someRef @ <span class="type">Some</span>(x) =&gt; println(someRef)  <span class="comment">// 打印Some(2)</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> x @ <span class="type">Some</span>(_) =&gt; println(x)  <span class="comment">// 打印Some(2)</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在处理 request 请求的时候，需要匹配请求的路径，然后还需要直接使用 requet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intent</span> </span>= &#123;</span><br><span class="line"> <span class="keyword">case</span> req @ <span class="type">GET</span>(<span class="type">Path</span>(<span class="type">Seg</span>(<span class="string">"api"</span> :: <span class="string">"user"</span> :: <span class="type">IntPathElement</span>(userId) :: <span class="type">Nil</span>))) =&gt;</span><br><span class="line">      <span class="keyword">val</span> f = (userManager ? <span class="type">FindUserById</span>(userId))</span><br><span class="line">      respond(f, req)</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">case</span> req @ <span class="type">GET</span>(<span class="type">Path</span>(<span class="type">Seg</span>(<span class="string">"api"</span> :: <span class="string">"user"</span> :: <span class="type">Nil</span>))) &amp; <span class="type">Params</span>(<span class="type">EmailParam</span>(email)) =&gt;</span><br><span class="line">      <span class="keyword">val</span> f = (userManager ? <span class="type">FindUserByEmail</span>(email))</span><br><span class="line">      respond(f, req)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Akka-相关特殊字符"><a href="#Akka-相关特殊字符" class="headerlink" title="Akka 相关特殊字符! ?"></a>Akka 相关特殊字符<code>! ?</code></h1><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>!</td><td>表示“即发即忘”，例如异步发送消息并立即返回,也称为tell</td></tr><tr><td>?</td><td>异步发送消息并返回表示可能回复的Future,也称为ask</td></tr></tbody></table><p><strong>举例</strong></p><ul><li><p>send !</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">ArticleBody</span>(uri, body) =&gt; <span class="comment">//If we get the parsed article back, then we've just parsed it</span></span><br><span class="line">    cacheActor ! <span class="type">SetRequest</span>(uri, body) <span class="comment">//Cache it as we just</span></span><br><span class="line">    parsed it</span><br><span class="line">    senderRef ! body</span><br><span class="line">    context.stop(self)</span><br></pre></td></tr></table></figure></li><li><p>ask ?</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> future = pongActor ? <span class="string">"unknown"</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      Scala中的特殊符号
    
    </summary>
    
      <category term="BigData" scheme="https://zjinc36.github.io/categories/BigData/"/>
    
    
      <category term="BigData" scheme="https://zjinc36.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装词典GoldenDict</title>
    <link href="https://zjinc36.github.io/2020/06/14/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E8%AF%8D%E5%85%B8GoldenDict/"/>
    <id>https://zjinc36.github.io/2020/06/14/Ubuntu中安装词典GoldenDict/</id>
    <published>2020-06-14T12:15:30.000Z</published>
    <updated>2020-06-15T02:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install goldendict</span><br></pre></td></tr></table></figure><h1 id="添加词库"><a href="#添加词库" class="headerlink" title="添加词库"></a>添加词库</h1><ol><li><p>离线词库下载<br>测试过<a href="http://download.huzheng.org/zh_CN/" target="_blank" rel="noopener">http://download.huzheng.org/zh_CN/</a><br>测试过<a href="https://freemdict.com/2018/06/04/%e8%8b%b1%e6%b1%89-%e6%9c%97%e6%96%875-%c2%b7%e5%8f%8c%e8%a7%a3%c2%b7%e4%be%8b%e5%8f%a5%e5%8f%91%e9%9f%b3/" target="_blank" rel="noopener">英汉:朗文5++ ·双解·例句发音</a><br>没测试过<a href="http://download.huzheng.org/" target="_blank" rel="noopener">http://download.huzheng.org/</a></p></li><li><p>添加<br><img src="/images/2020/06/20200614003.png" alt></p></li></ol><ol start="3"><li><p>添加在线搜索<br>这里添加有道<code>http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</code><br><img src="/images/2020/06/20200614005.png" alt></p></li><li><p>取消百科的搜索<br><img src="/images/2020/06/20200614006.png" alt></p></li><li><p>调整词典顺序<br><img src="/images/2020/06/20200614004.png" alt></p></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li><p>快捷键<br><img src="/images/2020/06/20200614007.png" alt></p></li><li><p>屏幕取词<br>将需要查询的内容选取,按<code>ctrl + c + c</code>快捷键</p></li></ul><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p><a href="https://www.jianshu.com/p/b6b2c1d78d7c" target="_blank" rel="noopener">安装使用 GoldenDict 查词神器 (Windows/Mac/Linux)</a></p>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装词典GoldenDict
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中一键OCR识别图片截图文字转文本</title>
    <link href="https://zjinc36.github.io/2020/06/14/Ubuntu%E4%B8%AD%E4%B8%80%E9%94%AEOCR%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E6%88%AA%E5%9B%BE%E6%96%87%E5%AD%97%E8%BD%AC%E6%96%87%E6%9C%AC/"/>
    <id>https://zjinc36.github.io/2020/06/14/Ubuntu中一键OCR识别图片截图文字转文本/</id>
    <published>2020-06-14T09:20:26.000Z</published>
    <updated>2020-06-14T01:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h1><p>利用截图软件gnome-screenshot 进行截取需要被文字识别的图片；利用文字识别OCR软件tesseract，进行识别将结果输出，复制到文件和剪切板</p><h1 id="步骤1：安装依赖软件"><a href="#步骤1：安装依赖软件" class="headerlink" title="步骤1：安装依赖软件"></a>步骤1：安装依赖软件</h1><h2 id="安装tesseract"><a href="#安装tesseract" class="headerlink" title="安装tesseract"></a>安装tesseract</h2><p>tesseract是一个开源的OCR引擎，最初是由惠普公司开发用来作为其平板扫描仪的OCR引擎，2005年惠普将其开源出来，之后google接手负责维护。目前稳定的版本是3.0。4.0版本加入了基于LSTM的神经网络技术，中文字符识别准确率有所提高。</p><ol><li><p>添加源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:alex-p/tesseract-ocr</span><br></pre></td></tr></table></figure></li><li><p>更新源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tesseract-ocr</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装中文字库"><a href="#安装中文字库" class="headerlink" title="安装中文字库"></a>安装中文字库</h2><ol><li>tesseract支持60多种语言的识别不同，使用之前需要先下载对应语言的字库，下载地址：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li><li>下载完成之后把.traineddata字库文件放到tessdata目录下，默认路径是/usr/share/tesseract-ocr/4.00/tessdata</li></ol><h2 id="安装剩余软件：shutter，xclip-imagemagick"><a href="#安装剩余软件：shutter，xclip-imagemagick" class="headerlink" title="安装剩余软件：shutter，xclip, imagemagick"></a>安装剩余软件：shutter，xclip, imagemagick</h2><p>这3个不需要添加源，直接终端输入代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 截屏软件</span><br><span class="line">sudo apt-get install shutter</span><br><span class="line"># 终端复制命令</span><br><span class="line">sudo apt-get install xclip</span><br><span class="line"># 图片处理</span><br><span class="line">sudo apt-get install imagemagick</span><br></pre></td></tr></table></figure><h1 id="步骤2：制作shell脚本"><a href="#步骤2：制作shell脚本" class="headerlink" title="步骤2：制作shell脚本"></a>步骤2：制作shell脚本</h1><ol><li><p>创建一个可执行脚本,脚本内容为以下代码,并脚本放到环境变量所在目录</p></li><li><p>注意：将代码中，SCR=”/home/Username/Documents/temp”双引号中的路径替换成你想要存放截图以及识别结果txt文档的路径</p></li><li><p>用<code>tesseract --list-langs</code>检查安装过的语言包</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tesseract --list-langs</span><br><span class="line">List of available languages (3):</span><br><span class="line">eng</span><br><span class="line">chi_sim</span><br><span class="line">osd</span><br></pre></td></tr></table></figure></li><li><p>脚本内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Dependencies: tesseract-ocr imagemagick shutter xclip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Name: OCR</span></span><br><span class="line"><span class="comment">#Date: 2020-06-14</span></span><br><span class="line"><span class="comment">#Fuction: take a screenshot and OCR the letters in the picture</span></span><br><span class="line"><span class="comment">#Path: /home/UserName/...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#you can only scan one character at a time</span></span><br><span class="line">SCR=<span class="string">"/home/UserName/Documents/temp"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####take a shot what you wana to OCR to text</span></span><br><span class="line"><span class="comment"># The purpose of assigning the result to the variable is</span></span><br><span class="line"><span class="comment"># to wait for this command to complete before executing the next line</span></span><br><span class="line">shutterOutput=`shutter -s -e -o <span class="variable">$SCR</span>.png &gt; /dev/null 2&gt;&amp;1`</span><br><span class="line"></span><br><span class="line"><span class="comment">####increase the png</span></span><br><span class="line">mogrify -modulate 100,0 -resize 400% <span class="variable">$SCR</span>.png</span><br><span class="line"><span class="comment">#should increase detection rate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####OCR by tesseract</span></span><br><span class="line"><span class="comment"># Language packages are identified with the `tesseract --list-langs` command</span></span><br><span class="line">tesseract <span class="variable">$SCR</span>.png <span class="variable">$SCR</span> &amp;&gt; /dev/null -l eng+chi_sim</span><br><span class="line"></span><br><span class="line"><span class="comment">####use sed to delete the blanks &amp; get the text and copy to clipboard</span></span><br><span class="line">cat <span class="variable">$SCR</span>.txt | sed <span class="string">'s/ //g'</span> | xclip -selection clipboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you need to delete the newline, please use this statement</span></span><br><span class="line"><span class="comment"># and comment the previous sentence (the first line plus #)</span></span><br><span class="line"><span class="comment">#cat $SCR.txt | sed 's/ //g'| xargs | xclip -selection clipboard</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The pop-up window prompts the end of OCR</span></span><br><span class="line">notify-send <span class="string">"OCR Done"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="步骤3：设置快捷键，一键调用shell脚本"><a href="#步骤3：设置快捷键，一键调用shell脚本" class="headerlink" title="步骤3：设置快捷键，一键调用shell脚本"></a>步骤3：设置快捷键，一键调用shell脚本</h1><ul><li>进入：设置-&gt;键盘 拉到底部，点击+</li><li>名称：自由设置，建议以shell脚本名称命名</li><li>命令：脚本名字<br><img src="/images/2020/06/20200614002.png" alt></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/114917496" target="_blank" rel="noopener">Linux系统（ubuntu）一键OCR识别图片截图文字转文本</a><br><a href="http://huanyouchen.github.io/2018/05/10/install-Tesseract-and-use-it-with-py/" target="_blank" rel="noopener">Tesseract安装使用</a></p>]]></content>
    
    <summary type="html">
    
      本文主要希望在ubuntu系统下实现 一键OCR识别图片截图中的内容使之转换为文本可以复制粘贴
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux中使用tar和gzip进行打包拆包压缩解压</title>
    <link href="https://zjinc36.github.io/2020/06/11/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8tar%E5%92%8Cgzip%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E6%8B%86%E5%8C%85%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    <id>https://zjinc36.github.io/2020/06/11/Linux中使用tar和gzip进行打包拆包压缩解压/</id>
    <published>2020-06-11T09:22:52.000Z</published>
    <updated>2020-06-11T01:35:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="压缩格式："><a href="#压缩格式：" class="headerlink" title="压缩格式："></a>压缩格式：</h1><ul><li><p>windows (zip、rar)</p></li><li><p>linux  (gz ，bzip，zip)</p></li><li><p>先打包再压缩， 打包后可以拆包，压缩后可以解压</p></li><li><p>打包：目录可能有很多个文件，我先把它们打包成一个文件</p></li><li><p>压缩：把打包后的那个文件压缩</p></li></ul><h1 id="tar打包与拆包"><a href="#tar打包与拆包" class="headerlink" title="tar打包与拆包"></a>tar打包与拆包</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -cvf  打包后的文件名即归档文件.tar  欲打包的文件夹名</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -cvf  news.tar  ./java   把java文件夹打包成new.tar</span><br></pre></td></tr></table></figure></li></ol><h2 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xvf  打包后的文件名即归档文件名.tar</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xvf  news.tar   可以把new.tar拆包，拆出来java文件夹</span><br></pre></td></tr></table></figure></li></ol><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- c ：打包，创建的一个归档文件 ，即打包文件夹</span><br><span class="line"></span><br><span class="line">- x ：拆包</span><br><span class="line"></span><br><span class="line">- z ：以gzip 格式压缩，默认压缩倍数 6倍  （0-9）</span><br><span class="line"></span><br><span class="line">- j ：以bzip2格式压缩</span><br><span class="line"></span><br><span class="line">- v ：显示打包或者拆包的文件信息</span><br><span class="line"></span><br><span class="line">- f ： 后面紧接一个 归档文件</span><br></pre></td></tr></table></figure><h1 id="gzip-压缩与解压-bzip2也可以"><a href="#gzip-压缩与解压-bzip2也可以" class="headerlink" title="gzip   压缩与解压(bzip2也可以)"></a>gzip   压缩与解压(bzip2也可以)</h1><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  要压缩的打包后的文件名即归档文件名.tar</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  news.tar</span><br></pre></td></tr></table></figure></li></ol><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  -d  要解压的文件名.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  -d  news.tar.gz</span><br></pre></td></tr></table></figure></li></ol><h1 id="打包且压缩"><a href="#打包且压缩" class="headerlink" title="打包且压缩"></a>打包且压缩</h1><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -czvf  打包并压缩后的文件名.tar.gz  欲打包及压缩的文件夹名</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar  -czvf  news.tar.gz  ./java</span><br><span class="line">或</span><br><span class="line">tar  -czvf  news.tar.gz  java/</span><br><span class="line">或</span><br><span class="line">tar  -czvf  news.tar.gz  java</span><br></pre></td></tr></table></figure></li></ol><h1 id="解压及拆包"><a href="#解压及拆包" class="headerlink" title="解压及拆包"></a>解压及拆包</h1><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xzvf  打包及压缩后的文件名.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xzvf  news.tar.gz</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      tar、gzip (打包拆包、压缩解压、打包压缩、解压拆包)
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Linux命令" scheme="https://zjinc36.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Java中用final修饰静态变量后对静态代码块的影响</title>
    <link href="https://zjinc36.github.io/2020/06/10/Java%E4%B8%AD%E7%94%A8final%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%90%8E%E5%AF%B9%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>https://zjinc36.github.io/2020/06/10/Java中用final修饰静态变量后对静态代码块的影响/</id>
    <published>2020-06-10T12:34:22.000Z</published>
    <updated>2020-06-10T05:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="判断如下代码打印结果"><a href="#判断如下代码打印结果" class="headerlink" title="判断如下代码打印结果"></a>判断如下代码打印结果</h1><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"user...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Emp.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意,这里的final</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"Emp...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(User.age);</span><br><span class="line">System.out.println(Emp.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user....</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p>问:为什么不打印<code>Emp....</code>,按理来说,static代码块在代码类加载的时候就应该调用的,也就是说<code>Emp....</code>应该要打印出来的</p><h1 id="为什么不打印Emp"><a href="#为什么不打印Emp" class="headerlink" title="为什么不打印Emp...."></a>为什么不打印<code>Emp....</code></h1><p>我们分别查看User.java和Emp.java的字节码</p><h2 id="不加final的User的字节码"><a href="#不加final的User的字节码" class="headerlink" title="不加final的User的字节码"></a>不加final的User的字节码</h2><p><img src="/images/2020/06/20200610004.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public static int age;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: bipush        20</span><br><span class="line">         2: putstatic     #10                 // Field age:I</span><br><span class="line">         5: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         8: ldc           #18                 // String user....</span><br><span class="line">        10: invokevirtual #20                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        13: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 6: 5</span><br><span class="line">        line 7: 13</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  public com.zjc.hbasedemo.User();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #29                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/zjc/hbasedemo/User;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;User.java&quot;</span><br></pre></td></tr></table></figure><h2 id="加final的Emp的字节码"><a href="#加final的Emp的字节码" class="headerlink" title="加final的Emp的字节码"></a>加final的Emp的字节码</h2><p><img src="/images/2020/06/20200610003.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  public static final int age;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: int 30</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=0, args_size=0</span><br><span class="line">         0: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #18                 // String Emp....</span><br><span class="line">         5: invokevirtual #20                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line"></span><br><span class="line">  public com.zjc.hbasedemo.Emp();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #29                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/zjc/hbasedemo/Emp;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Emp.java&quot;</span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对于有final关键字来说</p><ul><li>对<code>final</code>的含义来说,是将变量变为一个”不可改变的变量(类似常量)”</li><li>而从字节码可以看出,有<code>final</code>关键字的变量比static更早被赋值,所以,当我们调用<code>Emp.age</code>时,并不需要static块的内容被加载,所以static块的内容不会被打印</li></ul><p>对于无final关键字来说,从字节码中可以得出<br>这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"user...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (这代码在Test.java中调用也要跟着改,这里只是说明用)</span></span><br><span class="line"><span class="comment">// public static int age = 20;</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">            System.out.println(<span class="string">"User...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java中用final修饰静态变量后对静态代码块的影响
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中的多态传递</title>
    <link href="https://zjinc36.github.io/2020/06/10/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E4%BC%A0%E9%80%92/"/>
    <id>https://zjinc36.github.io/2020/06/10/Java中的多态传递/</id>
    <published>2020-06-10T12:07:09.000Z</published>
    <updated>2020-06-10T04:18:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下述代码中的A-a-new-C-中-类C是否实现了接口A"><a href="#下述代码中的A-a-new-C-中-类C是否实现了接口A" class="headerlink" title="下述代码中的A a = new C();中,类C是否实现了接口A"></a>下述代码中的<code>A a = new C();</code>中,类C是否实现了接口A</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">A a = new C();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface A &#123;</span><br><span class="line">&#125;</span><br><span class="line">class B implements A &#123;</span><br><span class="line">&#125;</span><br><span class="line">class C extends B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以打印看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(C.class.getInterfaces().length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface A &#123;</span><br><span class="line">&#125;</span><br><span class="line">class B implements A &#123;</span><br><span class="line">&#125;</span><br><span class="line">class C extends B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>说明C事实上是没有实现接口A的</strong></p><h1 id="那为什么A-a-new-C-没有报错呢"><a href="#那为什么A-a-new-C-没有报错呢" class="headerlink" title="那为什么A a = new C();没有报错呢?"></a>那为什么<code>A a = new C();</code>没有报错呢?</h1><ol><li><p>实现类是可以代替接口出现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = new B();</span><br></pre></td></tr></table></figure></li><li><p>子类是可以代替父类对象出现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B b = new C();</span><br></pre></td></tr></table></figure></li><li><p>所以可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = new C();</span><br></pre></td></tr></table></figure></li></ol><p>语法上是没问题的,虽然C没有特定实现A,但由于有一个<strong>多态传递</strong>的功能,所以是不会报错的</p>]]></content>
    
    <summary type="html">
    
      Java中的多态传递
    
    </summary>
    
      <category term="Java" scheme="https://zjinc36.github.io/categories/Java/"/>
    
    
      <category term="Java细节" scheme="https://zjinc36.github.io/tags/Java%E7%BB%86%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>Java的类加载器</title>
    <link href="https://zjinc36.github.io/2020/06/10/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://zjinc36.github.io/2020/06/10/Java的类加载器/</id>
    <published>2020-06-10T10:33:35.000Z</published>
    <updated>2020-06-10T03:58:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h1><h2 id="Java虚拟机自带的加载器"><a href="#Java虚拟机自带的加载器" class="headerlink" title="Java虚拟机自带的加载器"></a>Java虚拟机自带的加载器</h2><ol><li>启动类加载器(Bootstrap) -&gt; 加载java核心类库</li><li>扩展类加载器(Extension)</li><li>应用类加载器(Application) -&gt; 自定义类一般都是应用加载器加载的</li></ol><h2 id="用户自定义的类加载器-本文不讲"><a href="#用户自定义的类加载器-本文不讲" class="headerlink" title="用户自定义的类加载器(本文不讲)"></a>用户自定义的类加载器(本文不讲)</h2><ol><li>java.lang.ClassLoader 的子类</li><li>用户可以定制类的加载方式</li></ol><h1 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h1><p>加载类</p><blockquote><p>  Java类加载器（英语：Java Classloader）是Java运行时环境（Java Runtime Environment）的一个部件，负责动态加载Java类到Java虚拟机的内存空间中。类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。</p></blockquote><h1 id="类加载器的加载路径"><a href="#类加载器的加载路径" class="headerlink" title="类加载器的加载路径"></a>类加载器的加载路径</h1><h2 id="打印加载路径的代码"><a href="#打印加载路径的代码" class="headerlink" title="打印加载路径的代码"></a>打印加载路径的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BootstrapClassLoader 的加载路径: "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//String[] bootUrls = System.getProperty("sun.boot.class.path").split(";");</span></span><br><span class="line"></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span>(URL url : urls)</span><br><span class="line">System.out.println(url);</span><br><span class="line">System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得扩展类加载器</span></span><br><span class="line">URLClassLoader extClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">System.out.println(extClassLoader);</span><br><span class="line">System.out.println(<span class="string">"扩展类加载器 的加载路径: "</span>);</span><br><span class="line"></span><br><span class="line">urls = extClassLoader.getURLs();</span><br><span class="line"><span class="keyword">for</span>(URL url : urls)</span><br><span class="line">System.out.println(url);</span><br><span class="line">System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得应用(系统)类加载器</span></span><br><span class="line">URLClassLoader appClassLoader = (URLClassLoader)ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">System.out.println(appClassLoader);</span><br><span class="line">System.out.println(<span class="string">"应用(系统)类加载器 的加载路径: "</span>);</span><br><span class="line"></span><br><span class="line">urls = appClassLoader.getURLs();</span><br><span class="line"><span class="keyword">for</span>(URL url : urls)</span><br><span class="line">System.out.println(url);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">BootstrapClassLoader 的加载路径:</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/resources.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/rt.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/sunrsasign.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/jsse.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/jce.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/charsets.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/jfr.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/classes</span><br><span class="line">----------------------------</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">扩展类加载器 的加载路径:</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/sunpkcs11.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/nashorn.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/cldrdata.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/dnsns.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/sunjce_provider.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/jfxrt.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/localedata.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/jaccess.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/sunec.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/jre/lib/ext/zipfs.jar</span><br><span class="line">----------------------------</span><br><span class="line">sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">应用(系统)类加载器 的加载路径:</span><br><span class="line">file:/home/zjc/Documents/eclipse-workspace/hbase/target/classes/</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-server/1.3.1/hbase-server-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-common/1.3.1/hbase-common-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/github/stephenc/findbugs/findbugs-annotations/1.3.9-1/findbugs-annotations-1.3.9-1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-protocol/1.3.1/hbase-protocol-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-procedure/1.3.1/hbase-procedure-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-common/1.3.1/hbase-common-1.3.1-tests.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-prefix-tree/1.3.1/hbase-prefix-tree-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-codec/commons-codec/1.9/commons-codec-1.9.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-hadoop-compat/1.3.1/hbase-hadoop-compat-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-hadoop2-compat/1.3.1/hbase-hadoop2-compat-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/yammer/metrics/metrics-core/2.2.0/metrics-core-2.2.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/slf4j/slf4j-api/1.7.2/slf4j-api-1.7.2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/google/guava/guava/12.0.1/guava-12.0.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/sun/jersey/jersey-server/1.9/jersey-server-1.9.jar</span><br><span class="line">file:/home/zjc/.m2/repository/asm/asm/3.1/asm-3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-cli/commons-cli/1.2/commons-cli-1.2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-lang/commons-lang/2.6/commons-lang-2.6.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/commons/commons-math/2.2/commons-math-2.2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/slf4j/slf4j-log4j12/1.6.1/slf4j-log4j12-1.6.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/mortbay/jetty/jetty-sslengine/6.1.26/jetty-sslengine-6.1.26.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/mortbay/jetty/jsp-2.1/6.1.14/jsp-2.1-6.1.14.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/mortbay/jetty/jsp-api-2.1/6.1.14/jsp-api-2.1-6.1.14.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/mortbay/jetty/servlet-api-2.5/6.1.14/servlet-api-2.5-6.1.14.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar</span><br><span class="line">file:/home/zjc/.m2/repository/tomcat/jasper-compiler/5.5.23/jasper-compiler-5.5.23.jar</span><br><span class="line">file:/home/zjc/.m2/repository/tomcat/jasper-runtime/5.5.23/jasper-runtime-5.5.23.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-el/commons-el/1.0/commons-el-1.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/jamon/jamon-runtime/2.4.1/jamon-runtime-2.4.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/htrace/htrace-core/3.1.0-incubating/htrace-core-3.1.0-incubating.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/lmax/disruptor/3.3.0/disruptor-3.3.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-common/2.5.1/hadoop-common-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-annotations/2.5.1/hadoop-annotations-2.5.1.jar</span><br><span class="line">file:/usr/lib/jvm/java-8-oracle/lib/tools.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/xmlenc/xmlenc/0.52/xmlenc-0.52.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-net/commons-net/3.1/commons-net-3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/codehaus/jackson/jackson-xc/1.8.3/jackson-xc-1.8.3.jar</span><br><span class="line">file:/home/zjc/.m2/repository/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/httpcomponents/httpcore/4.1.2/httpcore-4.1.2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/avro/avro/1.7.4/avro-1.7.4.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/xerial/snappy/snappy-java/1.0.4.1/snappy-java-1.0.4.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/jcraft/jsch/0.1.42/jsch-0.1.42.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/tukaani/xz/1.0/xz-1.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-auth/2.5.1/hadoop-auth-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/httpcomponents/httpclient/4.2.5/httpclient-4.2.5.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-client/2.5.1/hadoop-client-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-app/2.5.1/hadoop-mapreduce-client-app-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-common/2.5.1/hadoop-mapreduce-client-common-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-client/2.5.1/hadoop-yarn-client-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/sun/jersey/jersey-client/1.9/jersey-client-1.9.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-server-common/2.5.1/hadoop-yarn-server-common-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-shuffle/2.5.1/hadoop-mapreduce-client-shuffle-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/fusesource/leveldbjni/leveldbjni-all/1.8/leveldbjni-all-1.8.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-api/2.5.1/hadoop-yarn-api-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-jobclient/2.5.1/hadoop-mapreduce-client-jobclient-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-core/2.5.1/hadoop-mapreduce-client-core-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-yarn-common/2.5.1/hadoop-yarn-common-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar</span><br><span class="line">file:/home/zjc/.m2/repository/javax/activation/activation/1.1/activation-1.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/google/inject/guice/3.0/guice-3.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/sun/jersey/contribs/jersey-guice/1.9/jersey-guice-1.9.jar</span><br><span class="line">file:/home/zjc/.m2/repository/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hadoop/hadoop-hdfs/2.5.1/hadoop-hdfs-2.5.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/commons-daemon/commons-daemon/1.0.13/commons-daemon-1.0.13.jar</span><br><span class="line">file:/home/zjc/.m2/repository/junit/junit/4.12/junit-4.12.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-client/1.3.1/hbase-client-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/apache/hbase/hbase-annotations/1.3.1/hbase-annotations-1.3.1.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/jruby/jcodings/jcodings/1.0.8/jcodings-1.0.8.jar</span><br><span class="line">file:/home/zjc/.m2/repository/org/jruby/joni/joni/2.1.2/joni-2.1.2.jar</span><br></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>启动器加载路径</p><ol><li>安装目录/jre/lib/</li><li>安装目录/jre/classes</li></ol><p>扩展类加载器</p><ol><li>安装目录/jre/lib/ext/</li></ol><p>应用类加载器</p><ol><li>不指定情况下是<code>./</code>目录,即当前目录</li></ol><h1 id="类加载器的”辈份”"><a href="#类加载器的”辈份”" class="headerlink" title="类加载器的”辈份”"></a>类加载器的”辈份”</h1><h2 id="类加载器的执行顺序"><a href="#类加载器的执行顺序" class="headerlink" title="类加载器的执行顺序"></a>类加载器的执行顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoader</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"当前类加载器是:"</span> + TestClassLoader.class.getClassLoader());</span><br><span class="line">System.out.println(<span class="string">"父类加载器是:"</span> + TestClassLoader.class.getClassLoader().getParent());</span><br><span class="line">System.out.println(<span class="string">"爷爷类加载器是:"</span> + TestClassLoader.class.getClassLoader().getParent().getParent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前类加载器是:sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">父类加载器是:sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">爷爷类加载器是:null</span><br></pre></td></tr></table></figure><p>也就是说三者顺序如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器 &gt; 扩展类加载器 &gt; 应用类加载器</span><br></pre></td></tr></table></figure><h2 id="启动类加载器打印为null说明"><a href="#启动类加载器打印为null说明" class="headerlink" title="启动类加载器打印为null说明"></a>启动类加载器打印为null说明</h2><ul><li>因为启动类加载器不是用java写的,因为执行完启动类加载器后才会将java的核心类加载.</li><li>也就是说,启动类加载器是用系统语言写的(比如是c++)</li><li>所以不可能打印出扩展类加载器或应用类加载器那样的java的类,只能是null</li></ul><h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ol><li>应用类加载器要加载环境变量classpath下的类</li><li>但不直接加载,而是交给父类加载器,即扩展类加载器加载</li><li>但不直接加载,而是交给父类加载器,即启动类加载器加载</li><li>如果启动类加载器能加载到则使用启动类加载到的类,否则返回null(返回null而不是抛出错误是因为此时不是java)</li><li>扩展类加载器收到null的情况下,才尝试加载,如果能加载到就使用扩展类加载器加载到的类,否则抛出异常</li><li>应用类加载器收到异常的情况下,才尝试加载,如果能加载到就使用应用类加载器加载到的类,否则抛出<code>ClassNotFound</code>异常</li></ol>]]></content>
    
    <summary type="html">
    
      Java的类加载器，重点理解双亲委派原则
    
    </summary>
    
      <category term="Java" scheme="https://zjinc36.github.io/categories/Java/"/>
    
    
      <category term="Java细节" scheme="https://zjinc36.github.io/tags/Java%E7%BB%86%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装和删除字体</title>
    <link href="https://zjinc36.github.io/2020/06/04/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E5%92%8C%E5%88%A0%E9%99%A4%E5%AD%97%E4%BD%93/"/>
    <id>https://zjinc36.github.io/2020/06/04/Ubuntu中安装和删除字体/</id>
    <published>2020-06-04T13:25:54.000Z</published>
    <updated>2020-06-04T05:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过命令管理字体"><a href="#通过命令管理字体" class="headerlink" title="通过命令管理字体"></a>通过命令管理字体</h1><h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><p>linux系统的字体文件放在/usr/share/fonts/目录以及用户的<del>/.fonts和</del>/.local/share/fonts目录下，第一个位置为系统所用用户共享，将字体安装到这个目录需要管理员权限；后面两个位置则为当前登陆用户所有,安装字体到这个目录不需要管理员权限。</p><ol><li><p>安装到 /usr/share/fonts/ (需要管理员权限)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载字体</span><br><span class="line">wget https://github.com/fangwentong/dotfiles/raw/master/ubuntu-gui/fonts/Monaco.ttf</span><br><span class="line"></span><br><span class="line"># 安装字体</span><br><span class="line">sudo mkdir -p /usr/share/fonts/custom</span><br><span class="line">sudo mv Monaco.ttf /usr/share/fonts/custom</span><br><span class="line">sudo chmod 744 /usr/share/fonts/custom/Monaco.ttf</span><br><span class="line"></span><br><span class="line">sudo mkfontscale  #生成核心字体信息</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo fc-cache -fv</span><br></pre></td></tr></table></figure></li><li><p>安装到 ~/.fonts/ (安装到 ~/.local/share/fonts 原理相同)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载字体</span><br><span class="line">wget https://github.com/fangwentong/dotfiles/blob/ubuntu/fonts/Monaco.ttf?raw=true</span><br><span class="line"></span><br><span class="line"># 安装字体</span><br><span class="line">mkdir -p ~/.fonts</span><br><span class="line">mv Monaco.ttf ~/.fonts</span><br><span class="line">fc-cache -vf  #刷新系统字体缓存</span><br></pre></td></tr></table></figure></li></ol><h2 id="卸载字体"><a href="#卸载字体" class="headerlink" title="卸载字体"></a>卸载字体</h2><p>若不再需要某个字体，可以删除相应字体文件，刷新系统字体缓存即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-cache -vf  #刷新系统字体缓存</span><br></pre></td></tr></table></figure><h1 id="通过图形界面"><a href="#通过图形界面" class="headerlink" title="通过图形界面"></a>通过图形界面</h1><h2 id="系统自带工具安装"><a href="#系统自带工具安装" class="headerlink" title="系统自带工具安装"></a>系统自带工具安装</h2><p>这种方法的优点是安装前能预览字体效果，安装过程简单便捷，动几下鼠标就完成了安装，非常适合在图形界面下安装; 缺点是安装借助图形化工具，无法通过自动化脚本安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   首先到这里下载字体,这里用Monaco.ttf进行说明</span><br><span class="line">+   然后在Ubuntu系统中，双击下载得到的Monaco.ttf文件，即用系统自带的字体查看器打开了该文件，点击面板上的安装按钮，即可完成安装</span><br><span class="line">+   这种方法安装后，字体文件存放在~/.local/share/fonts目录下。</span><br></pre></td></tr></table></figure><h2 id="安装第三方工具"><a href="#安装第三方工具" class="headerlink" title="安装第三方工具"></a>安装第三方工具</h2><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install font-manager</span><br></pre></td></tr></table></figure></li><li><p>界面<br><img src="/images/2020/06/20200604003.png" alt></p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.kutu66.com/ubuntu/article_165241" target="_blank" rel="noopener">在ubuntu中，如何删除字体</a><br><a href="https://blog.wentong.me/2014/05/add-fonts-to-your-linux/" target="_blank" rel="noopener">在linux中安装/卸载字体</a></p>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装和删除字体
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
</feed>
