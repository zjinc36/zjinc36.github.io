<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>想了20分钟的博客名</title>
  
  <subtitle>世界是唯物辩证的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zjinc36.github.io/"/>
  <updated>2020-08-27T16:05:26.253Z</updated>
  <id>https://zjinc36.github.io/</id>
  
  <author>
    <name>zjc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM从入门到精通_09_方法区</title>
    <link href="https://zjinc36.github.io/2020/08/28/JVM%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A-09-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>https://zjinc36.github.io/2020/08/28/JVM从入门到精通-09-方法区/</id>
    <published>2020-08-27T18:29:44.000Z</published>
    <updated>2020-08-27T16:05:26.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ol><li>系列文章是”尚硅谷宋红康老师的JVM教程”的读书笔记</li><li>是基于这个<a href="http://moxi159753.gitee.io/learningnotes/#/README?id=jvm" target="_blank" rel="noopener">学习笔记</a>进行修订</li></ol><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次所讲述的是运行时数据区的最后一个部分<br><img src="/images/2020/08/20200827183227.png" alt><br>从线程共享与否的角度来看<br><img src="/images/2020/08/20200827235018.png" alt><br>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及会话管理</p><h1 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h1><p>下面就涉及了对象的访问定位<br><img src="/images/2020/08/20200827235044.png" alt></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><h1 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h1><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。<br><img src="/images/2020/08/20200827235130.png" alt><br>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：ava.lang.OutofMemoryError：PermGen space 或者java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h2 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h2><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><ul><li>DK 1.8后，元空间存放在堆外内存中</li></ul><p>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。</p><ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易oom（超过-XX:MaxPermsize上限）<br><img src="/images/2020/08/20200827235225.png" alt></li></ul><p>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替<br><img src="/images/2020/08/20200827235246.png" alt></p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存</p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</p><h1 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h1><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 </p><h2 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h2><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。<br><img src="/images/2020/08/20200827235322.png" alt></li></ul><h2 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h2><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p><h2 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h2><ul><li>要解决ooM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<ul><li>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li></ul></li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><p><img src="/images/2020/08/20200827235408.png" alt><br>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等<br><img src="/images/2020/08/20200827235429.png" alt></p><h2 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h2><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h2 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h2><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h2 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h2><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h2 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h2><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * non-final的类变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，即使我们把order设置为null，也不会出现空指针异常</p><h2 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h2><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 </p><h2 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h2><p>运行时常量池，就是运行时常量池<br><img src="/images/2020/08/20200827235605.png" alt></p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><img src="/images/2020/08/20200827235628.png" alt><br>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><h3 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h3><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>比如：如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h3 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h3><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会被翻译成如下字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new #2  </span><br><span class="line">dup</span><br><span class="line">invokespecial</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</p><p>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛outofMemoryError异常。</p><h1 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码执行过程展示<br><img src="/images/2020/08/20200827235938.png" alt><br>首先现将操作数500放入到操作数栈中<br><img src="/images/2020/08/20200827235953.png" alt><br>然后存储到局部变量表中<br><img src="/images/2020/08/20200828000006.png" alt><br>然后重复一次，把100放入局部变量表中，最后再将变量表中的500 和 100 取出，进行操作<br><img src="/images/2020/08/20200828000020.png" alt><br>将500 和 100 进行一个除法运算，在把结果入栈<br><img src="/images/2020/08/20200828000038.png" alt><br>在最后就是输出流，需要调用运行时常量池的常量<br><img src="/images/2020/08/20200828000055.png" alt><br>最后调用invokevirtual（虚方法调用），然后返回<br><img src="/images/2020/08/20200828000112.png" alt><br>返回时<br><img src="/images/2020/08/20200828000129.png" alt><br>程序计数器始终计算的都是当前代码运行的位置，目的是为了方便记录 方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p><h1 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h1><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p><p>Hotspot中方法区的变化：</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>JDK6的时候<br><img src="/images/2020/08/20200828000242.png" alt></p><p>JDK7的时候<br><img src="/images/2020/08/20200828000258.png" alt></p><p>JDK8的时候，元空间大小只受物理内存影响<br><img src="/images/2020/08/20200828000318.png" alt></p><h2 id="为什么永久代要被元空间替代？"><a href="#为什么永久代要被元空间替代？" class="headerlink" title="为什么永久代要被元空间替代？"></a>为什么永久代要被元空间替代？</h2><p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p><ul><li>为永久代设置空间大小是很难确定的。</li></ul><p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>“Exception in thread‘dubbo client x.x connector’java.lang.OutOfMemoryError:PermGen space”</p><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p><ul><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p><h2 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h2><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而ful1gc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h2 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h2><p>静态引用对应的对象实体始终都存在堆空间</p><p>可以使用 jhsdb.ext，需要在jdk9的时候才引入的</p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。<br><img src="/images/2020/08/20200828000409.png" alt><br>测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：只要是对象实例必然会在Java堆中分配。</p><p>接着，找到了一个引用该staticobj对象的地方，是在一个java.1ang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：<br><img src="/images/2020/08/20200828000429.png" alt><br>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射class对象存放在一起，存储于Java堆之中，从我们的实验中也明确验证了这一点</p><h1 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h1><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的zGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/images/2020/08/20200828000510.png" alt></p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p>百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配</p><p>小米： jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动： 二面：Java的内存分区 二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？</p><p>京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改</p><p>拼多多： JVM内存分哪几个区，每个区的作用是什么？</p><p>美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？</p>]]></content>
    
    <summary type="html">
    
      方法区
    
    </summary>
    
      <category term="Java" scheme="https://zjinc36.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://zjinc36.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>解决Github-Page无法访问的其中一种情况</title>
    <link href="https://zjinc36.github.io/2020/08/26/%E8%A7%A3%E5%86%B3Github-Page%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>https://zjinc36.github.io/2020/08/26/解决Github-Page无法访问的其中一种情况/</id>
    <published>2020-08-26T12:56:43.000Z</published>
    <updated>2020-08-26T05:16:57.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改ip"><a href="#修改ip" class="headerlink" title="修改ip"></a>修改ip</h1><p>网上很多帖子,但是我修改之后无效</p><h1 id="修改dns服务器"><a href="#修改dns服务器" class="headerlink" title="修改dns服务器"></a>修改dns服务器</h1><ol><li>查看域名指向哪里<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup github.io</span><br></pre></td></tr></table></figure></li></ol><p>我本地如下,指向了127.0.0.1,所以确认是需要修改dns服务器地址了<br><img src="/images/2020/08/20200826130349.png" alt></p><ol start="2"><li>修改dns服务器地址<br>修改文件 /etc/resolvconf/resolv.conf.d/head（这个文件默认为空），添加以下内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure></li></ol><p>执行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvconf -u</span><br></pre></td></tr></table></figure><p>通过 /etc/resolv.conf 查看 DNS 设置,可看到多了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>此时nslookup可以看到如下<br><img src="/images/2020/08/20200826130600.png" alt><br>然后能成功访问<br><img src="/images/2020/08/20200826130832.png" alt></p>]]></content>
    
    <summary type="html">
    
      解决Github-Page无法访问的其中一种情况
    
    </summary>
    
      <category term="未分类" scheme="https://zjinc36.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu中修改DNS的方法</title>
    <link href="https://zjinc36.github.io/2020/08/26/Ubuntu%E4%B8%AD%E4%BF%AE%E6%94%B9DNS%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://zjinc36.github.io/2020/08/26/Ubuntu中修改DNS的方法/</id>
    <published>2020-08-26T12:43:41.000Z</published>
    <updated>2020-08-26T04:53:47.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改DNS的方法"><a href="#修改DNS的方法" class="headerlink" title="修改DNS的方法"></a>修改DNS的方法</h1><p>修改文件 <code>/etc/resolvconf/resolv.conf.d/head</code>（这个文件默认为空），添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>:wq 保存退出</p><p>执行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvconf -u</span><br></pre></td></tr></table></figure><p>通过 <code>/etc/resolv.conf</code> 查看 DNS 设置:</p><p>可看到多了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><h1 id="etc-resolv-conf基本说明"><a href="#etc-resolv-conf基本说明" class="headerlink" title="/etc/resolv.conf基本说明"></a>/etc/resolv.conf基本说明</h1><p>/etc/resolv.conf是DNS名称解析器库的主要配置文件。</p><p>解析程序是C库中的一组函数，提供对Internet域名系统 （ DNS ）的访问。 这些功能被配置为检查/etc/hosts文件或多个DNSNameservers中的条目，或者使用主机的网络信息服务 （ NIS ）数据库。</p><p>在使用systemd（系统和服务管理器）的现代Linux系统上，DNS或名称解析服务通过systemd解析的服务提供给本地应用程序。</p><p>默认情况下，此服务具有四种用于处理域名解析的模式，并在默认操作模式下使用systemd DNS存根文件（ /run/systemd/resolve/stub-resolv.conf ）。</p><p>DNS存根文件包含本地存根127.0.0.53作为唯一的DNS服务器，并且重定向到/etc/resolv.conf文件，该文件用于添加系统使用的Nameservers。</p><p>如果在/etc/resolv.conf上运行以下ls命令 ，您将看到该文件是/run/systemd/resolve/stub-resolv.conf文件的符号链接。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l /etc/resolv.conf</span></span><br><span class="line">lrwxrwxrwx 1 root root 39 Feb 15  2019 /etc/resolv.conf -&gt; ../run/systemd/resolve/stub-resolv.conf</span><br></pre></td></tr></table></figure><p>不幸的是，由于/etc/resolv.conf是由systemd解析的服务间接管理的，在某些情况下是由网络服务（通过使用initscripts或NetworkManager ）间接管理的，因此，用户手动进行的任何更改都无法永久保存或仅保存持续一会儿。</p><h1 id="为什么要修改-etc-resolv-conf文件？"><a href="#为什么要修改-etc-resolv-conf文件？" class="headerlink" title="为什么要修改 /etc/resolv.conf文件？"></a>为什么要修改 /etc/resolv.conf文件？</h1><p>主要原因可能是因为系统DNS设置配置错误，或者您更喜欢使用特定的Nameservers或您自己的Nameservers。 以下cat命令在我的Ubuntu系统上的/etc/resolv.conf文件中显示默认Nameservers。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf</span><br></pre></td></tr></table></figure><p><img src="/images/2020/08/20200826124922.png" alt></p><h2 id="检查DNSNameservers"><a href="#检查DNSNameservers" class="headerlink" title="检查DNSNameservers"></a>检查DNSNameservers</h2><p>在这种情况下，当APT程序包管理器之类的本地应用程序尝试访问本地网络上的FQDN （ 完全合格的域名 ）时，结果是“ 名称解析临时失败 ”错误，如下图所示。<br><img src="/images/2020/08/20200826125005.png" alt></p><h2 id="临时故障解决"><a href="#临时故障解决" class="headerlink" title="临时故障解决"></a>临时故障解决</h2><p>当您运行ping命令时，也会发生同样的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping google.com</span><br></pre></td></tr></table></figure><p><img src="/images/2020/08/20200826125029.png" alt></p><p>名称解析暂时失败</p><p>因此，当用户尝试手动设置Nameservers时，更改不会持续很长时间，也不会在重新启动后被撤销。 要解决此问题，您可以安装并使用reolvconf实用程序使更改永久生效 。</p><p>要安装下一部分中所示的resolvconf软件包，首先需要在/etc/resolv.conf文件中手动设置以下Nameservers，以便在Internet上访问Ubuntu仓库服务器的FQDM。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.4.4</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><h1 id="在Ubuntu和Debian中安装resolvconf"><a href="#在Ubuntu和Debian中安装resolvconf" class="headerlink" title="在Ubuntu和Debian中安装resolvconf"></a>在Ubuntu和Debian中安装resolvconf</h1><p>首先，更新系统软件包，然后通过运行以下命令从官方系统信息库安装resolvconf 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install resolvconf</span><br></pre></td></tr></table></figure><p>一旦resolvconf安装完成， systemd将触发resolvconf.service自动启动和启用。 要检查它是否已启动并正在运行，请发出以下命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status resolvconf.service</span><br></pre></td></tr></table></figure><p>如果由于某种原因未启动并自动启用该服务，则可以按以下步骤启动并启用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start resolvconf.service</span><br><span class="line">$ sudo systemctl enable resolvconf.service</span><br><span class="line">$ sudo systemctl status resolvconf.service</span><br></pre></td></tr></table></figure><h1 id="在Ubuntu和Debian中设置永久DNSNameservers"><a href="#在Ubuntu和Debian中设置永久DNSNameservers" class="headerlink" title="在Ubuntu和Debian中设置永久DNSNameservers"></a>在Ubuntu和Debian中设置永久DNSNameservers</h1><p>接下来，打开/etc/resolvconf/resolv.conf.d/head配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo nano /etc/resolvconf/resolv.conf.d/head</span><br></pre></td></tr></table></figure><p>并在其中添加以下几行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8 </span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure><p><img src="/images/2020/08/20200826125154.png" alt></p><p>在Resolvconf中设置永久DNSNameservers</p><p>保存更改，然后重新启动resolvconf.service或重新引导系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start resolvconf.service</span><br></pre></td></tr></table></figure><p>现在，当您检查/etc/resolv.conf文件时，Nameservers条目应永久存储在此处。 从今以后，您将不会在系统上遇到任何有关名称解析的问题<br><img src="/images/2020/08/20200826125212.png" alt><br>永久DNSNameservers</p>]]></content>
    
    <summary type="html">
    
      Ubuntu中修改DNS的方法
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Linux命令" scheme="https://zjinc36.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Nslookup命令-查DNS信息用</title>
    <link href="https://zjinc36.github.io/2020/08/26/nslookup%E5%91%BD%E4%BB%A4-%E6%9F%A5DNS%E4%BF%A1%E6%81%AF%E7%94%A8/"/>
    <id>https://zjinc36.github.io/2020/08/26/nslookup命令-查DNS信息用/</id>
    <published>2020-08-26T12:35:29.000Z</published>
    <updated>2020-08-26T04:55:14.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h1><p> nslookup命令是常用域名查询工具，就是查DNS信息用的命令。</p><p>nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。</p><p>进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>nslookup(选项)(参数)</p><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><ul><li>-sil：不显示任何警告信息。</li></ul><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>域名：指定要查询域名。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nslookup www.linuxde.net</span><br><span class="line">Server:         202.96.104.15</span><br><span class="line">Address:        202.96.104.15#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.linuxde.net canonical name = host.1.linuxde.net.</span><br><span class="line">Name:   host.1.linuxde.net</span><br><span class="line">Address: 100.42.212.8</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.howtoing.com/set-permanent-dns-nameservers-in-ubuntu-debian" target="_blank" rel="noopener">如何在Ubuntu和Debian中设置永久DNSNameservers</a></li><li><a href="https://www.runoob.com/w3cnote/ubuntu-modify-dns.html" target="_blank" rel="noopener">ubuntu 修改 DNS 的方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      nslookup命令-查DNS信息用
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Linux命令" scheme="https://zjinc36.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04中安装flameshot截屏工具</title>
    <link href="https://zjinc36.github.io/2020/08/02/Ubuntu20-04%E4%B8%AD%E5%AE%89%E8%A3%85flameshot%E6%88%AA%E5%B1%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://zjinc36.github.io/2020/08/02/Ubuntu20-04中安装flameshot截屏工具/</id>
    <published>2020-08-01T23:27:28.000Z</published>
    <updated>2020-08-02T04:56:22.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>截图工具，可添加文字、箭头等</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在软件商店里有，直接搜索软件名<code>flameshot</code>安装就行</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/images/2020/08/20200802125316.png" alt></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>←、↓、↑、→</td><td>移动选择区域 1px</td></tr><tr><td>Shift + ←、↓、↑、→</td><td>将选择区域大小更改 1px</td></tr><tr><td>Esc</td><td>退出截图</td></tr><tr><td>Ctrl + C</td><td>复制到粘贴板</td></tr><tr><td>Ctrl + S</td><td>将选择区域保存为文件</td></tr><tr><td>Ctrl + Z</td><td>撤销最近的一次操作</td></tr><tr><td>鼠标右键</td><td>展示颜色拾取器</td></tr><tr><td>鼠标滚轮</td><td>改变工具的宽度</td></tr></tbody></table><p>边按住 Shift 键并拖动选择区域的其中一个控制点将会对它相反方向的控制点做类似的拖放操作。</p><h2 id="Flameshot-命令行选项"><a href="#Flameshot-命令行选项" class="headerlink" title="Flameshot 命令行选项"></a>Flameshot 命令行选项</h2><p>Flameshot 支持一系列的命令行选项来延时截图和保存图片到自定义的路径。</p><p>要使用 Flameshot GUI 模式，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui</span><br></pre></td></tr></table></figure><p>要使用 GUI 模式截屏并将你选取的区域保存到一个自定义的路径，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui -p ~/myStuff/captures</span><br></pre></td></tr></table></figure><p>要延时 2 秒后打开 GUI 模式可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot gui -d 2000</span><br></pre></td></tr></table></figure><p>要延时 2 秒并将截图保存到一个自定义的路径（无 GUI）可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot full -p ~/myStuff/captures -d 2000</span><br></pre></td></tr></table></figure><p>要截图全屏并保存到自定义的路径和粘贴板中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot full -c -p ~/myStuff/captures</span><br></pre></td></tr></table></figure><p>要在截屏中包含鼠标并将图片保存为 PNG 格式可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot screen -r</span><br></pre></td></tr></table></figure><p>要对屏幕 1 进行截屏并将截屏复制到粘贴板中可以运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flameshot screen -n 1 -c</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/20fc667279ea" target="_blank" rel="noopener">Linux中的截图工具 - Flameshot</a><br><a href="https://www.sinocalife.com/ubuntu-20-04-screenshot-trident-tools-gnome-screenshot-flameshot-shutter" target="_blank" rel="noopener">Ubuntu 20.04 截图软件的使用 (gnome-screenshot、flameshot、shutter 截图编辑三叉戟)</a></p>]]></content>
    
    <summary type="html">
    
      截图工具，可添加文字、箭头等
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu刷新DNS</title>
    <link href="https://zjinc36.github.io/2020/07/31/Ubuntu%E5%88%B7%E6%96%B0DNS/"/>
    <id>https://zjinc36.github.io/2020/07/31/Ubuntu刷新DNS/</id>
    <published>2020-07-31T09:59:24.000Z</published>
    <updated>2020-07-31T02:03:00.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方式一-刷新DNS"><a href="#方式一-刷新DNS" class="headerlink" title="方式一:刷新DNS"></a>方式一:刷新DNS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/nscd restart</span><br></pre></td></tr></table></figure><p>如果发现提示命令找不到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo: /etc/init.d/nscd: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><p>需要先安装nscd包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nscd</span><br></pre></td></tr></table></figure><h1 id="方式二-重启网络刷dns"><a href="#方式二-重启网络刷dns" class="headerlink" title="方式二:重启网络刷dns"></a>方式二:重启网络刷dns</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu设置开机自动加/挂载硬盘
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu配置" scheme="https://zjinc36.github.io/tags/Ubuntu%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>循环冗余校验（CRC）算法</title>
    <link href="https://zjinc36.github.io/2020/07/28/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%EF%BC%88CRC%EF%BC%89%E7%AE%97%E6%B3%95/"/>
    <id>https://zjinc36.github.io/2020/07/28/循环冗余校验（CRC）算法/</id>
    <published>2020-07-27T22:39:14.000Z</published>
    <updated>2020-07-27T15:27:52.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.zhihu.com/question/20303082/answer/158430490" target="_blank" rel="noopener">知乎:https://www.zhihu.com/question/20303082/answer/158430490 – 作者：红猴子</a></li><li><a href="https://blog.csdn.net/liyuanbhu/article/details/7882789" target="_blank" rel="noopener">循环冗余校验（CRC）算法入门引导</a></li></ol><h1 id="从奇偶校验说起"><a href="#从奇偶校验说起" class="headerlink" title="从奇偶校验说起"></a>从奇偶校验说起</h1><p>所谓通讯过程的校验是指在通讯数据后加上一些附加信息，通过这些附加信息来判断接收到的数据是否和发送出的数据相同。比如说RS232串行通讯可以设置奇偶校验位，所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个。比如我们要发送的字节是0x1a，二进制表示为0001 1010。</p><p>采用奇校验，则在数据后补上个0，数据变为0001 1010 0，数据中1的个数为奇数个（3个）</p><p>采用偶校验，则在数据后补上个1，数据变为0001 1010 1，数据中1的个数为偶数个（4个）</p><p>接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错。</p><p>奇偶校验的缺点也很明显，首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大。因此，在高速数据通讯中很少采用奇偶校验。奇偶校验优点也很明显，它很简单，因此可以用硬件来实现，这样可以减少软件的负担。因此，奇偶校验也被广泛的应用着。</p><p>奇偶校验就先介绍到这来，之所以从奇偶校验说起，是因为这种校验方式最简单，而且后面将会知道奇偶校验其实就是CRC 校验的一种(CRC-1)。</p><h1 id="累加和校验"><a href="#累加和校验" class="headerlink" title="累加和校验"></a>累加和校验</h1><p>另一种常见的校验方式是累加和校验。所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后加入一个字节的校验数据。这个字节内容为前面数据包中全部数据的忽略进位的按字节累加和。比如下面的例子：</p><p>我们要传输的信息为： 6、23、4</p><p>加上校验和后的数据包：6、23、4、33</p><p>这里 33 为前三个字节的校验和。接收方收到全部数据后对前三个数据进行同样的累加计算，如果累加和与最后一个字节相同的话就认为传输的数据没有错误。</p><p>累加和校验由于实现起来非常简单，也被广泛的采用。但是这种校验方式的检错能力也比较一般，对于单字节的校验和大概有1/256 的概率将原本是错误的通讯数据误判为正确数据。之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节）</p><h1 id="CRC-Cyclic-Redundancy-算法"><a href="#CRC-Cyclic-Redundancy-算法" class="headerlink" title="CRC(Cyclic Redundancy )算法"></a>CRC(Cyclic Redundancy )算法</h1><p>CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面<br><img src="/images/2020/07/20200727006.png" alt></p><h2 id="发送端计算CRC的过程"><a href="#发送端计算CRC的过程" class="headerlink" title="发送端计算CRC的过程"></a>发送端计算CRC的过程</h2><ul><li>为什么添加4个0后面说明</li><li>什么是生成多项式后面说明</li><li>为什么是XOR后面说明</li></ul><p><img src="/images/2020/07/20200727002.png" alt></p><h2 id="验证码串是否正确"><a href="#验证码串是否正确" class="headerlink" title="验证码串是否正确"></a>验证码串是否正确</h2><p><img src="/images/2020/07/20200727004.png" alt></p><h1 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h1><p>比如说我们有两个二进制数，分别为：1101 和1011。</p><p>1101 与如下的多项式相联系：<br><img src="/images/2020/07/20200727008.png" alt></p><p>1011与如下的多项式相联系：<br><img src="/images/2020/07/20200727009.png" alt></p><p>两个多项式的乘法：<br><img src="/images/2020/07/20200727007.png" alt></p><p>得到结果后，<strong>合并同类项时采用模2运算</strong>。也就是说乘除法采用正常的多项式乘除法，而加减法都采用模2运算。所谓模2运算就是结果除以2后取余数。比如3 mod 2 = 1。<br>因此，上面最终得到的多项式为：<br><img src="/images/2020/07/20200727010.png" alt><br>对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明)</p><p>加减法采用模2运算后其实就成了一种运算了，就是我们通常所说的异或运算：</p><table><thead><tr><th>异或加法</th><th>异或减法</th></tr></thead><tbody><tr><td>0+0=0</td><td>0-0=0</td></tr><tr><td>0+1=1</td><td>1-0=1</td></tr><tr><td>1+0=1</td><td>0-1=1</td></tr><tr><td>1+1=0</td><td>1-1=0</td></tr></tbody></table><p>采用了模2的加减法后，不需要考虑借位的问题，所以除法变简单了。最后得到的余数就是CRC 校验字。为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“生成多项式”。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。好在这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了。</p><p>最常用的几种生成多项式如下：<br><img src="/images/2020/07/20200727005.png" alt></p><h2 id="什么是位宽"><a href="#什么是位宽" class="headerlink" title="什么是位宽"></a>什么是位宽</h2><p>文献中提到的生成多项式经常会说到多项式的位宽（Width，简记为W），这个<strong>位宽不是多项式对应的二进制数的位数，而是位数减1</strong>。</p><p>比如CRC8中用到的位宽为8的生成多项式，其实对应得二进制数有九位：100110001。另外一点，多项式表示和二进制表示都很繁琐，交流起来不方便，因此，文献中多用16进制简写法来表示，因为生成多项式的最高位肯定为1，最高位的位置由位宽可知，<strong>故在简记式中，将最高的1统一去掉了</strong>，如CRC32的生成多项式简记为04C11DB7实际上表示的是104C11DB7。当然，这样简记除了方便外，在编程计算时也有它的用处。</p><h2 id="为什么理论上有7个1但只写了6个"><a href="#为什么理论上有7个1但只写了6个" class="headerlink" title="为什么理论上有7个1但只写了6个"></a>为什么理论上有7个1但只写了6个</h2><ul><li>对于<strong>对应的二进制数:111111 (注意:这里理论上要有7个1,但这里只写了6个1,去掉的是最高位的1,原因在后面会说明)</strong>的例子，是将最高的1统一去掉了</li></ul><h2 id="为什么需要补4个0"><a href="#为什么需要补4个0" class="headerlink" title="为什么需要补4个0"></a>为什么需要补4个0</h2><ul><li>对于<strong>发送端计算CRC的过程</strong>的例子，除数是5位数10011，也就是位宽为4（W=4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0。</li></ul><h2 id="奇偶校验与生成多项式的关系"><a href="#奇偶校验与生成多项式的关系" class="headerlink" title="奇偶校验与生成多项式的关系"></a>奇偶校验与生成多项式的关系</h2><p>位宽W=1的生成多项式(CRC1)有两种，分别是X^1和X^1+X^0，读者可以自己证明10 对应的就是奇偶校验中的奇校验，而11对应则是偶校验。因此，写到这里我们知道了奇偶校验其实就是CRC校验的一种特例，这也是我要以奇偶校验作为开篇介绍的原因了。</p>]]></content>
    
    <summary type="html">
    
      循环冗余校验（CRC）算法
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://zjinc36.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu中Rime输入法的安装和配置</title>
    <link href="https://zjinc36.github.io/2020/07/26/ubuntu%E4%B8%ADRime%E8%BE%93%E5%85%A5%E6%B3%95%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://zjinc36.github.io/2020/07/26/ubuntu中Rime输入法的安装和配置/</id>
    <published>2020-07-26T12:24:13.000Z</published>
    <updated>2020-07-26T04:36:51.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官方网站及文档"><a href="#官方网站及文档" class="headerlink" title="官方网站及文档"></a>官方网站及文档</h1><p><a href="https://rime.im/" target="_blank" rel="noopener">https://rime.im/</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ibus-rime</span><br></pre></td></tr></table></figure></li><li><p>添加Rime输入法<br><img src="/images/2020/07/20200724004.png" alt></p></li></ol><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>Rime的配置是没有界面的</li><li>根据个人喜好修改配置文件：一般用户直接修改<code>default.yaml</code>即可。修改前最好备份一下<ul><li>网上有很多高端教程要大家创建<code>default.custom.yaml</code>，是因为rime升级的时候貌似会进行覆盖操作</li><li>但我实践中还是认为找个地方记下来才靠谱，这种基础配置，除非系统爆炸，否则不会再打开第二次的。增加<code>default.custom.yaml</code>，以后看到反而更容易出现混乱。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.config/ibus/rime/default.yaml</span><br></pre></td></tr></table></figure><p>如下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">schema_list:</span>   </span><br><span class="line"><span class="attr">  - schema:</span> <span class="string">luna_pinyin_simp</span> <span class="comment">#simp是简体，第一位是默认输入法 </span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  page_size:</span> <span class="number">7</span> <span class="comment">#每页候选词个数</span></span><br><span class="line"><span class="attr">ascii_composer:</span></span><br><span class="line"><span class="attr">  switch_key:</span></span><br><span class="line"><span class="attr">    Shift_L:</span> <span class="string">commit_code</span> <span class="comment">#左shift提交字母</span></span><br></pre></td></tr></table></figure><p>修改完之后重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus restart</span><br></pre></td></tr></table></figure><h1 id="修改候选字的大小"><a href="#修改候选字的大小" class="headerlink" title="修改候选字的大小"></a>修改候选字的大小</h1><ul><li>安装gnome的插件<code>ibus font setting</code></li><li>地址：<a href="https://extensions.gnome.org/extension/1121/ibus-font-setting/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/1121/ibus-font-setting/</a></li></ul>]]></content>
    
    <summary type="html">
    
      ubuntu中Rime输入法的安装和配置
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu18.04中ibus-Sunpinyin的安装与设置</title>
    <link href="https://zjinc36.github.io/2020/07/26/Ubuntu18.04%E4%B8%ADibus-sunpinyin%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
    <id>https://zjinc36.github.io/2020/07/26/Ubuntu18.04中ibus-sunpinyin的安装与设置/</id>
    <published>2020-07-26T11:43:09.000Z</published>
    <updated>2020-07-26T04:55:52.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-sunpinyin</span><br></pre></td></tr></table></figure><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><ol><li>配置<br>终端输入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus-setup</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/2020/07/20200726002.png" alt></p><ol start="2"><li>在设置中添加sun-pinyin输入法<br><img src="/images/2020/07/20200726001.png" alt></li></ol><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p><img src="/images/2020/07/20200726004.png" alt></p><h2 id="有可能打不开-问题如下"><a href="#有可能打不开-问题如下" class="headerlink" title="有可能打不开(问题如下)"></a>有可能打不开(问题如下)</h2><ol><li>ubuntu18.04安装了ibus-pinyin, 选用了sunpinyin，但是无法调出sunpinyin的设置窗口。</li><li>当通过命令/usr/lib/ibus/ibus-setup-sunpinyin时，出现如下错误：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/share//ibus-sunpinyin/setup/main.py"</span>, line <span class="number">42</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> ibus</span><br><span class="line">ImportError: No module named ibus</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>需要安装python-ibus，到 <a href="https://launchpad.net/ubuntu/trusty/amd64/python-ibus/1.5.5-1ubuntu3.2" target="_blank" rel="noopener">https://launchpad.net/ubuntu/trusty/amd64/python-ibus/1.5.5-1ubuntu3.2</a> 下载<code>python-ibus_1.5.5-1ubuntu3.2_all.deb</code>安装包，通过命令安装即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo gdebi python-ibus_1.5.5-1ubuntu3.2_all.deb</span><br><span class="line"></span><br><span class="line"><span class="comment">#   如果没有gdebi命令,用如下命令安装</span></span><br><span class="line">sudo apt-get install gdebi</span><br></pre></td></tr></table></figure><h1 id="修改候选字的大小"><a href="#修改候选字的大小" class="headerlink" title="修改候选字的大小"></a>修改候选字的大小</h1><ul><li>安装gnome的插件<code>ibus font setting</code></li><li>地址：<a href="https://extensions.gnome.org/extension/1121/ibus-font-setting/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/1121/ibus-font-setting/</a></li></ul><h1 id="如果配置没有生效"><a href="#如果配置没有生效" class="headerlink" title="如果配置没有生效"></a>如果配置没有生效</h1><ol><li><p>遇事不决先重启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibus restart</span><br></pre></td></tr></table></figure></li><li><p>注销系统重新登录</p></li></ol>]]></content>
    
    <summary type="html">
    
      ubuntu18.04中ibus-sunpinyin的安装与设置
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu配置" scheme="https://zjinc36.github.io/tags/Ubuntu%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu设置开机自动加/挂载硬盘</title>
    <link href="https://zjinc36.github.io/2020/07/25/Ubuntu%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%8A%A0-%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"/>
    <id>https://zjinc36.github.io/2020/07/25/Ubuntu设置开机自动加-挂载硬盘/</id>
    <published>2020-07-24T18:28:39.000Z</published>
    <updated>2020-07-24T11:00:28.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找到要挂载的磁盘的名称"><a href="#找到要挂载的磁盘的名称" class="headerlink" title="找到要挂载的磁盘的名称"></a>找到要挂载的磁盘的名称</h1><p><img src="/images/2020/07/20200724001.png" alt></p><h1 id="查看磁盘的分区UUID"><a href="#查看磁盘的分区UUID" class="headerlink" title="查看磁盘的分区UUID"></a>查看磁盘的分区UUID</h1><ol><li>新打开一个终端：sudo blkid </li><li>找到分区的UUID与tpye<br><img src="/images/2020/07/20200724003.png" alt></li></ol><h1 id="在-etc-fstab中添加"><a href="#在-etc-fstab中添加" class="headerlink" title="在/etc/fstab中添加"></a>在/etc/fstab中添加</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/fstab: static file system information.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use 'blkid' to print the universally unique identifier for a</span></span><br><span class="line"><span class="comment"># device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="comment"># that works even if disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span><br><span class="line"><span class="comment"># # &lt;file system&gt; 磁盘设备名或该设备的Label</span></span><br><span class="line"><span class="comment"># # &lt;mount point&gt; 挂载点（目录）</span></span><br><span class="line"><span class="comment"># # &lt;type&gt; 磁盘分区的文件系统</span></span><br><span class="line"><span class="comment"># # &lt;options&gt; 文件系统参数</span></span><br><span class="line"><span class="comment"># # &lt;dump&gt; 能否被dump命令作用</span></span><br><span class="line"><span class="comment"># # &lt;pass&gt; 是否以fsck检测扇区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># / was on /dev/nvme0n1p5 during installation</span></span><br><span class="line">UUID=81ae4ddb-7784-45bf-b770-47cb89c85aca /               ext4    errors=remount-ro 0       1</span><br><span class="line"><span class="comment"># /boot/efi was on /dev/nvme0n1p1 during installation</span></span><br><span class="line">UUID=3024-823F  /boot/efi       vfat    <span class="built_in">umask</span>=0077      0       1</span><br><span class="line"><span class="comment"># swap was on /dev/nvme0n1p6 during installation</span></span><br><span class="line">UUID=7b9777a0-d735-4c9e-b6ba-109ffce567c2 none            swap    sw              0       0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制前面的</span></span><br><span class="line"><span class="comment"># UUID=81ae4ddb-7784-45bf-b770-47cb89c85aca /               ext4    errors=remount-ro 0       1</span></span><br><span class="line"><span class="comment"># 将UUID改为前面得到的UUID</span></span><br><span class="line"><span class="comment"># 把/改为/media/zjc/otherDocuments</span></span><br><span class="line"><span class="comment"># 把errors=remount-ro改为defaults</span></span><br><span class="line"><span class="comment"># 后面的1改0</span></span><br><span class="line">UUID=EC9CB4199CB3DBF0 /media/zjc/otherDocuments               ntfs    defaults 0       1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu设置开机自动加/挂载硬盘
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04如何固定图标到任务栏</title>
    <link href="https://zjinc36.github.io/2020/07/18/Ubuntu18-04%E5%A6%82%E4%BD%95%E5%9B%BA%E5%AE%9A%E5%9B%BE%E6%A0%87%E5%88%B0%E4%BB%BB%E5%8A%A1%E6%A0%8F/"/>
    <id>https://zjinc36.github.io/2020/07/18/Ubuntu18-04如何固定图标到任务栏/</id>
    <published>2020-07-18T14:53:24.000Z</published>
    <updated>2020-07-18T07:15:21.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/applications/softName.desktop</span><br><span class="line">或者</span><br><span class="line">sudo vim ~/.local/share/applications/softName.desktop</span><br></pre></td></tr></table></figure><ul><li>softName就是添加快捷方式的名称，也就是软件的名称</li></ul><p>添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">#!/usr/bin/env xdg-open</span><br><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">Name=</span><br><span class="line">Exec=</span><br><span class="line">Icon=</span><br><span class="line">NoDisplay=false</span><br><span class="line">StartupWMClass=</span><br></pre></td></tr></table></figure><p><img src="/images/2020/07/20200701006.png" alt></p><p>说明</p><ul><li>[Desktop Entry] 每个desktop文件都以这个标签开始，说明这是一个Desktop Entry文件</li><li>Version = 1.0 标明Desktop Entry的版本（可选）</li><li>Name = IdeaIU 程序名称（必须），这里以创建一个idea的快捷方式为例</li><li>GenericName = IdeaIU 程序通用名称（可选）</li><li>Comment =IdeaIU 程序描述（可选）</li><li>Exec = 程序的启动命令（必选），可以带参数运行</li><li>Icon = 设置快捷方式的图标（可选），当Type为Application，此项有效</li><li>Terminal = false 是否在终端中运行（可选），当Type为Application，此项有效</li><li>Type = Application desktop的类型（必选），常见值有“Application”和“Link”</li><li>Categories = GNOME;Application;Network; //注明在菜单栏中显示的类别（可选）</li></ul><h1 id="将图标放到任务栏"><a href="#将图标放到任务栏" class="headerlink" title="将图标放到任务栏"></a>将图标放到任务栏</h1><p>点击应用按钮，把刚生成的应用图标拖到任务栏中<br><img src="/images/2020/07/20200701003.png" alt></p><p>但是有可能会出现启动应用出现双图标,如下<br><img src="/images/2020/07/20200701004.png" alt></p><p>为了解决这个问题，首先打开应用，然后在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xprop |grep WM_CLASS</span><br></pre></td></tr></table></figure><p>此时鼠标指针会变成一个十字准心，点击已经打开的软件界面，终端会反馈一条信息，包括2个字符串<br><img src="/images/2020/07/20200701005.png" alt><br>把第1个字符串里的内容添加到StartupWMClass里，保存，关闭应用重新打开，将不会出现双图标的情况了</p>]]></content>
    
    <summary type="html">
    
      Ubuntu18.04如何固定图标到任务栏
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中批量下载bilibili网站的视频</title>
    <link href="https://zjinc36.github.io/2020/07/11/Ubuntu%E4%B8%AD%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDbilibili%E7%BD%91%E7%AB%99%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    <id>https://zjinc36.github.io/2020/07/11/Ubuntu中批量下载bilibili网站的视频/</id>
    <published>2020-07-11T11:50:44.000Z</published>
    <updated>2020-08-19T03:37:39.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方案一-you-get"><a href="#方案一-you-get" class="headerlink" title="方案一:you-get"></a>方案一:you-get</h1><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">Github地址:https://github.com/soimort/you-get</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install you-get #安装You-Get</span><br><span class="line">pip3 install --upgrade you-get #升级You-Get</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you-get --playlist -o ./ https://www.bilibili.com/video/视频地址\?p\=1</span><br></pre></td></tr></table></figure><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><h2 id="项目地址-1"><a href="#项目地址-1" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/Henryhaohao/Bilibili_video_download" target="_blank" rel="noopener">Github地址:https://github.com/Henryhaohao/Bilibili_video_download</a></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li>将项目克隆到本地</li><li>运行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python /your/address/bilibili_video_download.py</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Ubuntu中批量下载bilibili网站的视频
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装分区管理工具gparted</title>
    <link href="https://zjinc36.github.io/2020/07/08/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7gparted/"/>
    <id>https://zjinc36.github.io/2020/07/08/Ubuntu中安装分区管理工具gparted/</id>
    <published>2020-07-08T15:16:44.000Z</published>
    <updated>2020-07-08T07:21:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li><a href="https://gparted.org/index.php" target="_blank" rel="noopener">官网</a></li><li>GNOME Partition Editor,分区管理工具</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><p><a href="https://gparted.org/download.php" target="_blank" rel="noopener">https://gparted.org/download.php</a></p></li><li><p>Ubuntu安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure></li><li><p>主界面<br><img src="/images/2020/07/20200708001.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装分区管理工具gparted
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中基于Docker安装QQ和WeChat</title>
    <link href="https://zjinc36.github.io/2020/07/08/Ubuntu%E4%B8%AD%E5%9F%BA%E4%BA%8EDocker%E5%AE%89%E8%A3%85QQ%E5%92%8CWeChat/"/>
    <id>https://zjinc36.github.io/2020/07/08/Ubuntu中基于Docker安装QQ和WeChat/</id>
    <published>2020-07-08T14:30:14.000Z</published>
    <updated>2020-07-08T06:34:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github上有这两个项目"><a href="#github上有这两个项目" class="headerlink" title="github上有这两个项目"></a>github上有这两个项目</h1><ul><li><a href="https://github.com/bestwu/docker-wechat" target="_blank" rel="noopener">https://github.com/bestwu/docker-wechat</a></li><li><a href="https://github.com/bestwu/docker-qq" target="_blank" rel="noopener">https://github.com/bestwu/docker-qq</a></li></ul><h1 id="有个管理脚本脚本"><a href="#有个管理脚本脚本" class="headerlink" title="有个管理脚本脚本"></a>有个管理脚本脚本</h1><ul><li><a href="https://github.com/ygcaicn/ubuntu_qq" target="_blank" rel="noopener">https://github.com/ygcaicn/ubuntu_qq</a></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装离线API文档大全Zeal
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装桌面搜索应用DocFetcher</title>
    <link href="https://zjinc36.github.io/2020/07/07/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E6%A1%8C%E9%9D%A2%E6%90%9C%E7%B4%A2%E5%BA%94%E7%94%A8DocFetcher/"/>
    <id>https://zjinc36.github.io/2020/07/07/Ubuntu中安装桌面搜索应用DocFetcher/</id>
    <published>2020-07-07T08:15:49.000Z</published>
    <updated>2020-07-07T00:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>DocFetcher 是一个使用 Java 语言开发的开源桌面搜索应用程序<ul><li>能搜索docx和pdf的内容</li></ul></li></ul><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Windows，Linux 和 OS X</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>基于java,所以需要运行环境：Java Runtime Environment（JRE）1.7 +</li><li>参考官网说明:<a href="http://docfetcher.sourceforge.net/en/download.html" target="_blank" rel="noopener">http://docfetcher.sourceforge.net/en/download.html</a></li></ol><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p>为了快速的进行文本检索，DocFetcher 在检索文档文本前需要建立索引，用户可以根据需要为文件夹或者整个磁盘建立索引，当然，仅仅在第一次检索时需要为所要检索的文件夹或磁盘建立索引，建立索引后，当文件内容发生了变化 DocFetcher 会自动更新索引。以下是建立索引的详细方法：</p><ol><li><p>如图所示，右击[搜索范围]框的空白处，选择弹出菜单中的[建立索引 - 资料夹]。<br><img src="/images/2020/07/20200707003.png" alt></p></li><li><p>在弹出的选择窗口中选择需要检索文档的位置，点击[确认]。<br><img src="/images/2020/07/20200707004.png" alt></p></li><li><p>在弹出的窗口中可以对索引的细节进行设置，可以选择所要检索的文件格式，在排除列表中可以使用正则表达式过滤不需要建立索引的文件和文件格式，其他选项没有特殊要求使用默认值即可。最后选择[执行]，将开始建立索引。<br><img src="/images/2020/07/20200707005.png" alt></p></li><li><p>建立索引的过程耗时较长，具体时间取决于所选建立索引的文件夹中包含的文件数量及文件大小。索引建立完成后在首页的[搜索范围]框内便有了对应的目录。</p></li></ol><h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><p>对于建立好索引的目录，可以通过勾选检索目录、勾选文件类型、设定文件大小、输入关键字来进行文本检索，这里仅对 DocFetcher 的检索语法做简单介绍，详细内容请参照官方文档。</p><ul><li>短语搜索：需要将所要检索的短语放入英文双引号内。如 ：”可转债”，返回包含词语”可转债”的文件；</li><li>布尔运算：支持复杂条件的检索，常用运算符包含 AND、OR 、NOT 等，短语间没有运算符时将默认使用 OR。如 “可转债” AND “可交换债”，返回既包含短语”可转债”又包含短语”可交换债”的文件；</li><li>通配符：问号（’?’）和星号（’<em>‘）可用于表示某些字符未知。如 ：”可”</em>，返回包含”可以”、”可转债”、”可交换债”等包含以”可”开头的语句的文件；</li><li>模糊搜索：可以搜索与给定单词类似的单词。如，roam~，返回包含 foam 和的单词的文档 roams 的文件。</li></ul><h3 id="检索关键字格式"><a href="#检索关键字格式" class="headerlink" title="检索关键字格式"></a>检索关键字格式</h3><p>关键字是默认分词的，中文分词有时候一言难尽，所以<strong>如果想搜索整个词语请务必使用英文双引号括住</strong>，否则将导致 DocFetcher 将词语分词后使用 OR 运算进行检索，最终使检索结果出乎意料</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hacpai.com/article/1568960776746#part1-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">DocFetcher 使用教程——高效的文档文本检索工具</a></p>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装桌面搜索应用DocFetcher
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装离线API文档大全Zeal</title>
    <link href="https://zjinc36.github.io/2020/07/07/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E7%A6%BB%E7%BA%BFAPI%E6%96%87%E6%A1%A3%E5%A4%A7%E5%85%A8Zeal/"/>
    <id>https://zjinc36.github.io/2020/07/07/Ubuntu中安装离线API文档大全Zeal/</id>
    <published>2020-07-07T08:03:04.000Z</published>
    <updated>2020-07-07T00:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://zealdocs.org/" target="_blank" rel="noopener">Zeal</a></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>离线 API 文档大全</p><h1 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h1><p>Linux 和 Windows </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>参考这里<a href="https://zealdocs.org/download.html" target="_blank" rel="noopener">https://zealdocs.org/download.html</a></li><li>ubuntu安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zeal</span><br></pre></td></tr></table></figure></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="下载文档"><a href="#下载文档" class="headerlink" title="下载文档"></a>下载文档</h2><p>在初次安装 Zeal 之后，需要转到 File → Options → Docsets 先下载文档，然后方能使用<br><img src="/images/2020/07/20200707001.png" alt></p><h2 id="使用文档"><a href="#使用文档" class="headerlink" title="使用文档"></a>使用文档</h2><ul><li>有两种方式来查询文档<ul><li>直接输入 keyword 关键字进行查询，这将搜索已下载的所有文档。</li><li>包含文档类型前缀的查询，例如：python:keyword 这将仅限于搜索 Python 文档。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装离线API文档大全Zeal
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Scala中的特殊符号</title>
    <link href="https://zjinc36.github.io/2020/07/05/Scala%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>https://zjinc36.github.io/2020/07/05/Scala中的特殊符号/</id>
    <published>2020-07-05T12:00:27.000Z</published>
    <updated>2020-07-05T07:08:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h1><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>[T &lt;: UpperBound]</td><td>上界</td><td>无</td></tr><tr><td>[T &gt;: LowerBound]</td><td>下界</td><td>无</td></tr><tr><td>[T &lt;% ViewBound]</td><td>视界</td><td>比上界多了隐式转换</td></tr><tr><td>[T : ContextBound]</td><td>上下文界</td><td>是隐式参数的语法糖</td></tr><tr><td>[+T]</td><td>协变</td><td>C[+T]：如果A是B的子类，那么C[A]是C[B]的子类，称为协变</td></tr><tr><td>[-T]</td><td>逆变</td><td>C[-T]：如果A是B的子类，那么C[B]是C[A]的子类，称为逆变</td></tr><tr><td>=:=</td><td>A 必须和 B相等</td><td>Scala 2.10 中被移除了</td></tr><tr><td>&lt;:&lt;</td><td>A 必须是 B的子类</td><td>Scala 2.10 中被移除了</td></tr><tr><td>&lt;%&lt;</td><td>A 必须可以被看做是 B</td><td>Scala 2.10 中被移除了</td></tr></tbody></table><p>如果你在尝试使用 &lt;:&lt; 或者 &lt;%&lt; 的时候出错了，那请注意这些符号在 Scala 2.10 中被移除了。Scala School 里的例子仅能在 Scala 2.9.x 下正常工作。你可以使用新版本的 Scala，但可能会遇到错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class Container[A](value: A) &#123; def addIt(implicit evidence: A =:= Int) = 123 + value &#125;</span></span><br><span class="line">defined class Container</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (new Container(123)).addIt</span></span><br><span class="line">res11: Int = 246</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (new Container(<span class="string">"123"</span>)).addIt</span></span><br><span class="line">&lt;console&gt;:10: error: could not find implicit value for parameter evidence: =:=[java.lang.String,Int]</span><br><span class="line"></span><br><span class="line">// 类似地，根据之前的隐式转换，我们可以将约束放松为可视性：</span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> class Container[A](value: A) &#123; def addIt(implicit evidence: A &lt;%&lt; Int) = 123 + value &#125;</span></span><br><span class="line">defined class Container</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> (new Container(<span class="string">"123"</span>)).addIt</span></span><br><span class="line">res15: Int = 246</span><br></pre></td></tr></table></figure><h1 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h1><p>这些符号全都是连接的作用，将元素与集合、集合与集合相连接</p><h2 id="集合拼接-等操作"><a href="#集合拼接-等操作" class="headerlink" title="集合拼接 :: ++:等操作"></a>集合拼接 :: ++:等操作</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a =  <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">a: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> b = <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">b: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>符号</th><th>位置</th><th>解释</th><th>操作</th><th>结果</th></tr></thead><tbody><tr><td>::</td><td>前插</td><td>把a当成一个元素，前插到b集合</td><td>a :: b</td><td>List(List(1, 2, 3), 4, 5, 6)</td></tr><tr><td>+:</td><td>前插</td><td>同上</td><td>a +: b</td><td>List(List(1, 2, 3), 4, 5, 6)</td></tr><tr><td>:+</td><td>后插</td><td>把b当成一个元素，后插到a集合</td><td>a :+ b</td><td>List(1, 2, 3, List(4, 5, 6))</td></tr><tr><td>++</td><td>拼接</td><td>a和b集合顺序合并</td><td>a ++ b</td><td>List(1, 2, 3, 4, 5, 6)</td></tr><tr><td>++:</td><td>拼接</td><td>同上</td><td>a ++:b</td><td>List(1, 2, 3, 4, 5, 6)</td></tr><tr><td>:::</td><td>拼接</td><td>同上</td><td>a :::b</td><td>List(1, 2, 3, 4, 5, 6)</td></tr></tbody></table><p><code>::</code>操作符是右结合的，如<code>9 :: 5 :: 2 :: Nil</code>相当于<code>9 :: (5 :: (2 :: Nil))</code>。所以 <code>:: +: :::</code>这些操作符都是在前面插入。<code>:+ ++ ++:</code>这些是追加、拼接。</p><h2 id="集合拼接-–-等操作"><a href="#集合拼接-–-等操作" class="headerlink" title="集合拼接 ++= –= 等操作"></a>集合拼接 ++= –= 等操作</h2><ul><li>++= —= </li><li>++= 用于拼接容器，而 += 用于拼接元素</li></ul><p><strong>加法</strong></p><ul><li>xs += x 把元素 x 添加到集合 xs 中。该操作有副作用，它会返回左操作符，这里是 xs 自身。</li><li>xs += (x, y, z) 添加指定的元素到集合 xs 中，并返回 xs 本身。（同样有副作用）</li><li>xs ++= ys 添加集合 ys 中的所有元素到集合 xs 中，并返回 xs 本身。（表达式有副作用）</li><li>xs add x 把元素 x 添加到集合 xs 中，如集合 xs 之前没有包含 x，该操作返回 true，否则返回 false。</li></ul><p><strong>移除</strong></p><ul><li>xs -= x 从集合 xs 中删除元素 x，并返回 xs 本身。（表达式有副作用）</li><li>xs -= (x, y, z) 从集合 xs 中删除指定的元素，并返回 xs 本身。（表达式有副作用）</li><li>xs –= ys 从集合 xs 中删除所有属于集合 ys 的元素，并返回 xs 本身。（表达式有副作用）</li><li>xs remove x 从集合 xs 中删除元素 x 。如之前 xs 中包含了 x 元素，返回 true，否则返回 false。</li><li>xs retain p 只保留集合 xs 中满足条件 p 的元素。</li><li>xs.clear() 删除集合 xs 中的所有元素。</li></ul><p><strong>更新</strong></p><ul><li>xs(x) = b （ 同 xs.update(x, b) ）参数 b 为布尔类型，如果值为 true 就把元素x加入集合 xs，否则从集合 xs 中删除 x。</li></ul><p><strong>克隆</strong></p><ul><li>xs.clone 产生一个与 xs 具有相同元素的可变集合。</li></ul><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>s 字符串插值器</td><td>在任何字符串前加上s，就可以直接在串中使用变量</td></tr><tr><td>f 插值器</td><td>在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数</td></tr><tr><td>raw 插值器</td><td>除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的</td></tr></tbody></table><p><strong>举例</strong></p><ul><li><p>s 字符串插值器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line"><span class="comment">// $name嵌套在一个将被s字符串插值器处理的字符串中。</span></span><br><span class="line"><span class="comment">// 插值器知道在这个字符串的这个地方应该插入这个name变量的值，以使输出字符串为Hello,James。</span></span><br><span class="line"><span class="comment">// 使用s插值器，在这个字符串中可以使用任何在处理范围内的名字。</span></span><br><span class="line">println(<span class="string">s"Hello,<span class="subst">$name</span>"</span>) <span class="comment">//Hello,James </span></span><br><span class="line"></span><br><span class="line">println(<span class="string">s"1+1=<span class="subst">$&#123;1+1&#125;</span>"</span>) <span class="comment">//将会输出字符串1+1=2。任何表达式都可以嵌入到$&#123;&#125;中。</span></span><br></pre></td></tr></table></figure></li><li><p>f 插值器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> height=<span class="number">1.9</span>d</span><br><span class="line"><span class="keyword">val</span> name=<span class="string">"James"</span></span><br><span class="line"><span class="comment">// f 插值器是类型安全的</span></span><br><span class="line">println(<span class="string">f"<span class="subst">$name</span>%s is <span class="subst">$height</span>%2.2f meters tall"</span>)<span class="comment">//James is 1.90 meters tall </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> height:<span class="type">Double</span>=<span class="number">1.9</span>d</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：</span></span><br><span class="line">scala&gt;<span class="string">f"<span class="subst">$height</span>%4d"</span></span><br><span class="line">&lt;console&gt;:<span class="number">9</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found : <span class="type">Double</span></span><br><span class="line"> required: <span class="type">Int</span></span><br><span class="line">           <span class="string">f"<span class="subst">$height</span>%4d"</span></span><br><span class="line">              ^ f 插值器利用了java中的字符串数据格式。这种以%开头的格式在</span><br></pre></td></tr></table></figure></li><li><p>raw 插值器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="string">s"a\nb"</span></span><br><span class="line">res0:<span class="type">String</span>=</span><br><span class="line">a</span><br><span class="line">b </span><br><span class="line"><span class="comment">// 这里，s 插值器用回车代替了\n。而raw插值器却不会如此处理。</span></span><br><span class="line"></span><br><span class="line">scala&gt;<span class="string">raw"a\nb"</span></span><br><span class="line">res1:<span class="type">String</span>=a\nb </span><br><span class="line"><span class="comment">// 当不想输入\n被转换为回车的时候，raw 插值器是非常实用的。</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="（下划线）的用法"><a href="#（下划线）的用法" class="headerlink" title="_（下划线）的用法"></a><code>_</code>（下划线）的用法</h1><ol><li><p>通配符</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_可以起到类似于*作用的通配符</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkContext</span>._</span><br></pre></td></tr></table></figure></li><li><p>指代集合中的每一个元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如 遍历集合筛选列表中大于某个值的元素。</span></span><br><span class="line"><span class="keyword">val</span> lst = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> lstFilter = lst.filter(_ &gt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>获取元组中指定下标的元素值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ss = (<span class="number">1</span>,<span class="string">"22"</span>,<span class="string">"333"</span>)</span><br><span class="line">println(ss._1)</span><br></pre></td></tr></table></figure></li><li><p>使用模式匹配可以用来获取元组的组员</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> m = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">2</span>,<span class="number">2</span> -&gt; <span class="number">4</span>)</span><br><span class="line"><span class="comment">//如果不需要所有部件， 则在不需要的部件使用_； 本例只取key,因此在value处用_</span></span><br><span class="line"><span class="keyword">for</span> ((k,_) &lt;- m) println(k)</span><br></pre></td></tr></table></figure></li><li><p>成员变量而非局部变量添加默认值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s:<span class="type">Int</span>=_</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变长度参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val arr = Array(1,2,3,4,5)</span></span><br><span class="line">arr: Array[Int] = Array(1, 2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> val Array(first, second, _*) = arr</span></span><br><span class="line">first: Int = 1</span><br><span class="line">second: Int = 2</span><br></pre></td></tr></table></figure></li><li><p>不需要的部件使用<code>_</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Some</span>(<span class="number">5</span>) <span class="keyword">match</span> &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(_) =&gt; println(<span class="string">"Yes"</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>,_,_) =&gt; <span class="string">" a list with three element and the first element is 1"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>(_*)  =&gt; <span class="string">" a list with zero or more elements "</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Map</span>[_,_] =&gt; <span class="string">" matches a map with any key type and any value type "</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (a, _) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> (_ &lt;- <span class="number">1</span> to <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要所有部件， 则在不需要的部件使用_； 本例只取key,因此在value处用 _ </span></span><br><span class="line"><span class="keyword">val</span> m = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">2</span>,<span class="number">2</span> -&gt; <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> ((k,_) &lt;- m) println(k)</span><br></pre></td></tr></table></figure></li></ol><h1 id="参数序列处理"><a href="#参数序列处理" class="headerlink" title=":_*参数序列处理"></a><code>:_*</code>参数序列处理</h1><p>:_* 作为一个整体，告诉编译器你希望将某个参数当作参数序列处理</p><p>当函数接收的参数不定长的时候，假如你想输入一个队列，可以在一个队列后加入“:_*”，因此，这里的“1 to 5”也可以改写为：“Seq(1,2,3,4,5)”。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>])=&#123;</span><br><span class="line">    <span class="keyword">val</span> result=sum(<span class="number">1</span> to <span class="number">5</span>:_*)   <span class="comment">// 在后面写上: _*将1 to 5转化为参数序列</span></span><br><span class="line">     println(result)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(parms:<span class="type">Int</span>*)=&#123;</span><br><span class="line">    <span class="keyword">var</span> result=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(parm &lt;- parms)result+=parm</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模式匹配中使用"><a href="#模式匹配中使用" class="headerlink" title="模式匹配中使用 @"></a>模式匹配中使用 @</h1><p><code>@</code>的主要功能是在模式匹配中，匹配到一个模式后，将引用交给<code>@</code>前的参数<br><strong>案例1</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> o: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">o <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(x) =&gt; println(x)  <span class="comment">// 打印2</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> someRef @ <span class="type">Some</span>(x) =&gt; println(someRef)  <span class="comment">// 打印Some(2)</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> x @ <span class="type">Some</span>(_) =&gt; println(x)  <span class="comment">// 打印Some(2)</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"do nothing"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例2</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在处理 request 请求的时候，需要匹配请求的路径，然后还需要直接使用 requet</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intent</span> </span>= &#123;</span><br><span class="line"> <span class="keyword">case</span> req @ <span class="type">GET</span>(<span class="type">Path</span>(<span class="type">Seg</span>(<span class="string">"api"</span> :: <span class="string">"user"</span> :: <span class="type">IntPathElement</span>(userId) :: <span class="type">Nil</span>))) =&gt;</span><br><span class="line">      <span class="keyword">val</span> f = (userManager ? <span class="type">FindUserById</span>(userId))</span><br><span class="line">      respond(f, req)</span><br><span class="line">      </span><br><span class="line"> <span class="keyword">case</span> req @ <span class="type">GET</span>(<span class="type">Path</span>(<span class="type">Seg</span>(<span class="string">"api"</span> :: <span class="string">"user"</span> :: <span class="type">Nil</span>))) &amp; <span class="type">Params</span>(<span class="type">EmailParam</span>(email)) =&gt;</span><br><span class="line">      <span class="keyword">val</span> f = (userManager ? <span class="type">FindUserByEmail</span>(email))</span><br><span class="line">      respond(f, req)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Akka-相关特殊字符"><a href="#Akka-相关特殊字符" class="headerlink" title="Akka 相关特殊字符! ?"></a>Akka 相关特殊字符<code>! ?</code></h1><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>!</td><td>表示“即发即忘”，例如异步发送消息并立即返回,也称为tell</td></tr><tr><td>?</td><td>异步发送消息并返回表示可能回复的Future,也称为ask</td></tr></tbody></table><p><strong>举例</strong></p><ul><li><p>send !</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">ArticleBody</span>(uri, body) =&gt; <span class="comment">//If we get the parsed article back, then we've just parsed it</span></span><br><span class="line">    cacheActor ! <span class="type">SetRequest</span>(uri, body) <span class="comment">//Cache it as we just</span></span><br><span class="line">    parsed it</span><br><span class="line">    senderRef ! body</span><br><span class="line">    context.stop(self)</span><br></pre></td></tr></table></figure></li><li><p>ask ?</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> future = pongActor ? <span class="string">"unknown"</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      Scala中的特殊符号
    
    </summary>
    
      <category term="BigData" scheme="https://zjinc36.github.io/categories/BigData/"/>
    
    
      <category term="BigData" scheme="https://zjinc36.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中安装词典GoldenDict</title>
    <link href="https://zjinc36.github.io/2020/06/14/Ubuntu%E4%B8%AD%E5%AE%89%E8%A3%85%E8%AF%8D%E5%85%B8GoldenDict/"/>
    <id>https://zjinc36.github.io/2020/06/14/Ubuntu中安装词典GoldenDict/</id>
    <published>2020-06-14T12:15:30.000Z</published>
    <updated>2020-06-15T02:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install goldendict</span><br></pre></td></tr></table></figure><h1 id="添加词库"><a href="#添加词库" class="headerlink" title="添加词库"></a>添加词库</h1><ol><li><p>离线词库下载<br>测试过<a href="http://download.huzheng.org/zh_CN/" target="_blank" rel="noopener">http://download.huzheng.org/zh_CN/</a><br>测试过<a href="https://freemdict.com/2018/06/04/%e8%8b%b1%e6%b1%89-%e6%9c%97%e6%96%875-%c2%b7%e5%8f%8c%e8%a7%a3%c2%b7%e4%be%8b%e5%8f%a5%e5%8f%91%e9%9f%b3/" target="_blank" rel="noopener">英汉:朗文5++ ·双解·例句发音</a><br>没测试过<a href="http://download.huzheng.org/" target="_blank" rel="noopener">http://download.huzheng.org/</a></p></li><li><p>添加<br><img src="/images/2020/06/20200614003.png" alt></p></li></ol><ol start="3"><li><p>添加在线搜索<br>这里添加有道<code>http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</code><br><img src="/images/2020/06/20200614005.png" alt></p></li><li><p>取消百科的搜索<br><img src="/images/2020/06/20200614006.png" alt></p></li><li><p>调整词典顺序<br><img src="/images/2020/06/20200614004.png" alt></p></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li><p>快捷键<br><img src="/images/2020/06/20200614007.png" alt></p></li><li><p>屏幕取词<br>将需要查询的内容选取,按<code>ctrl + c + c</code>快捷键</p></li></ul><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><p><a href="https://www.jianshu.com/p/b6b2c1d78d7c" target="_blank" rel="noopener">安装使用 GoldenDict 查词神器 (Windows/Mac/Linux)</a></p>]]></content>
    
    <summary type="html">
    
      Ubuntu中安装词典GoldenDict
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中一键OCR识别图片截图文字转文本</title>
    <link href="https://zjinc36.github.io/2020/06/14/Ubuntu%E4%B8%AD%E4%B8%80%E9%94%AEOCR%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E6%88%AA%E5%9B%BE%E6%96%87%E5%AD%97%E8%BD%AC%E6%96%87%E6%9C%AC/"/>
    <id>https://zjinc36.github.io/2020/06/14/Ubuntu中一键OCR识别图片截图文字转文本/</id>
    <published>2020-06-14T09:20:26.000Z</published>
    <updated>2020-06-14T01:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h1><p>利用截图软件gnome-screenshot 进行截取需要被文字识别的图片；利用文字识别OCR软件tesseract，进行识别将结果输出，复制到文件和剪切板</p><h1 id="步骤1：安装依赖软件"><a href="#步骤1：安装依赖软件" class="headerlink" title="步骤1：安装依赖软件"></a>步骤1：安装依赖软件</h1><h2 id="安装tesseract"><a href="#安装tesseract" class="headerlink" title="安装tesseract"></a>安装tesseract</h2><p>tesseract是一个开源的OCR引擎，最初是由惠普公司开发用来作为其平板扫描仪的OCR引擎，2005年惠普将其开源出来，之后google接手负责维护。目前稳定的版本是3.0。4.0版本加入了基于LSTM的神经网络技术，中文字符识别准确率有所提高。</p><ol><li><p>添加源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:alex-p/tesseract-ocr</span><br></pre></td></tr></table></figure></li><li><p>更新源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tesseract-ocr</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装中文字库"><a href="#安装中文字库" class="headerlink" title="安装中文字库"></a>安装中文字库</h2><ol><li>tesseract支持60多种语言的识别不同，使用之前需要先下载对应语言的字库，下载地址：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li><li>下载完成之后把.traineddata字库文件放到tessdata目录下，默认路径是/usr/share/tesseract-ocr/4.00/tessdata</li></ol><h2 id="安装剩余软件：shutter，xclip-imagemagick"><a href="#安装剩余软件：shutter，xclip-imagemagick" class="headerlink" title="安装剩余软件：shutter，xclip, imagemagick"></a>安装剩余软件：shutter，xclip, imagemagick</h2><p>这3个不需要添加源，直接终端输入代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 截屏软件</span><br><span class="line">sudo apt-get install shutter</span><br><span class="line"># 终端复制命令</span><br><span class="line">sudo apt-get install xclip</span><br><span class="line"># 图片处理</span><br><span class="line">sudo apt-get install imagemagick</span><br></pre></td></tr></table></figure><h1 id="步骤2：制作shell脚本"><a href="#步骤2：制作shell脚本" class="headerlink" title="步骤2：制作shell脚本"></a>步骤2：制作shell脚本</h1><ol><li><p>创建一个可执行脚本,脚本内容为以下代码,并脚本放到环境变量所在目录</p></li><li><p>注意：将代码中，SCR=”/home/Username/Documents/temp”双引号中的路径替换成你想要存放截图以及识别结果txt文档的路径</p></li><li><p>用<code>tesseract --list-langs</code>检查安装过的语言包</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tesseract --list-langs</span><br><span class="line">List of available languages (3):</span><br><span class="line">eng</span><br><span class="line">chi_sim</span><br><span class="line">osd</span><br></pre></td></tr></table></figure></li><li><p>脚本内容如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Dependencies: tesseract-ocr imagemagick shutter xclip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Name: OCR</span></span><br><span class="line"><span class="comment">#Date: 2020-06-14</span></span><br><span class="line"><span class="comment">#Fuction: take a screenshot and OCR the letters in the picture</span></span><br><span class="line"><span class="comment">#Path: /home/UserName/...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#you can only scan one character at a time</span></span><br><span class="line">SCR=<span class="string">"/home/UserName/Documents/temp"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####take a shot what you wana to OCR to text</span></span><br><span class="line"><span class="comment"># The purpose of assigning the result to the variable is</span></span><br><span class="line"><span class="comment"># to wait for this command to complete before executing the next line</span></span><br><span class="line">shutterOutput=`shutter -s -e -o <span class="variable">$SCR</span>.png &gt; /dev/null 2&gt;&amp;1`</span><br><span class="line"></span><br><span class="line"><span class="comment">####increase the png</span></span><br><span class="line">mogrify -modulate 100,0 -resize 400% <span class="variable">$SCR</span>.png</span><br><span class="line"><span class="comment">#should increase detection rate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####OCR by tesseract</span></span><br><span class="line"><span class="comment"># Language packages are identified with the `tesseract --list-langs` command</span></span><br><span class="line">tesseract <span class="variable">$SCR</span>.png <span class="variable">$SCR</span> &amp;&gt; /dev/null -l eng+chi_sim</span><br><span class="line"></span><br><span class="line"><span class="comment">####use sed to delete the blanks &amp; get the text and copy to clipboard</span></span><br><span class="line">cat <span class="variable">$SCR</span>.txt | sed <span class="string">'s/ //g'</span> | xclip -selection clipboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you need to delete the newline, please use this statement</span></span><br><span class="line"><span class="comment"># and comment the previous sentence (the first line plus #)</span></span><br><span class="line"><span class="comment">#cat $SCR.txt | sed 's/ //g'| xargs | xclip -selection clipboard</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The pop-up window prompts the end of OCR</span></span><br><span class="line">notify-send <span class="string">"OCR Done"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="步骤3：设置快捷键，一键调用shell脚本"><a href="#步骤3：设置快捷键，一键调用shell脚本" class="headerlink" title="步骤3：设置快捷键，一键调用shell脚本"></a>步骤3：设置快捷键，一键调用shell脚本</h1><ul><li>进入：设置-&gt;键盘 拉到底部，点击+</li><li>名称：自由设置，建议以shell脚本名称命名</li><li>命令：脚本名字<br><img src="/images/2020/06/20200614002.png" alt></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/114917496" target="_blank" rel="noopener">Linux系统（ubuntu）一键OCR识别图片截图文字转文本</a><br><a href="http://huanyouchen.github.io/2018/05/10/install-Tesseract-and-use-it-with-py/" target="_blank" rel="noopener">Tesseract安装使用</a></p>]]></content>
    
    <summary type="html">
    
      本文主要希望在ubuntu系统下实现 一键OCR识别图片截图中的内容使之转换为文本可以复制粘贴
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Ubuntu装机日志" scheme="https://zjinc36.github.io/tags/Ubuntu%E8%A3%85%E6%9C%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux中使用tar和gzip进行打包拆包压缩解压</title>
    <link href="https://zjinc36.github.io/2020/06/11/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8tar%E5%92%8Cgzip%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E6%8B%86%E5%8C%85%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B/"/>
    <id>https://zjinc36.github.io/2020/06/11/Linux中使用tar和gzip进行打包拆包压缩解压/</id>
    <published>2020-06-11T09:22:52.000Z</published>
    <updated>2020-06-11T01:35:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="压缩格式："><a href="#压缩格式：" class="headerlink" title="压缩格式："></a>压缩格式：</h1><ul><li><p>windows (zip、rar)</p></li><li><p>linux  (gz ，bzip，zip)</p></li><li><p>先打包再压缩， 打包后可以拆包，压缩后可以解压</p></li><li><p>打包：目录可能有很多个文件，我先把它们打包成一个文件</p></li><li><p>压缩：把打包后的那个文件压缩</p></li></ul><h1 id="tar打包与拆包"><a href="#tar打包与拆包" class="headerlink" title="tar打包与拆包"></a>tar打包与拆包</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -cvf  打包后的文件名即归档文件.tar  欲打包的文件夹名</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -cvf  news.tar  ./java   把java文件夹打包成new.tar</span><br></pre></td></tr></table></figure></li></ol><h2 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xvf  打包后的文件名即归档文件名.tar</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xvf  news.tar   可以把new.tar拆包，拆出来java文件夹</span><br></pre></td></tr></table></figure></li></ol><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- c ：打包，创建的一个归档文件 ，即打包文件夹</span><br><span class="line"></span><br><span class="line">- x ：拆包</span><br><span class="line"></span><br><span class="line">- z ：以gzip 格式压缩，默认压缩倍数 6倍  （0-9）</span><br><span class="line"></span><br><span class="line">- j ：以bzip2格式压缩</span><br><span class="line"></span><br><span class="line">- v ：显示打包或者拆包的文件信息</span><br><span class="line"></span><br><span class="line">- f ： 后面紧接一个 归档文件</span><br></pre></td></tr></table></figure><h1 id="gzip-压缩与解压-bzip2也可以"><a href="#gzip-压缩与解压-bzip2也可以" class="headerlink" title="gzip   压缩与解压(bzip2也可以)"></a>gzip   压缩与解压(bzip2也可以)</h1><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  要压缩的打包后的文件名即归档文件名.tar</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  news.tar</span><br></pre></td></tr></table></figure></li></ol><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  -d  要解压的文件名.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip  -d  news.tar.gz</span><br></pre></td></tr></table></figure></li></ol><h1 id="打包且压缩"><a href="#打包且压缩" class="headerlink" title="打包且压缩"></a>打包且压缩</h1><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -czvf  打包并压缩后的文件名.tar.gz  欲打包及压缩的文件夹名</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar  -czvf  news.tar.gz  ./java</span><br><span class="line">或</span><br><span class="line">tar  -czvf  news.tar.gz  java/</span><br><span class="line">或</span><br><span class="line">tar  -czvf  news.tar.gz  java</span><br></pre></td></tr></table></figure></li></ol><h1 id="解压及拆包"><a href="#解压及拆包" class="headerlink" title="解压及拆包"></a>解压及拆包</h1><ol><li><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xzvf  打包及压缩后的文件名.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar  -xzvf  news.tar.gz</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      tar、gzip (打包拆包、压缩解压、打包压缩、解压拆包)
    
    </summary>
    
      <category term="Ubuntu" scheme="https://zjinc36.github.io/categories/Ubuntu/"/>
    
    
      <category term="Linux命令" scheme="https://zjinc36.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
