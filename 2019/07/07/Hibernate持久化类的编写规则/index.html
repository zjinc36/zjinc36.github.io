<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Hibernate持久化类的编写规则 | 想了20分钟的博客名</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Hibernate持久化类的编写规则</h1><a id="logo" href="/.">想了20分钟的博客名</a><p class="description">世界是唯物辩证的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Hibernate持久化类的编写规则</h1><div class="post-meta"><a href="/2019/07/07/Hibernate持久化类的编写规则/#comments" class="comment-count"></a><p><span class="date">Jul 07, 2019</span><span><a href="/categories/Java/" class="category">Java</a></span></p></div><div class="post-content"><h1 id="什么是持久化类"><a href="#什么是持久化类" class="headerlink" title="什么是持久化类"></a>什么是持久化类</h1><ul>
<li>持久化:将内存中的一个对象持久化到数据库中的过程,Hibernate就是用来进行持久化的框架</li>
<li>持久化类:一个java对象与数据库的表建立了映射关系,那么这个类在Hibernate中称为持久化类,即<code>持久化类=Java类+映射文件</code></li>
</ul>
<h1 id="持久化类的编写规则"><a href="#持久化类的编写规则" class="headerlink" title="持久化类的编写规则"></a>持久化类的编写规则</h1><ul>
<li>对持久化类<code>提供一个无参数的构造方法</code>:Hibernate底层需要使用反射生成实例</li>
<li><code>属性需要私有,对私有属性提供public的get和set方法</code>:Hibernta中获取,设置对象的值</li>
<li>对持久化类<code>提供一个唯一标识OID与数据库主键对应</code>:java通过对象的地址区分是否是同一个对象,数据库中通过主键确定是否是同一个记录,在Hibernate中通过持久化类的OID的属性区分是否是同一个对象</li>
<li>持久化类中<code>属性尽量使用包装类类型</code>:因为基本数据类型默认是0,那么插入0的时候就会出现歧义.而包装类类型默认值是null</li>
<li>持久化类<code>不要使用final修饰</code>:延迟加载本身是hibernate一个优化的手段,返回的是一个代理对象(javassist可以对没有实现接口的类产生代理 —- 使用了非常底层字节码增强技术,继承这个类进行代理),如果不能被继承,就不能产生代理对象,延迟加载也就失效,load方法就和get方法一致</li>
</ul>
<h1 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h1><h2 id="主键的分类"><a href="#主键的分类" class="headerlink" title="主键的分类"></a>主键的分类</h2><ul>
<li>自然主键<br>主键的本身就是表中的一个字段(实体中一个具体的属性)</li>
<li>代理主键<br>主键本身不是表中必须的一个字段(不是实体中的某个具体属性)</li>
</ul>
<p><strong>在实际开发中,尽量使用代理主键</strong></p>
<blockquote>
<p>  因为一旦自然主键参与到业务逻辑中,后期有可能需要修改源代码<br>  设计原则:好的程序设计满足OCP原则,对程序的扩展是open,对修改源码是close的</p>
</blockquote>
<h2 id="Hibernate的主键生成策略"><a href="#Hibernate的主键生成策略" class="headerlink" title="Hibernate的主键生成策略"></a>Hibernate的主键生成策略</h2><p>在实际开发中一般不允许用户手动设置主键,一般将主键交给数据库,手动编写程序进行设置.在Hibernate中为了减少程序编写,提供了很多的主键生成策略</p>
<ul>
<li>increment:hibernate中提供的自动增长机制,适用short,int,long类型的主键<blockquote>
<p>  <strong>在单线程程序中使用,不准用在多线程程序</strong><br>  运行机制:首先发送一条语句: select max(id) from 表, 然后让 id+1 作为下一条记录的主键</p>
</blockquote>
</li>
<li>identity:适用short,int,long类型的主键,使用的是数据库底层的自动增长机制<blockquote>
<p>  <strong>没有自动增长机制的数据库不能用</strong><br>  适用于自动增长机制数据库(MySQL,MSSQL),Oracle没有自动增长机制</p>
</blockquote>
</li>
<li>sequence:适用short,int,long类型的主键,采用的是序列的方式<blockquote>
<p>  Oracle支持序列,MySQL不能使用sequence</p>
</blockquote>
</li>
<li>uuid:使用hibernate中的随机方式生成字符串主键<blockquote>
<p>  适用于字符串类型的主键</p>
</blockquote>
</li>
<li>native:本地策略,可以在identity和sequence之间进行自动切换<blockquote>
<p>  也就是说,如果底层使用MySQL,则使用identity机制,而如果使用oracle则使用sequence机制</p>
</blockquote>
</li>
<li>asigned:hibernat放弃外键的管理<blockquote>
<p>  也就是说:需要通过手动编写程序或者用户自己设置</p>
</blockquote>
</li>
<li>foreign:外部的(了解居多)<blockquote>
<p>  在一对一的一种关联映射的情况下使用</p>
</blockquote>
</li>
</ul>
<h2 id="主键生成策略写在xml中"><a href="#主键生成策略写在xml中" class="headerlink" title="主键生成策略写在xml中"></a>主键生成策略写在xml中</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Customer.hbm.xml文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在项目中的位置可以看"Hibernate入门与配置"一文中,下述代码对应位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 关注generator节点 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 建立类与表的映射 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- name对应类名,table对应表名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.zjinc36.hibernate.Customer"</span> <span class="attr">table</span>=<span class="string">"cst_customer"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 建立类中的属性和表中的主键对应 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- name对应类中的属性,column对应表中的字段 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"cust_id"</span> <span class="attr">column</span>=<span class="string">"cust_id"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_name"</span> <span class="attr">column</span>=<span class="string">"cust_name"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_source"</span> <span class="attr">column</span>=<span class="string">"cust_source"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_industry"</span> <span class="attr">column</span>=<span class="string">"cust_industry"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_level"</span> <span class="attr">column</span>=<span class="string">"cust_level"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_phone"</span> <span class="attr">column</span>=<span class="string">"cust_phone"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cust_mobile"</span> <span class="attr">column</span>=<span class="string">"cust_mobile"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="持久化类的三种状态"><a href="#持久化类的三种状态" class="headerlink" title="持久化类的三种状态"></a>持久化类的三种状态</h1><p>Hibernate是持久层框架,通过持久化类完成ORM操作,Hibernate为了更好的管理持久化类,将持久化类分成三种状态</p>
<h2 id="瞬时态"><a href="#瞬时态" class="headerlink" title="瞬时态"></a>瞬时态</h2><p>这种对象没有唯一的标识OID,被session管理,称之为瞬时态对象</p>
<ul>
<li>在Session的缓存中，与Session实例相关联</li>
<li>在数据库中没有与之相对应的记录<h2 id="持久态"><a href="#持久态" class="headerlink" title="持久态"></a>持久态</h2>这种对象有唯一标识OID,被session管理,称为持久态对象</li>
<li>在Session的缓存中，与Session实例相关联</li>
<li>在数据库中存在与之相对应的记录<h2 id="脱管态-游离态"><a href="#脱管态-游离态" class="headerlink" title="脱管态(游离态)"></a>脱管态(游离态)</h2>这种对象有唯一标识OID,没有被session管理,称为脱管态对象</li>
<li>不在Session的缓存中，不与任何的Session实例相关联</li>
<li>在数据库中存在与之相对应的记录(前提条件是没有其他Session实例删除该条记录)</li>
</ul>
<h1 id="区分三种状态对象"><a href="#区分三种状态对象" class="headerlink" title="区分三种状态对象"></a>区分三种状态对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Session session = HibernateUtils.openSession();</span><br><span class="line">		Transaction transaction = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这种对象没有唯一的标识OID,被session管理,称之为瞬时态对象</span></span><br><span class="line">		Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">		customer.setCust_name(<span class="string">"wangwu"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//这种对象有唯一标识OID,被session管理,称为持久态对象</span></span><br><span class="line">		Serializable id = session.save(customer);</span><br><span class="line"></span><br><span class="line">		transaction.commit();</span><br><span class="line">		session.close();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//这种对象有唯一标识OID,没有被session管理,称为脱管态对象</span></span><br><span class="line">		System.out.println(<span class="string">"客户名称:"</span> + customer.getCust_name());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三种状态的转换"><a href="#三种状态的转换" class="headerlink" title="三种状态的转换"></a>三种状态的转换</h1><p><em>参考这篇文章<a href="https://blog.csdn.net/a772304419/article/details/79319988" target="_blank" rel="noopener">https://blog.csdn.net/a772304419/article/details/79319988</a></em></p>
<p><img src="/images/20190707001.png" alt></p>
<h2 id="瞬时态对象"><a href="#瞬时态对象" class="headerlink" title="瞬时态对象"></a>瞬时态对象</h2><h3 id="获得"><a href="#获得" class="headerlink" title="获得"></a>获得</h3><p>Customer customer = new Customer();</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><ul>
<li>瞬时-&gt;持久:save();</li>
<li>瞬时-&gt;脱管:customer.setCust_id(1);</li>
</ul>
<h2 id="持久态对象"><a href="#持久态对象" class="headerlink" title="持久态对象"></a>持久态对象</h2><h3 id="获得-1"><a href="#获得-1" class="headerlink" title="获得"></a>获得</h3><ul>
<li>get() -&gt; Customer customer = session.get(Customer.class, 1L);</li>
<li>load()</li>
<li>find()</li>
<li>iterate()<h3 id="状态转换-1"><a href="#状态转换-1" class="headerlink" title="状态转换"></a>状态转换</h3></li>
<li>持久-&gt;瞬时:delete()</li>
<li>持久-&gt;脱管:close(),clear(),evict()<h2 id="脱管态对象"><a href="#脱管态对象" class="headerlink" title="脱管态对象"></a>脱管态对象</h2><h3 id="获得-2"><a href="#获得-2" class="headerlink" title="获得"></a>获得</h3></li>
<li>先变成瞬时:Customer customer = new Customer()</li>
<li>然后变成脱管:customer.setCust_id(1L)<h3 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h3></li>
<li>脱管-&gt;持久:update(),saveOrUpdate()</li>
<li>脱管-&gt;瞬时:customer.setCust_id(null)</li>
</ul>
<h1 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h1><p>缓存:是一种优化的方式,将数据存入到内存中,使用的时候直接从缓存中获取,不通过存储源</p>
<h1 id="Hibernate的缓存"><a href="#Hibernate的缓存" class="headerlink" title="Hibernate的缓存"></a>Hibernate的缓存</h1><p>Hibernate框架中提供了优化手段:缓存,抓取策略.<br>Hibernate中提供了两种缓存机制:一级缓存和二级缓存</p>
<h1 id="Hibernate的一级缓存"><a href="#Hibernate的一级缓存" class="headerlink" title="Hibernate的一级缓存"></a>Hibernate的一级缓存</h1><p>Hibernate的一级缓存:称为是Session级别的缓存,一级缓存生命周期与Session一致(一级缓存是由Session中的一系列的Java集合构成)<br><strong>一级缓存是自带的不可卸载的</strong></p>
<h2 id="证明一级缓存存在"><a href="#证明一级缓存存在" class="headerlink" title="证明一级缓存存在"></a>证明一级缓存存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 证明一级缓存的存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Session session = HibernateUtils.openSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// customer1和customer2是否执行了两次SQL语句</span></span><br><span class="line">	Customer customer1 = session.get(Customer.class, <span class="number">6L</span>);<span class="comment">//发送SQL语句</span></span><br><span class="line">	System.out.println(customer1);</span><br><span class="line">	Customer customer2 = session.get(Customer.class, <span class="number">6L</span>);<span class="comment">//不发送SQL语句</span></span><br><span class="line">	System.out.println(customer2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两次是否是同一个对象</span></span><br><span class="line">	System.out.println(customer1 == customer2);<span class="comment">//是指向同一个地址</span></span><br><span class="line"></span><br><span class="line">	Customer customer3 = <span class="keyword">new</span> Customer();</span><br><span class="line">	customer3.setCust_name(<span class="string">"关羽"</span>);</span><br><span class="line">	Serializable id = session.save(customer3);</span><br><span class="line">	session.get(Customer.class, id);<span class="comment">//不发送SQL语句,因为是直接从缓存中获取</span></span><br><span class="line"></span><br><span class="line">	tx.commit();</span><br><span class="line">	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么快照区"><a href="#什么快照区" class="headerlink" title="什么快照区"></a>什么快照区</h2><p>Hibernate一级缓存中的特殊区域</p>
<h2 id="快照区和缓冲区的作用"><a href="#快照区和缓冲区的作用" class="headerlink" title="快照区和缓冲区的作用"></a>快照区和缓冲区的作用</h2><p>比较缓冲区和快照区的数据,一致则不更新数据库,不一致则更新数据库</p>
<h3 id="代码运行过程"><a href="#代码运行过程" class="headerlink" title="代码运行过程"></a>代码运行过程</h3><p><img src="/images/20190707005.png" alt></p>
<h4 id="eclipse观察缓存区和快照区的变化"><a href="#eclipse观察缓存区和快照区的变化" class="headerlink" title="eclipse观察缓存区和快照区的变化"></a>eclipse观察缓存区和快照区的变化</h4><ul>
<li>取出数据后,快照区和缓冲区的变化<br><img src="/images/20190707007.png" alt><br><img src="/images/20190707009.png" alt></li>
<li>修改数据后,快照区和缓冲区的变化<br><img src="/images/20190707010.png" alt><br><img src="/images/20190707011.png" alt><h3 id="过程说明"><a href="#过程说明" class="headerlink" title="过程说明"></a>过程说明</h3>再来解剖一下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//一级缓存的快照区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Session session = HibernateUtils.openSession();</span><br><span class="line">	Transaction tx = session.beginTransaction();</span><br><span class="line"></span><br><span class="line">	Customer customer = session.get(Customer.class, <span class="number">6L</span>);</span><br><span class="line">	customer.setCust_name(<span class="string">"关羽"</span>);</span><br><span class="line"></span><br><span class="line">	tx.commit();</span><br><span class="line">	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>1）将数据从DB中取出来<br>2）将数据转变成对象，并存入堆内存中<br>3）将对象的id放入session缓存map的key中，将对象的引用放入session缓存map的 value中，这就纳入session管理了<br>4）将对象的详情放入到“快照”中<br>5) 当执行了<code>tx.commit();</code>时，Hibernate为了保证数据的一致性，Hibernate会清理session的一级缓存（flush），此时会将堆内存中的数据（已经纳入session管理的数据）与快照中的数据进行对比<br>6) 如果不一致，则会执行同步（update）操作，若相同，则不执行update</p>
<h1 id="Hibernate的二级缓存"><a href="#Hibernate的二级缓存" class="headerlink" title="Hibernate的二级缓存"></a>Hibernate的二级缓存</h1><p>Hibernate的二级缓存是SessionFactory级别的缓存,需要配置的,但是企业级中一般不开启,更多的是通过redis来替代二级缓存</p>
</div><div class="tags"><a href="/tags/Hibernate/">Hibernate</a></div><div class="post-share"></div><div class="post-nav"><a href="/2019/07/08/Ubuntu安装截屏工具Shutter/" class="pre">Ubuntu安装截屏工具Shutter</a><a href="/2019/07/04/Hibernate的API/" class="next">Hibernate的API</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDg2NC8yMTM4NQ=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是持久化类"><span class="toc-text">什么是持久化类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#持久化类的编写规则"><span class="toc-text">持久化类的编写规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#主键生成策略"><span class="toc-text">主键生成策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主键的分类"><span class="toc-text">主键的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hibernate的主键生成策略"><span class="toc-text">Hibernate的主键生成策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主键生成策略写在xml中"><span class="toc-text">主键生成策略写在xml中</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#持久化类的三种状态"><span class="toc-text">持久化类的三种状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#瞬时态"><span class="toc-text">瞬时态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久态"><span class="toc-text">持久态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脱管态-游离态"><span class="toc-text">脱管态(游离态)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#区分三种状态对象"><span class="toc-text">区分三种状态对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三种状态的转换"><span class="toc-text">三种状态的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#瞬时态对象"><span class="toc-text">瞬时态对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获得"><span class="toc-text">获得</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态转换"><span class="toc-text">状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久态对象"><span class="toc-text">持久态对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获得-1"><span class="toc-text">获得</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态转换-1"><span class="toc-text">状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脱管态对象"><span class="toc-text">脱管态对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获得-2"><span class="toc-text">获得</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态转化"><span class="toc-text">状态转化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是缓存"><span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate的缓存"><span class="toc-text">Hibernate的缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate的一级缓存"><span class="toc-text">Hibernate的一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#证明一级缓存存在"><span class="toc-text">证明一级缓存存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么快照区"><span class="toc-text">什么快照区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快照区和缓冲区的作用"><span class="toc-text">快照区和缓冲区的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码运行过程"><span class="toc-text">代码运行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eclipse观察缓存区和快照区的变化"><span class="toc-text">eclipse观察缓存区和快照区的变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过程说明"><span class="toc-text">过程说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hibernate的二级缓存"><span class="toc-text">Hibernate的二级缓存</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/02/Ubuntu20-04中安装flameshot截屏工具/">Ubuntu20.04中安装flameshot截屏工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/31/Ubuntu刷新DNS/">Ubuntu刷新DNS</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/28/循环冗余校验（CRC）算法/">循环冗余校验（CRC）算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/ubuntu中Rime输入法的安装和配置/">ubuntu中Rime输入法的安装和配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/Ubuntu18.04中ibus-sunpinyin的安装与设置/">ubuntu18.04中ibus-Sunpinyin的安装与设置</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/25/Ubuntu设置开机自动加-挂载硬盘/">Ubuntu设置开机自动加/挂载硬盘</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/18/Ubuntu18-04如何固定图标到任务栏/">Ubuntu18.04如何固定图标到任务栏</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/11/Ubuntu中批量下载bilibili网站的视频/">Ubuntu中批量下载bilibili网站的视频</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/Ubuntu中安装分区管理工具gparted/">Ubuntu中安装分区管理工具gparted</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/Ubuntu中基于Docker安装QQ和WeChat/">Ubuntu中基于Docker安装QQ和WeChat</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/BigData/">BigData</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Excel/">Excel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">90</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tampermonkey/">Tampermonkey</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ubuntu/">Ubuntu</a><span class="category-list-count">47</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能/">人工智能</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">40</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视频笔记/">视频笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机操作系统/">计算机操作系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机组成原理/">计算机组成原理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Http/" style="font-size: 15px;">Http</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Ubuntu装机日志/" style="font-size: 15px;">Ubuntu装机日志</a> <a href="/tags/Linux命令/" style="font-size: 15px;">Linux命令</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/Java细节/" style="font-size: 15px;">Java细节</a> <a href="/tags/Thymeleaf/" style="font-size: 15px;">Thymeleaf</a> <a href="/tags/Lombok/" style="font-size: 15px;">Lombok</a> <a href="/tags/Linux配置/" style="font-size: 15px;">Linux配置</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Junit/" style="font-size: 15px;">Junit</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/Jackson/" style="font-size: 15px;">Jackson</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/Eclipse插件/" style="font-size: 15px;">Eclipse插件</a> <a href="/tags/Hibernate/" style="font-size: 15px;">Hibernate</a> <a href="/tags/JSP-EL-JSTL/" style="font-size: 15px;">JSP/EL/JSTL</a> <a href="/tags/Struts2/" style="font-size: 15px;">Struts2</a> <a href="/tags/OGNL/" style="font-size: 15px;">OGNL</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/人工智能/" style="font-size: 15px;">人工智能</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Jquery/" style="font-size: 15px;">Jquery</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/视频笔记/" style="font-size: 15px;">视频笔记</a> <a href="/tags/Ubuntu配置/" style="font-size: 15px;">Ubuntu配置</a> <a href="/tags/计算机组成原理/" style="font-size: 15px;">计算机组成原理</a> <a href="/tags/数据结构与算法-Java实现/" style="font-size: 15px;">数据结构与算法(Java实现)</a> <a href="/tags/Tampermonkey/" style="font-size: 15px;">Tampermonkey</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">82</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">85</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">35</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://lotabout.me/" title="三点水" target="_blank">三点水</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p><span> Copyright &copy;<a href="/." rel="nofollow">zjc.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>