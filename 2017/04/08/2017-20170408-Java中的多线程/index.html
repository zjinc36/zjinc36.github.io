<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Java中的多线程 | 想了20分钟的博客名</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的多线程</h1><a id="logo" href="/.">想了20分钟的博客名</a><p class="description">世界是唯物辩证的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java中的多线程</h1><div class="post-meta"><a href="/2017/04/08/2017-20170408-Java中的多线程/#comments" class="comment-count"></a><p><span class="date">Apr 08, 2017</span><span><a href="/categories/Java/" class="category">Java</a></span></p></div><div class="post-content"><h1 id="进程和线程-Process与Thread"><a href="#进程和线程-Process与Thread" class="headerlink" title="进程和线程(Process与Thread)"></a>进程和线程(Process与Thread)</h1><table>
<thead>
<tr>
<th>区别</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>根本区别</td>
<td>作为资源分贝的单位</td>
<td>调度和执行的单位</td>
</tr>
<tr>
<td>开销</td>
<td>每个进程都有独立的代码和数据空间(进程的上下文),进程间的切换会有较大的开销</td>
<td>线程可以看成轻量级的进程,同一类线程共享代码和数据空间,每个线程有独立的运行栈和程序计数器(PC),线程切换的开销小</td>
</tr>
<tr>
<td>所处环境</td>
<td>在操作系统中能同时运行多个任务(程序)</td>
<td>在同一应用程序中有多个顺序流同时执行</td>
</tr>
<tr>
<td>分配内存</td>
<td>系统在运行的时候会为每个进程分配不同的内存区域</td>
<td>除了CPU之外,不会为线程分配内存(线程所使用的资源是它所属进程的资源),线程组只能共享资源</td>
</tr>
<tr>
<td>包含关系</td>
<td>没有线程的进程可以被看作是单线程的,如果一个进程内拥有多个线程,则执行过程不是一条线的,而是多条线(线程)共同完成的</td>
<td>线程是进程的一部分,所以线程有的时候被称为是轻权进程或者轻量级进程</td>
</tr>
</tbody></table>
<p>注意:<strong>很多多线程是模拟出来的,真正的多线程是指有多个CPU</strong>,即多核,如服务器.如果是模拟出来的多线程,即一个CPU的情况下,那么,在同一个时间点,CPU只能执行一个代码,因为切换的很快,所以就有同时执行的错觉</p>
<p>对于Java来说</p>
<ul>
<li>线程就是独立的执行路径</li>
<li>在程序运行时,即使没有自己创建线程,后台也会存在多个线程,如gc线程,主线程</li>
<li>main()称之为主线程,为系统的入口点,用于执行整个程序</li>
<li>在一个进程中,如果开辟了多个线程,线程的运行由调度器安排调度,调度器是与操作系统紧密相关,先后顺序是不能人为的干预的</li>
<li>对同一份资源操作时,会存在资源抢夺的问题,需要加入并发控制</li>
<li>线程会带来额外的开销,如CPU调度时间,并发控制开销</li>
<li>每个线程在自己的工作内存交互,加载和存储主内存不当会造成数据不一致</li>
</ul>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>三种方法</p>
<ul>
<li>继承Thread类(只能单继承)</li>
<li>实现Runnable接口(多用这个)</li>
<li>实现Callable接口(用的少,属于juc并发变成的一部分)</li>
</ul>
<h2 id="通过继承Thread类实现多线程"><a href="#通过继承Thread类实现多线程" class="headerlink" title="通过继承Thread类实现多线程"></a>通过继承Thread类实现多线程</h2><p>继承Thread类实现多线程的步骤：</p>
<ol>
<li>在Java中负责实现线程功能的类是java.lang.Thread 类。</li>
<li>可以通过创建 Thread的实例来创建新的线程。</li>
<li>每个线程都是通过某个特定的Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。</li>
<li>通过调用Thread类的start()方法来启动一个线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="comment">//自定义类继承Thread类</span></span><br><span class="line">    <span class="comment">//run()方法里是线程体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">":"</span> + i);<span class="comment">//getName()方法是返回线程名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread thread1 = <span class="keyword">new</span> TestThread();<span class="comment">//创建线程对象</span></span><br><span class="line">        thread1.start();<span class="comment">//启动线程</span></span><br><span class="line">        TestThread thread2 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="通过实现Runnable接口实现多线程"><a href="#通过实现Runnable接口实现多线程" class="headerlink" title="通过实现Runnable接口实现多线程"></a>通过实现Runnable接口实现多线程</h2><p>我们应用更多的是通过Runnable接口实现多线程。这种方式克服了继承Thread类实现线程的缺点，即在实现Runnable接口的同时还可以继承某个类。所以实现Runnable接口的方式要通用一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//自定义类实现Runnable接口；</span></span><br><span class="line">    <span class="comment">//run()方法里是线程体；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程对象，把实现了Runnable接口的对象作为参数传入；</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread2());</span><br><span class="line">        thread1.start();<span class="comment">//启动线程；</span></span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread2());</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过实现Callable接口实现多线程"><a href="#通过实现Callable接口实现多线程" class="headerlink" title="通过实现Callable接口实现多线程"></a>通过实现Callable接口实现多线程</h2><ol>
<li><p>实现Callable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjinc36.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateStringLength</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String word;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CalculateStringLength</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.word = word;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread currentThread = Thread.currentThread();</span><br><span class="line">		System.out.println(currentThread.getName() + <span class="string">":开始执行"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 假设处理需要2秒</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			currentThread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(currentThread.getName() + <span class="string">":正在处理"</span>);</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + word + <span class="string">"长度为："</span> + word.length());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> Integer.valueOf(word.length());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建执行服务,并提交执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjinc36.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunMultiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String[] words;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RunMultiThread</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.words = words;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">runThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个线程池(创建执行服务)</span></span><br><span class="line">		ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">		Set&lt;Future&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;Future&lt;Integer&gt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">			CalculateStringLength testCallable = <span class="keyword">new</span> CalculateStringLength(word);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 提交执行</span></span><br><span class="line">			Future&lt;Integer&gt; future = pool.submit(testCallable);</span><br><span class="line"></span><br><span class="line">			set.add(future);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (Future&lt;Integer&gt; future : set) &#123;</span><br><span class="line">				sum += future.get();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjinc36.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateStringLengthTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String[] words = &#123;<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"thread"</span>&#125;;</span><br><span class="line">		RunMultiThread runMultiThread = <span class="keyword">new</span> RunMultiThread(words);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> sumLength = runMultiThread.runThread();</span><br><span class="line">			System.out.println(<span class="string">"数组中所有单词的总长度为："</span> + sumLength);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="/images/2020/04/20200410001.png" alt></p>
<h2 id="新生状态-New"><a href="#新生状态-New" class="headerlink" title="新生状态(New)"></a>新生状态(New)</h2><p>用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态</p>
<h2 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h2><ul>
<li><p>什么是就绪状态</p>
<ul>
<li>处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。</li>
<li>就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。</li>
</ul>
</li>
<li><p>有4中原因会导致线程进入就绪状态：</p>
<ul>
<li>新建线程：调用start()方法，进入就绪状态;</li>
<li>阻塞线程：阻塞解除，进入就绪状态;</li>
<li>运行线程：调用yield()方法，直接进入就绪状态;</li>
<li>运行线程：JVM将CPU资源从本线程切换到其他线程。</li>
</ul>
</li>
</ul>
<h2 id="运行状态-Running"><a href="#运行状态-Running" class="headerlink" title="运行状态(Running)"></a>运行状态(Running)</h2><ul>
<li>在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。</li>
<li>如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。</li>
<li>也可能由于某些“导致阻塞的事件”而进入阻塞状态。</li>
</ul>
<h2 id="阻塞状态-Blocked"><a href="#阻塞状态-Blocked" class="headerlink" title="阻塞状态(Blocked)"></a>阻塞状态(Blocked)</h2><ul>
<li>阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)</li>
<li>有4种原因会导致阻塞<ul>
<li>执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。(这种是抱着资源睡觉)</li>
<li>执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。(这种是等在一边,资源是会让出来的)</li>
<li>线程运行时，某个操作进入阻塞状态<ul>
<li>比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。</li>
</ul>
</li>
<li>join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。<ul>
<li>“爸爸线程”要抽烟，于是联合了“儿子线程”去买烟，必须等待“儿子线程”买烟完毕，“爸爸线程”才能继续抽烟</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="死亡状态-Terminated"><a href="#死亡状态-Terminated" class="headerlink" title="死亡状态(Terminated)"></a>死亡状态(Terminated)</h2><ul>
<li>死亡状态是线程生命周期中的最后一个阶段</li>
<li>线程死亡的原因有两个<ul>
<li>一个是正常运行的线程完成了它run()方法内的全部工作;</li>
<li>另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。</li>
</ul>
</li>
<li>当一个线程进入死亡状态以后，就不能再回到其它状态了。</li>
</ul>
<h1 id="线程终止的典型方法"><a href="#线程终止的典型方法" class="headerlink" title="线程终止的典型方法"></a>线程终止的典型方法</h1><p>由于stop()/destroy()方法已将被JDK废弃了,而我们通常的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadCiycle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">boolean</span> live = <span class="keyword">true</span>;<span class="comment">// 标记变量，表示线程是否可中止；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThreadCiycle</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当live的值是true时，继续线程体；false则结束循环，继而终止线程体；</span></span><br><span class="line">        <span class="keyword">while</span> (live) &#123;</span><br><span class="line">            System.out.println(name + (i++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">terminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        live = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThreadCiycle ttc = <span class="keyword">new</span> TestThreadCiycle(<span class="string">"线程A:"</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ttc);<span class="comment">// 新生状态</span></span><br><span class="line">        t1.start();<span class="comment">// 就绪状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        ttc.terminate();</span><br><span class="line">        System.out.println(<span class="string">"ttc stop!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="暂停线程执行"><a href="#暂停线程执行" class="headerlink" title="暂停线程执行"></a>暂停线程执行</h1><h2 id="暂停sleep"><a href="#暂停sleep" class="headerlink" title="暂停sleep"></a>暂停sleep</h2><ul>
<li>sleep(时间)指定当前线程阻塞的毫秒数</li>
<li>sleep存在异常<code>InterruptedException</code></li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>sleep可以模拟网络延时,倒计时等</li>
<li>每一个对象都有一个锁,sleep不会释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StateThread thread1 = <span class="keyword">new</span> StateThread();</span><br><span class="line">        thread1.start();</span><br><span class="line">        StateThread thread2 = <span class="keyword">new</span> StateThread();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用继承方式实现多线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">":"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);<span class="comment">//调用线程的sleep()方法；</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时可以感受到每条结果输出之前的延迟，是Thread.sleep(2000)语句在起作用</p>
<h2 id="礼让yield"><a href="#礼让yield" class="headerlink" title="礼让yield"></a>礼让yield</h2><ul>
<li>礼让线程,让当前正在执行线程暂停</li>
<li>不是阻塞线程,而是将线程从运行状态转入就绪状态</li>
<li>让CPU调度器重新调度</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StateThread thread1 = <span class="keyword">new</span> StateThread();</span><br><span class="line">        thread1.start();</span><br><span class="line">        StateThread thread2 = <span class="keyword">new</span> StateThread();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用继承方式实现多线程</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">":"</span> + i);</span><br><span class="line">            Thread.yield();<span class="comment">//调用线程的yield()方法；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以引起线程切换，但运行时没有明显延迟</p>
<h2 id="插队join"><a href="#插队join" class="headerlink" title="插队join"></a>插队join</h2><p>线程A在运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸和儿子买烟故事"</span>);</span><br><span class="line">        Thread father = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FatherThread());</span><br><span class="line">        father.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FatherThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"爸爸想抽烟，发现烟抽完了"</span>);</span><br><span class="line">        System.out.println(<span class="string">"爸爸让儿子去买包红塔山"</span>);</span><br><span class="line">        Thread son = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SonThread());</span><br><span class="line">        son.start();</span><br><span class="line">        System.out.println(<span class="string">"爸爸等儿子买烟回来"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            son.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"爸爸出门去找儿子跑哪去了"</span>);</span><br><span class="line">            <span class="comment">// 结束JVM。如果是0则表示正常结束；如果是非0则表示非正常结束</span></span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"爸爸高兴的接过烟开始抽，并把零钱给了儿子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SonThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"儿子出门去买烟"</span>);</span><br><span class="line">        System.out.println(<span class="string">"儿子买烟需要10分钟"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + i + <span class="string">"分钟"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"儿子买烟回来了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取线程的基本信息"><a href="#获取线程的基本信息" class="headerlink" title="获取线程的基本信息"></a>获取线程的基本信息</h1><h2 id="手册中里对线程状态的规定"><a href="#手册中里对线程状态的规定" class="headerlink" title="手册中里对线程状态的规定"></a>手册中里对线程状态的规定</h2><p>可以在手册中查看<br><img src="/images/2020/04/20200410002.png" alt></p>
<p>线程可以处于以下状态之一：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>状态说明</th>
<th>对应的方法</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>尚未启动的线程处于此状态。</td>
<td></td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>在Java虚拟机中执行的线程处于此状态。</td>
<td></td>
</tr>
<tr>
<td>BLOCKED</td>
<td>被阻塞等待监视器锁定的线程处于此状态。</td>
<td>wait() 或 read/write IO操作 或 JUC里面的锁定</td>
</tr>
<tr>
<td>WAITING</td>
<td>正在等待另一个线程执行特定动作的线程处于此状态。</td>
<td>sleep()</td>
</tr>
<tr>
<td>TIMED_WAITING</td>
<td>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</td>
<td>join()</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>已退出的线程处于此状态。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="获取线程基本信息的方法"><a href="#获取线程基本信息的方法" class="headerlink" title="获取线程基本信息的方法"></a>获取线程基本信息的方法</h2><ol>
<li><p>方法说明</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>isAlive()</td>
<td>判断线程是否还”活”着,即线程是否还未终止</td>
</tr>
<tr>
<td>getPriority()</td>
<td>获取线程的优先级数值</td>
</tr>
<tr>
<td>setPriority()</td>
<td>设置线程的优先级数值</td>
</tr>
<tr>
<td>setName()</td>
<td>给线程一个名字</td>
</tr>
<tr>
<td>getName()</td>
<td>取得线程的名字</td>
</tr>
<tr>
<td>currentThread()</td>
<td>取得当前正在运行的线程对象,也就是取得自己本身</td>
</tr>
</tbody></table>
</li>
<li><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r, <span class="string">"Name test"</span>);<span class="comment">//定义线程对象，并传入参数；</span></span><br><span class="line">        t.start();<span class="comment">//启动线程；</span></span><br><span class="line">        System.out.println(<span class="string">"name is: "</span> + t.getName());<span class="comment">//输出线程名称；</span></span><br><span class="line">        Thread.currentThread().sleep(<span class="number">5000</span>);<span class="comment">//线程暂停5分钟；</span></span><br><span class="line">        System.out.println(t.isAlive());<span class="comment">//判断线程还在运行吗？</span></span><br><span class="line">        System.out.println(<span class="string">"over!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程体；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><h2 id="优先级的细节"><a href="#优先级的细节" class="headerlink" title="优先级的细节"></a>优先级的细节</h2><ul>
<li><p>Java提供一个线程调度器来监控程序启动后进入就绪状态的所有线程,线程调度器按照线程的优先级决定应调度哪个线程来执行</p>
<ul>
<li>处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选</li>
</ul>
</li>
<li><p>也就是说,优先级低只是意味着获得调度的概率低,并不是绝对先调用优先级高的线程后调用优先级低的线程</p>
</li>
<li><p>线程的优先级用数字表示,范围从1到10,一个线程缺省优先级为5<br><img src="/images/2020/04/20200411001.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.MIN_PRIORITY = 1</span><br><span class="line">Thread.MAX_PRIORITY = 10</span><br><span class="line">Thread.NORM_PRIORITY = 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用下述方法获得或设置线程对象的优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPriority</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优先级的设定建议在start()调用前</p>
</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(), <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(), <span class="string">"t2"</span>);</span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.setPriority(<span class="number">10</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h1><h2 id="守护线程细节"><a href="#守护线程细节" class="headerlink" title="守护线程细节"></a>守护线程细节</h2><ol>
<li>线程分为用户线程和守护线程</li>
<li>虚拟机不看守护线程的脸色,只看用户线程的脸色,也就是说<ul>
<li>虚拟机必须确保用户线程执行完毕</li>
<li>守护线程是为用户线程服务的,jvm停止不用等守护线程执行完毕</li>
</ul>
</li>
<li>守护线程(daemon)举例<ul>
<li>后台记录操作日志</li>
<li>监控内存使用</li>
<li>等等…</li>
</ul>
</li>
<li>使用<code>xxxThread.setDaemon(true)</code>改用户线程为守护线程</li>
</ol>
<h2 id="说明用代码"><a href="#说明用代码" class="headerlink" title="说明用代码"></a>说明用代码</h2><ol>
<li><p>上帝线程(守护线程)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjinc36.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">365</span> * <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"God bless you ..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"ooooo....."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>“你自己人生”线程(用户线程)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjinc36.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YouLife</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">365</span>*<span class="number">100</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"happy life..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"ooooooooooo......."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上帝保佑你的人生</p>
<ul>
<li>守护线程守护用户线程</li>
<li>虚拟机确保”你的人生”执行完毕,即确保守护线程执行完毕</li>
<li>虚拟机不用等”上帝”程执行完毕,即不用等守护线程执行完毕</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zjinc36.multithread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		God god = <span class="keyword">new</span> God();</span><br><span class="line">		YouLife youLife = <span class="keyword">new</span> YouLife();</span><br><span class="line"></span><br><span class="line">		Thread godThread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">		godThread.setDaemon(<span class="keyword">true</span>);  <span class="comment">// 将上帝线程设置为守护线程</span></span><br><span class="line">		godThread.start();</span><br><span class="line"></span><br><span class="line">		Thread youLifeThread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">		youLifeThread.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="同步问题的提出"><a href="#同步问题的提出" class="headerlink" title="同步问题的提出"></a>同步问题的提出</h2><h3 id="现实生活中的问题"><a href="#现实生活中的问题" class="headerlink" title="现实生活中的问题"></a>现实生活中的问题</h3><p>现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题。</p>
<ul>
<li>比如：教室里，只有一台电脑，多个人都想使用。天然的解决办法就是，在电脑旁边，大家排队。前一人使用完后，后一人再使用。</li>
<li>又或者:取钱,你和你老婆同时取同一个账户的钱</li>
</ul>
<h3 id="取钱会出问题的代码模拟"><a href="#取钱会出问题的代码模拟" class="headerlink" title="取钱会出问题的代码模拟"></a>取钱会出问题的代码模拟</h3><ol>
<li><p>代码模拟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account a1 = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">"高"</span>);</span><br><span class="line">        Drawing draw1 = <span class="keyword">new</span> Drawing(<span class="number">80</span>, a1);<span class="comment">// 定义取钱线程对象；</span></span><br><span class="line">        Drawing draw2 = <span class="keyword">new</span> Drawing(<span class="number">80</span>, a1);<span class="comment">// 定义取钱线程对象；</span></span><br><span class="line">        draw1.start(); <span class="comment">// 你取钱</span></span><br><span class="line">        draw2.start(); <span class="comment">// 你老婆取钱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 简单表示银行账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    String aname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String aname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.aname = aname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟提款操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> drawingNum; <span class="comment">// 取多少钱</span></span><br><span class="line">    Account account; <span class="comment">// 要取钱的账户</span></span><br><span class="line">    <span class="keyword">int</span> expenseTotal; <span class="comment">// 总共取的钱数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(<span class="keyword">int</span> drawingNum, Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.drawingNum = drawingNum;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (account.money - drawingNum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 判断完后阻塞。其他线程开始运行。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        account.money -= drawingNum;</span><br><span class="line">        expenseTotal += drawingNum;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"--账户余额："</span> + account.money);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"--总共取了："</span> + expenseTotal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果<br><img src="/images/2020/04/20200411002.png" alt><br>没有线程同步机制，两个线程同时操作同一个账户对象，竟然从只有100元的账户，轻松取出<code>80*2=160</code>元，账户余额竟然成为了<code>-60</code>。这么大的问题，显然银行不会答应的</p>
</li>
</ol>
<h2 id="线程同步的概念"><a href="#线程同步的概念" class="headerlink" title="线程同步的概念"></a>线程同步的概念</h2><ul>
<li>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。 这时候，我们就需要用到“线程同步”。</li>
<li>线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的<strong>等待池形成队列</strong>，等待前面的线程使用完毕后，下一个线程再使用。<ul>
<li>为了保证数据在方法中被访问时的正确性,在访问时加入锁机制(synchronized),当一个线程获得对象的排他锁,独占资源,其他线程必须等待</li>
</ul>
</li>
</ul>
<h2 id="线程同步带来的问题"><a href="#线程同步带来的问题" class="headerlink" title="线程同步带来的问题"></a>线程同步带来的问题</h2><p>由于同一进程的多个线程共享统一块存储空间,在带来方便的同时,也带来了访问冲突的问题,具体如下</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程被挂起</li>
<li>在多线程竞争下,加锁,释放锁会导致比较多上下文切换和调度延时,引起性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致线程优先级倒置,引起性能问题</li>
</ul>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><ol>
<li>synchronized关键字的提出<ul>
<li>由于我们可以通过private关键字来保证数据对象只能被方法访问,所以我们<strong>只需要针对方法提出一套机制</strong>,这套机制就是<code>synchronized</code>关键字</li>
<li>它包括两种方法,<code>synchronized方法</code>和<code>synchronized块</code></li>
</ul>
</li>
</ol>
<h2 id="synchronized方法和synchronized块"><a href="#synchronized方法和synchronized块" class="headerlink" title="synchronized方法和synchronized块"></a>synchronized方法和synchronized块</h2><h3 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h3><ol>
<li><p>通过在方法声明中加入 synchronized关键字来声明，语法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">(<span class="keyword">int</span> args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized关键字的机制</p>
<ul>
<li>synchronized方法控制对”成员变量|类变量”对象的访问</li>
<li>每个对象对应一把锁</li>
<li>每个synchronized方法都必须获得调用该方法的对象的锁方能执行,否则所属线程阻塞</li>
<li>方法一旦执行,就独占该锁,直到从该方法返回时才将锁释放</li>
<li>此后被阻塞的线程方能获得该锁,重新进入可执行状态</li>
</ul>
</li>
<li><p>缺陷:若将一个大的声明为synchronized将大大影响效率</p>
</li>
</ol>
<h3 id="synchronized块"><a href="#synchronized块" class="headerlink" title="synchronized块"></a>synchronized块</h3><ol>
<li>为了解决<code>若将一个大的声明为synchronized将大大影响效率</code>的缺陷,Java 为我们提供了更好的解决办法，那就是 synchronized 块。</li>
<li>块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率</li>
<li>synchronized 块：通过 synchronized关键字来声明synchronized 块，语法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(syncObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//允许访问控制的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="Java中的块"><a href="#Java中的块" class="headerlink" title="Java中的块"></a>Java中的块</h3><p>java中的块有4种,分别如下</p>
<ol>
<li>局部块(普通块) -&gt; 写在方法里面,作用是控制变量的作用范围</li>
<li>构造块 -&gt; 写在和类属性一个位置,方法之外,和构造方法作用一致,对象加载时加载</li>
<li>静态构造块 -&gt; 构造块加static关键字,类加载的时候加载</li>
<li>同步块 -&gt; 前面所述</li>
</ol>
<h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://blog.csdn.net/u010002184/article/details/90452918" target="_blank" rel="noopener">CopyOnWriteArrayList原理，优缺点，使用场景</a></li>
<li><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">聊聊并发-Java中的Copy-On-Write容器</a></li>
</ul>
<h4 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h4><ul>
<li>CopyOnWrite容器即写时复制的容器。</li>
<li>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器</li>
<li>然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器</li>
</ul>
<h4 id="有什么好处"><a href="#有什么好处" class="headerlink" title="有什么好处"></a>有什么好处</h4><ul>
<li>我们可以对CopyOnWrite容器进行并发的读，而不需要加锁,因为当前容器不会添加任何元素。</li>
<li>所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</li>
</ul>
<h4 id="CopyOnWrite在多线程场景中的使用"><a href="#CopyOnWrite在多线程场景中的使用" class="headerlink" title="CopyOnWrite在多线程场景中的使用"></a>CopyOnWrite在多线程场景中的使用</h4><ul>
<li>具体代码中的区别如下(CopyOnWriteArrayList)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程</span></span><br><span class="line"><span class="comment"> * 使用普通的ArrayList,不使用CopyOnWriteArrayList的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncContainer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line">			<span class="comment">// 需要写同步块</span></span><br><span class="line">			<span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">				list.add(Thread.currentThread().getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程</span></span><br><span class="line"><span class="comment"> * 使用CopyOnWriteArrayList的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncContainer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt;  &#123;</span><br><span class="line">			<span class="comment">// 不需要写同步块</span></span><br><span class="line">			list.add(Thread.currentThread().getName());</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h4><ul>
<li>上述代码使用了CopyOnWriteArrayList，接下去我们看看其源码是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</li>
<li>以下源码基于jdk1.8<ul>
<li>更新版本其实可以在搜索<code>synchronized</code>,是使用这个关键字实现的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程进行写前要加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 获取旧数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 创建一个新的数组,长度比旧数组多1,并将旧数组拷贝进新的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将要添加的元素添加进新的数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将原来指向旧数组的指针指向新的数组 </span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="comment">// 返回true表示成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 写结束,解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><img src="/images/2020/08/20200811122702.png" alt></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为开始读的那一刻已经确定了读的对象是旧对象。</li>
<li>CopyOnWrite并发容器<strong>用于读多写少的并发场景</strong><ul>
<li>比如白名单，黑名单等场景</li>
</ul>
</li>
</ul>
<h4 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h4><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<ol>
<li><p><strong>内存占用问题</strong></p>
<ul>
<li>因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</li>
<li>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</li>
</ul>
</li>
<li><p><strong>数据一致性问题</strong></p>
<ul>
<li>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li>
</ul>
</li>
</ol>
<h2 id="使用synchronized块解决前面取钱出问题的代码"><a href="#使用synchronized块解决前面取钱出问题的代码" class="headerlink" title="使用synchronized块解决前面取钱出问题的代码"></a>使用synchronized块解决前面取钱出问题的代码</h2><ol>
<li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account a1 = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">"高"</span>);</span><br><span class="line">        Drawing draw1 = <span class="keyword">new</span> Drawing(<span class="number">80</span>, a1);</span><br><span class="line">        Drawing draw2 = <span class="keyword">new</span> Drawing(<span class="number">80</span>, a1);</span><br><span class="line">        draw1.start(); <span class="comment">// 你取钱</span></span><br><span class="line">        draw2.start(); <span class="comment">// 你老婆取钱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 简单表示银行账户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    String aname;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String aname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.aname = aname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟提款操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> drawingNum; <span class="comment">// 取多少钱</span></span><br><span class="line">    Account account; <span class="comment">// 要取钱的账户</span></span><br><span class="line">    <span class="keyword">int</span> expenseTotal; <span class="comment">// 总共取的钱数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(<span class="keyword">int</span> drawingNum, Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.drawingNum = drawingNum;</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="keyword">if</span> (account.money - drawingNum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"取款，余额不足！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 判断完后阻塞。其他线程开始运行。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.money -= drawingNum;</span><br><span class="line">            expenseTotal += drawingNum;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"--账户余额："</span> + account.money);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"--总共取了："</span> + expenseTotal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><code>synchronized (account)</code>意味着线程需要获得account对象的“锁”才有资格运行同步块中的代码</li>
<li>Account对象的“锁”也称为“互斥锁”，在同一时刻只能被一个线程使用<ul>
<li>A线程拥有锁，则可以调用“同步块”中的代码;</li>
<li>B线程没有锁，则进入account对象的“锁池队列”等待，直到A线程使用完毕释放了account对象的锁，B线程得到锁才可以开始调用“同步块”中的代码。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>结果<br><img src="/images/2020/04/20200411003.png" alt><br><img src="/images/2020/04/20200411004.png" alt></li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><ul>
<li>“死锁”指的是:多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。</li>
<li>也就是说,<strong>某一个同步块需要同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题</strong></li>
</ul>
<h2 id="死锁问题演示"><a href="#死锁问题演示" class="headerlink" title="死锁问题演示"></a>死锁问题演示</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>下面案例中，</p>
<ol>
<li>“化妆线程”需要同时拥有“镜子对象”、“口红对象”才能运行同步块。</li>
<li>而在实际运行时<ul>
<li>“小丫的化妆线程”拥有了“镜子对象”</li>
<li>“大丫的化妆线程”拥有了“口红对象”</li>
<li>都在互相等待对方释放资源，才能化妆</li>
</ul>
</li>
<li>这样，两个线程就形成了互相等待，无法继续运行的“死锁状态”</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lipstick</span> </span>&#123;<span class="comment">//口红类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mirror</span> </span>&#123;<span class="comment">//镜子类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//化妆类继承了Thread类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    String girl;</span><br><span class="line">    <span class="keyword">static</span> Lipstick lipstick = <span class="keyword">new</span> Lipstick();</span><br><span class="line">    <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doMakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doMakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步块同时拥有"两个以上对象的锁"</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123;<span class="comment">//需要得到口红的“锁”；</span></span><br><span class="line">                System.out.println(girl + <span class="string">"拿着口红！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mirror) &#123;<span class="comment">//需要得到镜子的“锁”；</span></span><br><span class="line">                    System.out.println(girl + <span class="string">"拿着镜子！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 同步块同时拥有"两个以上对象的锁"</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                System.out.println(girl + <span class="string">"拿着镜子！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                    System.out.println(girl + <span class="string">"拿着口红！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup m1 = <span class="keyword">new</span> Makeup();<span class="comment">//大丫的化妆线程；</span></span><br><span class="line">        m1.girl = <span class="string">"大丫"</span>;</span><br><span class="line">        m1.flag = <span class="number">0</span>;</span><br><span class="line">        Makeup m2 = <span class="keyword">new</span> Makeup();<span class="comment">//小丫的化妆线程；</span></span><br><span class="line">        m2.girl = <span class="string">"小丫"</span>;</span><br><span class="line">        m2.flag = <span class="number">1</span>;</span><br><span class="line">        m1.start();</span><br><span class="line">        m2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/2020/04/20200413001.png" alt></p>
<h2 id="死锁问题解决"><a href="#死锁问题解决" class="headerlink" title="死锁问题解决"></a>死锁问题解决</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>死锁是由于“同步块需要同时持有多个对象锁造成”的，要解决这个问题，思路很简单，就是：<strong>同一个代码块，不要同时持有两个对象锁</strong></p>
<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lipstick</span> </span>&#123;<span class="comment">//口红类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mirror</span> </span>&#123;<span class="comment">//镜子类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="comment">//化妆类继承了Thread类</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    String girl;</span><br><span class="line">    <span class="keyword">static</span> Lipstick lipstick = <span class="keyword">new</span> Lipstick();</span><br><span class="line">    <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doMakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doMakeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                System.out.println(girl + <span class="string">"拿着口红！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                System.out.println(girl + <span class="string">"拿着镜子！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                System.out.println(girl + <span class="string">"拿着镜子！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                System.out.println(girl + <span class="string">"拿着口红！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup m1 = <span class="keyword">new</span> Makeup();<span class="comment">// 大丫的化妆线程；</span></span><br><span class="line">        m1.girl = <span class="string">"大丫"</span>;</span><br><span class="line">        m1.flag = <span class="number">0</span>;</span><br><span class="line">        Makeup m2 = <span class="keyword">new</span> Makeup();<span class="comment">// 小丫的化妆线程；</span></span><br><span class="line">        m2.girl = <span class="string">"小丫"</span>;</span><br><span class="line">        m2.flag = <span class="number">1</span>;</span><br><span class="line">        m1.start();</span><br><span class="line">        m2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="/images/2020/04/20200413002.png" alt></p>
<h1 id="线程并发协作-线程通信"><a href="#线程并发协作-线程通信" class="headerlink" title="线程并发协作(线程通信)"></a>线程并发协作(线程通信)</h1><h2 id="什么是生产者-消费者模式"><a href="#什么是生产者-消费者模式" class="headerlink" title="什么是生产者/消费者模式"></a>什么是生产者/消费者模式</h2><ol>
<li>生产者和消费者共享同一个资源,并且生产者和消费者之间相互依赖,互为条件</li>
<li>对于生产者<ul>
<li>没有生产产品之前,消费者要进入等待状态</li>
<li>生产了产平之后,需要马上通知消费者消费</li>
</ul>
</li>
<li>对于消费者,在消费之后,要通知生产者已经消费结束,需要继续新产品以供消费</li>
<li>在生产者消费者问题中,仅有synchronized是不够的</li>
</ol>
<h2 id="synchronized能做到什么"><a href="#synchronized能做到什么" class="headerlink" title="synchronized能做到什么"></a>synchronized能做到什么</h2><ul>
<li>synchronized可阻止并发更新同一个共享资源,实现同步</li>
<li>synchronized不能用来实现不同线程之间的消息传递(通信)</li>
</ul>
<h2 id="线程之间入额进行消息传递"><a href="#线程之间入额进行消息传递" class="headerlink" title="线程之间入额进行消息传递"></a>线程之间入额进行消息传递</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>final void wait()</td>
<td>表示线程一直等待,直到得到其他线程通知</td>
</tr>
<tr>
<td>void wait(long timeout)</td>
<td>线程等待指定毫秒参数时间</td>
</tr>
<tr>
<td>final void wait(long timeout, int nanos)</td>
<td>线程等待指定毫秒,微妙的时间</td>
</tr>
<tr>
<td>final void notify()</td>
<td>唤醒一个处于等待状态的线程</td>
</tr>
<tr>
<td>final void notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程,优先级别高的线程优先运行</td>
</tr>
</tbody></table>
<h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProduce</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncStack sStack = <span class="keyword">new</span> SyncStack();<span class="comment">// 定义缓冲区对象；</span></span><br><span class="line">        Shengchan sc = <span class="keyword">new</span> Shengchan(sStack);<span class="comment">// 定义生产线程；</span></span><br><span class="line">        Xiaofei xf = <span class="keyword">new</span> Xiaofei(sStack);<span class="comment">// 定义消费线程；</span></span><br><span class="line">        sc.start();</span><br><span class="line">        xf.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mantou</span> </span>&#123;<span class="comment">// 馒头</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Mantou(<span class="keyword">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncStack</span> </span>&#123;<span class="comment">// 缓冲区(相当于：馒头筐)</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Mantou[] ms = <span class="keyword">new</span> Mantou[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Mantou m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index == ms.length) &#123;<span class="comment">//说明馒头筐满了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//wait后，线程会将持有的锁释放，进入阻塞状态；</span></span><br><span class="line">               <span class="comment">//这样其它需要锁的线程就可以获得锁；</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">                <span class="comment">//这里的含义是执行此方法的线程暂停，进入阻塞状态，</span></span><br><span class="line">                <span class="comment">//等消费者消费了馒头后再生产。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒在当前对象等待池中等待的第一个线程。</span></span><br><span class="line">        <span class="comment">//notifyAll叫醒所有在当前对象等待池中等待的所有线程。</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        <span class="comment">// 如果不唤醒的话。以后这两个线程都会进入等待线程，没有人唤醒。</span></span><br><span class="line">        ms[index] = m;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Mantou <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index == <span class="number">0</span>) &#123;<span class="comment">//如果馒头筐是空的；</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果馒头筐是空的，就暂停此消费线程（因为没什么可消费的嘛）。</span></span><br><span class="line">                <span class="keyword">this</span>.wait();                <span class="comment">//等生产线程生产完再来消费；</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">return</span> ms[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shengchan</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="comment">// 生产者线程</span></span><br><span class="line">    SyncStack ss = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shengchan</span><span class="params">(SyncStack ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ss = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"生产馒头："</span> + i);</span><br><span class="line">            Mantou m = <span class="keyword">new</span> Mantou(i);</span><br><span class="line">            ss.push(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xiaofei</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;<span class="comment">// 消费者线程；</span></span><br><span class="line">    SyncStack ss = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Xiaofei</span><span class="params">(SyncStack ss)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ss = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Mantou m = ss.pop();</span><br><span class="line">            System.out.println(<span class="string">"消费馒头："</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/04/09/2017-20170409-Eclipse中一键删除类中无用的包/" class="pre">Eclipse中一键删除类中无用的包</a><a href="/2017/04/01/2017-20170401-Eclipse目录树中不显示空包/" class="next">Eclipse目录树中不显示空包</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDg2NC8yMTM4NQ=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#进程和线程-Process与Thread"><span class="toc-text">进程和线程(Process与Thread)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建线程"><span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过继承Thread类实现多线程"><span class="toc-text">通过继承Thread类实现多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过实现Runnable接口实现多线程"><span class="toc-text">通过实现Runnable接口实现多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过实现Callable接口实现多线程"><span class="toc-text">通过实现Callable接口实现多线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程状态"><span class="toc-text">线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#新生状态-New"><span class="toc-text">新生状态(New)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#就绪状态"><span class="toc-text">就绪状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行状态-Running"><span class="toc-text">运行状态(Running)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞状态-Blocked"><span class="toc-text">阻塞状态(Blocked)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死亡状态-Terminated"><span class="toc-text">死亡状态(Terminated)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程终止的典型方法"><span class="toc-text">线程终止的典型方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#暂停线程执行"><span class="toc-text">暂停线程执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#暂停sleep"><span class="toc-text">暂停sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#礼让yield"><span class="toc-text">礼让yield</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插队join"><span class="toc-text">插队join</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取线程的基本信息"><span class="toc-text">获取线程的基本信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#手册中里对线程状态的规定"><span class="toc-text">手册中里对线程状态的规定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取线程基本信息的方法"><span class="toc-text">获取线程基本信息的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程的优先级"><span class="toc-text">线程的优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#优先级的细节"><span class="toc-text">优先级的细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试代码"><span class="toc-text">测试代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#用户线程和守护线程"><span class="toc-text">用户线程和守护线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#守护线程细节"><span class="toc-text">守护线程细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#说明用代码"><span class="toc-text">说明用代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程同步"><span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步问题的提出"><span class="toc-text">同步问题的提出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#现实生活中的问题"><span class="toc-text">现实生活中的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取钱会出问题的代码模拟"><span class="toc-text">取钱会出问题的代码模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步的概念"><span class="toc-text">线程同步的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步带来的问题"><span class="toc-text">线程同步带来的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized关键字"><span class="toc-text">synchronized关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized方法和synchronized块"><span class="toc-text">synchronized方法和synchronized块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized方法"><span class="toc-text">synchronized方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized块"><span class="toc-text">synchronized块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题外话"><span class="toc-text">题外话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的块"><span class="toc-text">Java中的块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWrite容器"><span class="toc-text">CopyOnWrite容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是CopyOnWrite容器"><span class="toc-text">什么是CopyOnWrite容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有什么好处"><span class="toc-text">有什么好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWrite在多线程场景中的使用"><span class="toc-text">CopyOnWrite在多线程场景中的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWriteArrayList的实现原理"><span class="toc-text">CopyOnWriteArrayList的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用场景"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CopyOnWrite的缺点"><span class="toc-text">CopyOnWrite的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用synchronized块解决前面取钱出问题的代码"><span class="toc-text">使用synchronized块解决前面取钱出问题的代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#死锁"><span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁的概念"><span class="toc-text">死锁的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁问题演示"><span class="toc-text">死锁问题演示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明"><span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结果"><span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁问题解决"><span class="toc-text">死锁问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思路"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码修改"><span class="toc-text">代码修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结果-1"><span class="toc-text">结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程并发协作-线程通信"><span class="toc-text">线程并发协作(线程通信)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是生产者-消费者模式"><span class="toc-text">什么是生产者/消费者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized能做到什么"><span class="toc-text">synchronized能做到什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程之间入额进行消息传递"><span class="toc-text">线程之间入额进行消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用举例"><span class="toc-text">使用举例</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/2020-20200915-Kafka工作流程分析/">Kafka工作流程分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/2020-20200914-JUC之Semaphore信号灯/">JUC之Semaphore信号灯</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/2020-20200914-JUC之CyclicBarrier循环栅栏/">JUC之CyclicBarrier循环栅栏</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/2020-20200914-JUC之CountDownLatch减少计数/">JUC之CountDownLatch减少计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/14/2020-20200914-Druid-Kylin-Presto-Impala-SparkSQL-ES比较/">Druid-Kylin-Presto-Impala-SparkSQL-ES比较</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/01/2020-20200901-Linux下查询进程占用的内存方法总结/">Linux下查询进程占用的内存方法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/29/2020-20200829-项目遇到的问题之Spark/">项目遇到的问题之Spark</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/28/2020-20200828-项目遇到的问题之Sqoop/">项目遇到的问题之Sqoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/2020-20200826-解决Github-Page无法访问的其中一种情况/">解决Github-Page无法访问的其中一种情况</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/2020-20200826-Ubuntu中修改DNS的方法/">Ubuntu中修改DNS的方法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/BigData/">BigData</a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Excel/">Excel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">108</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tampermonkey/">Tampermonkey</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ubuntu/">Ubuntu</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能/">人工智能</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">40</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视频笔记/">视频笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机操作系统/">计算机操作系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机组成原理/">计算机组成原理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Http/" style="font-size: 15px;">Http</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Linux命令/" style="font-size: 15px;">Linux命令</a> <a href="/tags/Ubuntu装机日志/" style="font-size: 15px;">Ubuntu装机日志</a> <a href="/tags/MySql/" style="font-size: 15px;">MySql</a> <a href="/tags/项目遇到的问题/" style="font-size: 15px;">项目遇到的问题</a> <a href="/tags/JUC/" style="font-size: 15px;">JUC</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/Lombok/" style="font-size: 15px;">Lombok</a> <a href="/tags/Java细节/" style="font-size: 15px;">Java细节</a> <a href="/tags/Thymeleaf/" style="font-size: 15px;">Thymeleaf</a> <a href="/tags/Junit/" style="font-size: 15px;">Junit</a> <a href="/tags/Linux配置/" style="font-size: 15px;">Linux配置</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Jackson/" style="font-size: 15px;">Jackson</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/Eclipse插件/" style="font-size: 15px;">Eclipse插件</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/Hibernate/" style="font-size: 15px;">Hibernate</a> <a href="/tags/JSP-EL-JSTL/" style="font-size: 15px;">JSP/EL/JSTL</a> <a href="/tags/Struts2/" style="font-size: 15px;">Struts2</a> <a href="/tags/OGNL/" style="font-size: 15px;">OGNL</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/人工智能/" style="font-size: 15px;">人工智能</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Zookeeper/" style="font-size: 15px;">Zookeeper</a> <a href="/tags/Flume/" style="font-size: 15px;">Flume</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/Jquery/" style="font-size: 15px;">Jquery</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/计算机组成原理/" style="font-size: 15px;">计算机组成原理</a> <a href="/tags/视频笔记/" style="font-size: 15px;">视频笔记</a> <a href="/tags/Ubuntu配置/" style="font-size: 15px;">Ubuntu配置</a> <a href="/tags/数据结构与算法-Java实现/" style="font-size: 15px;">数据结构与算法(Java实现)</a> <a href="/tags/Tampermonkey/" style="font-size: 15px;">Tampermonkey</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/Sqoop/" style="font-size: 15px;">Sqoop</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">96</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">93</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">36</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">37</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p><span> Copyright &copy;<a href="/." rel="nofollow">zjc.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>