<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Java中的容器 | 想了20分钟的博客名</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的容器</h1><a id="logo" href="/.">想了20分钟的博客名</a><p class="description">世界是唯物辩证的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java中的容器</h1><div class="post-meta"><a href="/2017/08/11/2017-20170811-Java中的容器/#comments" class="comment-count"></a><p><span class="date">Aug 11, 2017</span><span><a href="/categories/Java/" class="category">Java</a></span></p></div><div class="post-content"><h1 id="Java集合层次图"><a href="#Java集合层次图" class="headerlink" title="Java集合层次图"></a>Java集合层次图</h1><p><img src="/images/2020/08/20200811214049.png" alt></p>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>Collection 表示一组对象，它是集中、收集的意思。Collection接口的两个子接口是List、Set接口。<br><img src="/images/2020/08/20200811154511.png" alt><br>由于List、Set是Collection的子接口，意味着所有List、Set的实现类都有上面的方法。</p>
<h1 id="List系列"><a href="#List系列" class="headerlink" title="List系列"></a>List系列</h1><h2 id="List特点和常用方法"><a href="#List特点和常用方法" class="headerlink" title="List特点和常用方法"></a>List特点和常用方法</h2><h3 id="List基本说明"><a href="#List基本说明" class="headerlink" title="List基本说明"></a>List基本说明</h3><p>List是有序、可重复的容器。</p>
<ul>
<li>有序：List中每个元素都有索引标记。可以根据元素的索引标记(在List中的位置)访问元素，从而精确控制这些元素。</li>
<li>可重复：List允许加入重复的元素。更确切地讲，List通常允许满足 e1.equals(e2) 的元素重复加入容器。</li>
<li>除了Collection接口中的方法，List多了一些跟顺序(索引)有关的方法，参见下表：<br><img src="/images/2020/08/20200811154652.png" alt><br>List接口常用的实现类有3个：ArrayList、LinkedList和Vector。</li>
</ul>
<h3 id="List的常用方法"><a href="#List的常用方法" class="headerlink" title="List的常用方法"></a>List的常用方法</h3><ol>
<li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试add/remove/size/isEmpty/contains/clear/toArrays等方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        System.out.println(list.isEmpty()); <span class="comment">// true,容器里面没有元素</span></span><br><span class="line">        list.add(<span class="string">"刘备"</span>);</span><br><span class="line">        System.out.println(list.isEmpty()); <span class="comment">// false,容器里面有元素</span></span><br><span class="line">        list.add(<span class="string">"关羽"</span>);</span><br><span class="line">        list.add(<span class="string">"张飞"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">"list的大小："</span> + list.size());</span><br><span class="line">        System.out.println(<span class="string">"是否包含指定元素："</span> + list.contains(<span class="string">"关羽"</span>));</span><br><span class="line">        list.remove(<span class="string">"刘备"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Object[] objs = list.toArray();</span><br><span class="line">        System.out.println(<span class="string">"转化成Object数组："</span> + Arrays.toString(objs));</span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">"清空所有元素："</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test01();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="两个List之间的元素处理"><a href="#两个List之间的元素处理" class="headerlink" title="两个List之间的元素处理"></a>两个List之间的元素处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试两个容器之间元素处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"刘备"</span>);</span><br><span class="line">        list.add(<span class="string">"关羽"</span>);</span><br><span class="line">        list.add(<span class="string">"张飞"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list2.add(<span class="string">"刘备"</span>);</span><br><span class="line">        list2.add(<span class="string">"张三"</span>);</span><br><span class="line">        list2.add(<span class="string">"李四"</span>);</span><br><span class="line">        System.out.println(list.containsAll(list2)); <span class="comment">//false list是否包含list2中所有元素</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.addAll(list2); <span class="comment">//将list2中所有元素都添加到list中</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.removeAll(list2); <span class="comment">//从list中删除同时在list和list2中存在的元素</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.retainAll(list2); <span class="comment">//取list和list2的交集</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList特点和底层实现"><a href="#ArrayList特点和底层实现" class="headerlink" title="ArrayList特点和底层实现"></a>ArrayList特点和底层实现</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>查询效率高，增删效率低，线程不安全。</li>
</ul>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><ol>
<li><p>ArrayList底层使用Object数组来存储元素数据。所有的方法，都围绕这个核心的Object数组来开展。源码如下:<br><img src="/images/2020/08/20200811174536.png" alt></p>
</li>
<li><p>数组新建与扩容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 新建 =&gt; 新建一个长度为10的object数组(确切来说,是一个空引用,当第一次add,才新建一个长度为10的数组)</span><br><span class="line">2. 第一次扩容 =&gt; 增加原先值的一半,即扩容到 (10 * 3) / 2 + 1 = 16</span><br><span class="line">3. 第二次扩容 =&gt; 增加原先值的一半,即扩容 (16 * 3) / 2 + 1 = 25</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>源码如下<br><img src="/images/2020/08/20200811174627.png" alt></p>
<h2 id="LinkedList特点和底层实现"><a href="#LinkedList特点和底层实现" class="headerlink" title="LinkedList特点和底层实现"></a>LinkedList特点和底层实现</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>查询效率低，增删效率高，线程不安全。</li>
</ul>
<h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><ul>
<li><p>LinkedList底层用双向链表实现的存储<br><img src="/images/2020/08/20200811180031.png" alt></p>
</li>
<li><p>每个节点都应该有3部分内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node  previous;     <span class="comment">//前一个节点</span></span><br><span class="line">    Object  element;    <span class="comment">//本节点保存的数据</span></span><br><span class="line">    Node  next;         <span class="comment">//后一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList的源码，可以看到里面包含了双向链表的相关代码<br><img src="/images/2020/08/20200811180114.png" alt></p>
</li>
</ul>
<h2 id="Vector向量"><a href="#Vector向量" class="headerlink" title="Vector向量"></a>Vector向量</h2><ul>
<li>Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。</li>
<li>比如，indexOf方法就增加了synchronized同步标记。<br><img src="/images/2020/08/20200811180400.png" alt></li>
</ul>
<h2 id="如何选用ArrayList、LinkedList、Vector"><a href="#如何选用ArrayList、LinkedList、Vector" class="headerlink" title="如何选用ArrayList、LinkedList、Vector?"></a>如何选用ArrayList、LinkedList、Vector?</h2><ol>
<li>需要线程安全时，用Vector。</li>
<li>不存在线程安全问题时，并且查找较多用ArrayList(一般使用它)。</li>
<li>不存在线程安全问题时，增加或删除元素较多用LinkedList。</li>
</ol>
<h1 id="Map系列"><a href="#Map系列" class="headerlink" title="Map系列"></a>Map系列</h1><ul>
<li>Map就是用来存储“键(key)-值(value) 对”的</li>
<li>Map类中存储的“键值对”通过键来标识，所以“键对象”不能重复</li>
<li>Map 接口的实现类有HashMap、TreeMap、HashTable、Properties等</li>
<li>Map接口中常用的方法<br><img src="/images/2020/08/20200811180706.png" alt></li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap基本说明"><a href="#HashMap基本说明" class="headerlink" title="HashMap基本说明"></a>HashMap基本说明</h3><ul>
<li>HashMap采用哈希算法实现，是Map接口最常用的实现类。</li>
<li>由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。</li>
<li>HashMap在查找、删除、修改方面都有非常高的效率</li>
</ul>
<h3 id="HashMap中的常用方法"><a href="#HashMap中的常用方法" class="headerlink" title="HashMap中的常用方法"></a>HashMap中的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; m1 = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        Map&lt;Integer, String&gt; m2 = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        m1.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">        m1.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        m1.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">        m2.put(<span class="number">1</span>, <span class="string">"一"</span>);</span><br><span class="line">        m2.put(<span class="number">2</span>, <span class="string">"二"</span>);</span><br><span class="line">        System.out.println(m1.size());</span><br><span class="line">        System.out.println(m1.containsKey(<span class="number">1</span>));</span><br><span class="line">        System.out.println(m2.containsValue(<span class="string">"two"</span>));</span><br><span class="line">        m1.put(<span class="number">3</span>, <span class="string">"third"</span>); <span class="comment">//键重复了，则会替换旧的键值对</span></span><br><span class="line">        Map&lt;Integer, String&gt; m3 = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        m3.putAll(m1);</span><br><span class="line">        m3.putAll(m2);</span><br><span class="line">        System.out.println(<span class="string">"m1:"</span> + m1);</span><br><span class="line">        System.out.println(<span class="string">"m2:"</span> + m2);</span><br><span class="line">        System.out.println(<span class="string">"m3:"</span> + m3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li>数据结构中由数组和链表来实现对数据的存储，他们各有特点<ul>
<li>数组：占用空间连续。 寻址容易，查询速度快。但是，增加和删除效率非常低</li>
<li>链表：占用空间不连续。 寻址困难，查询速度慢。但是，增加和删除效率非常高</li>
</ul>
</li>
<li>那么，我们能不能结合数组和链表的优点(即查询快，增删效率也高)呢? 答案就是“哈希表”</li>
<li>哈希表的本质就是“数组+链表”,<strong>HashMap底层实现采用了哈希表</strong></li>
<li>打开HashMap源码，发现有如下两个核心内容<br><img src="/images/2020/08/20200811181535.png" alt></li>
<li>其中的<code>Entry[] table</code>就是HashMap的核心数组结构，我们也称之为“位桶数组”。我们再继续看Entry是什么，源码如下：<br><img src="/images/2020/08/20200811181755.png" alt></li>
<li>一个Entry对象存储了<ul>
<li>key：键对象</li>
<li>value：值对象</li>
<li>next:下一个节点</li>
<li>hash: 键对象的hash值</li>
</ul>
</li>
<li>显然每一个Entry对象就是一个单向链表结构，而Engtry本身是一个数组,所以我们可以画出一个Entry对象的典型示意<br><img src="/images/2020/08/20200811181856.png" alt></li>
<li>然后，我们画出<code>Entry[]</code>数组的结构(这也是HashMap的结构)：<br><img src="/images/2020/08/20200811181940.png" alt></li>
</ul>
<h3 id="插入数据过程put-key-value"><a href="#插入数据过程put-key-value" class="headerlink" title="插入数据过程put(key,value)"></a>插入数据过程put(key,value)</h3><p><img src="/images/2020/08/20200811182539.png" alt><br>我们的目的是将”key-value两个对象”成对存放到HashMap的Entry[]数组中。参见以下步骤：</p>
<h4 id="1-获得key对象的hashcode"><a href="#1-获得key对象的hashcode" class="headerlink" title="(1) 获得key对象的hashcode"></a>(1) 获得key对象的hashcode</h4><p>首先调用key对象的hashcode()方法，获得hashcode。</p>
<h4 id="2-根据hashcode计算出hash值-要求在-0-数组长度-1-区间"><a href="#2-根据hashcode计算出hash值-要求在-0-数组长度-1-区间" class="headerlink" title="(2) 根据hashcode计算出hash值(要求在[0, 数组长度-1]区间)"></a>(2) 根据hashcode计算出hash值(要求在[0, 数组长度-1]区间)</h4><ul>
<li><p>hashcode是一个整数，我们需要将它转化成[0, 数组长度-1]的范围。我们要求转化后的hash值尽量均匀地分布在[0,数组长度-1]这个区间，减少“hash冲突”</p>
</li>
<li><p>i.一种极端简单和低下的算法是：</p>
<ul>
<li>hash值 = hashcode/hashcode;</li>
<li>也就是说，hash值总是1。意味着，键值对对象都会存储到数组索引1位置，这样就形成一个非常长的链表。相当于每存储一个对象都会发生“hash冲突”，HashMap也退化成了一个“链表”。</li>
</ul>
</li>
<li><p>ii. 一种简单和常用的算法是(相除取余算法)：</p>
<ul>
<li><code>hash值 = hashcode%数组长度</code></li>
<li>这种算法可以让hash值均匀的分布在[0,数组长度-1]的区间。 早期的HashTable就是采用这种算法。但是，这种算法由于使用了“除法”，效率低下。</li>
<li>JDK后来改进了算法。首先约定数组长度必须为2的整数幂，这样采用位运算即可实现取余的效果：<code>hash值 = hashcode&amp;(数组长度-1)</code></li>
</ul>
</li>
<li><p>如下为我们自己测试简单的hash算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">25860399</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">16</span>;<span class="comment">//length为2的整数次幂,则h&amp;(length-1)相当于对length取模</span></span><br><span class="line">        myHash(h, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  任意整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 长度必须为2的整数幂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">myHash</span><span class="params">(<span class="keyword">int</span> h,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        System.out.println(h&amp;(length-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//length为2的整数幂情况下，和取余的值一样</span></span><br><span class="line">        System.out.println(h%length);<span class="comment">//取余数</span></span><br><span class="line">        <span class="keyword">return</span> h&amp;(length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行如上程序，我们就能发现直接取余(h%length)和位运算(h&amp;(length-1))结果是一致的。事实上，为了获得更好的散列效果，JDK对hashcode进行了两次散列处理(核心目标就是为了分布更散更均匀)，源码如下<br><img src="/images/2020/08/20200811183520.png" alt></p>
</li>
</ul>
<h4 id="3-生成Entry对象"><a href="#3-生成Entry对象" class="headerlink" title="(3) 生成Entry对象"></a>(3) 生成Entry对象</h4><p>如上所述，一个Entry对象包含4部分：key对象、value对象、hash值、指向下一个Entry对象的引用。我们现在算出了hash值。下一个Entry对象的引用为null。</p>
<h4 id="4-将Entry对象放到table数组中"><a href="#4-将Entry对象放到table数组中" class="headerlink" title="(4) 将Entry对象放到table数组中"></a>(4) 将Entry对象放到table数组中</h4><p>如果本Entry对象对应的数组索引位置还没有放Entry对象，则直接将Entry对象存储进数组;如果对应索引位置已经有Entry对象，则将已有Entry对象的next指向本Entry对象，形成链表。</p>
<h4 id="总结如上过程"><a href="#总结如上过程" class="headerlink" title="总结如上过程"></a>总结如上过程</h4><ul>
<li>当添加一个元素(key-value)时，首先计算key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，就形成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。 </li>
<li><strong>JDK8中，当链表长度大于8时，链表就转换为红黑树</strong>，这样又大大提高了查找的效率。</li>
</ul>
<h3 id="取数据过程get-key"><a href="#取数据过程get-key" class="headerlink" title="取数据过程get(key)"></a>取数据过程get(key)</h3><ul>
<li>1) 获得key的hashcode，通过hash()散列算法得到hash值，进而定位到数组的位置。</li>
<li>2) 在链表上挨个比较key对象。调用equals()方法，将key对象和链表上所有节点的key对象进行比较，直到碰到返回true的节点对象为止。</li>
<li>3) 返回equals()为true的节点对象的value对象。</li>
<li>注意:hashcode()和equals方法的关系<ul>
<li>Java中规定，两个内容相同(equals()为true)的对象必须具有相等的hashCode。</li>
<li>因为如果equals()为true而两个对象的hashcode不同,那在整个存储过程中就发生了悖论。</li>
</ul>
</li>
</ul>
<h3 id="扩容问题"><a href="#扩容问题" class="headerlink" title="扩容问题"></a>扩容问题</h3><ul>
<li>HashMap的位桶数组，初始大小为16</li>
<li>实际使用时，显然大小是可变的</li>
<li>如果位桶数组中的元素达到(0.75*数组 length)， 就重新调整数组大小变为原来2倍大小</li>
<li>扩容很耗时</li>
<li>扩容的本质是定义新的更大的数组，并将旧数组内容挨个拷贝到新数组中。</li>
</ul>
<h3 id="JDK8将链表在大于8情况下变为红黑二叉树"><a href="#JDK8将链表在大于8情况下变为红黑二叉树" class="headerlink" title="JDK8将链表在大于8情况下变为红黑二叉树"></a>JDK8将链表在大于8情况下变为红黑二叉树</h3><ul>
<li>JDK8中，HashMap在存储一个元素时，当对应链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。</li>
</ul>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable类和HashMap用法几乎一样，底层实现几乎一样，只不过HashTable的方法添加了synchronized关键字确保线程同步检查，效率较低。</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h3 id="TreeMap基本介绍"><a href="#TreeMap基本介绍" class="headerlink" title="TreeMap基本介绍"></a>TreeMap基本介绍</h3><p>TreeMap和HashMap实现了同样的接口Map，因此，用法对于调用者来说没有区别。</p>
<h3 id="TreeMap底层实现"><a href="#TreeMap底层实现" class="headerlink" title="TreeMap底层实现"></a>TreeMap底层实现</h3><ul>
<li><p>TreeMap是红黑二叉树的典型实现。我们打开TreeMap的源码，发现里面有一行核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>root用来存储整个树的根节点。我们继续跟踪Entry(是TreeMap的内部类)的代码：<br><img src="/images/2020/08/20200811214048.png" alt></p>
</li>
<li><p>可以看到里面存储了本身数据、左节点、右节点、父节点、以及节点颜色。</p>
</li>
<li><p>TreeMap的put()/remove()方法大量使用了红黑树的理论。限于篇幅，不再展开</p>
</li>
</ul>
<h2 id="如何选用HashMap-HashTable和TreeMap"><a href="#如何选用HashMap-HashTable和TreeMap" class="headerlink" title="如何选用HashMap,HashTable和TreeMap"></a>如何选用HashMap,HashTable和TreeMap</h2><ol>
<li>HashMap: 线程不安全，效率高。允许key或value为null。</li>
<li>HashTable: 线程安全，效率低。不允许key或value为null。</li>
<li>HashMap效率高于TreeMap;在需要排序的Map时才选用TreeMap。</li>
</ol>
<h1 id="Set系列"><a href="#Set系列" class="headerlink" title="Set系列"></a>Set系列</h1><ul>
<li>Set接口继承自Collection，Set接口中没有新增方法，方法和Collection保持完全一致。</li>
<li>Set容器特点：无序、不可重复。<ul>
<li>无序指Set中的元素没有索引，我们只能遍历查找;</li>
<li>不可重复指不允许加入重复的元素。更确切地讲，新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入;甚至，Set中也只能放入一个null元素，不能多个。</li>
</ul>
</li>
<li>Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet。</li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h3 id="HashSet基本使用"><a href="#HashSet基本使用" class="headerlink" title="HashSet基本使用"></a>HashSet基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        s.add(<span class="string">"hello"</span>);</span><br><span class="line">        s.add(<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s.add(<span class="string">"hello"</span>); <span class="comment">//相同的元素不会被加入</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s.add(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        s.add(<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet底层实现"><a href="#HashSet底层实现" class="headerlink" title="HashSet底层实现"></a>HashSet底层实现</h3><ul>
<li>HashSet是采用哈希算法实现，底层实际是用HashMap实现的(HashSet本质就是一个简化版的HashMap)，因此，查询效率和增删效率都比较高。我们来看一下HashSet的源码：<br><img src="/images/2020/08/20200811215002.png" alt></li>
<li>我们发现里面有个map属性，这就是HashSet的核心秘密。我们再看add()方法，发现增加一个元素说白了就是在map中增加一个键值对，键对象就是这个元素，值对象是名为<code>PRESENT</code>的Object对象。说白了，就是<code>“往set中加入元素，本质就是把这个元素作为key加入到了内部的map中”</code>。
<img src="/images/2020/08/20200811125405.png" alt></li>
<li>由于map中key都是不可重复的，因此，Set天然具有“不可重复”的特性。</li>
</ul>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><h3 id="TreeSet基本使用"><a href="#TreeSet基本使用" class="headerlink" title="TreeSet基本使用"></a>TreeSet基本使用</h3><ul>
<li>TreeSet底层实际是用TreeMap实现的，内部维持了一个简化版的TreeMap，通过key来存储Set的元素。</li>
<li>TreeSet内部需要对存储的元素进行排序，因此，我们对应的类需要实现Comparable接口。这样，才能根据compareTo()方法比较对象之间的大小，才能进行内部排序。</li>
</ul>
<h3 id="TreeSet底层实现"><a href="#TreeSet底层实现" class="headerlink" title="TreeSet底层实现"></a>TreeSet底层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1001</span>, <span class="string">"高淇"</span>, <span class="number">18</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2001</span>, <span class="string">"高希希"</span>, <span class="number">5</span>);</span><br><span class="line">        Set&lt;User&gt; set = <span class="keyword">new</span> TreeSet&lt;User&gt;();</span><br><span class="line">        set.add(u1);</span><br><span class="line">        set.add(u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String uname;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String uname, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.uname = uname;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回0 表示 this == obj 返回正数表示 this &gt; obj 返回负数表示 this &lt; obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; o.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.id &lt; o.id) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用TreeSet要点"><a href="#使用TreeSet要点" class="headerlink" title="使用TreeSet要点"></a>使用TreeSet要点</h3><ol>
<li>由于是二叉树，需要对元素做内部排序。 如果要放入TreeSet中的类没有实现Comparable接口，则会抛出异常：java.lang.ClassCastException。</li>
<li>TreeSet中不能放入null元素</li>
</ol>
<h1 id="使用Iterator迭代器遍历容器"><a href="#使用Iterator迭代器遍历容器" class="headerlink" title="使用Iterator迭代器遍历容器"></a>使用Iterator迭代器遍历容器</h1><p>迭代器为我们提供了统一的遍历容器的方式，参见以下示例代码</p>
<h2 id="迭代器遍历List"><a href="#迭代器遍历List" class="headerlink" title="迭代器遍历List"></a>迭代器遍历List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            aList.add(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(aList);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; iter = aList.iterator(); iter.hasNext();) &#123;</span><br><span class="line">            String temp = iter.next();</span><br><span class="line">            System.out.print(temp + <span class="string">"\t"</span>);</span><br><span class="line">            <span class="keyword">if</span> (temp.endsWith(<span class="string">"3"</span>)) &#123;<span class="comment">// 删除3结尾的字符串</span></span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(aList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>建议:如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历</li>
</ul>
<h2 id="迭代器遍历Set"><a href="#迭代器遍历Set" class="headerlink" title="迭代器遍历Set"></a>迭代器遍历Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            set.add(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; iter = set.iterator(); iter.hasNext();) &#123;</span><br><span class="line">            String temp = iter.next();</span><br><span class="line">            System.out.print(temp + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器遍历Map"><a href="#迭代器遍历Map" class="headerlink" title="迭代器遍历Map"></a>迭代器遍历Map</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"A"</span>, <span class="string">"高淇"</span>);</span><br><span class="line">        map.put(<span class="string">"B"</span>, <span class="string">"高小七"</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; ss = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = ss.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            Entry&lt;String, String&gt; e = iterator.next();</span><br><span class="line">            System.out.println(e.getKey() + <span class="string">"--"</span> + e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"A"</span>, <span class="string">"高淇"</span>);</span><br><span class="line">        map.put(<span class="string">"B"</span>, <span class="string">"高小七"</span>);</span><br><span class="line">        Set&lt;String&gt; ss = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; iterator = ss.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(key + <span class="string">"--"</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="遍历集合的方法总结"><a href="#遍历集合的方法总结" class="headerlink" title="遍历集合的方法总结"></a>遍历集合的方法总结</h1><h2 id="遍历List"><a href="#遍历List" class="headerlink" title="遍历List"></a>遍历List</h2><h3 id="方法一：普通for循环"><a href="#方法一：普通for循环" class="headerlink" title="方法一：普通for循环"></a>方法一：普通for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;<span class="comment">//list为集合的对象名</span></span><br><span class="line">    String temp = (String)list.get(i);</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：增强for循环-使用泛型"><a href="#方法二：增强for循环-使用泛型" class="headerlink" title="方法二：增强for循环(使用泛型!)"></a>方法二：增强for循环(使用泛型!)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String temp : list) &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：使用Iterator迭代器-1"><a href="#方法三：使用Iterator迭代器-1" class="headerlink" title="方法三：使用Iterator迭代器(1)"></a>方法三：使用Iterator迭代器(1)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator iter= list.iterator();iter.hasNext();)&#123;</span><br><span class="line">    String temp = (String)iter.next();</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法四：使用Iterator迭代器-2"><a href="#方法四：使用Iterator迭代器-2" class="headerlink" title="方法四：使用Iterator迭代器(2)"></a>方法四：使用Iterator迭代器(2)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Iterator  iter =list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    Object  obj =  iter.next();</span><br><span class="line">    iter.remove();<span class="comment">//如果要遍历时，删除集合中的元素，建议使用这种方式！</span></span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历Set"><a href="#遍历Set" class="headerlink" title="遍历Set"></a>遍历Set</h2><h3 id="方法一：增强for循环"><a href="#方法一：增强for循环" class="headerlink" title="方法一：增强for循环"></a>方法一：增强for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String temp:set)&#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用Iterator迭代器"><a href="#方法二：使用Iterator迭代器" class="headerlink" title="方法二：使用Iterator迭代器"></a>方法二：使用Iterator迭代器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator iter = set.iterator();iter.hasNext();)&#123;</span><br><span class="line">    String temp = (String)iter.next();</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h2><h3 id="方法一：根据key获取value"><a href="#方法一：根据key获取value" class="headerlink" title="方法一：根据key获取value"></a>方法一：根据key获取value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Man&gt; maps = <span class="keyword">new</span> HashMap&lt;Integer, Man&gt;();</span><br><span class="line">Set&lt;Integer&gt;  keySet =  maps.keySet();</span><br><span class="line"><span class="keyword">for</span>(Integer id : keySet)&#123;</span><br><span class="line">    System.out.println(maps.get(id).name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用entrySet"><a href="#方法二：使用entrySet" class="headerlink" title="方法二：使用entrySet"></a>方法二：使用entrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;Integer, Man&gt;&gt;  ss = maps.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Iterator iterator = ss.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">    Entry e = (Entry) iterator.next(); </span><br><span class="line">    System.out.println(e.getKey()+<span class="string">"--"</span>+e.getValue());</span><br></pre></td></tr></table></figure>

<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><h2 id="Collections工具类基本说明"><a href="#Collections工具类基本说明" class="headerlink" title="Collections工具类基本说明"></a>Collections工具类基本说明</h2><p>类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。</p>
<ol>
<li>void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。</li>
<li>void shuffle(List) //对List容器内的元素进行随机排列。</li>
<li>void reverse(List) //对List容器内的元素进行逆续排列 。</li>
<li>void fill(List, Object) //用一个特定的对象重写整个List容器。</li>
<li>int binarySearch(List, Object)//对于顺序的List容器，采用折半查找的方法查找特定对象。</li>
</ol>
<h2 id="Collections工具类的常用方法"><a href="#Collections工具类的常用方法" class="headerlink" title="Collections工具类的常用方法"></a>Collections工具类的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            aList.add(<span class="string">"a"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(aList);</span><br><span class="line">        Collections.shuffle(aList); <span class="comment">// 随机排列</span></span><br><span class="line">        System.out.println(aList);</span><br><span class="line">        Collections.reverse(aList); <span class="comment">// 逆续</span></span><br><span class="line">        System.out.println(aList);</span><br><span class="line">        Collections.sort(aList); <span class="comment">// 排序</span></span><br><span class="line">        System.out.println(aList);</span><br><span class="line">        System.out.println(Collections.binarySearch(aList, <span class="string">"a2"</span>)); </span><br><span class="line">        Collections.fill(aList, <span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(aList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/08/11/2017-20170811-Java容器线程不安全该如何处理/" class="pre">Java容器线程不安全该如何处理</a><a href="/2017/08/10/2017-20170810-调整eclipse左边包的显示方式/" class="next">调整Eclipse左边包的显示方式</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDg2NC8yMTM4NQ=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java集合层次图"><span class="toc-text">Java集合层次图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collection接口"><span class="toc-text">Collection接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List系列"><span class="toc-text">List系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List特点和常用方法"><span class="toc-text">List特点和常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List基本说明"><span class="toc-text">List基本说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List的常用方法"><span class="toc-text">List的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个List之间的元素处理"><span class="toc-text">两个List之间的元素处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList特点和底层实现"><span class="toc-text">ArrayList特点和底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#底层实现"><span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList特点和底层实现"><span class="toc-text">LinkedList特点和底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点-1"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#底层实现-1"><span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector向量"><span class="toc-text">Vector向量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何选用ArrayList、LinkedList、Vector"><span class="toc-text">如何选用ArrayList、LinkedList、Vector?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map系列"><span class="toc-text">Map系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap基本说明"><span class="toc-text">HashMap基本说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap中的常用方法"><span class="toc-text">HashMap中的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap底层实现"><span class="toc-text">HashMap底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本结构"><span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入数据过程put-key-value"><span class="toc-text">插入数据过程put(key,value)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-获得key对象的hashcode"><span class="toc-text">(1) 获得key对象的hashcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-根据hashcode计算出hash值-要求在-0-数组长度-1-区间"><span class="toc-text">(2) 根据hashcode计算出hash值(要求在[0, 数组长度-1]区间)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-生成Entry对象"><span class="toc-text">(3) 生成Entry对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-将Entry对象放到table数组中"><span class="toc-text">(4) 将Entry对象放到table数组中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结如上过程"><span class="toc-text">总结如上过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取数据过程get-key"><span class="toc-text">取数据过程get(key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩容问题"><span class="toc-text">扩容问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8将链表在大于8情况下变为红黑二叉树"><span class="toc-text">JDK8将链表在大于8情况下变为红黑二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable"><span class="toc-text">HashTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-text">TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap基本介绍"><span class="toc-text">TreeMap基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap底层实现"><span class="toc-text">TreeMap底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何选用HashMap-HashTable和TreeMap"><span class="toc-text">如何选用HashMap,HashTable和TreeMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set系列"><span class="toc-text">Set系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet基本使用"><span class="toc-text">HashSet基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet底层实现"><span class="toc-text">HashSet底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet"><span class="toc-text">TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet基本使用"><span class="toc-text">TreeSet基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet底层实现"><span class="toc-text">TreeSet底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用TreeSet要点"><span class="toc-text">使用TreeSet要点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用Iterator迭代器遍历容器"><span class="toc-text">使用Iterator迭代器遍历容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器遍历List"><span class="toc-text">迭代器遍历List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器遍历Set"><span class="toc-text">迭代器遍历Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器遍历Map"><span class="toc-text">迭代器遍历Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方式一"><span class="toc-text">方式一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方式二"><span class="toc-text">方式二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遍历集合的方法总结"><span class="toc-text">遍历集合的方法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历List"><span class="toc-text">遍历List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一：普通for循环"><span class="toc-text">方法一：普通for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法二：增强for循环-使用泛型"><span class="toc-text">方法二：增强for循环(使用泛型!)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法三：使用Iterator迭代器-1"><span class="toc-text">方法三：使用Iterator迭代器(1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法四：使用Iterator迭代器-2"><span class="toc-text">方法四：使用Iterator迭代器(2)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历Set"><span class="toc-text">遍历Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一：增强for循环"><span class="toc-text">方法一：增强for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法二：使用Iterator迭代器"><span class="toc-text">方法二：使用Iterator迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历Map"><span class="toc-text">遍历Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法一：根据key获取value"><span class="toc-text">方法一：根据key获取value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法二：使用entrySet"><span class="toc-text">方法二：使用entrySet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collections工具类"><span class="toc-text">Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections工具类基本说明"><span class="toc-text">Collections工具类基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections工具类的常用方法"><span class="toc-text">Collections工具类的常用方法</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/JUC之Semaphore信号灯/">JUC之Semaphore信号灯</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/JUC之CyclicBarrier循环栅栏/">JUC之CyclicBarrier循环栅栏</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/JUC之CountDownLatch减少计数/">JUC之CountDownLatch减少计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/14/Druid-Kylin-Presto-Impala-SparkSQL-ES比较/">Druid-Kylin-Presto-Impala-SparkSQL-ES比较</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/01/2020-20200901-Linux下查询进程占用的内存方法总结/">Linux下查询进程占用的内存方法总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/2020-20200826-解决Github-Page无法访问的其中一种情况/">解决Github-Page无法访问的其中一种情况</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/2020-20200826-Ubuntu中修改DNS的方法/">Ubuntu中修改DNS的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/26/2020-20200826-nslookup命令-查DNS信息用/">Nslookup命令-查DNS信息用</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/02/2020-20200801-Ubuntu20-04中安装flameshot截屏工具/">Ubuntu20.04中安装flameshot截屏工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/31/2020-20200731-Ubuntu刷新DNS/">Ubuntu刷新DNS</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/BigData/">BigData</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Excel/">Excel</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">108</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">Javascript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tampermonkey/">Tampermonkey</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ubuntu/">Ubuntu</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/人工智能/">人工智能</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">40</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视频笔记/">视频笔记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机操作系统/">计算机操作系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机组成原理/">计算机组成原理</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Struts2/" style="font-size: 15px;">Struts2</a> <a href="/tags/BigData/" style="font-size: 15px;">BigData</a> <a href="/tags/Eclipse插件/" style="font-size: 15px;">Eclipse插件</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Linux命令/" style="font-size: 15px;">Linux命令</a> <a href="/tags/Ubuntu装机日志/" style="font-size: 15px;">Ubuntu装机日志</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/Lombok/" style="font-size: 15px;">Lombok</a> <a href="/tags/Java细节/" style="font-size: 15px;">Java细节</a> <a href="/tags/Thymeleaf/" style="font-size: 15px;">Thymeleaf</a> <a href="/tags/Junit/" style="font-size: 15px;">Junit</a> <a href="/tags/Linux配置/" style="font-size: 15px;">Linux配置</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Jackson/" style="font-size: 15px;">Jackson</a> <a href="/tags/Tomcat/" style="font-size: 15px;">Tomcat</a> <a href="/tags/Http/" style="font-size: 15px;">Http</a> <a href="/tags/Servlet/" style="font-size: 15px;">Servlet</a> <a href="/tags/JSP-EL-JSTL/" style="font-size: 15px;">JSP/EL/JSTL</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/Hibernate/" style="font-size: 15px;">Hibernate</a> <a href="/tags/OGNL/" style="font-size: 15px;">OGNL</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/SSH/" style="font-size: 15px;">SSH</a> <a href="/tags/MyBatis/" style="font-size: 15px;">MyBatis</a> <a href="/tags/人工智能/" style="font-size: 15px;">人工智能</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Zookeeper/" style="font-size: 15px;">Zookeeper</a> <a href="/tags/SpringSecurity/" style="font-size: 15px;">SpringSecurity</a> <a href="/tags/Jquery/" style="font-size: 15px;">Jquery</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/正则表达式/" style="font-size: 15px;">正则表达式</a> <a href="/tags/Flume/" style="font-size: 15px;">Flume</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/视频笔记/" style="font-size: 15px;">视频笔记</a> <a href="/tags/计算机组成原理/" style="font-size: 15px;">计算机组成原理</a> <a href="/tags/Ubuntu配置/" style="font-size: 15px;">Ubuntu配置</a> <a href="/tags/数据结构与算法-Java实现/" style="font-size: 15px;">数据结构与算法(Java实现)</a> <a href="/tags/Tampermonkey/" style="font-size: 15px;">Tampermonkey</a> <a href="/tags/JUC/" style="font-size: 15px;">JUC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">93</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">92</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">35</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">35</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p><span> Copyright &copy;<a href="/." rel="nofollow">zjc.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>