# 浅析IBMMQ和RabbitMq的区别

在项目开发中，使用到了IBMMQ和rabbitMq两种消息队列，实际使用过程中，发现他们其实是有点不同的。

分享出来大家一起交流学习。

## 队列节点个数不同

IBMmq的使用和涉及逻辑是：发送永远操作的是远程队列，接收操作的永远都是本地队列。

注意：远程和本地队列，这个远程和本地只是一个概念区分，区分一下什么样的操作应该对应什么样的队列。而不是说这个队列是一个在本地一个在远程。

## 举例

A系统 和 B系统之间通过IBM通信

在一个A和B都能访问的到服务器上面搭建一个IBM服务器。然后创建两个队列管理器

QM_A 、QM_B

然后在QM_A和QM_B两个队列管理器上面各创建两个队列

QM_A：-->QL_A（本地队列A）、QR_A（远程队列A）

QM_B：-->QL_B（本地队列B）、QR_B（远程队列B）

A系统和B系统 都各自跟各自的队列管理器进行交互。

这里需要注意的是，进行交互数据的两个队列，要配置相同的通道。

即：

A远程和B本地两个队列会建立起连接通道

B远程和A本地两个队列会建立起连接通道


实际的数据交互过程是：

1、A系统发送数据给B：

A系统发送数据到QR_A，IBM会把QR_A的数据同步到QL_B。然后B系统从QL_B本地取数据。这个过程就是A向B发送数据通信的过程

2、B系统发送数据给A：

B系统发送数据到QR_B，IBM会把QR_B的数据同步到QL_A。然后A系统从QL_A本地取数据。这个过程就是B向A发送数据通信的过程

 

# 总结一下

IBMmq实现数据通信其实并不仅仅是一个消息中间件的缓存概念，而是有他自己的一套设计规范，不同的队列干着不同的事。

但是rabbitMQ其实就是一个数据缓存的作用，并且rabbitMQ的Q是单向是，定义一个Q就定义好了这个Q是A来pushB来拉取，然后在定义另外一个Q，是B来push A 来拉取。

# 来源

- [浅析IBMMQ和RabbitMq的区别](https://blog.csdn.net/qq_39915083/article/details/106334330)

